00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.01
Created On: 12/13/2014 7:37:16 PM

00000000                             1  
00000000                             2  *##########################################################################
00000000                             3  * Title      : 
00000000                             4  * Written by : Andrew Watson
00000000                             5  *            : Elaine Keller
00000000                             6  *            : Robert Anderson
00000000                             7  * Date       : 11/14/2014
00000000                             8  * Description: 
00000000                             9  *##########################################################################
00000000                            10  
00000000                            11  ***Possible Bug***
00000000                            12  *can not tell data from an
00000000                            13  *unidentified instruction that is an actual
00000000                            14  *instruction therefore causing errors.
00000000                            15  *may not actually be a bug because data
00000000                            16  *is data to the machine, and if you modify
00000000                            17  *the instructions in memory for a program
00000000                            18  *by moivng data, you can modify the instuctions
00000000                            19  *executed.
00000000                            20  
00000000                            21  
00000000                            22  ***************************************************************************
00000000                            23  *                   Variable/Data Definitions
00000000                            24  ***************************************************************************
00000000                            25  
00000000  =00005000                 26  stack   EQU   $00005000
00000000  =00000000                 27  begin   EQU   $00000000
00000000  =00FFFFFE                 28  end     EQU   $00FFFFFE
00000000  =00000001                 29  byte    EQU   1
00000000  =00000002                 30  word    EQU   2
00000000  =00000004                 31  long    EQU   4
00000000  =00001000                 32  prgorg  EQU   $1000
00000000                            33  
00000FFE                            34      ORG $00000FFE
00000FFE                            35  FarLabel:
00001000                            36      ORG    prgorg
00001000                            37  start:
00001000  4FF8 5000                 38          LEA stack, SP                   ;initialize stack
00001004                            39  
00001000                            40      ORG    prgorg
00001000                            41  
00001000                            42  ******************************************************************************
00001000                            43  *                   Begin processing active code
00001000                            44  ******************************************************************************
00001000                            45      
00001000                            46  start:
00001000                            47  
00001000  4FF8 5000                 48          LEA         stack, SP           ;Initialize stack
00001004                            49          
00001004                            50  *.............................................................................
00001004                            51  * Debug Mode - Comment out when done
00001004                            52  *        MOVE.L      #snippet,A3
00001004                            53  *        MOVE.L      #snippetEnd,A4
00001004                            54  *        MOVE.L      #begin,A3
00001004                            55  *        MOVE.L      #end,A4
00001004                            56  *        MOVE.L      #$00004000,A3
00001004                            57  *        MOVE.L      #$00005000,A4
00001004                            58  *        BRA         screenLoop
00001004                            59  * Debug Mode - Comment out when done
00001004                            60  *.............................................................................        
00001004                            61          
00001004                            62  prompt_user:
00001004                            63  
00001004  6100 168A                 64          BSR         begin_address
00001008  B67C FFFF                 65          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000100C  6700 1672                 66          BEQ         fin                 ;Yes, then exit
00001010                            67          
00001010  6000 0004                 68          BRA         screenLoop
00001014                            69          ;BSR         process_op_codes
00001014  60EE                      70          BRA         prompt_user
00001016                            71                  
00001016                            72  ******************************************************************************
00001016                            73  *                   Begin processing OP Codes
00001016                            74  ******************************************************************************
00001016                            75  
00001016                            76  screenLoop:
00001016                            77  
00001016  143C 001E                 78          MOVE.B #30,D2
0000101A                            79   
0000101A                            80  main_Loop:
0000101A                            81  
0000101A  B9CB                      82          CMPA.L A3,A4                    ;check end of prog
0000101C  6F00 1662                 83          BLE fin
00001020                            84          
00001020  0C02 0000                 85          CMPI.B #0,D2
00001024  6700 0188                 86          BEQ checkContinue
00001028  5302                      87          SUBQ.B #1,D2
0000102A  48A7 2000                 88          MOVEM.W D2,-(SP)                ;save D2 for next iteration
0000102E                            89          
0000102E                            90          ;print memory location
0000102E  48E7 1200                 91          MOVEM.L D3/D6,-(SP)
00001032  7C02                      92          MOVEQ.L #2,D6                   ;set as long hex string
00001034  260B                      93          MOVE.L  A3,D3                   ;put hex in D3
00001036  6100 1A16                 94          BSR outputHex
0000103A  4CDF 0048                 95          MOVEM.L (SP)+,D3/D6
0000103E                            96          
0000103E                            97          ;print ' '
0000103E  48E7 4000                 98          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001042  123C 0020                 99          MOVE.B #' ',D1                  ;put ascii value of char in D1
00001046  103C 0006                100          MOVE.B #6,D0                    ;move task 6 into D0
0000104A  4E4F                     101          TRAP #15                        ;prin char
0000104C  4CDF 0002                102          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001050                           103          
00001050                           104          
00001050                           105          
00001050                           106          ;handle an odd memory access(instructions will never be misaligned)
00001050  240B                     107          MOVE.L A3,D2                    ; copy address to D2
00001052  0202 0001                108          ANDI.B #%00000001,D2            ;mask everything except the least significant bit
00001056  0C02 0001                109          CMPI.B #1,D2                    ;compare the least sig bit of the address to one
0000105A  6700 15EA                110          BEQ handlebytedata              ;the least sig bit will only be one if the insrtuction
0000105E                           111                             ;is odd(misaligned) and therefore not an instruction
0000105E                           112          
0000105E  7600                     113          MOVEQ.L #0,D3
00001060                           114          
00001060  3213                     115          MOVE.W (A3),D1                  ;copy word from other prog to analyze as instructioninstruction
00001062                           116          
00001062                           117          ***things to save A3,A4,D1(?)***
00001062  48E7 0018                118          MOVEM.L A3-A4,-(SP)
00001066  6100 0010                119          BSR checkOPcode
0000106A  4CDF 1800                120          MOVEM.L (SP)+,A3-A4
0000106E  D7C7                     121          ADDA.L  D7,A3                   ;look past data that was part of the instruction
00001070                           122          
00001070  548B                     123          ADDQ.L  #word,A3
00001072  4C9F 0004                124          MOVEM.W (SP)+,D2                ;restore D2 for next iteration
00001076  60A2                     125          BRA     main_Loop 
00001078                           126          
00001078                           127  checkOPcode:
00001078                           128  
00001078                           129  
00001078  7E00                     130          MOVEQ.L #0,D7
0000107A                           131          
0000107A  41F9 000010BE            132          LEA     instOPList,A0           ;get instruction signitrue list in A0
00001080  D1C3                     133          ADDA.L  D3,A0                   ;get correct sig         
00001082                           134          
00001082  43F9 000010FA            135          LEA     instMaskList,A1         ;get instruction mask in A1
00001088  D3C3                     136          ADDA.L  D3,A1                   ;get correct mast
0000108A                           137          
0000108A  3401                     138          MOVE.W  D1,D2                   ;move instruction into D2 for manipulaiton
0000108C                           139          
0000108C  C451                     140          AND.W   (A1),D2                 ;mask instruction
0000108E                           141          
0000108E                           142          
0000108E                           143          
0000108E                           144          
0000108E  B450                     145          CMP.W   (A0),D2                 ;compare to sig
00001090  6700 000C                146          BEQ     match                   ;if sig matches branch
00001094  5483                     147          ADDQ.L  #word,D3                ;add to D3 to check for next instruction
00001096  60E0                     148          BRA checkOPcode
00001098                           149          
00001098                           150  falsePositive:
00001098                           151          
00001098  103C 00FF                152          MOVE.B #-1,D0
0000109C  4E75                     153          RTS
0000109E                           154  
0000109E                           155  match:
0000109E                           156          
0000109E  43F9 00001136            157          LEA     instLabelList,A1        ;get instruction code label
000010A4  D3C3                     158          ADDA.L  D3,A1                   ;get correct label
000010A6  D3C3                     159          ADDA.L  D3,A1
000010A8  5483                     160          ADDQ.L  #word,D3                ;add to D3 incase false positive
000010AA  2251                     161          MOVEA.L (A1),A1
000010AC  48E7 1000                162          MOVEM.L D3,-(SP)                ; save D3
000010B0  4E91                     163          JSR     (A1)
000010B2  4CDF 0008                164          MOVEM.L (SP)+,D3                ;restore D3
000010B6  B03C 00FF                165          CMP.B   #-1,D0
000010BA  67BC                     166          BEQ     checkOPcode
000010BC  4E75                     167          RTS
000010BE                           168          
000010BE                           169  
000010BE= 0040 B000                170  instOPList  DC.W moveaInstruction,eorInstruction
000010C2= B000 8000 0880 0...      171  instOPList2 DC.W cmpInstruction,orInstruction,bclrdataInstruction,bclrInstruction,leaInstruction,divsInstruction,mulsInstruction,rsrlweaInstruction,rsrlregInstruction,asrlweaInstruction,asrlregInstruction,lsrlweaInstruction,lsrlregInstruction
000010DC= 5100 9000 D000 D...      172  instOPList3 DC.W subqInstruction,subInstruction,addaInstruction,addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruct
000010FA                           173      
000010FA= C1C0 F000                174  instMaskList  DC.W moveaMask,eorMask
000010FE= F000 F000 FFC0 F...      175  instMaskList2 DC.W cmpMask,orMask,bclrdataMask,bclrMask,leaMask,divsMask,mulsMask,rsrlweaMask,rsrlregMask,asrlweaMask,asrlregMask,lsrlweaMask,lsrlregMask
00001118= F100 F000 F000 F...      176  instMaskList3 DC.W subqMask,subMask,addaMask,addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
00001136= 000024DA 00001232        177  instLabelList  DC.L MOVEA,EOR
0000113E= 000012D4 00001382 ...    178  instLabelList2 DC.L CMP,OR,BCLRDATA,BCLR,LEA,DIVS,MULS,RSRLWEA,RSRLREG,ASRLWEA,ASRLREG,LSRLWEA,LSRLREG
00001172= 00001A6E 00001B2C ...    179  instLabelList3 DC.L SUBQ,SUB,ADDA,ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
000011AE                           180  
000011AE                           181  checkContinue:
000011AE                           182          
000011AE  48A7 6040                183          MOVEM.W D1/D2/A1,-(SP)          ;save reg that are modified just in case
000011B2                           184          
000011B2  43F9 00002DFB            185          LEA     continuePrompt,A1       ;move string
000011B8  103C 000E                186          MOVE.B  #14,D0                  ;set for task to display null terminated 
000011BC                           187                                ;string without CR, LF
000011BC  4E4F                     188          TRAP    #15
000011BE                           189          
000011BE                           190          
000011BE  103C 0005                191          MOVE.B  #5,D0                   ;set for task to read single char into D1
000011C2  4E4F                     192          TRAP    #15
000011C4                           193          
000011C4  43F9 00002CFE            194          LEA     clearLine,A1            ;move string for a CR and LF
000011CA  103C 000E                195          MOVE.B  #14,D0                  ;set for task to display null terminated 
000011CE                           196                                ;string without CR, LF
000011CE  4E4F                     197          TRAP    #15
000011D0                           198          
000011D0                           199          ;if either case of 'Q' is entered, quit the program
000011D0  0C01 0073                200          CMPI.B #'s',D1
000011D4  6700 0012                201          BEQ checkNextAddr
000011D8  0C01 0053                202          CMPI.B #'S',D1
000011DC  6700 000A                203          BEQ checkNextAddr
000011E0                           204          
000011E0  4C9F 0206                205          MOVEM.W (SP)+,D1/D2/A1
000011E4  6000 FE30                206          BRA screenLoop
000011E8                           207  
000011E8                           208  checkNextAddr:
000011E8                           209  
000011E8  43F9 00002DAF            210          LEA     nextAddrPrompt,A1  ;move string
000011EE  103C 000E                211          MOVE.B  #14,D0        ;set for task to display null terminated 
000011F2                           212                                ;string without CR, LF
000011F2  4E4F                     213          TRAP    #15
000011F4                           214          
000011F4                           215          
000011F4  103C 0005                216          MOVE.B  #5,D0         ;set for task to read single char into D1
000011F8  4E4F                     217          TRAP    #15
000011FA                           218          
000011FA  43F9 00002CFE            219          LEA     clearLine,A1  ;move string for a CR and LF
00001200  103C 000E                220          MOVE.B  #14,D0        ;set for task to display null terminated 
00001204                           221                                ;string without CR, LF
00001204  4E4F                     222          TRAP    #15
00001206                           223          
00001206  0C01 0071                224          CMPI.B #'q',D1
0000120A  6700 1474                225          BEQ fin
0000120E  0C01 0051                226          CMPI.B #'Q',D1
00001212  6700 146C                227          BEQ fin
00001216                           228          
00001216  323C FF00                229          MOVE.W  #$FF00, D1     ;Clear screen value
0000121A  103C 000B                230          MOVE.B  #11,D0        ;set for task to clear screen
0000121E  4E4F                     231          TRAP    #15
00001220                           232          
00001220  6000 FDE2                233          BRA prompt_user
00001224                           234  
00001224                           235  *.............................................................................
00001224                           236  * Debug Mode begin: Comment out when done
00001224                           237  *snippet:
00001224                           238  *         NOP
00001224                           239  *         BRA snippet
00001224                           240  *         BRA FarLabel
00001224                           241  *         BEQ snippet
00001224                           242  *         BGT NEG
00001224                           243  *         BSR snippet
00001224                           244  *         MOVEA.W #$5668,A4
00001224                           245  *         NEG.B $3242
00001224                           246  *         NEG.W D2
00001224                           247  *         MOVE.B #$85,D1
00001224                           248  *         ADDI.L #30,D5
00001224                           249  *         RTS
00001224                           250  *         JSR $54
00001224                           251  *         CMPI.W #3,D1
00001224                           252  *         ORI.L  #3,D1
00001224                           253  *         MOVEM.L A3-A4,-(SP)
00001224                           254  *         MOVEM.L (SP)+,D1-A3
00001224                           255  *         ADD.B D1,D2
00001224                           256  *         ADD.B #10,D3
00001224                           257  *         ADDA.W #23,A3
00001224                           258  *         SUB.W D3,D5
00001224                           259  *         SUBQ.B #8,D5
00001224                           260  *         SUBQ.L #1,D5
00001224                           261  *         LSR.B #3,D3
00001224                           262  *         LSL.L #3,D4
00001224                           263  *         LSL.W D1,D1
00001224                           264  *         LSR.B D3,D7
00001224                           265  *         LSR $3563
00001224                           266  *         LSL $486412
00001224                           267  *         ASR.W #3,D3
00001224                           268  *         ASL.L #3,D4
00001224                           269  *         ASL.L D1,D1
00001224                           270  *         ASR.B D3,D7
00001224                           271  *         ASR.W $3563
00001224                           272  *         ASL.W $486412
00001224                           273  *         ROR.L #3,D3
00001224                           274  *         ROL.W #3,D4
00001224                           275  *         ROL.B D1,D1
00001224                           276  *         ROR D3,D7
00001224                           277  *         ROR $3563
00001224                           278  *         ROL $486412
00001224                           279  *         MULS #$4562,D2
00001224                           280  *         DIVS #$4562,D2
00001224                           281  *         LEA leaEAmasks,A1
00001224                           282  *         BCLR D1,D4
00001224                           283  *         BCLR #20,D5
00001224                           284  *         OR.B D1,D2
00001224                           285  *         OR.B #10,D3
00001224                           286  *         CMP.W D2,D5
00001224                           287  *         CMP.L (A3),D4
00001224                           288  *         EOR.W D2,D5
00001224                           289  *         EOR.L D4,(A3)
00001224                           290  *         MOVE.W #$5435,D6
00001224                           291  *         MOVE.L #$463463,D3
00001224                           292  *snippetEnd:
00001224                           293  *         SIMHALT
00001224                           294  * Debug Mode end:   Comment out when done
00001224                           295  *.............................................................................
00001224                           296           
00001224                           297           
00001224= 00 10 18 20 38 39 00     298  eorEA      Dc.B %000000,%010000,%011000,%100000,%111000,%111001,0
0000122B= 38 38 38 38 3F 3F 00     299  eorEAmasks DC.B %111000,%111000,%111000,%111000,%111111,%111111,0
00001232                           300  
00001232                           301  
00001232                           302  
00001232                           303  EOR:
00001232                           304          
00001232                           305  
00001232                           306          
00001232  7000                     307          MOVEQ.L #0, D0                  ;clear D0
00001234                           308          
00001234                           309          ;Figure out if EA is source or destination
00001234  3401                     310          MOVE.W D1,D2                    ;copy inst to D2
00001236  EC4A                     311          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001238  0202 0007                312          ANDI.B #%00000111,D2            ;mask out rest of byte
0000123C  0C02 0003                313          CMPI.B #3,D2                    ;compare to 3
00001240  6F00 FE56                314          BLE falsePositive               ;3 or less is not valid
00001244                           315          
00001244  0C02 0007                316          CMPI.B #%111,D2                 ;compare to 7
00001248  6700 FE4E                317          BEQ falsePositive               ;thats not valid
0000124C  6000 0002                318          BRA validEorEA                  ;all thats left is valid EA size 
00001250                           319          
00001250                           320  validEorEA:
00001250                           321          
00001250  43F8 122B                322          LEA eorEAmasks,A1               ;load the list of masks
00001254  D3C0                     323          ADDA.L D0,A1                    ;displace to a specific mask
00001256  1A11                     324          MOVE.B (A1),D5                  ;move the mask to D5
00001258                           325          
00001258  0C05 0000                326          CMPI.B #0,D5                    ;check if the mask is 0
0000125C  6700 FE3A                327          BEQ falsePositive               ;branch if it is
00001260                           328          
00001260  1401                     329          MOVE.B D1,D2                    ;copy instruction to D2
00001262  C405                     330          AND.B D5,D2                     ;mask D2
00001264                           331          
00001264  43F8 1224                332          LEA eorEA,A1                    ;load the list of valid modes
00001268  D3C0                     333          ADDA.L D0,A1                    ;displace to a specific mode
0000126A  1811                     334          MOVE.B (A1),D4                  ;move mode to D4
0000126C  B404                     335          CMP.B D4,D2                     ;compare mode to masked value
0000126E  6700 0006                336          BEQ  eorBody                    ;if its match, its a valid mode and we can procede
00001272                           337          
00001272  5280                     338          ADDQ.L #1,D0                    ;add one to displacement
00001274  60DA                     339          BRA validEorEA                  ;check for next mode
00001276                           340                  
00001276                           341  
00001276                           342  eorBody
00001276                           343  
00001276  43F9 00002D01            344          LEA     eorMessage,A1           ;move string for MOVE
0000127C  103C 000E                345          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001280                           346                                ;string with CR, LF
00001280  4E4F                     347          TRAP    #15
00001282                           348          
00001282  6100 0EEA                349          BSR negSize
00001286                           350          
00001286                           351          ;Do Dn
00001286                           352          
00001286  3401                     353          MOVE.W  D1,D2
00001288  E04A                     354          LSR.W   #8,D2                   ;move reg into first byte
0000128A  E20A                     355          LSR.B   #1,D2                   ;line it up to least sig bit
0000128C  C43C 0007                356          AND.B   #%00000111,D2           ;force mode to Dn
00001290  1A02                     357          MOVE.B  D2,D5
00001292  48E7 4000                358          MOVEM.L D1,-(SP)
00001296  6100 1592                359          BSR     Get_Effective_Address
0000129A  4CDF 0002                360          MOVEM.L (SP)+,D1
0000129E                           361          
0000129E                           362          
0000129E                           363          ;print ','
0000129E  48E7 4000                364          MOVEM.L D1,-(SP)                ;save D1 to the stack
000012A2  123C 002C                365          MOVE.B #',',D1                  ;put ascii value of char in D1
000012A6  103C 0006                366          MOVE.B #6,D0                    ;move task 6 into D0
000012AA  4E4F                     367          TRAP #15                        ;prin char
000012AC  4CDF 0002                368          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000012B0                           369          
000012B0                           370          ;Then do EA
000012B0                           371          
000012B0  3401                     372          MOVE.W  D1,D2                   ;check mode
000012B2  C43C 003F                373          AND.B   #%00111111,D2
000012B6  1A02                     374          MOVE.B  D2,D5
000012B8  48E7 4000                375          MOVEM.L D1,-(SP)
000012BC  6100 156C                376          BSR     Get_Effective_Address
000012C0  4CDF 0002                377          MOVEM.L (SP)+,D1
000012C4                           378          
000012C4                           379          
000012C4  43F9 00002CFE            380          LEA     clearLine,A1            ;move string for a CR and LF
000012CA  103C 000E                381          MOVE.B  #14,D0                  ;set for task to display null terminated 
000012CE                           382                                ;string without CR, LF
000012CE  4E4F                     383          TRAP    #15
000012D0                           384  
000012D0  7000                     385          MOVEQ.L #0,D0
000012D2  4E75                     386          RTS
000012D4                           387  
000012D4                           388  
000012D4                           389  
000012D4                           390  CMP:
000012D4                           391          
000012D4                           392  
000012D4                           393          
000012D4  7000                     394          MOVEQ.L #0, D0                  ;clear D0
000012D6                           395          
000012D6                           396          ;Figure out if EA is source or destination
000012D6  3401                     397          MOVE.W D1,D2                    ;copy inst to D2
000012D8  EC4A                     398          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
000012DA  0202 0007                399          ANDI.B #%00000111,D2            ;mask out rest of byte
000012DE  0C02 0002                400          CMPI.B #2,D2                    ;compare to 2
000012E2  6F00 0006                401          BLE validCmpEA                  ;2 or less is EA 
000012E6                           402          
000012E6  6000 FDB0                403          BRA falsePositive               ;thats not valid
000012EA                           404          
000012EA                           405  validCmpEA:
000012EA                           406          
000012EA  43F9 000023C5            407          LEA moveSourceEAmasks,A1        ;load the list of masks
000012F0  D3C0                     408          ADDA.L D0,A1                    ;displace to a specific mask
000012F2  1A11                     409          MOVE.B (A1),D5                  ;move the mask to D5
000012F4                           410          
000012F4  0C05 0000                411          CMPI.B #0,D5                    ;check if the mask is 0
000012F8  6700 FD9E                412          BEQ falsePositive               ;branch if it is
000012FC                           413          
000012FC  1401                     414          MOVE.B D1,D2                    ;copy instruction to D2
000012FE  C405                     415          AND.B D5,D2                     ;mask D2
00001300                           416          
00001300  43F9 000023BC            417          LEA moveSourceEA,A1             ;load the list of valid modes
00001306  D3C0                     418          ADDA.L D0,A1                    ;displace to a specific mode
00001308  1811                     419          MOVE.B (A1),D4                  ;move mode to D4
0000130A  B404                     420          CMP.B D4,D2                     ;compare mode to masked value
0000130C  6700 0006                421          BEQ  cmpBody                    ;if its match, its a valid mode and we can procede
00001310                           422          
00001310  5280                     423          ADDQ.L #1,D0                    ;add one to displacement
00001312  60D6                     424          BRA validCmpEA                  ;check for next mode
00001314                           425          
00001314                           426          
00001314                           427          
00001314                           428  cmpBody
00001314                           429  
00001314  43F9 00002D05            430          LEA     cmpMessage,A1           ;move string for MOVE
0000131A  103C 000E                431          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000131E                           432                                ;string with CR, LF
0000131E  4E4F                     433          TRAP    #15
00001320                           434          
00001320  6100 0E4C                435          BSR negSize
00001324                           436          
00001324                           437          ;do EA
00001324                           438          
00001324  3401                     439          MOVE.W  D1,D2                   ;check mode
00001326  C43C 003F                440          AND.B   #%00111111,D2
0000132A  1A02                     441          MOVE.B  D2,D5
0000132C  48E7 4000                442          MOVEM.L D1,-(SP)
00001330  6100 14F8                443          BSR     Get_Effective_Address
00001334  4CDF 0002                444          MOVEM.L (SP)+,D1
00001338                           445          
00001338                           446          ;print ','
00001338  48E7 4000                447          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000133C  123C 002C                448          MOVE.B #',',D1                  ;put ascii value of char in D1
00001340  103C 0006                449          MOVE.B #6,D0                    ;move task 6 into D0
00001344  4E4F                     450          TRAP #15                        ;prin char
00001346  4CDF 0002                451          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000134A                           452          
0000134A                           453          ;Then do Dn
0000134A                           454          
0000134A  3401                     455          MOVE.W  D1,D2
0000134C  E04A                     456          LSR.W   #8,D2                   ;move reg into first byte
0000134E  E20A                     457          LSR.B   #1,D2                   ;line it up to least sig bit
00001350  C43C 0007                458          AND.B   #%00000111,D2           ;force mode to Dn
00001354  1A02                     459          MOVE.B  D2,D5
00001356  48E7 4000                460          MOVEM.L D1,-(SP)
0000135A  6100 14CE                461          BSR     Get_Effective_Address
0000135E  4CDF 0002                462          MOVEM.L (SP)+,D1
00001362                           463          
00001362  43F9 00002CFE            464          LEA     clearLine,A1            ;move string for a CR and LF
00001368  103C 000E                465          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000136C                           466                                ;string without CR, LF
0000136C  4E4F                     467          TRAP    #15
0000136E                           468  
0000136E  7000                     469          MOVEQ.L #0,D0
00001370  4E75                     470          RTS
00001372                           471  
00001372                           472  
00001372                           473  
00001372= 00 10 18 20 38 39 ...    474  orSourceEA      Dc.B %000000,%010000,%011000,%100000,%111000,%111001,%111100,0
0000137A= 38 38 38 38 3F 3F ...    475  orSourceEAmasks DC.B %111000,%111000,%111000,%111000,%111111,%111111,%111111,0
00001382                           476  
00001382                           477  OR:
00001382                           478          
00001382                           479  
00001382                           480          
00001382  7000                     481          MOVEQ.L #0, D0                  ;clear D0
00001384                           482          
00001384                           483          ;Figure out if EA is source or destination
00001384  3401                     484          MOVE.W D1,D2                    ;copy inst to D2
00001386  EC4A                     485          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001388  0202 0007                486          ANDI.B #%00000111,D2            ;mask out rest of byte
0000138C  0C02 0002                487          CMPI.B #2,D2                    ;compare to 2
00001390  6F00 0016                488          BLE validOrSourceEA             ;2 or less is EA is source
00001394                           489          
00001394  0C02 0007                490          CMPI.B #%111,D2                 ;compare to 7
00001398  6700 FCFE                491          BEQ falsePositive               ;thats not valid
0000139C  0C02 0003                492          CMPI.B #%11,D2                  ;compare to 3
000013A0  6700 FCF6                493          BEQ falsePositive               ;also not valid
000013A4  6000 0028                494          BRA validOrDestEA               ;all thats left is valid EA as Dest 
000013A8                           495          
000013A8                           496  validORSourceEA:
000013A8                           497          
000013A8  43F8 137A                498          LEA orSourceEAmasks,A1          ;load the list of masks
000013AC  D3C0                     499          ADDA.L D0,A1                    ;displace to a specific mask
000013AE  1A11                     500          MOVE.B (A1),D5                  ;move the mask to D5
000013B0                           501          
000013B0  0C05 0000                502          CMPI.B #0,D5                    ;check if the mask is 0
000013B4  6700 FCE2                503          BEQ falsePositive               ;branch if it is
000013B8                           504          
000013B8  1401                     505          MOVE.B D1,D2                    ;copy instruction to D2
000013BA  C405                     506          AND.B D5,D2                     ;mask D2
000013BC                           507          
000013BC  43F8 1372                508          LEA orSourceEA,A1               ;load the list of valid modes
000013C0  D3C0                     509          ADDA.L D0,A1                    ;displace to a specific mode
000013C2  1811                     510          MOVE.B (A1),D4                  ;move mode to D4
000013C4  B404                     511          CMP.B D4,D2                     ;compare mode to masked value
000013C6  6700 0030                512          BEQ  orSource                   ;if its match, its a valid mode and we can procede
000013CA                           513          
000013CA  5280                     514          ADDQ.L #1,D0                    ;add one to displacement
000013CC  60DA                     515          BRA validOrSourceEA             ;check for next mode
000013CE                           516          
000013CE                           517          
000013CE                           518  validOrDestEA:
000013CE                           519          
000013CE  43F9 00001D22            520          LEA addDestEAmasks,A1           ;load the list of masks
000013D4  D3C0                     521          ADDA.L D0,A1                    ;displace to a specific mask
000013D6  1A11                     522          MOVE.B (A1),D5                  ;move the mask to D5
000013D8                           523          
000013D8  0C05 0000                524          CMPI.B #0,D5                    ;check if the mask is 0
000013DC  6700 FCBA                525          BEQ falsePositive               ;branch if it is
000013E0                           526          
000013E0  3401                     527          MOVE.W D1,D2                    ;copy instruction to D2
000013E2  C405                     528          AND.B D5,D2                     ;mask D2
000013E4                           529          
000013E4  43F9 00001D1C            530          LEA addDestEA,A1                ;load the list of valid modes
000013EA  D3C0                     531          ADDA.L D0,A1                    ;displace to a specific mode
000013EC  1811                     532          MOVE.B (A1),D4                  ;move mode to D4
000013EE  B404                     533          CMP.B D4,D2                     ;compare mode to masked value
000013F0  6700 0064                534          BEQ orDest                      ;if its match, its a valid mode and we can procede
000013F4                           535          
000013F4  5280                     536          ADDQ.L #1,D0                    ;add one to displacement
000013F6  60D6                     537          BRA validOrDestEA               ;check for next mode
000013F8                           538          
000013F8                           539  orSource
000013F8                           540  
000013F8  43F9 00002D09            541          LEA     orMessage,A1            ;move string for MOVE
000013FE  103C 000E                542          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001402                           543                                ;string with CR, LF
00001402  4E4F                     544          TRAP    #15
00001404                           545          
00001404  6100 0D68                546          BSR negSize
00001408                           547          
00001408                           548          ;do EA
00001408                           549          
00001408  3401                     550          MOVE.W  D1,D2                   ;check mode
0000140A  C43C 003F                551          AND.B   #%00111111,D2
0000140E  1A02                     552          MOVE.B  D2,D5
00001410  48E7 4000                553          MOVEM.L D1,-(SP)
00001414  6100 1414                554          BSR     Get_Effective_Address
00001418  4CDF 0002                555          MOVEM.L (SP)+,D1
0000141C                           556          
0000141C                           557          ;print ','
0000141C  48E7 4000                558          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001420  123C 002C                559          MOVE.B #',',D1                  ;put ascii value of char in D1
00001424  103C 0006                560          MOVE.B #6,D0                    ;move task 6 into D0
00001428  4E4F                     561          TRAP #15                        ;prin char
0000142A  4CDF 0002                562          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000142E                           563          
0000142E                           564          ;Then do Dn
0000142E                           565          
0000142E  3401                     566          MOVE.W  D1,D2
00001430  E04A                     567          LSR.W   #8,D2                   ;move reg into first byte
00001432  E20A                     568          LSR.B   #1,D2                   ;line it up to least sig bit
00001434  C43C 0007                569          AND.B   #%00000111,D2           ;force mode to Dn
00001438  1A02                     570          MOVE.B  D2,D5
0000143A  48E7 4000                571          MOVEM.L D1,-(SP)
0000143E  6100 13EA                572          BSR     Get_Effective_Address
00001442  4CDF 0002                573          MOVEM.L (SP)+,D1
00001446                           574          
00001446  43F9 00002CFE            575          LEA     clearLine,A1            ;move string for a CR and LF
0000144C  103C 000E                576          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001450                           577                                ;string without CR, LF
00001450  4E4F                     578          TRAP    #15
00001452                           579  
00001452  7000                     580          MOVEQ.L #0,D0
00001454  4E75                     581          RTS
00001456                           582  
00001456                           583  orDest
00001456                           584  
00001456  43F9 00002D09            585          LEA     orMessage,A1            ;move string for MOVE
0000145C  103C 000E                586          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001460                           587                                ;string with CR, LF
00001460  4E4F                     588          TRAP    #15
00001462                           589          
00001462  6100 0D0A                590          BSR negSize
00001466                           591          
00001466                           592          ;Do Dn
00001466                           593          
00001466  3401                     594          MOVE.W  D1,D2
00001468  E04A                     595          LSR.W   #8,D2                   ;move reg into first byte
0000146A  E20A                     596          LSR.B   #1,D2                   ;line it up to least sig bit
0000146C  C43C 0007                597          AND.B   #%00000111,D2           ;force mode to Dn
00001470  1A02                     598          MOVE.B  D2,D5
00001472  48E7 4000                599          MOVEM.L D1,-(SP)
00001476  6100 13B2                600          BSR     Get_Effective_Address
0000147A  4CDF 0002                601          MOVEM.L (SP)+,D1
0000147E                           602          
0000147E                           603          
0000147E                           604          ;print ','
0000147E  48E7 4000                605          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001482  123C 002C                606          MOVE.B #',',D1                  ;put ascii value of char in D1
00001486  103C 0006                607          MOVE.B #6,D0                    ;move task 6 into D0
0000148A  4E4F                     608          TRAP #15                        ;prin char
0000148C  4CDF 0002                609          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001490                           610          
00001490                           611          ;Then do EA
00001490                           612          
00001490  3401                     613          MOVE.W  D1,D2                   ;check mode
00001492  C43C 003F                614          AND.B   #%00111111,D2
00001496  1A02                     615          MOVE.B  D2,D5
00001498  48E7 4000                616          MOVEM.L D1,-(SP)
0000149C  6100 138C                617          BSR     Get_Effective_Address
000014A0  4CDF 0002                618          MOVEM.L (SP)+,D1
000014A4                           619          
000014A4                           620          
000014A4  43F9 00002CFE            621          LEA     clearLine,A1            ;move string for a CR and LF
000014AA  103C 000E                622          MOVE.B  #14,D0                  ;set for task to display null terminated 
000014AE                           623                                ;string without CR, LF
000014AE  4E4F                     624          TRAP    #15
000014B0                           625  
000014B0  7000                     626          MOVEQ.L #0,D0
000014B2  4E75                     627          RTS
000014B4                           628  
000014B4                           629  
000014B4                           630  
000014B4                           631  
000014B4                           632  BCLRDATA:
000014B4                           633  
000014B4  7000                     634          MOVEQ.L #0, D0                  ;clear D0
000014B6                           635          
000014B6                           636  validBCLRdataModes:
000014B6                           637          
000014B6  43F9 000016F4            638          LEA mulsEAmasks,A1              ;load the list of masks
000014BC  D3C0                     639          ADDA.L D0,A1                    ;displace to a specific mask
000014BE  1A11                     640          MOVE.B (A1),D5                  ;move the mask to D5
000014C0                           641          
000014C0  0C05 0000                642          CMPI.B #0,D5                    ;check if the mask is 0
000014C4  6700 FBD2                643          BEQ falsePositive               ;branch if it is
000014C8                           644          
000014C8  1401                     645          MOVE.B D1,D2                    ;copy instruction to D2
000014CA  C405                     646          AND.B D5,D2                     ;mask D2
000014CC                           647          
000014CC  43F9 000016EC            648          LEA mulsEA,A1                   ;load the list of valid modes
000014D2  D3C0                     649          ADDA.L D0,A1                    ;displace to a specific mode
000014D4  1811                     650          MOVE.B (A1),D4                  ;move mode to D4
000014D6  B404                     651          CMP.B D4,D2                     ;compare mode to masked value
000014D8  6700 0006                652          BEQ  bclrdataBody               ;if its match, its a valid mode and we can procede
000014DC                           653          
000014DC  5280                     654          ADDQ.L #1,D0                    ;add one to displacement
000014DE  60D6                     655          BRA validBCLRdataModes          ;check for next mode
000014E0                           656          
000014E0                           657  bclrdataBody:
000014E0                           658          
000014E0                           659  
000014E0                           660  
000014E0  43F9 00002D0C            661          LEA     bclrMessage,A1          ;move string for MOVE
000014E6  103C 000E                662          MOVE.B  #14,D0                  ;set for task to display null terminated 
000014EA                           663                                ;string without CR, LF
000014EA  4E4F                     664          TRAP    #15
000014EC                           665  
000014EC  48E7 C010                666          MOVEM.L D0/D1/A3,-(SP)          ;save D1 and A3
000014F0  5487                     667          ADDQ.L #word,D7                 ;signal there is a word following this instruction
000014F2                           668          
000014F2                           669          ;print '#'
000014F2  48E7 4000                670          MOVEM.L D1,-(SP)                ;save D1 to the stack
000014F6  123C 0023                671          MOVE.B #'#',D1                  ;put ascii value of char in D1
000014FA  103C 0006                672          MOVE.B #6,D0                    ;move task 6 into D0
000014FE  4E4F                     673          TRAP #15                        ;prin char
00001500  4CDF 0002                674          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001504                           675          
00001504                           676          ;get following word
00001504  548B                     677          ADDQ.L #word,A3
00001506  3213                     678          MOVE.W (A3),D1                  ;move word at (A3)
00001508  0281 0000FFFF            679          ANDI.L #$0000FFFF,D1            ;clear unimportant bit of D1
0000150E                           680          
0000150E                           681          ;print number
0000150E  103C 0003                682          MOVE.B #3,D0
00001512  4E4F                     683          TRAP #15
00001514                           684          
00001514  4CDF 0803                685          MOVEM.L (SP)+,D0/D1/A3          ;restore D1 and A3
00001518                           686  
00001518                           687  
00001518                           688  
00001518                           689          ;print ','
00001518  48E7 4000                690          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000151C  123C 002C                691          MOVE.B #',',D1                  ;put ascii value of char in D1
00001520  103C 0006                692          MOVE.B #6,D0                    ;move task 6 into D0
00001524  4E4F                     693          TRAP #15                        ;prin char
00001526  4CDF 0002                694          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000152A                           695          
0000152A                           696          ;do dest EA
0000152A  3401                     697          MOVE.W  D1,D2                   ;check mode
0000152C  C43C 003F                698          AND.B   #%00111111,D2
00001530  1A02                     699          MOVE.B  D2,D5
00001532  48E7 4000                700          MOVEM.L D1,-(SP)
00001536  6100 12F2                701          BSR     Get_Effective_Address
0000153A  4CDF 0002                702          MOVEM.L (SP)+,D1
0000153E                           703          
0000153E  43F9 00002CFE            704          LEA     clearLine,A1            ;move string for a CR and LF
00001544  103C 000E                705          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001548                           706                                ;string without CR, LF
00001548  4E4F                     707          TRAP    #15
0000154A                           708  
0000154A  7000                     709          MOVEQ.L #0,D0
0000154C  4E75                     710          RTS
0000154E                           711  
0000154E                           712  
0000154E                           713  
0000154E                           714           
0000154E                           715  BCLR:
0000154E                           716  
0000154E  7000                     717          MOVEQ.L #0, D0                  ;clear D0
00001550                           718          
00001550                           719  validBCLRModes:
00001550                           720          
00001550  43F9 000016F4            721          LEA mulsEAmasks,A1              ;load the list of masks
00001556  D3C0                     722          ADDA.L D0,A1                    ;displace to a specific mask
00001558  1A11                     723          MOVE.B (A1),D5                  ;move the mask to D5
0000155A                           724          
0000155A  0C05 0000                725          CMPI.B #0,D5                    ;check if the mask is 0
0000155E  6700 FB38                726          BEQ falsePositive               ;branch if it is
00001562                           727          
00001562  1401                     728          MOVE.B D1,D2                    ;copy instruction to D2
00001564  C405                     729          AND.B D5,D2                     ;mask D2
00001566                           730          
00001566  43F9 000016EC            731          LEA mulsEA,A1                   ;load the list of valid modes
0000156C  D3C0                     732          ADDA.L D0,A1                    ;displace to a specific mode
0000156E  1811                     733          MOVE.B (A1),D4                  ;move mode to D4
00001570  B404                     734          CMP.B D4,D2                     ;compare mode to masked value
00001572  6700 0006                735          BEQ  bclrBody                   ;if its match, its a valid mode and we can procede
00001576                           736          
00001576  5280                     737          ADDQ.L #1,D0                    ;add one to displacement
00001578  60D6                     738          BRA validBCLRModes              ;check for next mode
0000157A                           739          
0000157A                           740  bclrBody:
0000157A                           741          
0000157A                           742  
0000157A                           743  
0000157A  43F9 00002D0C            744          LEA     bclrMessage,A1          ;move string for MOVE
00001580  103C 000E                745          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001584                           746                                ;string without CR, LF
00001584  4E4F                     747          TRAP    #15
00001586                           748  
00001586                           749          ;do source EA
00001586  3401                     750          MOVE.W  D1,D2                   ;check mode
00001588  C43C 003F                751          AND.B   #%00111111,D2
0000158C  1A02                     752          MOVE.B  D2,D5
0000158E  48E7 4000                753          MOVEM.L D1,-(SP)
00001592  6100 1296                754          BSR     Get_Effective_Address
00001596  4CDF 0002                755          MOVEM.L (SP)+,D1
0000159A                           756  
0000159A                           757          ;print ','
0000159A  48E7 4000                758          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000159E  123C 002C                759          MOVE.B #',',D1                  ;put ascii value of char in D1
000015A2  103C 0006                760          MOVE.B #6,D0                    ;move task 6 into D0
000015A6  4E4F                     761          TRAP #15                        ;prin char
000015A8  4CDF 0002                762          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000015AC                           763          
000015AC                           764          ;do dest data reg
000015AC  3401                     765          MOVE.W  D1,D2                   ;check mode
000015AE  E04A                     766          LSR.W #8,D2                     ;shift reg over
000015B0  E20A                     767          LSR.B #1,D2
000015B2  C43C 0007                768          AND.B   #%00000111,D2           ;force recognition as a Dn
000015B6  1A02                     769          MOVE.B  D2,D5
000015B8  48E7 4000                770          MOVEM.L D1,-(SP)
000015BC  6100 126C                771          BSR     Get_Effective_Address
000015C0  4CDF 0002                772          MOVEM.L (SP)+,D1
000015C4                           773          
000015C4  43F9 00002CFE            774          LEA     clearLine,A1            ;move string for a CR and LF
000015CA  103C 000E                775          MOVE.B  #14,D0                  ;set for task to display null terminated 
000015CE                           776                                ;string without CR, LF
000015CE  4E4F                     777          TRAP    #15
000015D0                           778  
000015D0  7000                     779          MOVEQ.L #0,D0
000015D2  4E75                     780          RTS
000015D4                           781  
000015D4                           782           
000015D4                           783  
000015D4= 10 38 39 00              784  leaEA        DC.B %010000,%111000,%111001,0
000015D8= 38 3F 3F 00              785  leaEAmasks   DC.B %111000,%111111,%111111,0
000015DC                           786          
000015DC                           787  LEA:
000015DC                           788  
000015DC  7000                     789          MOVEQ.L #0, D0                  ;clear D0
000015DE                           790          
000015DE                           791  validLeaModes:
000015DE                           792          
000015DE  43F8 15D8                793          LEA leaEAmasks,A1               ;load the list of masks
000015E2  D3C0                     794          ADDA.L D0,A1                    ;displace to a specific mask
000015E4  1A11                     795          MOVE.B (A1),D5                  ;move the mask to D5
000015E6                           796          
000015E6  0C05 0000                797          CMPI.B #0,D5                    ;check if the mask is 0
000015EA  6700 FAAC                798          BEQ falsePositive               ;branch if it is
000015EE                           799          
000015EE  1401                     800          MOVE.B D1,D2                    ;copy instruction to D2
000015F0  C405                     801          AND.B D5,D2                     ;mask D2
000015F2                           802          
000015F2  43F8 15D4                803          LEA leaEA,A1                    ;load the list of valid modes
000015F6  D3C0                     804          ADDA.L D0,A1                    ;displace to a specific mode
000015F8  1811                     805          MOVE.B (A1),D4                  ;move mode to D4
000015FA  B404                     806          CMP.B D4,D2                     ;compare mode to masked value
000015FC  6700 0006                807          BEQ  leaBody                    ;if its match, its a valid mode and we can procede
00001600                           808          
00001600  5280                     809          ADDQ.L #1,D0                    ;add one to displacement
00001602  60DA                     810          BRA validLeaModes               ;check for next mode
00001604                           811          
00001604                           812  leaBody:
00001604                           813          
00001604                           814  
00001604                           815  
00001604  43F9 00002D12            816          LEA     leaMessage,A1           ;move string for MOVE
0000160A  103C 000E                817          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000160E                           818                                ;string without CR, LF
0000160E  4E4F                     819          TRAP    #15
00001610                           820  
00001610                           821          ;do source EA
00001610  3401                     822          MOVE.W  D1,D2                   ;check mode
00001612  C43C 003F                823          AND.B   #%00111111,D2
00001616  1A02                     824          MOVE.B  D2,D5
00001618  48E7 4000                825          MOVEM.L D1,-(SP)
0000161C  6100 120C                826          BSR     Get_Effective_Address
00001620  4CDF 0002                827          MOVEM.L (SP)+,D1
00001624                           828  
00001624                           829          ;print ','
00001624  48E7 4000                830          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001628  123C 002C                831          MOVE.B #',',D1                  ;put ascii value of char in D1
0000162C  103C 0006                832          MOVE.B #6,D0                    ;move task 6 into D0
00001630  4E4F                     833          TRAP #15                        ;prin char
00001632  4CDF 0002                834          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001636                           835          
00001636                           836          ;do dest addr reg
00001636  3401                     837          MOVE.W  D1,D2                   ;check mode
00001638  E04A                     838          LSR.W #8,D2                     ;shift reg over
0000163A  E20A                     839          LSR.B #1,D2
0000163C  C43C 0007                840          AND.B   #%00000111,D2           ;force recognition as a An
00001640  5002                     841          ADDQ.B #%1000,D2
00001642  1A02                     842          MOVE.B  D2,D5
00001644  48E7 4000                843          MOVEM.L D1,-(SP)
00001648  6100 11E0                844          BSR     Get_Effective_Address
0000164C  4CDF 0002                845          MOVEM.L (SP)+,D1
00001650                           846          
00001650  43F9 00002CFE            847          LEA     clearLine,A1            ;move string for a CR and LF
00001656  103C 000E                848          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000165A                           849                                ;string without CR, LF
0000165A  4E4F                     850          TRAP    #15
0000165C                           851  
0000165C  7000                     852          MOVEQ.L #0,D0
0000165E  4E75                     853          RTS
00001660                           854  
00001660                           855  
00001660                           856  
00001660                           857  DIVS:
00001660                           858  
00001660  7000                     859          MOVEQ.L #0, D0                  ;clear D0
00001662                           860          
00001662                           861  validDivsModes:
00001662                           862          
00001662  43F9 000016F4            863          LEA mulsEAmasks,A1              ;load the list of masks
00001668  D3C0                     864          ADDA.L D0,A1                    ;displace to a specific mask
0000166A  1A11                     865          MOVE.B (A1),D5                  ;move the mask to D5
0000166C                           866          
0000166C  0C05 0000                867          CMPI.B #0,D5                    ;check if the mask is 0
00001670  6700 FA26                868          BEQ falsePositive               ;branch if it is
00001674                           869          
00001674  1401                     870          MOVE.B D1,D2                    ;copy instruction to D2
00001676  C405                     871          AND.B D5,D2                     ;mask D2
00001678                           872          
00001678  43F9 000016EC            873          LEA mulsEA,A1                   ;load the list of valid modes
0000167E  D3C0                     874          ADDA.L D0,A1                    ;displace to a specific mode
00001680  1811                     875          MOVE.B (A1),D4                  ;move mode to D4
00001682  B404                     876          CMP.B D4,D2                     ;compare mode to masked value
00001684  6700 0006                877          BEQ  divsBody                   ;if its match, its a valid mode and we can procede
00001688                           878          
00001688  5280                     879          ADDQ.L #1,D0                    ;add one to displacement
0000168A  60D6                     880          BRA validDivsModes              ;check for next mode
0000168C                           881          
0000168C                           882  divsBody:
0000168C                           883          
0000168C                           884  
0000168C                           885  
0000168C  43F9 00002D17            886          LEA     divsMessage,A1          ;move string for MOVE
00001692  103C 000E                887          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001696                           888                                ;string without CR, LF
00001696  4E4F                     889          TRAP    #15
00001698                           890          
00001698                           891          ;set size to word
00001698  7C01                     892          MOVEQ.L #1,D6
0000169A  6100 132C                893          BSR printSize
0000169E                           894          
0000169E                           895          ;do source EA
0000169E  3401                     896          MOVE.W  D1,D2                   ;check mode
000016A0  C43C 003F                897          AND.B   #%00111111,D2
000016A4  1A02                     898          MOVE.B  D2,D5
000016A6  48E7 4000                899          MOVEM.L D1,-(SP)
000016AA  6100 117E                900          BSR     Get_Effective_Address
000016AE  4CDF 0002                901          MOVEM.L (SP)+,D1
000016B2                           902  
000016B2                           903          ;print ','
000016B2  48E7 4000                904          MOVEM.L D1,-(SP)                ;save D1 to the stack
000016B6  123C 002C                905          MOVE.B #',',D1                  ;put ascii value of char in D1
000016BA  103C 0006                906          MOVE.B #6,D0                    ;move task 6 into D0
000016BE  4E4F                     907          TRAP #15                        ;prin char
000016C0  4CDF 0002                908          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000016C4                           909          
000016C4                           910          ;do dest data reg
000016C4  3401                     911          MOVE.W  D1,D2                   ;check mode
000016C6  E04A                     912          LSR.W #8,D2                     ;shift reg over
000016C8  E20A                     913          LSR.B #1,D2
000016CA  C43C 0007                914          AND.B   #%00000111,D2           ;force recognition as a Dn
000016CE  1A02                     915          MOVE.B  D2,D5
000016D0  48E7 4000                916          MOVEM.L D1,-(SP)
000016D4  6100 1154                917          BSR     Get_Effective_Address
000016D8  4CDF 0002                918          MOVEM.L (SP)+,D1
000016DC                           919          
000016DC  43F9 00002CFE            920          LEA     clearLine,A1            ;move string for a CR and LF
000016E2  103C 000E                921          MOVE.B  #14,D0                  ;set for task to display null terminated 
000016E6                           922                                ;string without CR, LF
000016E6  4E4F                     923          TRAP    #15
000016E8                           924  
000016E8  7000                     925          MOVEQ.L #0,D0
000016EA  4E75                     926          RTS
000016EC                           927  
000016EC                           928  
000016EC                           929  
000016EC                           930  
000016EC= 00 10 18 20 38 39 ...    931  mulsEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,%111100,0
000016F4= 38 38 38 38 3F 3F ...    932  mulsEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,%111111,0
000016FC                           933          
000016FC                           934  MULS:
000016FC                           935  
000016FC  7000                     936          MOVEQ.L #0, D0                  ;clear D0
000016FE                           937          
000016FE                           938  validMulsModes:
000016FE                           939          
000016FE  43F8 16F4                940          LEA mulsEAmasks,A1              ;load the list of masks
00001702  D3C0                     941          ADDA.L D0,A1                    ;displace to a specific mask
00001704  1A11                     942          MOVE.B (A1),D5                  ;move the mask to D5
00001706                           943          
00001706  0C05 0000                944          CMPI.B #0,D5                    ;check if the mask is 0
0000170A  6700 F98C                945          BEQ falsePositive               ;branch if it is
0000170E                           946          
0000170E  1401                     947          MOVE.B D1,D2                    ;copy instruction to D2
00001710  C405                     948          AND.B D5,D2                     ;mask D2
00001712                           949          
00001712  43F8 16EC                950          LEA mulsEA,A1                   ;load the list of valid modes
00001716  D3C0                     951          ADDA.L D0,A1                    ;displace to a specific mode
00001718  1811                     952          MOVE.B (A1),D4                  ;move mode to D4
0000171A  B404                     953          CMP.B D4,D2                     ;compare mode to masked value
0000171C  6700 0006                954          BEQ  mulsBody                   ;if its match, its a valid mode and we can procede
00001720                           955          
00001720  5280                     956          ADDQ.L #1,D0                    ;add one to displacement
00001722  60DA                     957          BRA validMulsModes              ;check for next mode
00001724                           958          
00001724                           959  mulsBody:
00001724                           960          
00001724                           961  
00001724                           962  
00001724  43F9 00002D1C            963          LEA     mulsMessage,A1          ;move string for MOVE
0000172A  103C 000E                964          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000172E                           965                                ;string without CR, LF
0000172E  4E4F                     966          TRAP    #15
00001730                           967          
00001730                           968          ;set size to word
00001730  7C01                     969          MOVEQ.L #1,D6
00001732  6100 1294                970          BSR printSize
00001736                           971  
00001736                           972          ;do source EA
00001736  3401                     973          MOVE.W  D1,D2                   ;check mode
00001738  C43C 003F                974          AND.B   #%00111111,D2
0000173C  1A02                     975          MOVE.B  D2,D5
0000173E  48E7 4000                976          MOVEM.L D1,-(SP)
00001742  6100 10E6                977          BSR     Get_Effective_Address
00001746  4CDF 0002                978          MOVEM.L (SP)+,D1
0000174A                           979  
0000174A                           980          ;print ','
0000174A  48E7 4000                981          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000174E  123C 002C                982          MOVE.B #',',D1                  ;put ascii value of char in D1
00001752  103C 0006                983          MOVE.B #6,D0                    ;move task 6 into D0
00001756  4E4F                     984          TRAP #15                        ;prin char
00001758  4CDF 0002                985          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000175C                           986          
0000175C                           987          ;do dest data reg
0000175C  3401                     988          MOVE.W  D1,D2                   ;check mode
0000175E  E04A                     989          LSR.W #8,D2                     ;shift reg over
00001760  E20A                     990          LSR.B #1,D2
00001762  C43C 0007                991          AND.B   #%00000111,D2           ;force recognition as a Dn
00001766  1A02                     992          MOVE.B  D2,D5
00001768  48E7 4000                993          MOVEM.L D1,-(SP)
0000176C  6100 10BC                994          BSR     Get_Effective_Address
00001770  4CDF 0002                995          MOVEM.L (SP)+,D1
00001774                           996          
00001774  43F9 00002CFE            997          LEA     clearLine,A1            ;move string for a CR and LF
0000177A  103C 000E                998          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000177E                           999                                ;string without CR, LF
0000177E  4E4F                    1000          TRAP    #15
00001780                          1001  
00001780  7000                    1002          MOVEQ.L #0,D0
00001782  4E75                    1003          RTS
00001784                          1004  
00001784                          1005  
00001784                          1006  
00001784                          1007  RSRLWEA:
00001784                          1008          
00001784                          1009  
00001784                          1010          
00001784  7000                    1011          MOVEQ.L #0, D0                  ;clear D0
00001786                          1012          
00001786                          1013  validRSRL:
00001786                          1014          
00001786  43F9 000018D6           1015          LEA lsrlEAmasks,A1              ;load the list of masks
0000178C  D3C0                    1016          ADDA.L D0,A1                    ;displace to a specific mask
0000178E  1A11                    1017          MOVE.B (A1),D5                  ;move the mask to D5
00001790                          1018          
00001790  0C05 0000               1019          CMPI.B #0,D5                    ;check if the mask is 0
00001794  6700 F902               1020          BEQ falsePositive               ;branch if it is
00001798                          1021          
00001798  1401                    1022          MOVE.B D1,D2                    ;copy instruction to D2
0000179A  C405                    1023          AND.B D5,D2                     ;mask D2
0000179C                          1024          
0000179C  43F9 000018D0           1025          LEA lsrlEA,A1                   ;load the list of valid modes
000017A2  D3C0                    1026          ADDA.L D0,A1                    ;displace to a specific mode
000017A4  1811                    1027          MOVE.B (A1),D4                  ;move mode to D4
000017A6  B404                    1028          CMP.B D4,D2                     ;compare mode to masked value
000017A8  6700 0006               1029          BEQ  rsrlweaCheckDirection      ;if its match, its a valid mode and we can procede
000017AC                          1030          
000017AC  5280                    1031          ADDQ.L #1,D0                    ;add one to displacement
000017AE  60D6                    1032          BRA validRSRL                   ;check for next mode
000017B0                          1033  
000017B0                          1034  rsrlweaCheckDirection:
000017B0                          1035          ;Figure out which direction we are going
000017B0  3401                    1036          MOVE.W D1,D2                    ;copy inst to D2
000017B2  E04A                    1037          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
000017B4  0202 0001               1038          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
000017B8  0C02 0000               1039          CMPI.B #0,D2                    ;compare bit to zero
000017BC  6700 0006               1040          BEQ RSREA                       ;if zero, right
000017C0  6000 0012               1041          BRA RSLEA                       ;else, its left
000017C4                          1042  
000017C4                          1043  RSREA:
000017C4                          1044  
000017C4  43F9 00002D25           1045          LEA     rsrMessage,A1           ;move string for MOVE
000017CA  103C 000E               1046          MOVE.B  #14,D0                  ;set for task to display null terminated 
000017CE                          1047                                ;string with CR, LF
000017CE  4E4F                    1048          TRAP    #15
000017D0  6000 0166               1049          BRA lsrlweaBody
000017D4                          1050          
000017D4                          1051  RSLEA:
000017D4                          1052          
000017D4  43F9 00002D21           1053          LEA     rslMessage,A1           ;move string for MOVE
000017DA  103C 000E               1054          MOVE.B  #14,D0                  ;set for task to display null terminated 
000017DE                          1055                                ;string with CR, LF
000017DE  4E4F                    1056          TRAP    #15
000017E0  6000 0156               1057          BRA lsrlweaBody        
000017E4                          1058          
000017E4                          1059  
000017E4                          1060  
000017E4                          1061  RSRLREG:
000017E4                          1062          
000017E4                          1063  
000017E4                          1064          
000017E4  7000                    1065          MOVEQ.L #0, D0                  ;clear D0
000017E6                          1066          
000017E6                          1067          ;check valid size field
000017E6  3401                    1068          MOVE.W D1,D2                    ;copy inst to D2
000017E8  EC4A                    1069          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
000017EA  0202 0003               1070          ANDI.B #%00000011,D2            ;mask out rest of byte
000017EE  0C02 0003               1071          CMPI.B #%11,D2                  ;compare to 3
000017F2  6700 F8A4               1072          BEQ falsePositive               ;invalid size
000017F6                          1073  
000017F6                          1074          
000017F6                          1075          ;Figure out which direction we are going
000017F6  3401                    1076          MOVE.W D1,D2                    ;copy inst to D2
000017F8  E04A                    1077          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
000017FA  0202 0001               1078          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
000017FE  0C02 0000               1079          CMPI.B #0,D2                    ;compare bit to zero
00001802  6700 0006               1080          BEQ RSRreg                      ;if zero, right
00001806  6000 0012               1081          BRA RSLreg                      ;else, its left        
0000180A                          1082          
0000180A                          1083  RSRreg:
0000180A                          1084  
0000180A  43F9 00002D25           1085          LEA     rsrMessage,A1           ;move string for MOVE
00001810  103C 000E               1086          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001814                          1087                                ;string with CR, LF
00001814  4E4F                    1088          TRAP    #15
00001816  6000 019C               1089          BRA LSRLregBody
0000181A                          1090          
0000181A                          1091  RSLreg:
0000181A                          1092          
0000181A  43F9 00002D21           1093          LEA     rslMessage,A1           ;move string for MOVE
00001820  103C 000E               1094          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001824                          1095                                ;string with CR, LF
00001824  4E4F                    1096          TRAP    #15
00001826  6000 018C               1097          BRA LSRLregBody
0000182A                          1098  
0000182A                          1099       
0000182A                          1100  
0000182A                          1101  ASRLWEA:
0000182A                          1102          
0000182A                          1103  
0000182A                          1104          
0000182A  7000                    1105          MOVEQ.L #0, D0                  ;clear D0
0000182C                          1106          
0000182C                          1107  validASRL:
0000182C                          1108          
0000182C  43F9 000018D6           1109          LEA lsrlEAmasks,A1              ;load the list of masks
00001832  D3C0                    1110          ADDA.L D0,A1                    ;displace to a specific mask
00001834  1A11                    1111          MOVE.B (A1),D5                  ;move the mask to D5
00001836                          1112          
00001836  0C05 0000               1113          CMPI.B #0,D5                    ;check if the mask is 0
0000183A  6700 F85C               1114          BEQ falsePositive               ;branch if it is
0000183E                          1115          
0000183E  1401                    1116          MOVE.B D1,D2                    ;copy instruction to D2
00001840  C405                    1117          AND.B D5,D2                     ;mask D2
00001842                          1118          
00001842  43F9 000018D0           1119          LEA lsrlEA,A1                   ;load the list of valid modes
00001848  D3C0                    1120          ADDA.L D0,A1                    ;displace to a specific mode
0000184A  1811                    1121          MOVE.B (A1),D4                  ;move mode to D4
0000184C  B404                    1122          CMP.B D4,D2                     ;compare mode to masked value
0000184E  6700 0006               1123          BEQ  asrlweaCheckDirection      ;if its match, its a valid mode and we can procede
00001852                          1124          
00001852  5280                    1125          ADDQ.L #1,D0                    ;add one to displacement
00001854  60D6                    1126          BRA validASRL                   ;check for next mode
00001856                          1127  
00001856                          1128  asrlweaCheckDirection:
00001856                          1129          ;Figure out which direction we are going
00001856  3401                    1130          MOVE.W D1,D2                    ;copy inst to D2
00001858  E04A                    1131          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
0000185A  0202 0001               1132          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
0000185E  0C02 0000               1133          CMPI.B #0,D2                    ;compare bit to zero
00001862  6700 0006               1134          BEQ ASREA                       ;if zero, right
00001866  6000 0012               1135          BRA ASLEA                       ;else, its left
0000186A                          1136  
0000186A                          1137  ASREA:
0000186A                          1138  
0000186A  43F9 00002D2D           1139          LEA     asrMessage,A1           ;move string for MOVE
00001870  103C 000E               1140          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001874                          1141                                ;string with CR, LF
00001874  4E4F                    1142          TRAP    #15
00001876  6000 00C0               1143          BRA lsrlweaBody
0000187A                          1144          
0000187A                          1145  ASLEA:
0000187A                          1146          
0000187A  43F9 00002D29           1147          LEA     aslMessage,A1           ;move string for MOVE
00001880  103C 000E               1148          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001884                          1149                                ;string with CR, LF
00001884  4E4F                    1150          TRAP    #15
00001886  6000 00B0               1151          BRA lsrlweaBody        
0000188A                          1152          
0000188A                          1153  
0000188A                          1154  
0000188A                          1155  ASRLREG:
0000188A                          1156          
0000188A                          1157  
0000188A                          1158          
0000188A  7000                    1159          MOVEQ.L #0, D0                  ;clear D0
0000188C                          1160          
0000188C                          1161          ;check valid size field
0000188C  3401                    1162          MOVE.W D1,D2                    ;copy inst to D2
0000188E  EC4A                    1163          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
00001890  0202 0003               1164          ANDI.B #%00000011,D2            ;mask out rest of byte
00001894  0C02 0003               1165          CMPI.B #%11,D2                  ;compare to 3
00001898  6700 F7FE               1166          BEQ falsePositive               ;invalid size
0000189C                          1167  
0000189C                          1168          
0000189C                          1169          ;Figure out which direction we are going
0000189C  3401                    1170          MOVE.W D1,D2                    ;copy inst to D2
0000189E  E04A                    1171          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
000018A0  0202 0001               1172          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
000018A4  0C02 0000               1173          CMPI.B #0,D2                    ;compare bit to zero
000018A8  6700 0006               1174          BEQ ASRreg                      ;if zero, right
000018AC  6000 0012               1175          BRA ASLreg                      ;else, its left        
000018B0                          1176          
000018B0                          1177  ASRreg:
000018B0                          1178  
000018B0  43F9 00002D2D           1179          LEA     asrMessage,A1           ;move string for MOVE
000018B6  103C 000E               1180          MOVE.B  #14,D0                  ;set for task to display null terminated 
000018BA                          1181                                ;string with CR, LF
000018BA  4E4F                    1182          TRAP    #15
000018BC  6000 00F6               1183          BRA LSRLregBody
000018C0                          1184          
000018C0                          1185  ASLreg:
000018C0                          1186          
000018C0  43F9 00002D29           1187          LEA     aslMessage,A1           ;move string for MOVE
000018C6  103C 000E               1188          MOVE.B  #14,D0                  ;set for task to display null terminated 
000018CA                          1189                                ;string with CR, LF
000018CA  4E4F                    1190          TRAP    #15
000018CC  6000 00E6               1191          BRA LSRLregBody
000018D0                          1192  
000018D0                          1193  
000018D0= 10 18 20 38 39 00       1194  lsrlEA        DC.B %010000,%011000,%100000,%111000,%111001,0
000018D6= 38 38 38 3F 3F 00       1195  lsrlEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0       
000018DC                          1196  
000018DC                          1197  LSRLWEA:
000018DC                          1198          
000018DC                          1199  
000018DC                          1200          
000018DC  7000                    1201          MOVEQ.L #0, D0                  ;clear D0
000018DE                          1202          
000018DE                          1203  validLSRL:
000018DE                          1204          
000018DE  43F8 18D6               1205          LEA lsrlEAmasks,A1              ;load the list of masks
000018E2  D3C0                    1206          ADDA.L D0,A1                    ;displace to a specific mask
000018E4  1A11                    1207          MOVE.B (A1),D5                  ;move the mask to D5
000018E6                          1208          
000018E6  0C05 0000               1209          CMPI.B #0,D5                    ;check if the mask is 0
000018EA  6700 F7AC               1210          BEQ falsePositive               ;branch if it is
000018EE                          1211          
000018EE  1401                    1212          MOVE.B D1,D2                    ;copy instruction to D2
000018F0  C405                    1213          AND.B D5,D2                     ;mask D2
000018F2                          1214          
000018F2  43F8 18D0               1215          LEA lsrlEA,A1                   ;load the list of valid modes
000018F6  D3C0                    1216          ADDA.L D0,A1                    ;displace to a specific mode
000018F8  1811                    1217          MOVE.B (A1),D4                  ;move mode to D4
000018FA  B404                    1218          CMP.B D4,D2                     ;compare mode to masked value
000018FC  6700 0006               1219          BEQ  lsrlweaCheckDirection      ;if its match, its a valid mode and we can procede
00001900                          1220          
00001900  5280                    1221          ADDQ.L #1,D0                    ;add one to displacement
00001902  60DA                    1222          BRA validLSRL                   ;check for next mode
00001904                          1223  
00001904                          1224  lsrlweaCheckDirection:
00001904                          1225          ;Figure out which direction we are going
00001904  3401                    1226          MOVE.W D1,D2                    ;copy inst to D2
00001906  E04A                    1227          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
00001908  0202 0001               1228          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
0000190C  0C02 0000               1229          CMPI.B #0,D2                    ;compare bit to zero
00001910  6700 0006               1230          BEQ LSREA                       ;if zero, right
00001914  6000 0012               1231          BRA LSLEA                       ;else, its left
00001918                          1232  
00001918                          1233  LSREA:
00001918                          1234  
00001918  43F9 00002D35           1235          LEA     lsrMessage,A1           ;move string for MOVE
0000191E  103C 000E               1236          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001922                          1237                                ;string with CR, LF
00001922  4E4F                    1238          TRAP    #15
00001924  6000 0012               1239          BRA lsrlweaBody
00001928                          1240          
00001928                          1241  LSLEA:
00001928                          1242          
00001928  43F9 00002D31           1243          LEA     lslMessage,A1           ;move string for MOVE
0000192E  103C 000E               1244          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001932                          1245                                ;string with CR, LF
00001932  4E4F                    1246          TRAP    #15
00001934  6000 0002               1247          BRA lsrlweaBody        
00001938                          1248          
00001938                          1249  lsrlweaBody:
00001938                          1250          
00001938                          1251          ;print ' '
00001938  48E7 4000               1252          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000193C  123C 0020               1253          MOVE.B #' ',D1                  ;put ascii value of char in D1
00001940  103C 0006               1254          MOVE.B #6,D0                    ;move task 6 into D0
00001944  4E4F                    1255          TRAP #15                        ;print char
00001946  4CDF 0002               1256          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000194A                          1257          
0000194A  3401                    1258          MOVE.W  D1,D2                   ;check mode
0000194C  C43C 003F               1259          AND.B   #%00111111,D2
00001950  1A02                    1260          MOVE.B  D2,D5
00001952  48E7 4000               1261          MOVEM.L D1,-(SP)
00001956  6100 0ED2               1262          BSR     Get_Effective_Address
0000195A  4CDF 0002               1263          MOVEM.L (SP)+,D1
0000195E                          1264          
0000195E                          1265          
0000195E  43F9 00002CFE           1266          LEA     clearLine,A1            ;move string for a CR and LF
00001964  103C 000E               1267          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001968                          1268                                ;string without CR, LF
00001968  4E4F                    1269          TRAP    #15
0000196A                          1270  
0000196A  7000                    1271          MOVEQ.L #0,D0
0000196C  4E75                    1272          RTS
0000196E                          1273  
0000196E                          1274  
0000196E                          1275  LSRLREG:
0000196E                          1276          
0000196E                          1277  
0000196E                          1278          
0000196E  7000                    1279          MOVEQ.L #0, D0                  ;clear D0
00001970                          1280          
00001970                          1281          ;check valid size field
00001970  3401                    1282          MOVE.W D1,D2                    ;copy inst to D2
00001972  EC4A                    1283          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
00001974  0202 0003               1284          ANDI.B #%00000011,D2            ;mask out rest of byte
00001978  0C02 0003               1285          CMPI.B #%11,D2                  ;compare to 3
0000197C  6700 F71A               1286          BEQ falsePositive               ;invalid size
00001980                          1287  
00001980                          1288          
00001980                          1289          ;Figure out which direction we are going
00001980  3401                    1290          MOVE.W D1,D2                    ;copy inst to D2
00001982  E04A                    1291          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
00001984  0202 0001               1292          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
00001988  0C02 0000               1293          CMPI.B #0,D2                    ;compare bit to zero
0000198C  6700 0006               1294          BEQ LSRreg                      ;if zero, right
00001990  6000 0012               1295          BRA LSLreg                      ;else, its left        
00001994                          1296          
00001994                          1297  LSRreg:
00001994                          1298  
00001994  43F9 00002D35           1299          LEA     lsrMessage,A1           ;move string for MOVE
0000199A  103C 000E               1300          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000199E                          1301                                ;string with CR, LF
0000199E  4E4F                    1302          TRAP    #15
000019A0  6000 0012               1303          BRA LSRLregBody
000019A4                          1304          
000019A4                          1305  LSLreg:
000019A4                          1306          
000019A4  43F9 00002D31           1307          LEA     lslMessage,A1           ;move string for MOVE
000019AA  103C 000E               1308          MOVE.B  #14,D0                  ;set for task to display null terminated 
000019AE                          1309                                ;string with CR, LF
000019AE  4E4F                    1310          TRAP    #15
000019B0  6000 0002               1311          BRA LSRLregBody
000019B4                          1312          
000019B4                          1313  LSRLregBody:
000019B4                          1314          
000019B4  6100 07B8               1315          BSR negSize        
000019B8                          1316              
000019B8                          1317          ;check i/r
000019B8  48E7 4000               1318          MOVEM.L D1,-(SP)
000019BC  6100 003C               1319          BSR LSRLcheckIR
000019C0  4CDF 0002               1320          MOVEM.L (SP)+,D1
000019C4                          1321          
000019C4                          1322          ;print ','
000019C4  48E7 4000               1323          MOVEM.L D1,-(SP)                ;save D1 to the stack
000019C8  123C 002C               1324          MOVE.B #',',D1                  ;put ascii value of char in D1
000019CC  103C 0006               1325          MOVE.B #6,D0                    ;move task 6 into D0
000019D0  4E4F                    1326          TRAP #15                        ;prin char
000019D2  4CDF 0002               1327          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000019D6                          1328          
000019D6  3401                    1329          MOVE.W  D1,D2                   ;check mode
000019D8  C43C 0007               1330          AND.B   #%00000111,D2
000019DC  1A02                    1331          MOVE.B  D2,D5
000019DE  48E7 4000               1332          MOVEM.L D1,-(SP)
000019E2  6100 0E46               1333          BSR     Get_Effective_Address
000019E6  4CDF 0002               1334          MOVEM.L (SP)+,D1
000019EA                          1335          
000019EA                          1336          
000019EA  43F9 00002CFE           1337          LEA     clearLine,A1            ;move string for a CR and LF
000019F0  103C 000E               1338          MOVE.B  #14,D0                  ;set for task to display null terminated 
000019F4                          1339                                ;string without CR, LF
000019F4  4E4F                    1340          TRAP    #15
000019F6                          1341  
000019F6  7000                    1342          MOVEQ.L #0,D0
000019F8  4E75                    1343          RTS
000019FA                          1344  
000019FA                          1345  LSRLcheckIR:
000019FA                          1346  
000019FA  1401                    1347          MOVE.B D1,D2                    ;move inst to D2
000019FC  EA0A                    1348          LSR.B  #5,D2
000019FE  C43C 0001               1349          AND.B  #%00000001,D2
00001A02  0C02 0000               1350          CMPI.B #0,D2
00001A06  6700 0008               1351          BEQ  LSRLcheckI
00001A0A  6000 0038               1352          BRA  LSRLcheckR
00001A0E                          1353  LSRLcheckIRreturn:
00001A0E  4E75                    1354          RTS
00001A10                          1355          
00001A10                          1356  LSRLcheckI:
00001A10                          1357          ;print '#'
00001A10  48E7 4000               1358          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001A14  123C 0023               1359          MOVE.B #'#',D1                  ;put ascii value of '#' in D1
00001A18  103C 0006               1360          MOVE.B #6,D0                    ;move task 6 into D0
00001A1C  4E4F                    1361          TRAP #15                        ;prin char
00001A1E  4CDF 0002               1362          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001A22                          1363          
00001A22                          1364          
00001A22                          1365          ;print number
00001A22  48E7 4000               1366          MOVEM.L D1,-(SP)
00001A26  3401                    1367          MOVE.W D1,D2                    ;copy inst to d2
00001A28  E04A                    1368          LSR.W #8,D2                     ;shift data section
00001A2A  E20A                    1369          LSR.B #1,D2
00001A2C  C43C 0007               1370          AND.B #%00000111,D2             ;mask out rest of data
00001A30  6100 00EC               1371          BSR ZeroToEight                 ;handle zero
00001A34  7200                    1372          MOVEQ.L #0,D1                   ;clear D1
00001A36  1202                    1373          MOVE.B D2,D1                    ;move number to display into D1
00001A38  103C 0003               1374          MOVE.B #3,D0                    ;move task 3 to D0
00001A3C  4E4F                    1375          TRAP #15
00001A3E  4CDF 0002               1376          MOVEM.L (SP)+,D1
00001A42  60CA                    1377          BRA LSRLcheckIRreturn
00001A44                          1378          
00001A44                          1379  LSRLcheckR:
00001A44  3401                    1380          MOVE.W D1,D2                    ;copy inst to d2
00001A46  E04A                    1381          LSR.W #8,D2                     ;shift data section
00001A48  E20A                    1382          LSR.B #1,D2
00001A4A  C43C 0007               1383          AND.B #%00000111,D2             ;mask out rest of data
00001A4E  1A02                    1384          MOVE.B D2,D5                    ;force Dn
00001A50  48E7 4000               1385          MOVEM.L D1,-(SP)
00001A54  6100 0DD4               1386          BSR     Get_Effective_Address
00001A58  4CDF 0002               1387          MOVEM.L (SP)+,D1
00001A5C  60B0                    1388          BRA LSRLcheckIRreturn
00001A5E                          1389          
00001A5E= 00 08 10 18 20 38 ...   1390  subqEA        DC.B %000000,%001000,%010000,%011000,%100000,%111000,%111001,0
00001A66= 38 38 38 38 38 3F ...   1391  subqEAmasks   DC.B %111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001A6E                          1392  
00001A6E                          1393  SUBQ:
00001A6E                          1394          
00001A6E                          1395  
00001A6E                          1396          
00001A6E  7000                    1397          MOVEQ.L #0, D0                  ;clear D0
00001A70                          1398          
00001A70                          1399          ;check valid size field
00001A70  3401                    1400          MOVE.W D1,D2                    ;copy inst to D2
00001A72  EC4A                    1401          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
00001A74  0202 0003               1402          ANDI.B #%00000011,D2            ;mask out rest of byte
00001A78  0C02 0003               1403          CMPI.B #%11,D2                  ;compare to 3
00001A7C  6700 F61A               1404          BEQ falsePositive               ;invalid size
00001A80                          1405          
00001A80                          1406  validSubq:
00001A80                          1407          
00001A80  43F8 1A66               1408          LEA subqEAmasks,A1              ;load the list of masks
00001A84  D3C0                    1409          ADDA.L D0,A1                    ;displace to a specific mask
00001A86  1A11                    1410          MOVE.B (A1),D5                  ;move the mask to D5
00001A88                          1411          
00001A88  0C05 0000               1412          CMPI.B #0,D5                    ;check if the mask is 0
00001A8C  6700 F60A               1413          BEQ falsePositive               ;branch if it is
00001A90                          1414          
00001A90  1401                    1415          MOVE.B D1,D2                    ;copy instruction to D2
00001A92  C405                    1416          AND.B D5,D2                     ;mask D2
00001A94                          1417          
00001A94  43F8 1A5E               1418          LEA subqEA,A1                   ;load the list of valid modes
00001A98  D3C0                    1419          ADDA.L D0,A1                    ;displace to a specific mode
00001A9A  1811                    1420          MOVE.B (A1),D4                  ;move mode to D4
00001A9C  B404                    1421          CMP.B D4,D2                     ;compare mode to masked value
00001A9E  6700 0006               1422          BEQ  subqBody                   ;if its match, its a valid mode and we can procede
00001AA2                          1423          
00001AA2  5280                    1424          ADDQ.L #1,D0                    ;add one to displacement
00001AA4  60DA                    1425          BRA validSubq                   ;check for next mode
00001AA6                          1426          
00001AA6                          1427          
00001AA6                          1428  subqBody
00001AA6                          1429  
00001AA6  43F9 00002D39           1430          LEA     subqMessage,A1          ;move string for MOVE
00001AAC  103C 000E               1431          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001AB0                          1432                                ;string with CR, LF
00001AB0  4E4F                    1433          TRAP    #15
00001AB2                          1434          
00001AB2  6100 06BA               1435          BSR negSize
00001AB6                          1436          
00001AB6                          1437          ;immediate data
00001AB6                          1438          
00001AB6                          1439          ;print '#'
00001AB6  48E7 4000               1440          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001ABA  123C 0023               1441          MOVE.B #'#',D1                  ;put ascii value of '#' in D1
00001ABE  103C 0006               1442          MOVE.B #6,D0                    ;move task 6 into D0
00001AC2  4E4F                    1443          TRAP #15                        ;prin char
00001AC4  4CDF 0002               1444          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001AC8                          1445          
00001AC8                          1446          ;print number
00001AC8  48E7 4000               1447          MOVEM.L D1,-(SP)
00001ACC  3401                    1448          MOVE.W D1,D2                    ;copy inst to d2
00001ACE  E04A                    1449          LSR.W #8,D2                     ;shift data section
00001AD0  E20A                    1450          LSR.B #1,D2
00001AD2  C43C 0007               1451          AND.B #%00000111,D2             ;mask out rest of data
00001AD6  6100 0046               1452          BSR ZeroToEight                 ;handle zero
00001ADA  7200                    1453          MOVEQ.L #0,D1                   ;clear D1
00001ADC  1202                    1454          MOVE.B D2,D1                    ;move number to display into D1
00001ADE  103C 0003               1455          MOVE.B #3,D0                    ;move task 3 to D0
00001AE2  4E4F                    1456          TRAP #15
00001AE4  4CDF 0002               1457          MOVEM.L (SP)+,D1
00001AE8                          1458          
00001AE8                          1459          ;print ','
00001AE8  48E7 4000               1460          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001AEC  123C 002C               1461          MOVE.B #',',D1                  ;put ascii value of char in D1
00001AF0  103C 0006               1462          MOVE.B #6,D0                    ;move task 6 into D0
00001AF4  4E4F                    1463          TRAP #15                        ;prin char
00001AF6  4CDF 0002               1464          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001AFA                          1465          
00001AFA                          1466          ;Then do EA
00001AFA                          1467          
00001AFA  3401                    1468          MOVE.W  D1,D2                   ;check mode
00001AFC  C43C 003F               1469          AND.B   #%00111111,D2
00001B00  1A02                    1470          MOVE.B  D2,D5
00001B02  48E7 4000               1471          MOVEM.L D1,-(SP)
00001B06  6100 0D22               1472          BSR     Get_Effective_Address
00001B0A  4CDF 0002               1473          MOVEM.L (SP)+,D1
00001B0E                          1474          
00001B0E  43F9 00002CFE           1475          LEA     clearLine,A1            ;move string for a CR and LF
00001B14  103C 000E               1476          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001B18                          1477                                ;string without CR, LF
00001B18  4E4F                    1478          TRAP    #15
00001B1A                          1479  
00001B1A  7000                    1480          MOVEQ.L #0,D0
00001B1C  4E75                    1481          RTS
00001B1E                          1482          
00001B1E                          1483  ZeroToEight:
00001B1E                          1484          
00001B1E  0C02 0000               1485          CMPI.B #0,D2
00001B22  6700 0004               1486          BEQ toEight
00001B26                          1487  ZeroToEightReturn:
00001B26                          1488          
00001B26  4E75                    1489          RTS
00001B28                          1490  toEight:
00001B28                          1491          
00001B28  5002                    1492          ADDQ.B #8,D2
00001B2A  60FA                    1493          BRA ZeroToEightReturn
00001B2C                          1494  
00001B2C                          1495      
00001B2C                          1496  SUB:
00001B2C                          1497          
00001B2C                          1498  
00001B2C                          1499          
00001B2C  7000                    1500          MOVEQ.L #0, D0                  ;clear D0
00001B2E                          1501          
00001B2E                          1502          ;Figure out if EA is source or destination
00001B2E  3401                    1503          MOVE.W D1,D2                    ;copy inst to D2
00001B30  EC4A                    1504          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001B32  0202 0007               1505          ANDI.B #%00000111,D2            ;mask out rest of byte
00001B36  0C02 0002               1506          CMPI.B #2,D2                    ;compare to 2
00001B3A  6F00 0016               1507          BLE validSubSourceEA            ;2 or less is EA is source
00001B3E                          1508          
00001B3E  0C02 0007               1509          CMPI.B #%111,D2                 ;compare to 7
00001B42  6700 F554               1510          BEQ falsePositive               ;thats not valid
00001B46  0C02 0003               1511          CMPI.B #%11,D2                  ;compare to 3
00001B4A  6700 F54C               1512          BEQ falsePositive               ;also not valid
00001B4E  6000 002C               1513          BRA validSubDestEA              ;all thats left is valid EA as Dest 
00001B52                          1514          
00001B52                          1515  validSubSourceEA:
00001B52                          1516          
00001B52  43F9 000023C5           1517          LEA moveSourceEAmasks,A1        ;load the list of masks
00001B58  D3C0                    1518          ADDA.L D0,A1                    ;displace to a specific mask
00001B5A  1A11                    1519          MOVE.B (A1),D5                  ;move the mask to D5
00001B5C                          1520          
00001B5C  0C05 0000               1521          CMPI.B #0,D5                    ;check if the mask is 0
00001B60  6700 F536               1522          BEQ falsePositive               ;branch if it is
00001B64                          1523          
00001B64  1401                    1524          MOVE.B D1,D2                    ;copy instruction to D2
00001B66  C405                    1525          AND.B D5,D2                     ;mask D2
00001B68                          1526          
00001B68  43F9 000023BC           1527          LEA moveSourceEA,A1             ;load the list of valid modes
00001B6E  D3C0                    1528          ADDA.L D0,A1                    ;displace to a specific mode
00001B70  1811                    1529          MOVE.B (A1),D4                  ;move mode to D4
00001B72  B404                    1530          CMP.B D4,D2                     ;compare mode to masked value
00001B74  6700 0030               1531          BEQ  subSource                  ;if its match, its a valid mode and we can procede
00001B78                          1532          
00001B78  5280                    1533          ADDQ.L #1,D0                    ;add one to displacement
00001B7A  60D6                    1534          BRA validSubSourceEA            ;check for next mode
00001B7C                          1535          
00001B7C                          1536          
00001B7C                          1537  validSubDestEA:
00001B7C                          1538          
00001B7C  43F9 00001D22           1539          LEA addDestEAmasks,A1           ;load the list of masks
00001B82  D3C0                    1540          ADDA.L D0,A1                    ;displace to a specific mask
00001B84  1A11                    1541          MOVE.B (A1),D5                  ;move the mask to D5
00001B86                          1542          
00001B86  0C05 0000               1543          CMPI.B #0,D5                    ;check if the mask is 0
00001B8A  6700 F50C               1544          BEQ falsePositive               ;branch if it is
00001B8E                          1545          
00001B8E  3401                    1546          MOVE.W D1,D2                    ;copy instruction to D2
00001B90  C405                    1547          AND.B D5,D2                     ;mask D2
00001B92                          1548          
00001B92  43F9 00001D1C           1549          LEA addDestEA,A1                ;load the list of valid modes
00001B98  D3C0                    1550          ADDA.L D0,A1                    ;displace to a specific mode
00001B9A  1811                    1551          MOVE.B (A1),D4                  ;move mode to D4
00001B9C  B404                    1552          CMP.B D4,D2                     ;compare mode to masked value
00001B9E  6700 0064               1553          BEQ subDest                     ;if its match, its a valid mode and we can procede
00001BA2                          1554          
00001BA2  5280                    1555          ADDQ.L #1,D0                    ;add one to displacement
00001BA4  60D6                    1556          BRA validSubDestEA              ;check for next mode
00001BA6                          1557          
00001BA6                          1558  subSource
00001BA6                          1559  
00001BA6  43F9 00002D3E           1560          LEA     subMessage,A1           ;move string for MOVE
00001BAC  103C 000E               1561          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001BB0                          1562                                ;string with CR, LF
00001BB0  4E4F                    1563          TRAP    #15
00001BB2                          1564          
00001BB2  6100 05BA               1565          BSR negSize
00001BB6                          1566          
00001BB6                          1567          ;do EA
00001BB6                          1568          
00001BB6  3401                    1569          MOVE.W  D1,D2                   ;check mode
00001BB8  C43C 003F               1570          AND.B   #%00111111,D2
00001BBC  1A02                    1571          MOVE.B  D2,D5
00001BBE  48E7 4000               1572          MOVEM.L D1,-(SP)
00001BC2  6100 0C66               1573          BSR     Get_Effective_Address
00001BC6  4CDF 0002               1574          MOVEM.L (SP)+,D1
00001BCA                          1575          
00001BCA                          1576          ;print ','
00001BCA  48E7 4000               1577          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001BCE  123C 002C               1578          MOVE.B #',',D1                  ;put ascii value of char in D1
00001BD2  103C 0006               1579          MOVE.B #6,D0                    ;move task 6 into D0
00001BD6  4E4F                    1580          TRAP #15                        ;prin char
00001BD8  4CDF 0002               1581          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001BDC                          1582          
00001BDC                          1583          ;Then do Dn
00001BDC                          1584          
00001BDC  3401                    1585          MOVE.W  D1,D2
00001BDE  E04A                    1586          LSR.W   #8,D2                   ;move reg into first byte
00001BE0  E20A                    1587          LSR.B   #1,D2                   ;line it up to least sig bit
00001BE2  C43C 0007               1588          AND.B   #%00000111,D2           ;force mode to Dn
00001BE6  1A02                    1589          MOVE.B  D2,D5
00001BE8  48E7 4000               1590          MOVEM.L D1,-(SP)
00001BEC  6100 0C3C               1591          BSR     Get_Effective_Address
00001BF0  4CDF 0002               1592          MOVEM.L (SP)+,D1
00001BF4                          1593          
00001BF4  43F9 00002CFE           1594          LEA     clearLine,A1            ;move string for a CR and LF
00001BFA  103C 000E               1595          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001BFE                          1596          ;string without CR, LF
00001BFE  4E4F                    1597          TRAP    #15
00001C00                          1598  
00001C00  7000                    1599          MOVEQ.L #0,D0
00001C02  4E75                    1600          RTS
00001C04                          1601  
00001C04                          1602  subDest
00001C04                          1603  
00001C04  43F9 00002D3E           1604          LEA     subMessage,A1           ;move string for MOVE
00001C0A  103C 000E               1605          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001C0E                          1606                                          ;string with CR, LF
00001C0E  4E4F                    1607          TRAP    #15
00001C10                          1608          
00001C10  6100 055C               1609          BSR negSize
00001C14                          1610          
00001C14                          1611          ;Do Dn
00001C14                          1612          
00001C14  3401                    1613          MOVE.W  D1,D2
00001C16  E04A                    1614          LSR.W   #8,D2                   ;move reg into first byte
00001C18  E20A                    1615          LSR.B   #1,D2                   ;line it up to least sig bit
00001C1A  C43C 0007               1616          AND.B   #%00000111,D2           ;force mode to Dn
00001C1E  1A02                    1617          MOVE.B  D2,D5
00001C20  48E7 4000               1618          MOVEM.L D1,-(SP)
00001C24  6100 0C04               1619          BSR     Get_Effective_Address
00001C28  4CDF 0002               1620          MOVEM.L (SP)+,D1
00001C2C                          1621          
00001C2C                          1622          
00001C2C                          1623          ;print ','
00001C2C  48E7 4000               1624          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001C30  123C 002C               1625          MOVE.B #',',D1                  ;put ascii value of char in D1
00001C34  103C 0006               1626          MOVE.B #6,D0                    ;move task 6 into D0
00001C38  4E4F                    1627          TRAP #15                        ;prin char
00001C3A  4CDF 0002               1628          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001C3E                          1629          
00001C3E                          1630          ;Then do EA
00001C3E                          1631          
00001C3E  3401                    1632          MOVE.W  D1,D2                   ;check mode
00001C40  C43C 003F               1633          AND.B   #%00111111,D2
00001C44  1A02                    1634          MOVE.B  D2,D5
00001C46  48E7 4000               1635          MOVEM.L D1,-(SP)
00001C4A  6100 0BDE               1636          BSR     Get_Effective_Address
00001C4E  4CDF 0002               1637          MOVEM.L (SP)+,D1
00001C52                          1638          
00001C52                          1639          
00001C52  43F9 00002CFE           1640          LEA     clearLine,A1            ;move string for a CR and LF
00001C58  103C 000E               1641          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001C5C                          1642          ;string without CR, LF
00001C5C  4E4F                    1643          TRAP    #15
00001C5E                          1644  
00001C5E  7000                    1645          MOVEQ.L #0,D0
00001C60  4E75                    1646          RTS
00001C62                          1647  
00001C62                          1648  
00001C62                          1649  ADDA:
00001C62                          1650          
00001C62                          1651  
00001C62                          1652          
00001C62  7000                    1653          MOVEQ.L #0, D0                  ;clear D0
00001C64                          1654          
00001C64                          1655          ;check opmode field
00001C64  3401                    1656          MOVE.W D1,D2                    ;copy inst to D2
00001C66  EC4A                    1657          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001C68  0202 0007               1658          ANDI.B #%00000111,D2            ;mask out rest of byte
00001C6C  0C02 0007               1659          CMPI.B #%111,D2                 ;compare to 7
00001C70  6700 000E               1660          BEQ validAdda                   ;thats valid
00001C74  0C02 0003               1661          CMPI.B #%11,D2                  ;compare to 3
00001C78  6700 0006               1662          BEQ validAdda                   ;also valid
00001C7C  6000 F41A               1663          BRA falsePositive               ;all thats left is invalid 
00001C80                          1664          
00001C80                          1665  validAdda:
00001C80                          1666          
00001C80  43F9 000023C5           1667          LEA moveSourceEAmasks,A1        ;load the list of masks
00001C86  D3C0                    1668          ADDA.L D0,A1                    ;displace to a specific mask
00001C88  1A11                    1669          MOVE.B (A1),D5                  ;move the mask to D5
00001C8A                          1670          
00001C8A  0C05 0000               1671          CMPI.B #0,D5                    ;check if the mask is 0
00001C8E  6700 F408               1672          BEQ falsePositive               ;branch if it is
00001C92                          1673          
00001C92  1401                    1674          MOVE.B D1,D2                    ;copy instruction to D2
00001C94  C405                    1675          AND.B D5,D2                     ;mask D2
00001C96                          1676          
00001C96  43F9 000023BC           1677          LEA moveSourceEA,A1             ;load the list of valid modes
00001C9C  D3C0                    1678          ADDA.L D0,A1                    ;displace to a specific mode
00001C9E  1811                    1679          MOVE.B (A1),D4                  ;move mode to D4
00001CA0  B404                    1680          CMP.B D4,D2                     ;compare mode to masked value
00001CA2  6700 0006               1681          BEQ  addaBody                   ;if its match, its a valid mode and we can procede
00001CA6                          1682          
00001CA6  5280                    1683          ADDQ.L #1,D0                    ;add one to displacement
00001CA8  60D6                    1684          BRA validAdda                   ;check for next mode
00001CAA                          1685          
00001CAA                          1686          
00001CAA                          1687  addaBody
00001CAA                          1688  
00001CAA  43F9 00002D42           1689          LEA     addaMessage,A1          ;move string for MOVE
00001CB0  103C 000E               1690          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001CB4                          1691          ;string with CR, LF
00001CB4  4E4F                    1692          TRAP    #15
00001CB6                          1693          
00001CB6                          1694          ;size
00001CB6  48E7 4000               1695          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001CBA                          1696          ;make it look like NEG's size
00001CBA  E449                    1697          LSR.W #2,D1                     ;shift opmode bits over to use them as size
00001CBC  C23C 007F               1698          AND.B #%01111111,D1             ;clear bit next to size
00001CC0  0641 0040               1699          ADDI.W #%01000000,D1            ;add 1 to size to make it look like a word or long
00001CC4  6100 04A8               1700          BSR negSize
00001CC8  4CDF 0002               1701          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001CCC                          1702          
00001CCC                          1703          ;do EA
00001CCC                          1704          
00001CCC  3401                    1705          MOVE.W  D1,D2                   ;check mode
00001CCE  C43C 003F               1706          AND.B   #%00111111,D2
00001CD2  1A02                    1707          MOVE.B  D2,D5
00001CD4  48E7 4000               1708          MOVEM.L D1,-(SP)
00001CD8  6100 0B50               1709          BSR     Get_Effective_Address
00001CDC  4CDF 0002               1710          MOVEM.L (SP)+,D1
00001CE0                          1711          
00001CE0                          1712          ;print ','
00001CE0  48E7 4000               1713          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001CE4  123C 002C               1714          MOVE.B #',',D1                  ;put ascii value of char in D1
00001CE8  103C 0006               1715          MOVE.B #6,D0                    ;move task 6 into D0
00001CEC  4E4F                    1716          TRAP #15                        ;prin char
00001CEE  4CDF 0002               1717          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001CF2                          1718          
00001CF2                          1719          ;Then do Dn
00001CF2                          1720          
00001CF2  3401                    1721          MOVE.W  D1,D2
00001CF4  E04A                    1722          LSR.W   #8,D2                   ;move reg into first byte
00001CF6  E20A                    1723          LSR.B   #1,D2                   ;line it up to least sig bit
00001CF8  C43C 0007               1724          AND.B   #%00000111,D2           ;force mode to An
00001CFC  5002                    1725          ADDI.B  #%00001000,D2 
00001CFE  1A02                    1726          MOVE.B  D2,D5
00001D00  48E7 4000               1727          MOVEM.L D1,-(SP)
00001D04  6100 0B24               1728          BSR     Get_Effective_Address
00001D08  4CDF 0002               1729          MOVEM.L (SP)+,D1
00001D0C                          1730          
00001D0C  43F9 00002CFE           1731          LEA     clearLine,A1            ;move string for a CR and LF
00001D12  103C 000E               1732          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001D16                          1733          ;string without CR, LF
00001D16  4E4F                    1734          TRAP    #15
00001D18                          1735  
00001D18  7000                    1736          MOVEQ.L #0,D0
00001D1A  4E75                    1737          RTS
00001D1C                          1738  
00001D1C                          1739  
00001D1C                          1740      
00001D1C= 10 18 20 38 39 00       1741  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
00001D22= 38 38 38 3F 3F 00       1742  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
00001D28                          1743  
00001D28                          1744  ADD:
00001D28                          1745          
00001D28                          1746  
00001D28                          1747          
00001D28  7000                    1748          MOVEQ.L #0, D0                  ;clear D0
00001D2A                          1749          
00001D2A                          1750          ;Figure out if EA is source or destination
00001D2A  3401                    1751          MOVE.W D1,D2                    ;copy inst to D2
00001D2C  EC4A                    1752          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001D2E  0202 0007               1753          ANDI.B #%00000111,D2            ;mask out rest of byte
00001D32  0C02 0002               1754          CMPI.B #2,D2                    ;compare to 2
00001D36  6F00 0016               1755          BLE validAddSourceEA            ;2 or less is EA is source
00001D3A                          1756          
00001D3A  0C02 0007               1757          CMPI.B #%111,D2                 ;compare to 7
00001D3E  6700 F358               1758          BEQ falsePositive               ;thats not valid
00001D42  0C02 0003               1759          CMPI.B #%11,D2                  ;compare to 3
00001D46  6700 F350               1760          BEQ falsePositive               ;also not valid
00001D4A  6000 002C               1761          BRA validAddDestEA              ;all thats left is valid EA as Dest 
00001D4E                          1762          
00001D4E                          1763  validAddSourceEA:
00001D4E                          1764          
00001D4E  43F9 000023C5           1765          LEA moveSourceEAmasks,A1        ;load the list of masks
00001D54  D3C0                    1766          ADDA.L D0,A1                    ;displace to a specific mask
00001D56  1A11                    1767          MOVE.B (A1),D5                  ;move the mask to D5
00001D58                          1768          
00001D58  0C05 0000               1769          CMPI.B #0,D5                    ;check if the mask is 0
00001D5C  6700 F33A               1770          BEQ falsePositive               ;branch if it is
00001D60                          1771          
00001D60  1401                    1772          MOVE.B D1,D2                    ;copy instruction to D2
00001D62  C405                    1773          AND.B D5,D2                     ;mask D2
00001D64                          1774          
00001D64  43F9 000023BC           1775          LEA moveSourceEA,A1             ;load the list of valid modes
00001D6A  D3C0                    1776          ADDA.L D0,A1                    ;displace to a specific mode
00001D6C  1811                    1777          MOVE.B (A1),D4                  ;move mode to D4
00001D6E  B404                    1778          CMP.B D4,D2                     ;compare mode to masked value
00001D70  6700 002C               1779          BEQ  addSource                  ;if its match, its a valid mode and we can procede
00001D74                          1780          
00001D74  5280                    1781          ADDQ.L #1,D0                    ;add one to displacement
00001D76  60D6                    1782          BRA validAddSourceEA            ;check for next mode
00001D78                          1783          
00001D78                          1784          
00001D78                          1785  validAddDestEA:
00001D78                          1786          
00001D78  43F8 1D22               1787          LEA addDestEAmasks,A1           ;load the list of masks
00001D7C  D3C0                    1788          ADDA.L D0,A1                    ;displace to a specific mask
00001D7E  1A11                    1789          MOVE.B (A1),D5                  ;move the mask to D5
00001D80                          1790          
00001D80  0C05 0000               1791          CMPI.B #0,D5                    ;check if the mask is 0
00001D84  6700 F312               1792          BEQ falsePositive               ;branch if it is
00001D88                          1793          
00001D88  3401                    1794          MOVE.W D1,D2                    ;copy instruction to D2
00001D8A  C405                    1795          AND.B D5,D2                     ;mask D2
00001D8C                          1796          
00001D8C  43F8 1D1C               1797          LEA addDestEA,A1                ;load the list of valid modes
00001D90  D3C0                    1798          ADDA.L D0,A1                    ;displace to a specific mode
00001D92  1811                    1799          MOVE.B (A1),D4                  ;move mode to D4
00001D94  B404                    1800          CMP.B D4,D2                     ;compare mode to masked value
00001D96  6700 0064               1801          BEQ addDest                     ;if its match, its a valid mode and we can procede
00001D9A                          1802          
00001D9A  5280                    1803          ADDQ.L #1,D0                    ;add one to displacement
00001D9C  60DA                    1804          BRA validAddDestEA              ;check for next mode
00001D9E                          1805          
00001D9E                          1806  addSource
00001D9E                          1807  
00001D9E  43F9 00002D47           1808          LEA     addMessage,A1           ;move string for MOVE
00001DA4  103C 000E               1809          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001DA8                          1810          ;string with CR, LF
00001DA8  4E4F                    1811          TRAP    #15
00001DAA                          1812          
00001DAA  6100 03C2               1813          BSR negSize
00001DAE                          1814          
00001DAE                          1815          ;do EA
00001DAE                          1816          
00001DAE  3401                    1817          MOVE.W  D1,D2                   ;check mode
00001DB0  C43C 003F               1818          AND.B   #%00111111,D2
00001DB4  1A02                    1819          MOVE.B  D2,D5
00001DB6  48E7 4000               1820          MOVEM.L D1,-(SP)
00001DBA  6100 0A6E               1821          BSR     Get_Effective_Address
00001DBE  4CDF 0002               1822          MOVEM.L (SP)+,D1
00001DC2                          1823          
00001DC2                          1824          ;print ','
00001DC2  48E7 4000               1825          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001DC6  123C 002C               1826          MOVE.B #',',D1                  ;put ascii value of char in D1
00001DCA  103C 0006               1827          MOVE.B #6,D0                    ;move task 6 into D0
00001DCE  4E4F                    1828          TRAP #15                        ;prin char
00001DD0  4CDF 0002               1829          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001DD4                          1830          
00001DD4                          1831          ;Then do Dn
00001DD4                          1832          
00001DD4  3401                    1833          MOVE.W  D1,D2
00001DD6  E04A                    1834          LSR.W   #8,D2                   ;move reg into first byte
00001DD8  E20A                    1835          LSR.B   #1,D2                   ;line it up to least sig bit
00001DDA  C43C 0007               1836          AND.B   #%00000111,D2           ;force mode to Dn
00001DDE  1A02                    1837          MOVE.B  D2,D5
00001DE0  48E7 4000               1838          MOVEM.L D1,-(SP)
00001DE4  6100 0A44               1839          BSR     Get_Effective_Address
00001DE8  4CDF 0002               1840          MOVEM.L (SP)+,D1
00001DEC                          1841          
00001DEC  43F9 00002CFE           1842          LEA     clearLine,A1            ;move string for a CR and LF
00001DF2  103C 000E               1843          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001DF6                          1844                                ;string without CR, LF
00001DF6  4E4F                    1845          TRAP    #15
00001DF8                          1846  
00001DF8  7000                    1847          MOVEQ.L #0,D0
00001DFA  4E75                    1848          RTS
00001DFC                          1849  
00001DFC                          1850  addDest
00001DFC                          1851  
00001DFC  43F9 00002D47           1852          LEA     addMessage,A1           ;move string for MOVE
00001E02  103C 000E               1853          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001E06                          1854                                          ;string with CR, LF
00001E06  4E4F                    1855          TRAP    #15
00001E08                          1856          
00001E08  6100 0364               1857          BSR negSize
00001E0C                          1858          
00001E0C                          1859          ;Do Dn
00001E0C                          1860          
00001E0C  3401                    1861          MOVE.W  D1,D2
00001E0E  E04A                    1862          LSR.W   #8,D2                   ;move reg into first byte
00001E10  E20A                    1863          LSR.B   #1,D2                   ;line it up to least sig bit
00001E12  C43C 0007               1864          AND.B   #%00000111,D2           ;force mode to Dn
00001E16  1A02                    1865          MOVE.B  D2,D5
00001E18  48E7 4000               1866          MOVEM.L D1,-(SP)
00001E1C  6100 0A0C               1867          BSR     Get_Effective_Address
00001E20  4CDF 0002               1868          MOVEM.L (SP)+,D1
00001E24                          1869          
00001E24                          1870          
00001E24                          1871          ;print ','
00001E24  48E7 4000               1872          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001E28  123C 002C               1873          MOVE.B #',',D1                  ;put ascii value of char in D1
00001E2C  103C 0006               1874          MOVE.B #6,D0                    ;move task 6 into D0
00001E30  4E4F                    1875          TRAP #15                        ;prin char
00001E32  4CDF 0002               1876          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001E36                          1877          
00001E36                          1878          ;Then do EA
00001E36                          1879          
00001E36  3401                    1880          MOVE.W  D1,D2                   ;check mode
00001E38  C43C 003F               1881          AND.B   #%00111111,D2
00001E3C  1A02                    1882          MOVE.B  D2,D5
00001E3E  48E7 4000               1883          MOVEM.L D1,-(SP)
00001E42  6100 09E6               1884          BSR     Get_Effective_Address
00001E46  4CDF 0002               1885          MOVEM.L (SP)+,D1
00001E4A                          1886          
00001E4A                          1887          
00001E4A  43F9 00002CFE           1888          LEA     clearLine,A1            ;move string for a CR and LF
00001E50  103C 000E               1889          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001E54                          1890                                          ;string without CR, LF
00001E54  4E4F                    1891          TRAP    #15
00001E56                          1892  
00001E56  7000                    1893          MOVEQ.L #0,D0
00001E58  4E75                    1894          RTS
00001E5A                          1895  
00001E5A                          1896  
00001E5A= 10 20 38 39 00          1897  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
00001E5F= 38 38 3F 3F 00          1898  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
00001E64                          1899  
00001E64= 10 18 38 39 00          1900  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
00001E69= 38 38 3F 3F 00          1901  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
00001E6E                          1902  
00001E6E                          1903  MOVEM:
00001E6E                          1904          
00001E6E                          1905  
00001E6E                          1906          
00001E6E  7000                    1907          MOVEQ.L #0, D0                  ;clear D0
00001E70                          1908          
00001E70                          1909          ;Figure out which direction we are going
00001E70  3401                    1910          MOVE.W D1,D2                    ;copy inst to D2
00001E72  E64A                    1911          LSR.W #3,D2                     ;shift direction bit into most sig bit of first byte
00001E74  0202 0080               1912          ANDI.B #%10000000,D2            ;mask out everything but direction bit in first byte
00001E78  0C02 0000               1913          CMPI.B #0,D2                    ;compare bit to zero
00001E7C  6700 0006               1914          BEQ validRegToMem               ;if zero, reg to mem
00001E80  6000 0028               1915          BRA validMemToReg               ;else, its mem to reg
00001E84                          1916          
00001E84                          1917  validRegToMem:
00001E84                          1918          
00001E84  43F8 1E5F               1919          LEA movemRegToMemEAmasks,A1     ;load the list of masks
00001E88  D3C0                    1920          ADDA.L D0,A1                    ;displace to a specific mask
00001E8A  1A11                    1921          MOVE.B (A1),D5                  ;move the mask to D5
00001E8C                          1922          
00001E8C  0C05 0000               1923          CMPI.B #0,D5                    ;check if the mask is 0
00001E90  6700 F206               1924          BEQ falsePositive               ;branch if it is
00001E94                          1925          
00001E94  1401                    1926          MOVE.B D1,D2                    ;copy instruction to D2
00001E96  C405                    1927          AND.B D5,D2                     ;mask D2
00001E98                          1928          
00001E98  43F8 1E5A               1929          LEA movemRegToMemEA,A1          ;load the list of valid modes
00001E9C  D3C0                    1930          ADDA.L D0,A1                    ;displace to a specific mode
00001E9E  1811                    1931          MOVE.B (A1),D4                  ;move mode to D4
00001EA0  B404                    1932          CMP.B D4,D2                     ;compare mode to masked value
00001EA2  6700 002C               1933          BEQ  movemPre                   ;if its match, its a valid mode and we can procede
00001EA6                          1934          
00001EA6  5280                    1935          ADDQ.L #1,D0                    ;add one to displacement
00001EA8  60DA                    1936          BRA validRegToMem               ;check for next mode
00001EAA                          1937          
00001EAA                          1938          
00001EAA                          1939  validMemToReg:
00001EAA                          1940          
00001EAA  43F8 1E69               1941          LEA movemMemToRegEAmasks,A1     ;load the list of masks
00001EAE  D3C0                    1942          ADDA.L D0,A1                    ;displace to a specific mask
00001EB0  1A11                    1943          MOVE.B (A1),D5                  ;move the mask to D5
00001EB2                          1944          
00001EB2  0C05 0000               1945          CMPI.B #0,D5                    ;check if the mask is 0
00001EB6  6700 F1E0               1946          BEQ falsePositive               ;branch if it is
00001EBA                          1947          
00001EBA  3401                    1948          MOVE.W D1,D2                    ;copy instruction to D2
00001EBC  C405                    1949          AND.B D5,D2                     ;mask D2
00001EBE                          1950          
00001EBE  43F8 1E64               1951          LEA movemMemToRegEA,A1          ;load the list of valid modes
00001EC2  D3C0                    1952          ADDA.L D0,A1                    ;displace to a specific mode
00001EC4  1811                    1953          MOVE.B (A1),D4                  ;move mode to D4
00001EC6  B404                    1954          CMP.B D4,D2                     ;compare mode to masked value
00001EC8  6700 0062               1955          BEQ movemPost                   ;if its match, its a valid mode and we can procede
00001ECC                          1956          
00001ECC  5280                    1957          ADDQ.L #1,D0                    ;add one to displacement
00001ECE  60DA                    1958          BRA validMemToReg               ;check for next mode
00001ED0                          1959  
00001ED0                          1960  movemPre:
00001ED0                          1961  
00001ED0  43F9 00002D4B           1962          LEA     movemMessage,A1         ;move string for MOVE
00001ED6  103C 000E               1963          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001EDA                          1964                                          ;string with CR, LF
00001EDA  4E4F                    1965          TRAP    #15
00001EDC                          1966          
00001EDC                          1967          ;size
00001EDC  48E7 4000               1968          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001EE0                          1969          ;make it look like NEG's size
00001EE0  C23C 007F               1970          AND.B #%01111111,D1             ;clear bit next to size
00001EE4  0641 0040               1971          ADDI.W #%01000000,D1            ;add 1 to size to make it look like a word or long
00001EE8  6100 0284               1972          BSR negSize
00001EEC  4CDF 0002               1973          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001EF0                          1974          
00001EF0                          1975          
00001EF0                          1976          ;show list
00001EF0                          1977          
00001EF0  6100 00E6               1978          BSR outputPreIncrement     
00001EF4                          1979          
00001EF4  5487                    1980          ADDQ.L #word,D7                 ;read past the register list mask(word) following
00001EF6                          1981                                          ;the instruction
00001EF6                          1982          
00001EF6                          1983          ;print ','
00001EF6  48E7 4000               1984          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001EFA  123C 002C               1985          MOVE.B #',',D1                  ;put ascii value of char in D1
00001EFE  103C 0006               1986          MOVE.B #6,D0                    ;move task 6 into D0
00001F02  4E4F                    1987          TRAP #15                        ;prin char
00001F04  4CDF 0002               1988          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001F08                          1989          
00001F08  3401                    1990          MOVE.W  D1,D2                   ;check mode
00001F0A  C43C 003F               1991          AND.B   #%00111111,D2
00001F0E  1A02                    1992          MOVE.B  D2,D5
00001F10  48E7 4000               1993          MOVEM.L D1,-(SP)
00001F14  6100 0914               1994          BSR     Get_Effective_Address
00001F18  4CDF 0002               1995          MOVEM.L (SP)+,D1
00001F1C                          1996          
00001F1C                          1997          
00001F1C  43F9 00002CFE           1998          LEA     clearLine,A1            ;move string for a CR and LF
00001F22  103C 000E               1999          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001F26                          2000                                          ;string without CR, LF
00001F26  4E4F                    2001          TRAP    #15
00001F28                          2002  
00001F28  7000                    2003          MOVEQ.L #0,D0
00001F2A  4E75                    2004          RTS
00001F2C                          2005          
00001F2C                          2006  movemPost:
00001F2C                          2007  
00001F2C  43F9 00002D4B           2008          LEA     movemMessage,A1         ;move string for MOVE
00001F32  103C 000E               2009          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001F36                          2010                                          ;string with CR, LF
00001F36  4E4F                    2011          TRAP    #15
00001F38                          2012          
00001F38                          2013          ;size
00001F38  48E7 4000               2014          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001F3C                          2015          ;make it look like NEG's size
00001F3C  C23C 007F               2016          AND.B #%01111111,D1             ;clear bit next to size
00001F40  0641 0040               2017          ADDI.W #%01000000,D1            ;add 1 to size to make it look like a word or long
00001F44  6100 0228               2018          BSR negSize
00001F48  4CDF 0002               2019          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001F4C                          2020  
00001F4C  3401                    2021          MOVE.W  D1,D2                   ;check mode
00001F4E  C43C 003F               2022          AND.B   #%00111111,D2
00001F52  1A02                    2023          MOVE.B  D2,D5
00001F54  48E7 4000               2024          MOVEM.L D1,-(SP)
00001F58  6100 08D0               2025          BSR     Get_Effective_Address
00001F5C  4CDF 0002               2026          MOVEM.L (SP)+,D1
00001F60                          2027          
00001F60                          2028          
00001F60                          2029          ;print ','
00001F60  48E7 4000               2030          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001F64  123C 002C               2031          MOVE.B #',',D1                  ;put ascii value of char in D1
00001F68  103C 0006               2032          MOVE.B #6,D0                    ;move task 6 into D0
00001F6C  4E4F                    2033          TRAP #15                        ;prin char
00001F6E  4CDF 0002               2034          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001F72                          2035          
00001F72                          2036  
00001F72                          2037          
00001F72                          2038          ;show list
00001F72  6100 0102               2039          BSR outputPostIncrement        
00001F76                          2040          
00001F76  5487                    2041          ADDQ.L #word,D7                 ;read past the register list mask(word) following
00001F78                          2042                                          ;the instruction
00001F78                          2043          
00001F78  43F9 00002CFE           2044          LEA     clearLine,A1            ;move string for a CR and LF
00001F7E  103C 000E               2045          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001F82                          2046                                          ;string without CR, LF
00001F82  4E4F                    2047          TRAP    #15
00001F84                          2048  
00001F84  7000                    2049          MOVEQ.L #0,D0
00001F86  4E75                    2050          RTS
00001F88                          2051  
00001F88= 00000000 00000000 ...   2052  movemRegListBuffer DC.L 0,0,0,0,0,0,0,0,0,0,0,0 
00001FB8                          2053                                          ;max of 16 regs @ 2 bytes each, 
00001FB8                          2054                                          ;15 possible '/' @ a byte
00001FB8                          2055                                          ;byte for null terminator
00001FB8                          2056                                          ; 48 bytes = 12 longs 
00001FB8                          2057                              
00001FB8= 41 37 41 36 41 35 ...   2058  movemPostRegList DC.B 'A7','A6','A5','A4','A3','A2','A1','A0','D7','D6','D5','D4','D3','D2','D1','D0'
00001FD8                          2059  movemPreRegList ;should be location after PostList
00001FD8                          2060          
00001FD8                          2061  outputPreincrement:
00001FD8  548B                    2062             ADDQ.L #word,A3
00001FDA  3413                    2063          MOVE.W (A3),D2
00001FDC  7600                    2064          MOVEQ.L #0,D3
00001FDE  47F8 1F88               2065          LEA movemRegListBuffer,A3
00001FE2  49F8 1FD8               2066          LEA movemPreRegList,A4        
00001FE6  558C                    2067          SUBQ.L #word,A4
00001FE8                          2068          
00001FE8  6100 00E8               2069          BSR checkPreRegAdd              ;1
00001FEC                          2070          
00001FEC  558C                    2071          SUBQ.L #word,A4
00001FEE                          2072          
00001FEE  6100 00E2               2073          BSR checkPreRegAdd              ;2
00001FF2  558C                    2074          SUBQ.L #word,A4
00001FF4  6100 00DC               2075          BSR checkPreRegAdd              ;3
00001FF8  558C                    2076          SUBQ.L #word,A4
00001FFA  6100 00D6               2077          BSR checkPreRegAdd              ;4
00001FFE  558C                    2078          SUBQ.L #word,A4
00002000  6100 00D0               2079          BSR checkPreRegAdd              ;5
00002004  558C                    2080          SUBQ.L #word,A4
00002006  6100 00CA               2081          BSR checkPreRegAdd              ;6
0000200A  558C                    2082          SUBQ.L #word,A4
0000200C  6100 00C4               2083          BSR checkPreRegAdd              ;7
00002010  558C                    2084          SUBQ.L #word,A4
00002012  6100 00BE               2085          BSR checkPreRegAdd              ;8
00002016  558C                    2086          SUBQ.L #word,A4
00002018  6100 00B8               2087          BSR checkPreRegAdd              ;9
0000201C  558C                    2088          SUBQ.L #word,A4
0000201E  6100 00B2               2089          BSR checkPreRegAdd              ;10
00002022  558C                    2090          SUBQ.L #word,A4
00002024  6100 00AC               2091          BSR checkPreRegAdd              ;11
00002028  558C                    2092          SUBQ.L #word,A4
0000202A  6100 00A6               2093          BSR checkPreRegAdd              ;12
0000202E  558C                    2094          SUBQ.L #word,A4
00002030  6100 00A0               2095          BSR checkPreRegAdd              ;13
00002034  558C                    2096          SUBQ.L #word,A4
00002036  6100 009A               2097          BSR checkPreRegAdd              ;14
0000203A  558C                    2098          SUBQ.L #word,A4
0000203C  6100 0094               2099          BSR checkPreRegAdd              ;15
00002040  558C                    2100          SUBQ.L #word,A4
00002042  6100 008E               2101          BSR checkPreRegAdd              ;16
00002046                          2102          
00002046  16BC 0000               2103          MOVE.B #0,(A3)
0000204A  43F8 1F88               2104          LEA     movemRegListBuffer,A1   ;move string for MOVE
0000204E  103C 000E               2105          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002052                          2106                                          ;string without CR, LF
00002052  4E4F                    2107          TRAP    #15 
00002054                          2108          
00002054  4E75                    2109          RTS
00002056                          2110          
00002056                          2111  checkPostRegAdd:
00002056  E342                    2112          ASL.W #1,D2
00002058  6500 0004               2113          BCS PostRegAdd
0000205C                          2114  addPostRegDone:
0000205C  4E75                    2115          RTS
0000205E                          2116          
0000205E                          2117  PostRegAdd:
0000205E  4BF8 1F88               2118          LEA movemRegListBuffer,A5
00002062  BBCB                    2119          CMP.L A3,A5
00002064  6600 000A               2120          BNE postAddBackslash
00002068                          2121  PostRegAddDone:
00002068  16DC                    2122          MOVE.B (A4)+,(A3)+
0000206A  16D4                    2123          MOVE.B (A4),(A3)+
0000206C  538C                    2124          SUBQ.L #byte,A4
0000206E  60EC                    2125          BRA addPostRegDone
00002070                          2126          
00002070                          2127  postAddBackslash:
00002070  16FC 002F               2128          MOVE.B #'/',(A3)+
00002074  60F2                    2129          BRA PostRegAddDone
00002076                          2130          
00002076                          2131  
00002076                          2132  outputPostincrement:
00002076  548B                    2133          ADDQ.L #word,A3
00002078  3413                    2134          MOVE.W (A3),D2
0000207A  7600                    2135          MOVEQ.L #0,D3
0000207C  47F8 1F88               2136          LEA movemRegListBuffer,A3
00002080  49F8 1FB8               2137          LEA movemPostRegList,A4
00002084                          2138          
00002084  61D0                    2139          BSR checkPostRegAdd             ;1
00002086  548C                    2140          ADDQ.L #word,A4
00002088  61CC                    2141          BSR checkPostRegAdd             ;2
0000208A  548C                    2142          ADDQ.L #word,A4
0000208C  61C8                    2143          BSR checkPostRegAdd             ;3
0000208E  548C                    2144          ADDQ.L #word,A4
00002090  61C4                    2145          BSR checkPostRegAdd             ;4
00002092  548C                    2146          ADDQ.L #word,A4
00002094  61C0                    2147          BSR checkPostRegAdd             ;5
00002096  548C                    2148          ADDQ.L #word,A4
00002098  61BC                    2149          BSR checkPostRegAdd             ;6
0000209A  548C                    2150          ADDQ.L #word,A4
0000209C  61B8                    2151          BSR checkPostRegAdd             ;7
0000209E  548C                    2152          ADDQ.L #word,A4
000020A0  61B4                    2153          BSR checkPostRegAdd             ;8
000020A2  548C                    2154          ADDQ.L #word,A4
000020A4  61B0                    2155          BSR checkPostRegAdd             ;9
000020A6  548C                    2156          ADDQ.L #word,A4
000020A8  61AC                    2157          BSR checkPostRegAdd             ;10
000020AA  548C                    2158          ADDQ.L #word,A4
000020AC  61A8                    2159          BSR checkPostRegAdd             ;11
000020AE  548C                    2160          ADDQ.L #word,A4
000020B0  61A4                    2161          BSR checkPostRegAdd             ;12
000020B2  548C                    2162          ADDQ.L #word,A4
000020B4  61A0                    2163          BSR checkPostRegAdd             ;13
000020B6  548C                    2164          ADDQ.L #word,A4
000020B8  619C                    2165          BSR checkPostRegAdd             ;14
000020BA  548C                    2166          ADDQ.L #word,A4
000020BC  6198                    2167          BSR checkPostRegAdd             ;15
000020BE  548C                    2168          ADDQ.L #word,A4
000020C0  6194                    2169          BSR checkPostRegAdd             ;16
000020C2                          2170          
000020C2  16BC 0000               2171          MOVE.B #0,(A3)
000020C6  43F8 1F88               2172          LEA     movemRegListBuffer,A1   ;move string for MOVE
000020CA  103C 000E               2173          MOVE.B  #14,D0                  ;set for task to display null terminated 
000020CE                          2174                               ;string without CR, LF
000020CE  4E4F                    2175          TRAP    #15 
000020D0                          2176          
000020D0  4E75                    2177          RTS
000020D2                          2178          
000020D2                          2179  checkPreRegAdd:
000020D2  E342                    2180          ASL.W #1,D2
000020D4  6500 0004               2181          BCS PreRegAdd
000020D8                          2182  addPreRegDone:
000020D8  4E75                    2183          RTS
000020DA                          2184          
000020DA                          2185  PreRegAdd:
000020DA  4BF8 1F88               2186          LEA movemRegListBuffer,A5
000020DE  BBCB                    2187          CMP.L A3,A5
000020E0  6600 000A               2188          BNE preAddBackslash
000020E4                          2189  PreRegAddDone:
000020E4  16DC                    2190          MOVE.B (A4)+,(A3)+
000020E6  16D4                    2191          MOVE.B (A4),(A3)+
000020E8  538C                    2192          SUBQ.L #byte,A4
000020EA  60EC                    2193          BRA addPreRegDone
000020EC                          2194          
000020EC                          2195  preAddBackslash:
000020EC  16FC 002F               2196          MOVE.B #'/',(A3)+
000020F0  6000 FF76               2197          BRA PostRegAddDone
000020F4                          2198  
000020F4                          2199      
000020F4= 00 10 18 20 28 38 ...   2200  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
000020FC= 38 38 38 38 38 3F ...   2201  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
00002104                          2202     
00002104                          2203  NEG:            
00002104                          2204       
00002104  7000                    2205          MOVEQ.L #0, D0                  ;clear D0
00002106                          2206          
00002106                          2207  validNegModes:
00002106                          2208          
00002106  43F8 20FC               2209          LEA NegEAmasks,A1               ;load the list of masks
0000210A  D3C0                    2210          ADDA.L D0,A1                    ;displace to a specific mask
0000210C  1A11                    2211          MOVE.B (A1),D5                  ;move the mask to D5
0000210E                          2212          
0000210E  0C05 0000               2213          CMPI.B #0,D5                    ;check if the mask is 0
00002112  6700 EF84               2214          BEQ falsePositive               ;branch if it is
00002116                          2215          
00002116  1401                    2216          MOVE.B D1,D2                    ;copy instruction to D2
00002118  C405                    2217          AND.B D5,D2                     ;mask D2
0000211A  43F8 20F4               2218          LEA NegEA,A1                    ;load the list of valid modes
0000211E  D3C0                    2219          ADDA.L D0,A1                    ;displace to a specific mode
00002120  1811                    2220          MOVE.B (A1),D4                  ;move mode to D4
00002122  B404                    2221          CMP.B D4,D2                     ;compare mode to masked value
00002124  6700 0006               2222          BEQ NegBody                     ;if its match, its a valid mode and we can procede
00002128                          2223          
00002128  5280                    2224          ADDQ.L #1,D0                    ;add one to displacement
0000212A  60DA                    2225          BRA validNegModes               ;check for next mode
0000212C                          2226          
0000212C                          2227  NegBody:
0000212C                          2228  
0000212C                          2229  
0000212C  3401                    2230          MOVE.W  D1,D2                   ;copy inst to D2
0000212E  C47C 0600               2231          AND.W  #%0011000000000,D2       ;mask word for size
00002132  0C42 0000               2232          CMPI.W #0,D2                    ;0 is the only non valid size
00002136  6700 EF60               2233          BEQ falsePositive               ; zero is not valid
0000213A                          2234  
0000213A  43F9 00002D75           2235          LEA     negMessage,A1           ;move string for NEG info
00002140  103C 000E               2236          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002144                          2237                                ;string without CR, LF
00002144  4E4F                    2238          TRAP    #15
00002146                          2239          
00002146  6100 0026               2240          BSR NegSize
0000214A                          2241          
0000214A  3401                    2242          MOVE.W D1,D2
0000214C  C47C 003F               2243          AND #%000000000111111,D2
00002150  1A02                    2244          MOVE.B D2,D5
00002152                          2245          
00002152  48E7 4000               2246          MOVEM.L D1,-(SP)
00002156  6100 06D2               2247          BSR     Get_Effective_Address
0000215A  4CDF 0002               2248          MOVEM.L (SP)+,D1
0000215E                          2249          
0000215E                          2250                
0000215E                          2251          
0000215E                          2252  NEGdone:
0000215E                          2253  
0000215E  43F9 00002CFE           2254          LEA     clearLine,A1            ;move string for a CR and LF
00002164  103C 000E               2255          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002168                          2256                                          ;string without CR, LF
00002168  4E4F                    2257          TRAP    #15
0000216A  7000                    2258          MOVEQ.L #0,D0
0000216C  4E75                    2259          RTS
0000216E                          2260          
0000216E                          2261  NegSize:
0000216E  3401                    2262          MOVE.W  D1,D2                   ;copy inst to D2
00002170  EC4A                    2263          LSR.W #6,D2                     ;shift size over to first byte
00002172  C4BC 00000003           2264          AND.L  #%11,D2                  ;mask word for size
00002178  2C02                    2265          MOVE.L D2,D6                    ;size does not need to be translated,
0000217A                          2266                                          ;so moved directly to D6
0000217A                          2267          
0000217A  6100 084C               2268          BSR printSize
0000217E                          2269          
0000217E  4E75                    2270          RTS
00002180                          2271          
00002180                          2272          
00002180                          2273   ADDI:            
00002180                          2274       
00002180  7000                    2275          MOVEQ.L #0, D0                  ;clear D0
00002182                          2276          
00002182                          2277  validAddiModes:
00002182                          2278          
00002182                          2279          
00002182  43F9 000022A7           2280          LEA cmpiEAmasks,A1              ;load the list of masks
00002188  D3C0                    2281          ADDA.L D0,A1                    ;displace to a specific mask
0000218A  1A11                    2282          MOVE.B (A1),D5                  ;move the mask to D5
0000218C                          2283          
0000218C  0C05 0000               2284          CMPI.B #0,D5                    ;check if the mask is 0
00002190  6700 EF06               2285          BEQ falsePositive               ;branch if it is
00002194                          2286          
00002194  1401                    2287          MOVE.B D1,D2                    ;copy instruction to D2
00002196  C405                    2288          AND.B D5,D2                     ;mask D2
00002198  43F9 000022A0           2289          LEA cmpiEA,A1                   ;load the list of valid modes
0000219E  D3C0                    2290          ADDA.L D0,A1                    ;displace to a specific mode
000021A0  1811                    2291          MOVE.B (A1),D4                  ;move mode to D4
000021A2  B404                    2292          CMP.B D4,D2                     ;compare mode to masked value
000021A4  6700 0006               2293          BEQ addiBody                    ;if its match, its a valid mode and we can procede
000021A8                          2294          
000021A8  5280                    2295          ADDQ.L #1,D0                    ;add one to displacement
000021AA  60D6                    2296          BRA validAddiModes              ;check for next mode
000021AC                          2297          
000021AC                          2298  addiBody:
000021AC                          2299  
000021AC                          2300  
000021AC  3401                    2301          MOVE.W  D1,D2                   ;copy inst to D2
000021AE  C47C 00C0               2302          AND.W  #%0000000011000000,D2    ;mask word for size
000021B2  0C42 00C0               2303          CMPI.W #%0000000011000000,D2    ;11 is the only non valid size
000021B6  6700 EEE0               2304          BEQ falsePositive
000021BA                          2305  
000021BA  43F9 00002D51           2306          LEA     addiMessage,A1          ;move string for NEG info
000021C0  103C 000E               2307          MOVE.B  #14,D0                  ;set for task to display null terminated 
000021C4                          2308                                ;string without CR, LF
000021C4  4E4F                    2309          TRAP    #15
000021C6                          2310          
000021C6  61A6                    2311          BSR NegSize
000021C8                          2312          
000021C8                          2313          ;go to Effective_Address for immediate data
000021C8  743C                    2314          MOVE.L #%00111100,D2
000021CA  2A02                    2315          MOVE.L D2,D5
000021CC  48E7 4000               2316          MOVEM.L D1,-(SP)
000021D0  6100 0658               2317          BSR     Get_Effective_Address
000021D4  4CDF 0002               2318          MOVEM.L (SP)+,D1
000021D8                          2319          
000021D8                          2320          ;print ','
000021D8  48E7 4000               2321          MOVEM.L D1,-(SP)                ;save D1 to the stack
000021DC  123C 002C               2322          MOVE.B #',',D1                  ;put ascii value of char in D1
000021E0  103C 0006               2323          MOVE.B #6,D0                    ;move task 6 into D0
000021E4  4E4F                    2324          TRAP #15                        ;prin char
000021E6  4CDF 0002               2325          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000021EA                          2326          
000021EA  3401                    2327          MOVE.W D1,D2                    ;copy inst to D2
000021EC  C47C 003F               2328          AND #%000000000111111,D2        ;and out everything but modes and regs
000021F0  1A02                    2329          MOVE.B D2,D5                    ; copy to D5 for following BSR
000021F2                          2330          
000021F2  48E7 4000               2331          MOVEM.L D1,-(SP)
000021F6  6100 0632               2332          BSR     Get_Effective_Address
000021FA  4CDF 0002               2333          MOVEM.L (SP)+,D1
000021FE                          2334          
000021FE                          2335                
000021FE                          2336          
000021FE                          2337  addidone:
000021FE                          2338  
000021FE  43F9 00002CFE           2339          LEA     clearLine,A1            ;move string for a CR and LF
00002204  103C 000E               2340          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002208                          2341                                          ;string without CR, LF
00002208  4E4F                    2342          TRAP    #15
0000220A  7000                    2343          MOVEQ.L #0,D0
0000220C  4E75                    2344          RTS
0000220E                          2345    
0000220E                          2346  ORI:            
0000220E                          2347       
0000220E  7000                    2348          MOVEQ.L #0, D0                  ;clear D0
00002210                          2349          
00002210                          2350  validOriModes:
00002210                          2351          
00002210                          2352          
00002210  43F9 000022A7           2353          LEA cmpiEAmasks,A1              ;load the list of masks
00002216  D3C0                    2354          ADDA.L D0,A1                    ;displace to a specific mask
00002218  1A11                    2355          MOVE.B (A1),D5                  ;move the mask to D5
0000221A                          2356          
0000221A  0C05 0000               2357          CMPI.B #0,D5                    ;check if the mask is 0
0000221E  6700 EE78               2358          BEQ falsePositive               ;branch if it is
00002222                          2359          
00002222  1401                    2360          MOVE.B D1,D2                    ;copy instruction to D2
00002224  C405                    2361          AND.B D5,D2                     ;mask D2
00002226  43F9 000022A0           2362          LEA cmpiEA,A1                   ;load the list of valid modes
0000222C  D3C0                    2363          ADDA.L D0,A1                    ;displace to a specific mode
0000222E  1811                    2364          MOVE.B (A1),D4                  ;move mode to D4
00002230  B404                    2365          CMP.B D4,D2                     ;compare mode to masked value
00002232  6700 0006               2366          BEQ oriBody                     ;if its match, its a valid mode and we can procede
00002236                          2367          
00002236  5280                    2368          ADDQ.L #1,D0                    ;add one to displacement
00002238  60D6                    2369          BRA validOriModes               ;check for next mode
0000223A                          2370          
0000223A                          2371  oriBody:
0000223A                          2372  
0000223A                          2373  
0000223A  3401                    2374          MOVE.W  D1,D2                   ;copy inst to D2
0000223C  C47C 00C0               2375          AND.W  #%0000000011000000,D2    ;mask word for size
00002240  0C42 00C0               2376          CMPI.W #%0000000011000000,D2    ;11 is the only non valid size
00002244  6700 EE52               2377          BEQ falsePositive
00002248                          2378  
00002248  43F9 00002D56           2379          LEA     oriMessage,A1           ;move string for NEG info
0000224E  103C 000E               2380          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002252                          2381                                ;string without CR, LF
00002252  4E4F                    2382          TRAP    #15
00002254                          2383          
00002254  6100 FF18               2384          BSR negSize
00002258                          2385          
00002258                          2386          ;go to Effective_Address for immediate data
00002258  143C 003C               2387          MOVE.B #%00111100,D2
0000225C  1A02                    2388          MOVE.B D2,D5
0000225E  48E7 4000               2389          MOVEM.L D1,-(SP)
00002262  6100 05C6               2390          BSR     Get_Effective_Address
00002266  4CDF 0002               2391          MOVEM.L (SP)+,D1
0000226A                          2392          
0000226A                          2393          ;print ','
0000226A  48E7 4000               2394          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000226E  123C 002C               2395          MOVE.B #',',D1                  ;put ascii value of char in D1
00002272  103C 0006               2396          MOVE.B #6,D0                    ;move task 6 into D0
00002276  4E4F                    2397          TRAP #15                        ;print char
00002278  4CDF 0002               2398          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000227C                          2399          
0000227C  3401                    2400          MOVE.W D1,D2                    ;copy inst to D2
0000227E  C47C 003F               2401          AND #%000000000111111,D2        ;and out everything but modes and regs
00002282  1A02                    2402          MOVE.B D2,D5                    ; copy to D5 for following BSR
00002284                          2403          
00002284  48E7 4000               2404          MOVEM.L D1,-(SP)
00002288  6100 05A0               2405          BSR     Get_Effective_Address
0000228C  4CDF 0002               2406          MOVEM.L (SP)+,D1
00002290                          2407          
00002290                          2408                
00002290                          2409          
00002290                          2410  oridone:
00002290                          2411  
00002290  43F9 00002CFE           2412          LEA     clearLine,A1            ;move string for a CR and LF
00002296  103C 000E               2413          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000229A                          2414                                          ;string without CR, LF
0000229A  4E4F                    2415          TRAP    #15
0000229C  7000                    2416          MOVEQ.L #0,D0
0000229E  4E75                    2417          RTS
000022A0                          2418  
000022A0                          2419          
000022A0                          2420          
000022A0= 20 18 00 10 38 39 00    2421  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
000022A7= 38 38 38 38 3F 3F 00    2422  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
000022AE                          2423     
000022AE                          2424  CMPI:            
000022AE                          2425       
000022AE  7000                    2426          MOVEQ.L #0, D0                  ;clear D0
000022B0                          2427          
000022B0                          2428  validCmpiModes:
000022B0                          2429          
000022B0                          2430          
000022B0  43F8 22A7               2431          LEA cmpiEAmasks,A1              ;load the list of masks
000022B4  D3C0                    2432          ADDA.L D0,A1                    ;displace to a specific mask
000022B6  1A11                    2433          MOVE.B (A1),D5                  ;move the mask to D5
000022B8                          2434          
000022B8  0C05 0000               2435          CMPI.B #0,D5                    ;check if the mask is 0
000022BC  6700 EDDA               2436          BEQ falsePositive               ;branch if it is
000022C0                          2437          
000022C0  1401                    2438          MOVE.B D1,D2                    ;copy instruction to D2
000022C2  C405                    2439          AND.B D5,D2                     ;mask D2
000022C4  43F8 22A0               2440          LEA cmpiEA,A1                   ;load the list of valid modes
000022C8  D3C0                    2441          ADDA.L D0,A1                    ;displace to a specific mode
000022CA  1811                    2442          MOVE.B (A1),D4                  ;move mode to D4
000022CC  B404                    2443          CMP.B D4,D2                     ;compare mode to masked value
000022CE  6700 0006               2444          BEQ CMPIBody                    ;if its match, its a valid mode and we can procede
000022D2                          2445          
000022D2  5280                    2446          ADDQ.L #1,D0                    ;add one to displacement
000022D4  60DA                    2447          BRA validCmpiModes              ;check for next mode
000022D6                          2448          
000022D6                          2449  CMPIBody:
000022D6                          2450  
000022D6                          2451  
000022D6  3401                    2452          MOVE.W  D1,D2                   ;copy inst to D2
000022D8  C47C 00C0               2453          AND.W  #%0000000011000000,D2    ;mask word for size
000022DC  0C42 00C0               2454          CMPI.W #%0000000011000000,D2    ;11 is the only non valid size
000022E0  6700 EDB6               2455          BEQ falsePositive
000022E4                          2456  
000022E4  43F9 00002D5A           2457          LEA     cmpiMessage,A1          ;move string for NEG info
000022EA  103C 000E               2458          MOVE.B  #14,D0                  ;set for task to display null terminated 
000022EE                          2459                                ;string without CR, LF
000022EE  4E4F                    2460          TRAP    #15
000022F0                          2461          
000022F0  6100 FE7C               2462          BSR negSize
000022F4                          2463          
000022F4                          2464          ;go to Effective_Address for immediate data
000022F4  143C 003C               2465          MOVE.B #%00111100,D2
000022F8  1A02                    2466          MOVE.B D2,D5
000022FA  48E7 4000               2467          MOVEM.L D1,-(SP)
000022FE  6100 052A               2468          BSR     Get_Effective_Address
00002302  4CDF 0002               2469          MOVEM.L (SP)+,D1
00002306                          2470          
00002306                          2471          ;print ','
00002306  48E7 4000               2472          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000230A  123C 002C               2473          MOVE.B #',',D1                  ;put ascii value of char in D1
0000230E  103C 0006               2474          MOVE.B #6,D0                    ;move task 6 into D0
00002312  4E4F                    2475          TRAP #15                        ;prin char
00002314  4CDF 0002               2476          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002318                          2477          
00002318  3401                    2478          MOVE.W D1,D2                    ;copy inst to D2
0000231A  C47C 003F               2479          AND #%000000000111111,D2        ;and out everything but modes and regs
0000231E  1A02                    2480          MOVE.B D2,D5                    ; copy to D5 for following BSR
00002320                          2481          
00002320  48E7 4000               2482          MOVEM.L D1,-(SP)
00002324  6100 0504               2483          BSR     Get_Effective_Address
00002328  4CDF 0002               2484          MOVEM.L (SP)+,D1
0000232C                          2485          
0000232C                          2486                
0000232C                          2487          
0000232C                          2488  CMPidone:
0000232C                          2489  
0000232C  43F9 00002CFE           2490          LEA     clearLine,A1            ;move string for a CR and LF
00002332  103C 000E               2491          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002336                          2492                                ;string without CR, LF
00002336  4E4F                    2493          TRAP    #15
00002338  7000                    2494          MOVEQ.L #0,D0
0000233A  4E75                    2495          RTS
0000233C                          2496  
0000233C                          2497          
0000233C= 10 38 39 00             2498  JsrEA        DC.B %010000, %111000, %111001,0
00002340= 38 3F 3F 00             2499  JsrEAmasks   DC.B %111000, %111111, %111111,0
00002344                          2500     
00002344                          2501  JSR:            
00002344                          2502       
00002344  7000                    2503          MOVEQ.L #0, D0                  ;clear D0
00002346                          2504          
00002346                          2505  validJsrModes:
00002346                          2506          
00002346  43F8 2340               2507          LEA JsrEAmasks,A1               ;load the list of masks
0000234A  D3C0                    2508          ADDA.L D0,A1                    ;displace to a specific mask
0000234C  1A11                    2509          MOVE.B (A1),D5                  ;move the mask to D5
0000234E                          2510          
0000234E  0C05 0000               2511          CMPI.B #0,D5                    ;check if the mask is 0
00002352  6700 ED44               2512          BEQ falsePositive               ;branch if it is
00002356                          2513          
00002356  1401                    2514          MOVE.B D1,D2                    ;copy instruction to D2
00002358  C405                    2515          AND.B D5,D2                     ;mask D2
0000235A  43F8 233C               2516          LEA JsrEA,A1                    ;load the list of valid modes
0000235E  D3C0                    2517          ADDA.L D0,A1                    ;displace to a specific mode
00002360  1811                    2518          MOVE.B (A1),D4                  ;move mode to D4
00002362  B404                    2519          CMP.B D4,D2                     ;compare mode to masked value
00002364  6700 0006               2520          BEQ JsrBody                     ;if its match, its a valid mode and we can procede
00002368                          2521          
00002368  5280                    2522          ADDQ.L #1,D0                    ;add one to displacement
0000236A  60DA                    2523          BRA validJsrModes               ;check for next mode
0000236C                          2524          
0000236C                          2525  JsrBody:
0000236C                          2526  
0000236C                          2527  
0000236C  43F9 00002D5F           2528          LEA     jsrMessage,A1           ;move string for NEG info
00002372  103C 000E               2529          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002376                          2530                                ;string without CR, LF
00002376  4E4F                    2531          TRAP    #15
00002378                          2532          
00002378  3401                    2533          MOVE.W D1,D2                    ;copy inst to D2
0000237A  C47C 003F               2534          AND #%000000000111111,D2        ;and out everything but modes and regs
0000237E  1A02                    2535          MOVE.B D2,D5                    ; copy to D5 for following BSR
00002380                          2536          
00002380  48E7 4000               2537          MOVEM.L D1,-(SP)
00002384  6100 04A4               2538          BSR     Get_Effective_Address
00002388  4CDF 0002               2539          MOVEM.L (SP)+,D1
0000238C                          2540          
0000238C                          2541                
0000238C                          2542          
0000238C                          2543  Jsrdone:
0000238C                          2544  
0000238C  43F9 00002CFE           2545          LEA     clearLine,A1            ;move string for a CR and LF
00002392  103C 000E               2546          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002396                          2547                                ;string without CR, LF
00002396  4E4F                    2548          TRAP    #15
00002398  7000                    2549          MOVEQ.L #0,D0
0000239A  4E75                    2550          RTS
0000239C                          2551  
0000239C                          2552  
0000239C                          2553          
0000239C                          2554  NOP:
0000239C                          2555  
0000239C  43F9 00002D69           2556          LEA     nopMessage,A1           ;move string for NOP info
000023A2  103C 000D               2557          MOVE.B  #13,D0                  ;set for task to display null terminated 
000023A6                          2558                                          ;string with CR, LF
000023A6  4E4F                    2559          TRAP    #15
000023A8                          2560          
000023A8  7000                    2561          MOVEQ.L #0,D0
000023AA  4E75                    2562          RTS
000023AC                          2563          
000023AC                          2564  RTS:
000023AC                          2565          
000023AC  43F9 00002D64           2566          LEA     rtsMessage,A1           ;move string for rts info
000023B2  103C 000D               2567          MOVE.B  #13,D0                  ;set for task to display null terminated 
000023B6                          2568                                          ;string with CR, LF
000023B6  4E4F                    2569          TRAP    #15  
000023B8                          2570     
000023B8  7000                    2571          MOVEQ.L #0,D0
000023BA  4E75                    2572          RTS   
000023BC                          2573  
000023BC= 3C 08 00 10 18 20 ...   2574  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
000023C5= 3F 38 38 38 38 38 ...   2575  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
000023CE                          2576  
000023CE= 00 10 18 20 38 39 00    2577  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
000023D5= 38 38 38 38 3F 3F 00    2578  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
000023DC                          2579  
000023DC                          2580  MOVE:
000023DC                          2581          
000023DC                          2582  
000023DC                          2583          
000023DC  7000                    2584          MOVEQ.L #0, D0                  ;clear D0
000023DE                          2585          
000023DE                          2586  validMoveSourceModes:
000023DE                          2587          
000023DE  43F8 23C5               2588          LEA moveSourceEAmasks,A1        ;load the list of masks
000023E2  D3C0                    2589          ADDA.L D0,A1                    ;displace to a specific mask
000023E4  1A11                    2590          MOVE.B (A1),D5                  ;move the mask to D5
000023E6                          2591          
000023E6  0C05 0000               2592          CMPI.B #0,D5                    ;check if the mask is 0
000023EA  6700 ECAC               2593          BEQ falsePositive               ;branch if it is
000023EE                          2594          
000023EE  1401                    2595          MOVE.B D1,D2                    ;copy instruction to D2
000023F0  C405                    2596          AND.B D5,D2                     ;mask D2
000023F2                          2597          
000023F2  43F8 23BC               2598          LEA moveSourceEA,A1             ;load the list of valid modes
000023F6  D3C0                    2599          ADDA.L D0,A1                    ;displace to a specific mode
000023F8  1811                    2600          MOVE.B (A1),D4                  ;move mode to D4
000023FA  B404                    2601          CMP.B D4,D2                     ;compare mode to masked value
000023FC  6700 0006               2602          BEQ  checkMoveDest              ;if its match, its a valid mode and we can procede
00002400                          2603          
00002400  5280                    2604          ADDQ.L #1,D0                    ;add one to displacement
00002402  60DA                    2605          BRA validMoveSourceModes        ;check for next mode
00002404                          2606          
00002404                          2607  checkMoveDest:
00002404  7000                    2608          MOVEQ.L #0, D0                  ;clear D0
00002406                          2609          
00002406                          2610  validMoveDestModes:
00002406                          2611          
00002406  43F8 23D5               2612          LEA moveDestEAmasks,A1          ;load the list of masks
0000240A  D3C0                    2613          ADDA.L D0,A1                    ;displace to a specific mask
0000240C  1A11                    2614          MOVE.B (A1),D5                  ;move the mask to D5
0000240E                          2615          
0000240E  0C05 0000               2616          CMPI.B #0,D5                    ;check if the mask is 0
00002412  6700 EC84               2617          BEQ falsePositive               ;branch if it is
00002416                          2618          
00002416  3401                    2619          MOVE.W D1,D2                    ;copy instruction to D2
00002418  EC4A                    2620          LSR.W #6,D2                     ;move mode
0000241A  6100 06DE               2621          BSR switchModeAndReg            ;switch register and mode
0000241E  C405                    2622          AND.B D5,D2                     ;mask D2
00002420                          2623          
00002420  43F8 23CE               2624          LEA moveDestEA,A1               ;load the list of valid modes
00002424  D3C0                    2625          ADDA.L D0,A1                    ;displace to a specific mode
00002426  1811                    2626          MOVE.B (A1),D4                  ;move mode to D4
00002428  B404                    2627          CMP.B D4,D2                     ;compare mode to masked value
0000242A  6700 0006               2628          BEQ moveBody                    ;if its match, its a valid mode and we can procede
0000242E                          2629          
0000242E  5280                    2630          ADDQ.L #1,D0                    ;add one to displacement
00002430  60D4                    2631          BRA validMoveDestModes          ;check for next mode
00002432                          2632          
00002432                          2633  moveBody
00002432  3401                    2634          MOVE.W  D1,D2                   ;copy inst to D2
00002434  C47C 3000               2635          AND.W  #%0011000000000000,D2    ;mask word for size
00002438  0C42 0000               2636          CMPI.W #0,D2                    ;0 is the only non valid size
0000243C  6700 EC5A               2637          BEQ falsePositive               ; if zero, this is not move
00002440                          2638  
00002440  43F9 00002D6E           2639          LEA     moveMessage,A1          ;move string for MOVE
00002446  103C 000E               2640          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000244A                          2641                                ;string with CR, LF
0000244A  4E4F                    2642          TRAP    #15
0000244C                          2643          
0000244C  6100 0052               2644          BSR moveSize
00002450                          2645          
00002450  3401                    2646          MOVE.W  D1,D2                   ;check source mode
00002452  C43C 003F               2647          AND.B   #%00111111,D2
00002456  1A02                    2648          MOVE.B  D2,D5
00002458  48E7 4000               2649          MOVEM.L D1,-(SP)
0000245C  6100 03CC               2650          BSR     Get_Effective_Address
00002460  4CDF 0002               2651          MOVEM.L (SP)+,D1
00002464                          2652          
00002464                          2653          ;print ','
00002464  48E7 4000               2654          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002468  123C 002C               2655          MOVE.B #',',D1                  ;put ascii value of char in D1
0000246C  103C 0006               2656          MOVE.B #6,D0                    ;move task 6 into D0
00002470  4E4F                    2657          TRAP #15                        ;prin char
00002472  4CDF 0002               2658          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002476                          2659          
00002476  3401                    2660          MOVE.W  D1,D2                   ;check dest mode
00002478  EC4A                    2661          LSR.W   #6,D2
0000247A  6100 067E               2662          BSR  switchModeAndReg
0000247E  C43C 003F               2663          AND.B   #%00111111,D2
00002482  1A02                    2664          MOVE.B  D2,D5
00002484  48E7 4000               2665          MOVEM.L D1,-(SP)
00002488  6100 03A0               2666          BSR     Get_Effective_Address
0000248C  4CDF 0002               2667          MOVEM.L (SP)+,D1
00002490                          2668          
00002490                          2669          
00002490                          2670          
00002490  43F9 00002CFE           2671          LEA     clearLine,A1            ;move string for a CR and LF
00002496  103C 000E               2672          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000249A                          2673                                ;string without CR, LF
0000249A  4E4F                    2674          TRAP    #15
0000249C                          2675  
0000249C  7000                    2676          MOVEQ.L #0,D0
0000249E  4E75                    2677          RTS
000024A0                          2678          
000024A0                          2679  moveSize:
000024A0  3401                    2680          MOVE.W  D1,D2                   ;copy inst to D2
000024A2  E04A                    2681          LSR.W   #8,D2                   ;shift size
000024A4  E80A                    2682          LSR.B   #4,D2
000024A6  C4BC 00000003           2683          AND.L  #%11,D2                  ;mask for size
000024AC  7C00                    2684          MOVEQ.L #0,D6                   ;clear D6
000024AE  0C42 0002               2685          CMPI.W #2,D2                    ;compare and then branch depending on size
000024B2  6700 001C               2686          BEQ moveSizeLong
000024B6  6E00 0012               2687          BGT moveSizeWord
000024BA  6D00 0008               2688          BLT moveSizeByte
000024BE                          2689  moveSizeDone:        
000024BE  6100 0508               2690          BSR printSize
000024C2  4E75                    2691          RTS
000024C4                          2692          
000024C4                          2693  moveSizeByte:
000024C4  1C3C 0000               2694          MOVE.B #0,D6
000024C8  60F4                    2695          BRA moveSizeDone
000024CA                          2696          
000024CA                          2697  moveSizeWord:
000024CA  1C3C 0001               2698          MOVE.B #1,D6
000024CE  60EE                    2699          BRA moveSizeDone
000024D0                          2700          
000024D0                          2701  moveSizeLong:
000024D0  1C3C 0002               2702          MOVE.B #2,D6
000024D4  60E8                    2703          BRA moveSizeDone
000024D6                          2704          
000024D6= 08 00                   2705  moveADestEA        DC.B %001000,0
000024D8= 38 00                   2706  moveADestEAmasks   DC.B %111000,0
000024DA                          2707          
000024DA                          2708  MOVEA:
000024DA                          2709  
000024DA  7000                    2710          MOVEQ.L #0, D0                  ;clear D0
000024DC                          2711          
000024DC                          2712  validMoveAModes:
000024DC                          2713          
000024DC  43F8 23C5               2714          LEA moveSourceEAmasks,A1        ;load the list of masks
000024E0  D3C0                    2715          ADDA.L D0,A1                    ;displace to a specific mask
000024E2  1A11                    2716          MOVE.B (A1),D5                  ;move the mask to D5
000024E4                          2717          
000024E4  0C05 0000               2718          CMPI.B #0,D5                    ;check if the mask is 0
000024E8  6700 EBAE               2719          BEQ falsePositive               ;branch if it is
000024EC                          2720          
000024EC  1401                    2721          MOVE.B D1,D2                    ;copy instruction to D2
000024EE  C405                    2722          AND.B D5,D2                     ;mask D2
000024F0                          2723          
000024F0  43F8 23BC               2724          LEA moveSourceEA,A1             ;load the list of valid modes
000024F4  D3C0                    2725          ADDA.L D0,A1                    ;displace to a specific mode
000024F6  1811                    2726          MOVE.B (A1),D4                  ;move mode to D4
000024F8  B404                    2727          CMP.B D4,D2                     ;compare mode to masked value
000024FA  6700 0006               2728          BEQ  moveABody                  ;if its match, its a valid mode and we can procede
000024FE                          2729          
000024FE  5280                    2730          ADDQ.L #1,D0                    ;add one to displacement
00002500  60DA                    2731          BRA validMoveAModes             ;check for next mode
00002502                          2732          
00002502                          2733  moveABody:
00002502  3401                    2734          MOVE.W  D1,D2                   ;copy inst to D2
00002504  C47C 3000               2735          AND.W  #%0011000000000000,D2    ;mask word for size
00002508  0C42 0000               2736          CMPI.W #0,D2                    ;0 is the non valid size
0000250C  6700 EB8A               2737          BEQ falsePositive               ; if zero, this is not move
00002510  0C42 1000               2738          CMPI.W #%0001000000000000,D2
00002514  6700 EB82               2739          BEQ falsePositive               ; if byte, this is not movea
00002518                          2740  
00002518                          2741  
00002518  43F9 00002D7F           2742          LEA     moveAMessage,A1         ;move string for MOVE
0000251E  103C 000E               2743          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002522                          2744                                ;string without CR, LF
00002522  4E4F                    2745          TRAP    #15
00002524                          2746  
00002524  6100 FF7A               2747          BSR moveSize
00002528                          2748          
00002528                          2749          ;Do EA
00002528                          2750          
00002528  3401                    2751          MOVE.W  D1,D2                   ;check mode
0000252A  C43C 003F               2752          AND.B   #%00111111,D2
0000252E  1A02                    2753          MOVE.B  D2,D5
00002530  48E7 4000               2754          MOVEM.L D1,-(SP)
00002534  6100 02F4               2755          BSR     Get_Effective_Address
00002538  4CDF 0002               2756          MOVEM.L (SP)+,D1
0000253C                          2757          
0000253C                          2758          
0000253C                          2759          ;print ','
0000253C  48E7 4000               2760          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002540  123C 002C               2761          MOVE.B #',',D1                  ;put ascii value of char in D1
00002544  103C 0006               2762          MOVE.B #6,D0                    ;move task 6 into D0
00002548  4E4F                    2763          TRAP #15                        ;prin char
0000254A  4CDF 0002               2764          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000254E                          2765          
0000254E                          2766          
0000254E                          2767          ;Then do An
0000254E                          2768          
0000254E  3401                    2769          MOVE.W  D1,D2
00002550  E04A                    2770          LSR.W   #8,D2                   ;move reg into first byte
00002552  E20A                    2771          LSR.B   #1,D2                   ;line it up to least sig bit
00002554  C43C 0007               2772          AND.B   #%00000111,D2           ;force mode to An
00002558  5002                    2773          ADDQ.B  #8,D2
0000255A  1A02                    2774          MOVE.B  D2,D5
0000255C  48E7 4000               2775          MOVEM.L D1,-(SP)
00002560  6100 02C8               2776          BSR     Get_Effective_Address
00002564  4CDF 0002               2777          MOVEM.L (SP)+,D1
00002568                          2778          
00002568  43F9 00002CFE           2779          LEA     clearLine,A1            ;move string for a CR and LF
0000256E  103C 000E               2780          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002572                          2781                                ;string without CR, LF
00002572  4E4F                    2782          TRAP    #15
00002574                          2783  
00002574  7000                    2784          MOVEQ.L #0,D0
00002576  4E75                    2785          RTS
00002578                          2786  
00002578                          2787             
00002578                          2788  Bcc:
00002578                          2789          
00002578  48E7 4000               2790          MOVEM.L D1,-(SP)
0000257C  43F9 00002D73           2791          LEA     bccMessage,A1           ;move string for BRA info
00002582  103C 000E               2792          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002586                          2793                                ;string without CR, LF
00002586  4E4F                    2794          TRAP    #15
00002588                          2795          
00002588  7000                    2796          MOVEQ.L #0,D0                   ;clear D0
0000258A  3401                    2797          MOVE.W  D1,D2                   ;move instruction into D2 for manipulaiton
0000258C  E04A                    2798          LSR.W   #8,D2
0000258E  C47C 000F               2799          AND.W   #$0F,D2                 ;mask instruction
00002592                          2800          
00002592                          2801  checkCC:        
00002592  41F9 00002C85           2802          LEA     bccList,A0              ;get condition code signature list in A0
00002598  D1C0                    2803          ADDA.L  D0,A0                   ;get correct sig         
0000259A  B410                    2804          CMP.B   (A0),D2                 ;compare to sig
0000259C  6700 0006               2805          BEQ     foundCC                 ;if sig matches branch
000025A0  5200                    2806          ADDQ.B  #byte,D0
000025A2  60EE                    2807          BRA     checkCC
000025A4                          2808  foundCC:
000025A4  43F9 00002C96           2809          LEA     conditionCodeMessage,A1 ;get condition code message in A1
000025AA  C0FC 0004               2810          MULU.W  #long,D0                ;adjust size of D0 for a long
000025AE  D3C0                    2811          ADDA.L  D0,A1                   ;get correct message location
000025B0  2251                    2812          MOVEA.L (A1),A1                 ;get correct message
000025B2                          2813          
000025B2  103C 000E               2814          MOVE.B  #14,D0                  ;set for task to display null terminated 
000025B6                          2815                                ;string without CR, LF
000025B6  4E4F                    2816          TRAP    #15
000025B8                          2817  
000025B8                          2818          
000025B8                          2819          
000025B8  548B                    2820          ADDQ.L  #word,A3                ;move past instruction in case long displacement
000025BA  C27C 00FF               2821          AND.W   #$00FF,D1               ;check for word sized displacement
000025BE                          2822          
000025BE  B23C 0000               2823          CMP.B   #$0,D1
000025C2  6700 0028               2824          BEQ     BccWord
000025C6                          2825          
000025C6  B23C 00FF               2826          CMP.B   #$FF,D1 check for long sized displacement
000025CA  6700 002A               2827          BEQ     BccLong
000025CE                          2828          
000025CE                          2829  BccByte:
000025CE                          2830          
000025CE  1201                    2831          MOVE.B D1,D1                    ;lazy check if negative
000025D0                          2832          
000025D0  6B00 000E               2833          BMI signExtendByte
000025D4                          2834          
000025D4  C2BC 000000FF           2835          AND.L #$000000FF,D1             ;mask out rest of reg just in case
000025DA                          2836          
000025DA  7E00                    2837          MOVEQ.L #0,D7                   ;pass back no extra data followed
000025DC  6000 0020               2838          BRA     BccDone
000025E0                          2839          
000025E0                          2840  signExtendByte:        
000025E0                          2841          
000025E0  82BC FFFFFF00           2842          OR.L #$FFFFFF00,D1              ;extend to long by set all bits not part of the
000025E6                          2843                             ;least significant byte
000025E6                          2844          
000025E6  7E00                    2845          MOVEQ.L #0,D7                   ;pass back no extra data followed
000025E8  6000 0014               2846          BRA     BccDone
000025EC                          2847  
000025EC                          2848  BccWord:
000025EC  3253                    2849          MOVEA.W  (A3),A1                ;sign extend word
000025EE  2209                    2850          MOVE.L   A1,D1
000025F0  7E02                    2851          MOVEQ.L #word,D7                ;pass back an extra word followed
000025F2  6000 000A               2852          BRA     BccDone
000025F6                          2853  BccLong:
000025F6  2213                    2854          MOVE.L  (A3),D1 
000025F8  7E04                    2855          MOVEQ.L #long,D7                ;pass back an extra long followed
000025FA  6000 0002               2856          BRA     BccDone
000025FE                          2857  BccDone:
000025FE                          2858  
000025FE  303C 0003               2859          MOVE.W  #3,D0                   ;put task #15 in D0
00002602  4E4F                    2860          TRAP    #15
00002604                          2861          
00002604  43F9 00002CFE           2862          LEA     clearLine,A1            ;move string for a CR and LF
0000260A  103C 000E               2863          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000260E                          2864                                ;string without CR, LF
0000260E  4E4F                    2865          TRAP    #15
00002610                          2866          
00002610  4CDF 0002               2867          MOVEM.L (SP)+,D1
00002614  7000                    2868          MOVEQ.L #0,D0
00002616  4E75                    2869          RTS
00002618                          2870          
00002618                          2871          
00002618                          2872  unknownOpCode:
00002618  43F9 00002D79           2873          LEA     dataMessage,A1          ;move string for data info
0000261E  103C 000E               2874          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002622                          2875                                ;string without CR, LF
00002622  4E4F                    2876          TRAP    #15
00002624                          2877          
00002624                          2878          ;print word in D1
00002624  48E7 1200               2879          MOVEM.L D6/D3,-(SP)
00002628  1C3C 0001               2880          MOVE.B #1,D6                    ;put size of word in D6
0000262C  2601                    2881          MOVE.L D1,D3                    ;move data at D1 to D3
0000262E  6100 041E               2882          BSR outputHex
00002632  4CDF 0048               2883          MOVEM.L (SP)+,D6/D3
00002636                          2884          
00002636  43F9 00002CFE           2885          LEA     clearLine,A1            ;move string for a CR and LF
0000263C  103C 000E               2886          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002640                          2887                                ;string without CR, LF
00002640  4E4F                    2888          TRAP    #15
00002642                          2889          
00002642  7000                    2890          MOVEQ.L #0,D0
00002644  4E75                    2891          RTS
00002646                          2892          
00002646                          2893  handlebytedata:
00002646                          2894  
00002646  43F9 00002D79           2895          LEA     dataMessage,A1          ;move string for data info
0000264C  103C 000E               2896          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002650                          2897                                ;string without CR, LF
00002650  4E4F                    2898          TRAP    #15
00002652                          2899          
00002652  1213                    2900          MOVE.B (A3),D1                  ;copy word from other prog to analyze as instruction
00002654                          2901          
00002654  E049                    2902          LSR.W   #8,D1                   ;shift the word read into D1 by a byte
00002656                          2903          
00002656  48E7 1200               2904          MOVEM.L D6/D3,-(SP)
0000265A  1C3C 0000               2905          MOVE.B #0,D6                    ;put size of byte in D6
0000265E  1601                    2906          MOVE.B D1,D3                    ;move data at D1 to D3
00002660  6100 03EC               2907          BSR outputHex
00002664  4CDF 0048               2908          MOVEM.L (SP)+,D6/D3
00002668                          2909          
00002668  43F9 00002CFE           2910          LEA     clearLine,A1            ;move string for a CR and LF
0000266E  103C 000E               2911          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002672                          2912                                ;string without CR, LF
00002672  4E4F                    2913          TRAP    #15
00002674                          2914          
00002674  4C9F 0004               2915          MOVEM.W (SP)+,D2                ;restore D2 for next iteration in main loop
00002678  7000                    2916          MOVEQ.L #0,D0
0000267A                          2917          
0000267A  528B                    2918          ADDQ.L  #byte,A3
0000267C  6000 E99C               2919          BRA main_Loop
00002680                          2920  
00002680                          2921          
00002680                          2922          
00002680                          2923  fin:
00002680  43F9 00002E40           2924          LEA     thankyouMessage,A1      ;move string for MOVE
00002686  103C 000E               2925          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000268A                          2926                                ;string without CR, LF
0000268A  4E4F                    2927          TRAP    #15
0000268C                          2928          
0000268C                          2929          
0000268C  FFFF FFFF               2930          simhalt
00002690                          2931          
00002690                          2932  
00002690                          2933  *******************************************************************************
00002690                          2934  *                            SUB ROUTINES
00002690                          2935  *******************************************************************************
00002690                          2936  
00002690                          2937  *******************************************************************************
00002690                          2938  *                          IO ROLE ROUTINES
00002690                          2939  *******************************************************************************
00002690                          2940  
00002690                          2941  *==========================================================================
00002690                          2942  *                   Enter / Validate beginning address 
00002690                          2943  *==========================================================================
00002690                          2944   
00002690                          2945  begin_address:
00002690                          2946  
00002690                          2947         
00002690  43F9 00002B0E           2948          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00002696  2239 00002B0E           2949          MOVE.L      slPrompt,D1         ;Load display length to D1
0000269C  700E                    2950          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
0000269E  4E4F                    2951          TRAP        #15                 ;Perform task 14 (display)
000026A0                          2952          
000026A0  43F9 00002E5E           2953          LEA         startLocation,A1    ;Load address to store user input
000026A6  103C 0002               2954          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
000026AA  4E4F                    2955          TRAP        #15                 ;Perform task 2 (input)
000026AC                          2956          
000026AC                          2957          ;CMP.B       #27,(A1)            ;Check for ESC entered
000026AC                          2958          ;BEQ         address_Exit        ;Exit condition
000026AC  0C01 0071               2959          CMPI.B #'q',D1
000026B0  6700 0062               2960          BEQ address_Exit
000026B4  0C01 0051               2961          CMPI.B #'Q',D1
000026B8  6700 005A               2962          BEQ address_Exit 
000026BC                          2963          
000026BC  6100 005E               2964          BSR         enter_addr_edit_all
000026C0  B67C FFFF               2965          CMP.W       #-1,D3              ;Did the edit pass?
000026C4  67CA                    2966          BEQ         begin_address       ;No, loop and ask for correct input
000026C6                          2967          
000026C6  2643                    2968          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
000026C8                          2969          
000026C8  43F9 00002C43           2970          LEA         spc,A1              ;Load address for starting loaction prompt
000026CE  1239 00002C44           2971          MOVE.B      spc_len,D1          ;Load empty line length
000026D4  7000                    2972          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
000026D6  4E4F                    2973          TRAP        #15                 ;Perform task 14 (display)
000026D8  6000 0002               2974          BRA         end_address
000026DC                          2975  
000026DC                          2976  *===========================================================================
000026DC                          2977  *                   Enter / Validate ending address 
000026DC                          2978  *===========================================================================
000026DC                          2979  
000026DC                          2980  end_address:
000026DC                          2981          
000026DC  43F9 00002B53           2982          LEA         elPrompt,A1         ;Load address for ending loaction prompt
000026E2                          2983          ;MOVE.L     elPrompt,D1         ;Load display length to D1
000026E2  7250                    2984          MOVE.L      #80,D1              ;did not like previous command, do not know why, it should have worked
000026E4  700E                    2985          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
000026E6  4E4F                    2986          TRAP        #15                 ;Perform task 14 (display)
000026E8                          2987          
000026E8  43F9 00002E62           2988          LEA         endLocation,A1      ;Load address to store user input
000026EE  103C 0002               2989          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
000026F2  4E4F                    2990          TRAP        #15                 ;Perform task 2 (input)
000026F4                          2991          
000026F4                          2992          ;CMP.B       #27,(A1)            ;Check for ESC entered
000026F4                          2993          ;BEQ         address_Exit        ;Exit condition 
000026F4  0C01 0071               2994          CMPI.B #'q',D1
000026F8  6700 001A               2995          BEQ address_Exit
000026FC  0C01 0051               2996          CMPI.B #'Q',D1
00002700  6700 0012               2997          BEQ address_Exit
00002704                          2998          
00002704  6100 0016               2999          BSR         enter_addr_edit_all
00002708  B67C FFFF               3000          CMP.W       #-1,D3              ;Did the edit pass?
0000270C  67CE                    3001          BEQ         end_address         ;No, loop and ask for correct input
0000270E                          3002  
0000270E  2843                    3003          MOVEA.L     D3,A4               ;Ending address gets stored in A4
00002710  6000 0008               3004          BRA         address_done
00002714                          3005  
00002714                          3006  address_Exit:
00002714                          3007  
00002714  76FF                    3008          MOVE.L      #-1,D3              ;Load -1 into return parameter
00002716  6000 0002               3009          BRA         address_done
0000271A                          3010          
0000271A                          3011  address_done:
0000271A                          3012  
0000271A  4E75                    3013          RTS    
0000271C                          3014  
0000271C                          3015  *==============================================================================
0000271C                          3016  * enter_addr_edit_all - Enter address edit check to edit all errors  
0000271C                          3017  *                       using multiple different error checking routines.
0000271C                          3018  *
0000271C                          3019  * Parameters -
0000271C                          3020  *   Input   A1      The data that needs checked.
0000271C                          3021  *   Input   D1      The number of characters input     
0000271C                          3022  *   Output  D3      Returns '-1' when there is an error.
0000271C                          3023  *==============================================================================
0000271C                          3024  
0000271C                          3025  enter_addr_edit_all
0000271C                          3026  
0000271C                          3027  *------------------------------------------------------------------------------
0000271C                          3028  * Test for odd number of characters entered, not allowed
0000271C                          3029  *------------------------------------------------------------------------------
0000271C                          3030         
0000271C  6100 0024               3031          BSR         ck_boundry          ;check if the input is on a odd / even boundry
00002720  B67C FFFF               3032          CMP.W       #-1,D3              ;Is the address odd?
00002724  6700 001A               3033          BEQ         enter_addr_edit_all_exit     ;No, return
00002728                          3034  
00002728                          3035  *------------------------------------------------------------------------------
00002728                          3036  * Ttest for character entered all being valid address characters
00002728                          3037  * Note: lower case a-f, gets converted to upper case A-F in D3
00002728                          3038  *------------------------------------------------------------------------------
00002728                          3039          
00002728  6100 0062               3040          BSR         parseHexString      ;check if the input contains valid Hex characters
0000272C  B67C FFFF               3041          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
00002730  6700 000E               3042          BEQ         enter_addr_edit_all_exit     ;No, return
00002734                          3043  
00002734                          3044  *------------------------------------------------------------------------------
00002734                          3045  * Verify that the address entered is witin the range defined in the Equate
00002734                          3046  *------------------------------------------------------------------------------        
00002734                          3047          
00002734  6100 00C8               3048          BSR         ck_addr_range       ;is address entered witin the range 
00002738                          3049                                          ;   as defined in the Equate? 
00002738  B67C FFFF               3050          CMP.W       #-1,D3              ;is the address  valid?
0000273C  6700 0002               3051          BEQ         enter_addr_edit_all_exit     ;No, return
00002740                          3052  
00002740                          3053  enter_addr_edit_all_exit:
00002740                          3054  
00002740  4E75                    3055          RTS                             ;return
00002742                          3056  
00002742                          3057  *==============================================================================
00002742                          3058  * ck_boundry - Check the size of the data characters input and determine
00002742                          3059  *              if an odd number of characters was entered
00002742                          3060  *
00002742                          3061  * Parameters -
00002742                          3062  *   Input   A1      The data that needs checked for odd length.
00002742                          3063  *   Input   D1      The number of characters input     
00002742                          3064  *   Output  D3      Returns '-1' when there is an odd length.
00002742                          3065  *==============================================================================
00002742                          3066  
00002742                          3067  ck_boundry:
00002742                          3068  
00002742  4243                    3069          CLR.W       D3                  ;Clear the return
00002744                          3070  
00002744  B23C 0000               3071          CMP.B       #0,D1               ;Check for nothing entered
00002748  6700 002E               3072          BEQ         ck_size_error       ;Number of characters entered must be 
0000274C                          3073                                          ;greater than 0  
0000274C                          3074          
0000274C                          3075          
0000274C                          3076          * The program will branch to ck_size_error if D1 is greater than #8        
0000274C  B23C 0008               3077          CMP.B       #8,D1               ;Check for more than 8 characters entered
00002750  6E00 0026               3078          BGT         ck_size_error       ;Number of characters entered must be less
00002754                          3079                                          ;than 9
00002754                          3080          
00002754  7402                    3081          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
00002756  82C2                    3082          DIVU        D2,D1               ;Divide address by 2
00002758  4841                    3083          SWAP        D1                  ;get remainder
0000275A  B23C 0001               3084          CMP.B       #$01,D1             ;Check for remainder of 1
0000275E  6700 0004               3085          BEQ         ck_boundry_error    ;Number of characters entered must be an 
00002762                          3086                                          ;even number   
00002762                          3087    
00002762  4E75                    3088          RTS                             ;return
00002764                          3089  
00002764                          3090  *------------------------------------------------------------------------------
00002764                          3091  * ck_boundry_error - An odd number of characters was entered
00002764                          3092  *                  - Load error message and display it
00002764                          3093  *                  - Return error condition
00002764                          3094  *------------------------------------------------------------------------------
00002764                          3095          
00002764                          3096  ck_boundry_error:
00002764                          3097  
00002764  43F9 00002C23           3098          LEA         even_msg,A1         ;Load odd error message into A1
0000276A  2239 00002C23           3099          MOVE.L      even_msg,D1         ;Load error length to D1
00002770                          3100          
00002770  7000                    3101          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00002772                          3102                                          ; n is D1.W with CR, LF. 
00002772  4E4F                    3103          TRAP #15                        ;Display the error message
00002774  76FF                    3104          MOVE.L #-1,D3                   ;Load -1 into return parameter
00002776  4E75                    3105          RTS                             ;Return
00002778                          3106          
00002778                          3107  *------------------------------------------------------------------------------
00002778                          3108  * ck_size_error -   The number of characters entered must be more than zero
00002778                          3109  *                  - Load error message and display it
00002778                          3110  *                  - Return error condition
00002778                          3111  *------------------------------------------------------------------------------
00002778                          3112          
00002778                          3113  ck_size_error:
00002778                          3114  
00002778  43F9 00002B96           3115          LEA         invalidMsg,A1       ;Load invalid range message into A1
0000277E  2239 00002B96           3116          MOVE.L      invalidMsg,D1       ;Load error length to D1
00002784                          3117          
00002784  7000                    3118          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00002786                          3119                                          ; n is D1.W with CR, LF. 
00002786  4E4F                    3120          TRAP        #15                 ;Display the error message
00002788  76FF                    3121          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000278A  4E75                    3122          RTS                             ;Return        
0000278C                          3123  
0000278C                          3124  
0000278C                          3125  *==============================================================================
0000278C                          3126  * parseHexString - Converts user input string into a valid memory address
0000278C                          3127  *                - Stores parsed address data into D3
0000278C                          3128  *                - Stores good/bad (1/0) data in D4 
0000278C                          3129  *
0000278C                          3130  * Hex values are stored as bytes in D2, the ASCII chart shows their value
0000278C                          3131  *   The ASCII chart values we care about are in the ranges of: 
0000278C                          3132  *                            Hex            Decimal
0000278C                          3133  *       No Value           NULL = 0         0
0000278C                          3134  *       Numeric Values:     0-9 = 30-39     48-57
0000278C                          3135  *       Upper Case letters: A-F = 41-46     65-70
0000278C                          3136  *       Lower Case letterc: a-f = 61-66     97-102
0000278C                          3137  
0000278C                          3138  * Parameters -
0000278C                          3139  *   Input   A1      The data that needs checked for valid input.
0000278C                          3140  *   Output  D3      The return value, '-1' for error
0000278C                          3141  *==============================================================================
0000278C                          3142  
0000278C                          3143  parseHexString:
0000278C                          3144  
0000278C                          3145  * setup any initializing item that do not get looped through
0000278C  4243                    3146          CLR.W       D3                  ;Clear the return
0000278E                          3147  
0000278E                          3148          
0000278E                          3149  *------------------------------------------------------------------------------
0000278E                          3150  * NextHex - Loop through all bytes and vaildate the input
0000278E                          3151  * Parameters -
0000278E                          3152  *   Input   A1      The data that needs checked for valid input.
0000278E                          3153  *   Output  D3      The return value, '-1' for error
0000278E                          3154  *------------------------------------------------------------------------------
0000278E                          3155          
0000278E                          3156  NextHex:
0000278E                          3157  
0000278E  1419                    3158          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00002790  B43C 0000               3159          CMP.B       #0,D2               ;Check character for null 
00002794  6700 0066               3160          BEQ         NextHexReturn       ;Character is null (end of input)
00002798                          3161          
00002798                          3162  *................................................................................
00002798                          3163  *  Check decimal values 0-9 by testing hexadecimal values 30-39
00002798                          3164  *................................................................................
00002798                          3165                  
00002798                          3166          * The program will branch to hex_range_error if D2 is less than #30
00002798  B43C 0030               3167          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
0000279C  6D00 0048               3168          BLT         hex_range_error     ;Branch to handle range error hexidecimal
000027A0                          3169                                          ;processing
000027A0                          3170          
000027A0                          3171          * The program will branch to UcaseHex if D2 is greater than #39
000027A0  B43C 0039               3172          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
000027A4  6E00 000A               3173          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
000027A8                          3174          
000027A8                          3175          *a valid number was found within this range
000027A8  0402 0030               3176          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
000027AC  6000 0032               3177          BRA         NextHexDone         ;Done parsing this byte
000027B0                          3178  
000027B0                          3179  
000027B0                          3180  *..............................................................................
000027B0                          3181  *  Check upper case values A-F by testing hexadecimal values 41-46
000027B0                          3182  *..............................................................................
000027B0                          3183  
000027B0                          3184  UcaseHex:
000027B0                          3185  
000027B0                          3186          * The program will branch to hex_range_error if D2 is less than #41
000027B0  B43C 0041               3187          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
000027B4  6D00 0030               3188          BLT         hex_range_error     ;Branch to handle range error hexidecimal
000027B8                          3189                                          ;processing
000027B8                          3190          
000027B8  B43C 0046               3191          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
000027BC  6E00 000A               3192          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
000027C0                          3193                                          ;processing
000027C0                          3194          
000027C0                          3195          *a valid number was found within this range
000027C0  0402 0037               3196          SUBI.B      #55,D2              ;Change uppercase character to actual value
000027C4  6000 001A               3197          BRA         NextHexDone         ;Done parsing this byte
000027C8                          3198  
000027C8                          3199  
000027C8                          3200  *..............................................................................
000027C8                          3201  *  Check lower case values a-f by testing hexadecimal values 61-66
000027C8                          3202  *..............................................................................
000027C8                          3203  
000027C8                          3204  LcaseHex
000027C8                          3205          
000027C8                          3206          * The program will branch to hex_range_error if D2 is less than #61
000027C8  B43C 0061               3207          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
000027CC  6D00 0018               3208          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
000027D0                          3209                                          ;processing
000027D0                          3210  
000027D0  B43C 0066               3211          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
000027D4  6E00 0010               3212          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
000027D8                          3213                                          ;processing
000027D8                          3214  
000027D8                          3215          *a valid number was found within this range
000027D8  0402 0057               3216          SUBI.B      #87,D2              ;Change lowercase character to actual value
000027DC  6000 0002               3217          BRA         NextHexDone         ;Done parsing this byte
000027E0                          3218  
000027E0                          3219  NextHexDone:
000027E0                          3220  
000027E0  E983                    3221          ASL.L       #4,D3               ; Make rooom for new byte in the return register
000027E2  D602                    3222          ADD.B       D2,D3               ; Move the new byte into the return register
000027E4  60A8                    3223          BRA         NextHex             ; We're ready to parse the next byte
000027E6                          3224          
000027E6                          3225  *-------------------------------------------------------------------------------------
000027E6                          3226  * hex_range_error -  A character entered was within the valid range for a hex address
000027E6                          3227  *                 -  Load error message and display it
000027E6                          3228  *                 -  Return error condition
000027E6                          3229  *-------------------------------------------------------------------------------------
000027E6                          3230          
000027E6                          3231  hex_range_error:
000027E6                          3232  
000027E6  43F9 00002BDB           3233          LEA         invCharMsg,A1       ;Load invalid range message into A1
000027EC  2239 00002BDB           3234          MOVE.L      invCharMsg,D1       ;Load error length to D1
000027F2                          3235          
000027F2  7000                    3236          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
000027F4                          3237                                          ; n is D1.W with CR, LF. 
000027F4  4E4F                    3238          TRAP        #15                 ;Display the error message
000027F6  76FF                    3239          MOVE.L      #-1,D3              ;Load -1 into return parameter
000027F8  6000 0002               3240          BRA         NextHexReturn
000027FC                          3241          
000027FC                          3242  NextHexReturn:
000027FC                          3243          
000027FC  4E75                    3244          RTS                             ;Return      
000027FE                          3245  
000027FE                          3246  
000027FE                          3247  *===============================================================================
000027FE                          3248  * ck_addr_range - check the address input is within a valid memory address range
000027FE                          3249  *                - Parsed address data into D3
000027FE                          3250  *
000027FE                          3251  * Parameters -
000027FE                          3252  *   Input   A1      The data that needs checked for valid address.
000027FE                          3253  *   Output  D3      The return value, '-1' for error
000027FE                          3254  *===============================================================================
000027FE                          3255  
000027FE                          3256  
000027FE                          3257  ck_addr_range:   
000027FE                          3258  
000027FE                          3259  *------------------------------------------------------------------------------
000027FE                          3260  * Verify that the address entered is witin the 
000027FE                          3261  * beginning range ('begin') as defined in the Equate
000027FE                          3262  *------------------------------------------------------------------------------   
000027FE                          3263              
000027FE  7C00                    3264          MOVE.L      #begin,D6           * Load minimum starting address
00002800  B686                    3265          CMP.L       D6,D3               * Is input at or above minimum?
00002802  6D00 0012               3266          BLT         ck_addr_range_error 
00002806                          3267          
00002806                          3268  *------------------------------------------------------------------------------
00002806                          3269  * Verify that the address entered is witin the 
00002806                          3270  * ending range ('end') as defined in the Equate
00002806                          3271  *------------------------------------------------------------------------------
00002806                          3272          
00002806  2C3C 00FFFFFE           3273          MOVE.L      #end,D6             * Load maximum starting address
0000280C  B686                    3274          CMP.L       D6,D3               * Is input at or below maximum?
0000280E  6E00 0006               3275          BGT         ck_addr_range_error 
00002812  6000 0012               3276          BRA         ck_addr_done        ;done checking
00002816                          3277          
00002816                          3278  *..............................................................................
00002816                          3279  * ck_addr_range_error -  A address entered is not within the 
00002816                          3280  *                        valid range for a hex address
00002816                          3281  *..............................................................................
00002816                          3282          
00002816                          3283  ck_addr_range_error
00002816                          3284  
00002816  43F9 00002B96           3285          LEA         invalidMsg,A1       ;Load invalid range message into A1
0000281C                          3286          
0000281C  700D                    3287          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
0000281E                          3288                                          ;with CR, LF. 
0000281E  4E4F                    3289          TRAP        #15                 ;Display the error message
00002820  76FF                    3290          MOVE.L      #-1,D3              ;Load -1 into return parameter
00002822  6000 0002               3291          BRA         ck_addr_done 
00002826                          3292  
00002826                          3293  ck_addr_done:
00002826                          3294  
00002826  4E75                    3295          RTS                             ;Return
00002828                          3296  
00002828                          3297  *******************************************************************************
00002828                          3298  *                          OP CODE ROLE ROUTINES
00002828                          3299  *******************************************************************************
00002828                          3300  
00002828                          3301  process_op_codes:
00002828                          3302  
00002828                          3303  
00002828                          3304  
00002828                          3305  process_op_codes_exit:
00002828                          3306  
00002828  4E75                    3307          RTS
0000282A                          3308  
0000282A                          3309  
0000282A                          3310  *******************************************************************************
0000282A                          3311  *                    Effective Addressing ROLE ROUTINES
0000282A                          3312  *******************************************************************************
0000282A                          3313  
0000282A                          3314  Get_Effective_Address:
0000282A                          3315  
0000282A  48E7 0200               3316          MOVEM.L D6,-(SP)                ;save D6 data
0000282E  1C05                    3317          MOVE.B      D5,D6
00002830  E60E                    3318          LSR.B       #3,D6               ;mode
00002832  CA3C 0007               3319          And.B       #%00000111,D5       ;register
00002836                          3320          
00002836  BC3C 0000               3321          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
0000283A  6700 004A               3322          BEQ         Data_Reg_Direct
0000283E                          3323          
0000283E  BC3C 0001               3324          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
00002842  6700 005C               3325          BEQ         Addr_Reg_Direct
00002846                          3326          
00002846  BC3C 0002               3327          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
0000284A  6700 006E               3328          BEQ         Addr_Reg_Indirect
0000284E                          3329          
0000284E  BC3C 0003               3330          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
00002852  6700 0098               3331          BEQ         Addr_Reg_Indirect_Inc
00002856                          3332          
00002856  BC3C 0004               3333          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
0000285A  6700 00CE               3334          BEQ         Addr_Reg_Indirect_Dec
0000285E                          3335          
0000285E  BC3C 0007               3336          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
00002862  6700 0006               3337          BEQ         Get_Effective_Address_Other
00002866                          3338          
00002866  6000 015A               3339          BRA         invalidEA
0000286A                          3340          
0000286A                          3341  Get_Effective_Address_Other:        
0000286A                          3342          
0000286A  BA3C 0000               3343          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
0000286E  6700 00F8               3344          BEQ Addr_Abs_Short
00002872                          3345          
00002872  BA3C 0001               3346          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
00002876  6700 010A               3347          BEQ Addr_Abs_Long
0000287A                          3348          
0000287A  BA3C 0004               3349          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
0000287E  6700 011C               3350          BEQ Addr_Immediate_Data
00002882                          3351          
00002882  6000 013E               3352          BRA         invalidEA
00002886                          3353          
00002886                          3354  Data_Reg_Direct:                        ;case 0(0000)
00002886                          3355  
00002886  43F9 00002DA5           3356          LEA         letterD,A1          ;output 'D' for data register
0000288C  103C 000E               3357          MOVE.B      #14,D0              ;set for task to display null terminated 
00002890  4E4F                    3358          TRAP        #15                 ;string without CR, LF
00002892                          3359                          
00002892  4281                    3360          CLR.L       D1
00002894  1205                    3361          MOVE.B      D5,D1               ;move register number for display into D1
00002896  103C 0003               3362          MOVE.B      #3,D0               ;set for task to display null terminated 
0000289A  4E4F                    3363          TRAP        #15                 ;string without CR, LF
0000289C                          3364                 
0000289C  6000 0124               3365          BRA         Get_Effective_Address_Exit  ;return
000028A0                          3366          
000028A0                          3367          
000028A0                          3368  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
000028A0                          3369        
000028A0  43F9 00002DA3           3370          LEA         letterA,A1          ;output 'A' for address register
000028A6  103C 000E               3371          MOVE.B      #14,D0              ;set for task to display null terminated 
000028AA  4E4F                    3372          TRAP        #15                 ;string without CR, LF
000028AC                          3373          
000028AC  4281                    3374          CLR.L       D1
000028AE  1205                    3375          MOVE.B      D5,D1               ;move register number for display into D1
000028B0  103C 0003               3376          MOVE.B      #3,D0               ;set for task to display null terminated 
000028B4  4E4F                    3377          TRAP        #15                 ;string without CR, LF
000028B6                          3378          
000028B6  6000 010A               3379          BRA         Get_Effective_Address_Exit  ;return
000028BA                          3380  
000028BA                          3381  
000028BA                          3382  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
000028BA                          3383          
000028BA  43F9 00002DAB           3384          LEA         lprn,A1             ;output 'D' for data register
000028C0  103C 000E               3385          MOVE.B      #14,D0              ;set for task to display null terminated 
000028C4  4E4F                    3386          TRAP        #15                 ;string without CR, LF
000028C6                          3387  
000028C6  43F9 00002DA3           3388          LEA         letterA,A1          ;output 'A' for address register
000028CC  103C 000E               3389          MOVE.B      #14,D0              ;set for task to display null terminated 
000028D0  4E4F                    3390          TRAP        #15                 ;string without CR, LF
000028D2                          3391          
000028D2  4281                    3392          CLR.L       D1
000028D4  1205                    3393          MOVE.B      D5,D1               ;move register number for display into D1
000028D6  103C 0003               3394          MOVE.B      #3,D0               ;set for task to display null terminated 
000028DA  4E4F                    3395          TRAP        #15                 ;string without CR, LF
000028DC                          3396  
000028DC  43F9 00002DAD           3397          LEA         rprn,A1             ;output 'D' for data register
000028E2  103C 000E               3398          MOVE.B      #14,D0              ;set for task to display null terminated 
000028E6  4E4F                    3399          TRAP        #15                 ;string without CR, LF
000028E8                          3400          
000028E8  6000 00D8               3401          BRA         Get_Effective_Address_Exit  ;return
000028EC                          3402  
000028EC                          3403                 
000028EC                          3404  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
000028EC                          3405  
000028EC  43F9 00002DAB           3406          LEA         lprn,A1             ;output 'D' for data register
000028F2  103C 000E               3407          MOVE.B      #14,D0              ;set for task to display null terminated 
000028F6  4E4F                    3408          TRAP        #15                 ;string without CR, LF
000028F8                          3409  
000028F8  43F9 00002DA3           3410          LEA         letterA,A1          ;output 'A' for address register
000028FE  103C 000E               3411          MOVE.B      #14,D0              ;set for task to display null terminated 
00002902  4E4F                    3412          TRAP        #15                 ;string without CR, LF
00002904                          3413          
00002904  4281                    3414          CLR.L       D1
00002906  1205                    3415          MOVE.B      D5,D1               ;move register number for display into D1
00002908  103C 0003               3416          MOVE.B      #3,D0               ;set for task to display null terminated 
0000290C  4E4F                    3417          TRAP        #15                 ;string without CR, LF
0000290E                          3418  
0000290E  43F9 00002DAD           3419          LEA         rprn,A1             ;output 'D' for data register
00002914  103C 000E               3420          MOVE.B      #14,D0              ;set for task to display null terminated 
00002918  4E4F                    3421          TRAP        #15                 ;string without CR, LF
0000291A                          3422          
0000291A  43F9 00002DA7           3423          LEA         plus,A1             ;output 'D' for data register
00002920  103C 000E               3424          MOVE.B      #14,D0              ;set for task to display null terminated 
00002924  4E4F                    3425          TRAP        #15                 ;string without CR, LF
00002926                          3426          
00002926  6000 009A               3427          BRA         Get_Effective_Address_Exit  ;return
0000292A                          3428  
0000292A                          3429  Addr_Reg_Indirect_Dec                   ;4 = ?(An) - Address Register Indirect with Predecrement (100)
0000292A                          3430  
0000292A  43F9 00002DA9           3431          LEA         minus,A1            ;output '-' for Predecrement
00002930  103C 000E               3432          MOVE.B      #14,D0              ;set for task to display null terminated 
00002934  4E4F                    3433          TRAP        #15                 ;string without CR, LF
00002936                          3434  
00002936  43F9 00002DAB           3435          LEA         lprn,A1             ;output 'D' for data register
0000293C  103C 000E               3436          MOVE.B      #14,D0              ;set for task to display null terminated 
00002940  4E4F                    3437          TRAP        #15                 ;string without CR, LF
00002942                          3438  
00002942  43F9 00002DA3           3439          LEA         letterA,A1          ;output 'A' for address register
00002948  103C 000E               3440          MOVE.B      #14,D0              ;set for task to display null terminated 
0000294C  4E4F                    3441          TRAP        #15                 ;string without CR, LF
0000294E                          3442          
0000294E  4281                    3443          CLR.L       D1
00002950  1205                    3444          MOVE.B      D5,D1               ;move register number for display into D1
00002952  103C 0003               3445          MOVE.B      #3,D0               ;set for task to display null terminated 
00002956  4E4F                    3446          TRAP        #15                 ;string without CR, LF
00002958                          3447  
00002958  43F9 00002DAD           3448          LEA         rprn,A1             ;output 'D' for data register
0000295E  103C 000E               3449          MOVE.B      #14,D0              ;set for task to display null terminated 
00002962  4E4F                    3450          TRAP        #15                 ;string without CR, LF
00002964                          3451          
00002964  6000 005C               3452          BRA         Get_Effective_Address_Exit  ;return
00002968                          3453          
00002968                          3454                         
00002968                          3455  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00002968                          3456          
00002968                          3457          
00002968  548B                    3458          ADDA.L      #word,A3            ;move past instruction
0000296A                          3459          
0000296A                          3460          ;print word (A3)
0000296A  48E7 1200               3461          MOVEM.L D6/D3,-(SP)
0000296E  1C3C 0001               3462          MOVE.B #1,D6                    ;put size of word in D6
00002972  3613                    3463          MOVE.W (A3),D3                  ;move data at (A3) to D3
00002974  6100 00D8               3464          BSR outputHex
00002978  4CDF 0048               3465          MOVEM.L (SP)+,D6/D3
0000297C                          3466          
0000297C  5487                    3467          ADDI.L      #word,D7 
0000297E  6000 0042               3468          BRA         Get_Effective_Address_Exit  ;return
00002982                          3469                         
00002982                          3470  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
00002982                          3471          
00002982                          3472          ;LEA         xxxL,A1             ;output 'D' for data register
00002982                          3473          ;MOVE.B      #14,D0              ;set for task to display null terminated 
00002982                          3474          ;TRAP        #15                 ;string without CR, LF
00002982                          3475  
00002982  548B                    3476          ADDA.L      #word,A3
00002984                          3477          
00002984                          3478          ;print long (A3)
00002984  48E7 1200               3479          MOVEM.L D6/D3,-(SP)
00002988  1C3C 0002               3480          MOVE.B #2,D6                    ;put size of word in D6
0000298C  2613                    3481          MOVE.L (A3),D3                  ;move data at (A3) to D3
0000298E  6100 00BE               3482          BSR outputHex
00002992  4CDF 0048               3483          MOVEM.L (SP)+,D6/D3
00002996                          3484  
00002996                          3485          
00002996  5887                    3486          ADDI.L      #long,D7
00002998  6000 0028               3487          BRA         Get_Effective_Address_Exit  ;return
0000299C                          3488                         
0000299C                          3489  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
0000299C                          3490  
0000299C                          3491  *        LEA         iData,A1            ;output 'D' for data register
0000299C                          3492  *        MOVE.B      #14,D0              ;set for task to display null terminated 
0000299C                          3493  *        TRAP        #15                 ;string without CR, LF
0000299C                          3494          
0000299C  4CDF 0040               3495          MOVEM.L (SP)+,D6                 ;restore D6 data
000029A0  48E7 0200               3496          MOVEM.L D6,-(SP)                 ;save D6 data again to balance stack
000029A4                          3497  
000029A4                          3498          ;print '#'
000029A4  48E7 4000               3499          MOVEM.L D1,-(SP)                ;save D1 to the stack
000029A8  123C 0023               3500          MOVE.B #'#',D1                  ;put ascii value of char in D1
000029AC  103C 0006               3501          MOVE.B #6,D0                    ;move task 6 into D0
000029B0  4E4F                    3502          TRAP #15                        ;print char
000029B2  4CDF 0002               3503          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000029B6                          3504          
000029B6  0C06 0001               3505          CMPI.B #1,D6
000029BA  6FAC                    3506          BLE Addr_Abs_Short
000029BC  6EC4                    3507          BGT Addr_Abs_Long
000029BE                          3508          
000029BE  6000 0002               3509          BRA         Get_Effective_Address_Exit  ;return
000029C2                          3510  
000029C2                          3511  invalidEA:
000029C2                          3512  
000029C2                          3513          ;do something
000029C2                          3514   
000029C2                          3515  Get_Effective_Address_Exit:     
000029C2                          3516  
000029C2  4CDF 0040               3517          MOVEM.L (SP)+,D6                 ;restore D6 data
000029C6  4E75                    3518          RTS                             ;return
000029C8                          3519  
000029C8                          3520  ***assume size in D6. 00 = byte, 01 = word, 10 = long
000029C8                          3521  printSize:
000029C8  48E7 C000               3522          MOVEM.L D0/D1,-(SP)
000029CC                          3523          
000029CC                          3524          ;print '.'
000029CC  48E7 4000               3525          MOVEM.L D1,-(SP)                ;save D1 to the stack
000029D0  123C 002E               3526          MOVE.B #'.',D1                  ;put ascii value of char in D1
000029D4  103C 0006               3527          MOVE.B #6,D0                    ;move task 6 into D0
000029D8  4E4F                    3528          TRAP #15                        ;print char
000029DA  4CDF 0002               3529          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000029DE                          3530          
000029DE  0C06 0001               3531          CMPI.B #1,D6
000029E2  6D00 0022               3532          BLT printByteSize
000029E6  6700 0032               3533          BEQ printWordSize
000029EA  6E00 0042               3534          BGT printLongSize
000029EE                          3535  printSizeDone:
000029EE                          3536          ;print ' '
000029EE  48E7 4000               3537          MOVEM.L D1,-(SP)                ;save D1 to the stack
000029F2  123C 0020               3538          MOVE.B #' ',D1                  ;put ascii value of char in D1
000029F6  103C 0006               3539          MOVE.B #6,D0                    ;move task 6 into D0
000029FA  4E4F                    3540          TRAP #15                        ;print char
000029FC  4CDF 0002               3541          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002A00                          3542          
00002A00  4CDF 0003               3543          MOVEM.L (SP)+,D0/D1
00002A04  4E75                    3544          RTS
00002A06                          3545          
00002A06                          3546  printByteSize:
00002A06                          3547          ;print 'B'
00002A06  48E7 4000               3548          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002A0A  123C 0042               3549          MOVE.B #'B',D1                  ;put ascii value of char in D1
00002A0E  103C 0006               3550          MOVE.B #6,D0                    ;move task 6 into D0
00002A12  4E4F                    3551          TRAP #15                        ;print char
00002A14  4CDF 0002               3552          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002A18  60D4                    3553          BRA printSizeDone
00002A1A                          3554          
00002A1A                          3555  printWordSize:
00002A1A                          3556          ;print 'W'
00002A1A  48E7 4000               3557          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002A1E  123C 0057               3558          MOVE.B #'W',D1                  ;put ascii value of char in D1
00002A22  103C 0006               3559          MOVE.B #6,D0                    ;move task 6 into D0
00002A26  4E4F                    3560          TRAP #15                        ;print char
00002A28  4CDF 0002               3561          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002A2C  60C0                    3562          BRA printSizeDone
00002A2E                          3563  
00002A2E                          3564  printLongSize:
00002A2E                          3565          ;print 'L'
00002A2E  48E7 4000               3566          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002A32  123C 004C               3567          MOVE.B #'L',D1                  ;put ascii value of char in D1
00002A36  103C 0006               3568          MOVE.B #6,D0                    ;move task 6 into D0
00002A3A  4E4F                    3569          TRAP #15                        ;print char
00002A3C  4CDF 0002               3570          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002A40  60AC                    3571          BRA printSizeDone       
00002A42                          3572          
00002A42                          3573  
00002A42                          3574  ***assume hex to print is in D3***
00002A42                          3575  ***assume size in D6. 00 = byte, 01 = word, 10 = long
00002A42                          3576  
00002A42= 00000000 00000000 ...   3577  hexoutputbuffer DC.L 0,0,0
00002A4E                          3578  
00002A4E                          3579  outputHex:
00002A4E  48E7 B248               3580          MOVEM.L D0/D2/D3/D6/A1/A4,-(SP)
00002A52  49F8 2A42               3581          LEA hexoutputbuffer,A4
00002A56  0C06 0001               3582          CMPI.B #1,D6
00002A5A  6D00 006A               3583          BLT hexByte
00002A5E  6700 004C               3584          BEQ hexWord
00002A62  6E00 0016               3585          BGT hexLong
00002A66                          3586  outputHexDone:
00002A66  18BC 0000               3587          MOVE.B #0,(A4)
00002A6A                          3588          
00002A6A                          3589          ;output string of hex
00002A6A  103C 000E               3590          MOVE.B #14,D0
00002A6E  43F8 2A42               3591          LEA hexoutputbuffer,A1
00002A72  4E4F                    3592          TRAP #15
00002A74  4CDF 124D               3593          MOVEM.L (SP)+ ,D0/D2/D3/D6/A1/A4
00002A78  4E75                    3594          RTS
00002A7A                          3595          
00002A7A                          3596  hexLong:
00002A7A  E99B                    3597          ROL.L #4,D3
00002A7C  6100 0056               3598          BSR convertHexToASCII
00002A80  E99B                    3599          ROL.L #4,D3
00002A82  6100 0050               3600          BSR convertHexToASCII
00002A86  E99B                    3601          ROL.L #4,D3
00002A88  6100 004A               3602          BSR convertHexToASCII
00002A8C  E99B                    3603          ROL.L #4,D3
00002A8E  6100 0044               3604          BSR convertHexToASCII
00002A92  E99B                    3605          ROL.L #4,D3
00002A94  6100 003E               3606          BSR convertHexToASCII
00002A98  E99B                    3607          ROL.L #4,D3
00002A9A  6100 0038               3608          BSR convertHexToASCII
00002A9E  E99B                    3609          ROL.L #4,D3
00002AA0  6100 0032               3610          BSR convertHexToASCII
00002AA4  E99B                    3611          ROL.L #4,D3
00002AA6  6100 002C               3612          BSR convertHexToASCII
00002AAA                          3613          
00002AAA  60BA                    3614          BRA outputHexDone
00002AAC                          3615          
00002AAC                          3616  hexWord:
00002AAC  E95B                    3617          ROL.W #4,D3
00002AAE  6100 0024               3618          BSR convertHexToASCII
00002AB2  E95B                    3619          ROL.W #4,D3
00002AB4  6100 001E               3620          BSR convertHexToASCII
00002AB8  E95B                    3621          ROL.W #4,D3
00002ABA  6100 0018               3622          BSR convertHexToASCII
00002ABE  E95B                    3623          ROL.W #4,D3
00002AC0  6100 0012               3624          BSR convertHexToASCII
00002AC4                          3625  
00002AC4  60A0                    3626          BRA outputHexDone
00002AC6                          3627          
00002AC6                          3628  hexByte:
00002AC6  E91B                    3629          ROL.B #4,D3
00002AC8  6100 000A               3630          BSR convertHexToASCII
00002ACC  E91B                    3631          ROL.B #4,D3
00002ACE  6100 0004               3632          BSR convertHexToASCII
00002AD2                          3633          
00002AD2  6092                    3634          BRA outputHexDone
00002AD4                          3635          
00002AD4                          3636  convertHexToASCII:
00002AD4  1403                    3637          MOVE.B D3,D2
00002AD6  0202 000F               3638          ANDI.B #%00001111,D2            ;mask out all but hex at least significant nyb
00002ADA  0C02 0009               3639          CMPI.B #9,D2
00002ADE  6F00 0006               3640          BLE Number
00002AE2  6000 000A               3641          BRA Letter       
00002AE6                          3642  
00002AE6                          3643  Number:
00002AE6  0602 0030               3644          ADDI.B #'0',D2
00002AEA  18C2                    3645          MOVE.B D2,(A4)+
00002AEC  4E75                    3646          RTS
00002AEE                          3647          
00002AEE                          3648  Letter:
00002AEE  0402 000A               3649          SUBI.B #$A,D2
00002AF2  0602 0041               3650          ADDI.B #'A',D2
00002AF6  18C2                    3651          MOVE.B D2,(A4)+
00002AF8  4E75                    3652          RTS
00002AFA                          3653  
00002AFA                          3654  
00002AFA                          3655  
00002AFA                          3656  switchModeAndReg:
00002AFA                          3657  ***
00002AFA                          3658  * Assumed in D2
00002AFA                          3659  *
00002AFA                          3660  * Assumed that they are in least significant byte:
00002AFA                          3661  *
00002AFA                          3662  *            _this_
00002AFA                          3663  *           /      \
00002AFA                          3664  *  ........ ........
00002AFA                          3665  *  \                /
00002AFA                          3666  *   -----word-------
00002AFA                          3667  *
00002AFA                          3668  *  and that in that byte they are ordered:
00002AFA                          3669  *
00002AFA                          3670  *       ........   
00002AFA                          3671  *       \/\_/\_/
00002AFA                          3672  *      /  /    \
00002AFA                          3673  *    /   /      \
00002AFA                          3674  * dont  one    other
00002AFA                          3675  * care
00002AFA                          3676  *
00002AFA                          3677  * after they will be
00002AFA                          3678  *
00002AFA                          3679  *       ........   
00002AFA                          3680  *       \/\_/\_/
00002AFA                          3681  *      /  /    \
00002AFA                          3682  *    /   /      \
00002AFA                          3683  * dont other    one
00002AFA                          3684  * care
00002AFA                          3685  *** 
00002AFA  0202 003F               3686          AndI.B #%00111111,D2            ;remove unwanted bits from D2
00002AFE  0283 00000000           3687          ANDI.L #0,D3                    ;clear D3
00002B04  1602                    3688          MOVE.B D2,D3                    ;copy to D3
00002B06  E70B                    3689          LSL.B  #3,D3 
00002B08  E60A                    3690          LSR.B  #3,D2
00002B0A  D403                    3691          ADD.B  D3,D2
00002B0C  4E75                    3692          RTS
00002B0E                          3693  
00002B0E                          3694          
00002B0E                          3695  *==============================================================================
00002B0E                          3696  *                            variables and constants
00002B0E                          3697  *==============================================================================
00002B0E                          3698  
00002B0E                          3699  
00002B0E                          3700  ***initial user prompt stuff        
00002B0E= 45 6E 74 65 72 20 ...   3701  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE, "Q" or "q" to quit: $',0
00002B53= 45 6E 74 65 72 20 ...   3702  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE, "Q" or "q" to quit: $',0
00002B96                          3703  
00002B96= 20 41 64 64 72 65 ...   3704  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
00002BDB= 20 41 20 43 68 61 ...   3705  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
00002C23                          3706  
00002C23= 20 59 6F 75 20 6D ...   3707  even_msg        DC.B    ' You must enter an even address!'
00002C43                          3708  
00002C43= 20                      3709  spc             DC.B    ' '
00002C44= 01                      3710  spc_len         DC.B    spc_len-spc
00002C45                          3711  ***
00002C45                          3712  
00002C45                          3713  
00002C45                          3714  
00002C45                          3715  ***list of OP codes
00002C45                          3716  
00002C45  =00000040               3717  moveaInstruction EQU %0000000001000000
00002C45  =0000B000               3718  eorInstruction   EQU %1011000000000000
00002C45  =0000B000               3719  cmpInstruction   EQU %1011000000000000
00002C45  =00008000               3720  orInstruction    EQU %1000000000000000
00002C45  =00000880               3721  bclrdataInstruction EQU %0000100010000000
00002C45  =00000180               3722  bclrInstruction  EQU %0000000110000000
00002C45  =000041C0               3723  leaInstruction   EQU %0100000111000000
00002C45  =000081C0               3724  divsInstruction  EQU %1000000111000000
00002C45  =0000C1C0               3725  mulsInstruction  EQU %1100000111000000
00002C45  =0000E6C0               3726  rsrlweaInstruction  EQU %1110011011000000
00002C45  =0000E018               3727  rsrlregInstruction  EQU %1110000000011000
00002C45  =0000E0C0               3728  asrlweaInstruction  EQU %1110000011000000
00002C45  =0000E000               3729  asrlregInstruction  EQU %1110000000000000
00002C45  =0000E2C0               3730  lsrlweaInstruction  EQU %1110001011000000
00002C45  =0000E008               3731  lsrlregInstruction  EQU %1110000000001000
00002C45  =00005100               3732  subqInstruction  EQU %0101000100000000
00002C45  =00009000               3733  subInstruction   EQU %1001000000000000
00002C45  =0000D000               3734  addaInstruction  EQU %1101000000000000
00002C45  =0000D000               3735  addInstruction   EQU %1101000000000000
00002C45  =00004880               3736  movemInstruction EQU %0100100010000000
00002C45  =00000600               3737  addiInstruction  EQU %0000011000000000
00002C45  =00000000               3738  oriInstruction   EQU 0
00002C45  =00000C00               3739  cmpiInstruction  EQU %0000110000000000
00002C45  =00004E80               3740  jsrInstruction   EQU %0100111010000000
00002C45  =00004E75               3741  rtsInstruction   EQU %0100111001110101
00002C45  =00004E71               3742  NoOpInstruction  EQU %0100111001110001
00002C45  =00000000               3743  moveInstruction  EQU 0
00002C45  =00006000               3744  bccInstruction   EQU %0110000000000000
00002C45  =00004400               3745  negInstruction   EQU %0100010000000000
00002C45  =00000000               3746  dataInstruction  EQU 0
00002C45                          3747  
00002C45                          3748  ***
00002C45                          3749  
00002C45                          3750  ***list of OP masks
00002C45                          3751  
00002C45  =0000C1C0               3752  moveaMask EQU %1100000111000000
00002C45  =0000F000               3753  eorMask   EQU %1111000000000000
00002C45  =0000F000               3754  cmpMask   EQU %1111000000000000
00002C45  =0000F000               3755  orMask    EQU %1111000000000000
00002C45  =0000FFC0               3756  bclrdataMask EQU %1111111111000000
00002C45  =0000F1C0               3757  bclrMask  EQU %1111000111000000
00002C45  =0000F1C0               3758  leaMask   EQU %1111000111000000
00002C45  =0000F1C0               3759  divsMask  EQU %1111000111000000
00002C45  =0000F1C0               3760  mulsMask  EQU %1111000111000000
00002C45  =0000FEC0               3761  rsrlweaMask  EQU %1111111011000000
00002C45  =0000F018               3762  rsrlregMask  EQU %1111000000011000
00002C45  =0000FEC0               3763  asrlweaMask  EQU %1111111011000000
00002C45  =0000F018               3764  asrlregMask  EQU %1111000000011000
00002C45  =0000FEC0               3765  lsrlweaMask  EQU %1111111011000000
00002C45  =0000F018               3766  lsrlregMask  EQU %1111000000011000
00002C45  =0000F100               3767  subqMask  EQU %1111000100000000
00002C45  =0000F000               3768  subMask   EQU %1111000000000000
00002C45  =0000F000               3769  addaMask  EQU %1111000000000000
00002C45  =0000F000               3770  addMask   EQU %1111000000000000
00002C45  =0000FB80               3771  movemMask EQU %1111101110000000
00002C45  =0000FF00               3772  addiMask  EQU %1111111100000000
00002C45  =0000FF00               3773  oriMask   EQU %1111111100000000
00002C45  =0000FF00               3774  cmpiMask  EQU %1111111100000000
00002C45  =0000FFC0               3775  jsrMask   EQU %1111111111000000
00002C45  =0000FFFF               3776  rtsMask   EQU $FFFF
00002C45  =0000FFFF               3777  NoOpMask  EQU $FFFF
00002C45  =0000C000               3778  moveMask  EQU $C000
00002C45  =0000F000               3779  bccMask   EQU $F000
00002C45  =0000FF00               3780  negMask   EQU $FF00
00002C45  =00000000               3781  dataMask  EQU 0
00002C45                          3782  ***
00002C45                          3783  
00002C45                          3784  ***Bcc Codes***
00002C45  =00000004               3785  CC EQU $04
00002C45  =00000005               3786  CS EQU $05
00002C45  =00000007               3787  EQ EQU $07
00002C45  =0000000C               3788  GE EQU $0C
00002C45  =0000000E               3789  GT EQU $0E
00002C45  =00000002               3790  HI EQU $02
00002C45  =0000000F               3791  LE EQU $0F
00002C45  =00000003               3792  LS EQU $03
00002C45  =0000000D               3793  LT EQU $0D
00002C45  =0000000B               3794  MI EQU $0B
00002C45  =00000006               3795  NE EQU $06
00002C45  =0000000A               3796  PL EQU $0A
00002C45  =00000008               3797  VC EQU $08
00002C45  =00000009               3798  VS EQU $09
00002C45  =00000000               3799  RA EQU $00 ;not really a Condition Code
00002C45  =00000001               3800  SR EQU $01 ;not really a Condition Code
00002C45                          3801  
00002C45= 43 43 20 00             3802  CCm DC.B 'CC ',0
00002C49= 43 53 20 00             3803  CSm DC.B 'CS ',0
00002C4D= 45 51 20 00             3804  EQm DC.B 'EQ ',0
00002C51= 47 45 20 00             3805  GEm DC.B 'GE ',0
00002C55= 47 54 20 00             3806  GTm DC.B 'GT ',0
00002C59= 48 49 20 00             3807  HIm DC.B 'HI ',0
00002C5D= 4C 45 20 00             3808  LEm DC.B 'LE ',0
00002C61= 4C 53 20 00             3809  LSm DC.B 'LS ',0
00002C65= 4C 54 20 00             3810  LTm DC.B 'LT ',0
00002C69= 4D 49 20 00             3811  MIm DC.B 'MI ',0
00002C6D= 4E 45 20 00             3812  NEm DC.B 'NE ',0
00002C71= 50 4C 20 00             3813  PLm DC.B 'PL ',0
00002C75= 56 43 20 00             3814  VCm DC.B 'VC ',0
00002C79= 56 53 20 00             3815  VSm DC.B 'VS ',0
00002C7D= 52 41 20 00             3816  RAm DC.B 'RA ',0
00002C81= 53 52 20 00             3817  SRm DC.B 'SR ',0
00002C85                          3818  
00002C85= 01 04 05 07 0C 0E ...   3819  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
00002C96= 00002C81 00002C45 ...   3820  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
00002CD6                          3821  ***
00002CD6                          3822  
00002CD6= 45 6E 74 65 72 20 ...   3823  startLocationPrompt DC.B    'Enter start location',0
00002CEB= 45 6E 74 65 72 20 ...   3824  endLocationPrompt   DC.B    'Enter end location',0
00002CFE                          3825  
00002CFE= 0D 0A 00                3826  clearLine  DC.B $0D,$0A,0
00002D01                          3827  
00002D01= 45 4F 52 00             3828  eorMessage      DC.B 'EOR',0
00002D05= 43 4D 50 00             3829  cmpMessage      DC.B 'CMP',0
00002D09= 4F 52 00                3830  orMessage       DC.B 'OR',0
00002D0C= 42 43 4C 52 20 00       3831  bclrMessage     DC.B 'BCLR ',0
00002D12= 4C 45 41 20 00          3832  leaMessage      DC.B 'LEA ',0
00002D17= 44 49 56 53 00          3833  divsMessage     DC.B 'DIVS',0
00002D1C= 4D 55 4C 53 00          3834  mulsMessage     DC.B 'MULS',0
00002D21= 52 4F 4C 00             3835  rslMessage      DC.B 'ROL',0
00002D25= 52 4F 52 00             3836  rsrMessage      DC.B 'ROR',0
00002D29= 41 53 4C 00             3837  aslMessage      DC.B 'ASL',0
00002D2D= 41 53 52 00             3838  asrMessage      DC.B 'ASR',0
00002D31= 4C 53 4C 00             3839  lslMessage      DC.B 'LSL',0
00002D35= 4C 53 52 00             3840  lsrMessage      DC.B 'LSR',0
00002D39= 53 55 42 51 00          3841  subqMessage     DC.B 'SUBQ',0
00002D3E= 53 55 42 00             3842  subMessage      DC.B 'SUB',0 
00002D42= 41 44 44 41 00          3843  addaMessage     DC.B 'ADDA',0
00002D47= 41 44 44 00             3844  addMessage      DC.B 'ADD',0
00002D4B= 4D 4F 56 45 4D 00       3845  movemMessage    DC.B 'MOVEM',0
00002D51= 41 44 44 49 00          3846  addiMessage     DC.B 'ADDI',0
00002D56= 4F 52 49 00             3847  oriMessage      DC.B 'ORI',0
00002D5A= 43 4D 50 49 00          3848  cmpiMessage     DC.B 'CMPI',0
00002D5F= 4A 53 52 20 00          3849  jsrMessage      DC.B 'JSR ',0
00002D64= 52 54 53 20 00          3850  rtsMessage      DC.B 'RTS ',0
00002D69= 4E 4F 50 20 00          3851  nopMessage      DC.B 'NOP ',0 
00002D6E= 4D 4F 56 45 00          3852  moveMessage     DC.B 'MOVE',0
00002D73= 42 00                   3853  bccMessage      DC.B 'B',0
00002D75= 4E 45 47 00             3854  negMessage      DC.B 'NEG',0
00002D79= 44 41 54 41 20 00       3855  dataMessage     DC.B 'DATA ',0
00002D7F= 4D 4F 56 45 41 00       3856  moveaMessage    DC.B 'MOVEA',0
00002D85                          3857  
00002D85= 28 78 78 78 29 2E ...   3858  xxxW            DC.B '(xxx).W: ',0
00002D8F= 28 78 78 78 29 2E ...   3859  xxxL            DC.B '(xxx).L: ',0
00002D99= 23 28 64 61 74 61 ...   3860  iData           DC.B '#(data): ',0
00002DA3                          3861  
00002DA3= 41 00                   3862  letterA         DC.B 'A', 0
00002DA5= 44 00                   3863  letterD         DC.B 'D', 0
00002DA7                          3864  
00002DA7= 2B 00                   3865  plus            DC.B '+', 0
00002DA9= 2D 00                   3866  minus           DC.B '-', 0
00002DAB= 28 00                   3867  lPrn            DC.B '(', 0
00002DAD= 29 00                   3868  rPrn            DC.B ')', 0
00002DAF                          3869  
00002DAF                          3870  
00002DAF= 50 72 65 73 73 20 ...   3871  nextAddrPrompt  DC.B 'Press "Q" or "q" to quit or any other key to enter a new starting address: ',0
00002DFB= 50 72 65 73 73 20 ...   3872  continuePrompt  DC.B 'Press "S" or "s" to stop or any other key to display the next page: ',0
00002E40= 50 72 6F 67 72 61 ...   3873  thankyoumessage DC.B 'Program Complete. Thank You!',0
00002E5D                          3874  
00002E5E= 00000000                3875  startLocation       DC.L    0
00002E62= 00000000                3876  endLocation         DC.L    0
00002E66                          3877  
00002E66                          3878  
00002E66                          3879     
00002E66                          3880      END    START                        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 1D28
ADDA                1C62
ADDABODY            1CAA
ADDAINSTRUCTION     D000
ADDAMASK            F000
ADDAMESSAGE         2D42
ADDDEST             1DFC
ADDDESTEA           1D1C
ADDDESTEAMASKS      1D22
ADDI                2180
ADDIBODY            21AC
ADDIDONE            21FE
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         2D51
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          2D47
ADDPOSTREGDONE      205C
ADDPREREGDONE       20D8
ADDRESS_DONE        271A
ADDRESS_EXIT        2714
ADDR_ABS_LONG       2982
ADDR_ABS_SHORT      2968
ADDR_IMMEDIATE_DATA  299C
ADDR_REG_DIRECT     28A0
ADDR_REG_INDIRECT   28BA
ADDR_REG_INDIRECT_DEC  292A
ADDR_REG_INDIRECT_INC  28EC
ADDSOURCE           1D9E
ASLEA               187A
ASLMESSAGE          2D29
ASLREG              18C0
ASREA               186A
ASRLREG             188A
ASRLREGINSTRUCTION  E000
ASRLREGMASK         F018
ASRLWEA             182A
ASRLWEACHECKDIRECTION  1856
ASRLWEAINSTRUCTION  E0C0
ASRLWEAMASK         FEC0
ASRMESSAGE          2D2D
ASRREG              18B0
BCC                 2578
BCCBYTE             25CE
BCCDONE             25FE
BCCINSTRUCTION      6000
BCCLIST             2C85
BCCLONG             25F6
BCCMASK             F000
BCCMESSAGE          2D73
BCCWORD             25EC
BCLR                154E
BCLRBODY            157A
BCLRDATA            14B4
BCLRDATABODY        14E0
BCLRDATAINSTRUCTION  880
BCLRDATAMASK        FFC0
BCLRINSTRUCTION     180
BCLRMASK            F1C0
BCLRMESSAGE         2D0C
BEGIN               0
BEGIN_ADDRESS       2690
BYTE                1
CC                  4
CCM                 2C45
CHECKCC             2592
CHECKCONTINUE       11AE
CHECKMOVEDEST       2404
CHECKNEXTADDR       11E8
CHECKOPCODE         1078
CHECKPOSTREGADD     2056
CHECKPREREGADD      20D2
CK_ADDR_DONE        2826
CK_ADDR_RANGE       27FE
CK_ADDR_RANGE_ERROR  2816
CK_BOUNDRY          2742
CK_BOUNDRY_ERROR    2764
CK_SIZE_ERROR       2778
CLEARLINE           2CFE
CMP                 12D4
CMPBODY             1314
CMPI                22AE
CMPIBODY            22D6
CMPIDONE            232C
CMPIEA              22A0
CMPIEAMASKS         22A7
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         2D5A
CMPINSTRUCTION      B000
CMPMASK             F000
CMPMESSAGE          2D05
CONDITIONCODEMESSAGE  2C96
CONTINUEPROMPT      2DFB
CONVERTHEXTOASCII   2AD4
CS                  5
CSM                 2C49
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         2D79
DATA_REG_DIRECT     2886
DIVS                1660
DIVSBODY            168C
DIVSINSTRUCTION     81C0
DIVSMASK            F1C0
DIVSMESSAGE         2D17
ELPROMPT            2B53
END                 FFFFFE
ENDLOCATION         2E62
ENDLOCATIONPROMPT   2CEB
END_ADDRESS         26DC
ENTER_ADDR_EDIT_ALL  271C
ENTER_ADDR_EDIT_ALL_EXIT  2740
EOR                 1232
EORBODY             1276
EOREA               1224
EOREAMASKS          122B
EORINSTRUCTION      B000
EORMASK             F000
EORMESSAGE          2D01
EQ                  7
EQM                 2C4D
EVEN_MSG            2C23
FALSEPOSITIVE       1098
FARLABEL            FFE
FIN                 2680
FOUNDCC             25A4
GE                  C
GEM                 2C51
GET_EFFECTIVE_ADDRESS  282A
GET_EFFECTIVE_ADDRESS_EXIT  29C2
GET_EFFECTIVE_ADDRESS_OTHER  286A
GT                  E
GTM                 2C55
HANDLEBYTEDATA      2646
HEXBYTE             2AC6
HEXLONG             2A7A
HEXOUTPUTBUFFER     2A42
HEXWORD             2AAC
HEX_RANGE_ERROR     27E6
HI                  2
HIM                 2C59
IDATA               2D99
INSTLABELLIST       1136
INSTLABELLIST2      113E
INSTLABELLIST3      1172
INSTMASKLIST        10FA
INSTMASKLIST2       10FE
INSTMASKLIST3       1118
INSTOPLIST          10BE
INSTOPLIST2         10C2
INSTOPLIST3         10DC
INVALIDEA           29C2
INVALIDMSG          2B96
INVCHARMSG          2BDB
JSR                 2344
JSRBODY             236C
JSRDONE             238C
JSREA               233C
JSREAMASKS          2340
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          2D5F
LCASEHEX            27C8
LE                  F
LEA                 15DC
LEABODY             1604
LEAEA               15D4
LEAEAMASKS          15D8
LEAINSTRUCTION      41C0
LEAMASK             F1C0
LEAMESSAGE          2D12
LEM                 2C5D
LETTER              2AEE
LETTERA             2DA3
LETTERD             2DA5
LONG                4
LPRN                2DAB
LS                  3
LSLEA               1928
LSLMESSAGE          2D31
LSLREG              19A4
LSM                 2C61
LSREA               1918
LSRLCHECKI          1A10
LSRLCHECKIR         19FA
LSRLCHECKIRRETURN   1A0E
LSRLCHECKR          1A44
LSRLEA              18D0
LSRLEAMASKS         18D6
LSRLREG             196E
LSRLREGBODY         19B4
LSRLREGINSTRUCTION  E008
LSRLREGMASK         F018
LSRLWEA             18DC
LSRLWEABODY         1938
LSRLWEACHECKDIRECTION  1904
LSRLWEAINSTRUCTION  E2C0
LSRLWEAMASK         FEC0
LSRMESSAGE          2D35
LSRREG              1994
LT                  D
LTM                 2C65
MAIN_LOOP           101A
MATCH               109E
MI                  B
MIM                 2C69
MINUS               2DA9
MOVE                23DC
MOVEA               24DA
MOVEABODY           2502
MOVEADESTEA         24D6
MOVEADESTEAMASKS    24D8
MOVEAINSTRUCTION    40
MOVEAMASK           C1C0
MOVEAMESSAGE        2D7F
MOVEBODY            2432
MOVEDESTEA          23CE
MOVEDESTEAMASKS     23D5
MOVEINSTRUCTION     0
MOVEM               1E6E
MOVEMASK            C000
MOVEMESSAGE         2D6E
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     1E64
MOVEMMEMTOREGEAMASKS  1E69
MOVEMMESSAGE        2D4B
MOVEMPOST           1F2C
MOVEMPOSTREGLIST    1FB8
MOVEMPRE            1ED0
MOVEMPREREGLIST     1FD8
MOVEMREGLISTBUFFER  1F88
MOVEMREGTOMEMEA     1E5A
MOVEMREGTOMEMEAMASKS  1E5F
MOVESIZE            24A0
MOVESIZEBYTE        24C4
MOVESIZEDONE        24BE
MOVESIZELONG        24D0
MOVESIZEWORD        24CA
MOVESOURCEEA        23BC
MOVESOURCEEAMASKS   23C5
MULS                16FC
MULSBODY            1724
MULSEA              16EC
MULSEAMASKS         16F4
MULSINSTRUCTION     C1C0
MULSMASK            F1C0
MULSMESSAGE         2D1C
NE                  6
NEG                 2104
NEGBODY             212C
NEGDONE             215E
NEGEA               20F4
NEGEAMASKS          20FC
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          2D75
NEGSIZE             216E
NEM                 2C6D
NEXTADDRPROMPT      2DAF
NEXTHEX             278E
NEXTHEXDONE         27E0
NEXTHEXRETURN       27FC
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 239C
NOPMESSAGE          2D69
NUMBER              2AE6
OR                  1382
ORDEST              1456
ORI                 220E
ORIBODY             223A
ORIDONE             2290
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          2D56
ORINSTRUCTION       8000
ORMASK              F000
ORMESSAGE           2D09
ORSOURCE            13F8
ORSOURCEEA          1372
ORSOURCEEAMASKS     137A
OUTPUTHEX           2A4E
OUTPUTHEXDONE       2A66
OUTPUTPOSTINCREMENT  2076
OUTPUTPREINCREMENT  1FD8
PARSEHEXSTRING      278C
PL                  A
PLM                 2C71
PLUS                2DA7
POSTADDBACKSLASH    2070
POSTREGADD          205E
POSTREGADDDONE      2068
PREADDBACKSLASH     20EC
PREREGADD           20DA
PREREGADDDONE       20E4
PRGORG              1000
PRINTBYTESIZE       2A06
PRINTLONGSIZE       2A2E
PRINTSIZE           29C8
PRINTSIZEDONE       29EE
PRINTWORDSIZE       2A1A
PROCESS_OP_CODES    2828
PROCESS_OP_CODES_EXIT  2828
PROMPT_USER         1004
RA                  0
RAM                 2C7D
RPRN                2DAD
RSLEA               17D4
RSLMESSAGE          2D21
RSLREG              181A
RSREA               17C4
RSRLREG             17E4
RSRLREGINSTRUCTION  E018
RSRLREGMASK         F018
RSRLWEA             1784
RSRLWEACHECKDIRECTION  17B0
RSRLWEAINSTRUCTION  E6C0
RSRLWEAMASK         FEC0
RSRMESSAGE          2D25
RSRREG              180A
RTS                 23AC
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          2D64
SCREENLOOP          1016
SIGNEXTENDBYTE      25E0
SLPROMPT            2B0E
SPC                 2C43
SPC_LEN             2C44
SR                  1
SRM                 2C81
STACK               5000
START               1000
STARTLOCATION       2E5E
STARTLOCATIONPROMPT  2CD6
SUB                 1B2C
SUBDEST             1C04
SUBINSTRUCTION      9000
SUBMASK             F000
SUBMESSAGE          2D3E
SUBQ                1A6E
SUBQBODY            1AA6
SUBQEA              1A5E
SUBQEAMASKS         1A66
SUBQINSTRUCTION     5100
SUBQMASK            F100
SUBQMESSAGE         2D39
SUBSOURCE           1BA6
SWITCHMODEANDREG    2AFA
THANKYOUMESSAGE     2E40
TOEIGHT             1B28
UCASEHEX            27B0
UNKNOWNOPCODE       2618
VALIDADDA           1C80
VALIDADDDESTEA      1D78
VALIDADDIMODES      2182
VALIDADDSOURCEEA    1D4E
VALIDASRL           182C
VALIDBCLRDATAMODES  14B6
VALIDBCLRMODES      1550
VALIDCMPEA          12EA
VALIDCMPIMODES      22B0
VALIDDIVSMODES      1662
VALIDEOREA          1250
VALIDJSRMODES       2346
VALIDLEAMODES       15DE
VALIDLSRL           18DE
VALIDMEMTOREG       1EAA
VALIDMOVEAMODES     24DC
VALIDMOVEDESTMODES  2406
VALIDMOVESOURCEMODES  23DE
VALIDMULSMODES      16FE
VALIDNEGMODES       2106
VALIDORDESTEA       13CE
VALIDORIMODES       2210
VALIDORSOURCEEA     13A8
VALIDREGTOMEM       1E84
VALIDRSRL           1786
VALIDSUBDESTEA      1B7C
VALIDSUBQ           1A80
VALIDSUBSOURCEEA    1B52
VC                  8
VCM                 2C75
VS                  9
VSM                 2C79
WORD                2
XXXL                2D8F
XXXW                2D85
ZEROTOEIGHT         1B1E
ZEROTOEIGHTRETURN   1B26

00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.01
Created On: 12/14/2014 4:39:49 PM

00000000                             1  
00000000                             2  *#################################################################################################
00000000                             3  * Title      : 
00000000                             4  * Written by : Andrew Watson
00000000                             5  *            : Elaine Keller
00000000                             6  *            : Robert Anderson
00000000                             7  * Date       : 11/14/2014
00000000                             8  * Description: 
00000000                             9  *#################################################################################################
00000000                            10  
00000000                            11  **************************************************************************************************
00000000                            12  *  Assumptions: Can not tell data from an unidentified instruction that is an actual 
00000000                            13  *               instruction therefore causing errors. It may not actually be a bug because 
00000000                            14  *               data is data to the machine, and if you modify the instructions in memory for a 
00000000                            15  *               program by moivng data, you can modify the instuctions executed.
00000000                            16  **************************************************************************************************
00000000                            17  
00000000                            18  **************************************************************************************************
00000000                            19  *                                    Variable/Data Definitions
00000000                            20  **************************************************************************************************
00000000                            21  
00000000  =00005000                 22  stack   EQU   $00005000
00000000  =00000000                 23  begin   EQU   $00000000
00000000  =00FFFFFE                 24  end     EQU   $00FFFFFE
00000000  =00000001                 25  byte    EQU   1
00000000  =00000002                 26  word    EQU   2
00000000  =00000004                 27  long    EQU   4
00000000  =00001000                 28  prgorg  EQU   $1000
00000000                            29  
00000FFE                            30          ORG         $00000FFE
00000FFE                            31  FarLabel:
00001000                            32          ORG         prgorg
00001000                            33  start:
00001000  4FF8 5000                 34          LEA         stack, SP           ;initialize stack
00001004                            35  
00001000                            36          ORG         prgorg
00001000                            37  
00001000                            38  **************************************************************************************************
00001000                            39  *                                   Begin processing active code
00001000                            40  **************************************************************************************************
00001000                            41  
00001000                            42      
00001000                            43  start:
00001000                            44  
00001000  4FF8 5000                 45          LEA         stack, SP           ;Initialize stack
00001004                            46          
00001004                            47  prompt_user:
00001004                            48  
00001004  6100 1688                 49          BSR         begin_address
00001008  B67C FFFF                 50          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000100C  6700 1670                 51          BEQ         fin                 ;Yes, then exit
00001010                            52          
00001010  6000 0002                 53          BRA         screenLoop
00001014                            54                          
00001014                            55  **************************************************************************************************
00001014                            56  *                                  Begin processing OP Codes
00001014                            57  **************************************************************************************************
00001014                            58  
00001014                            59  
00001014                            60  screenLoop:
00001014                            61  
00001014  143C 001E                 62          MOVE.B      #30,D2
00001018                            63   
00001018                            64  main_Loop:
00001018                            65  
00001018  B9CB                      66          CMPA.L      A3,A4               ;check end of prog
0000101A  6F00 01CA                 67          BLE         checkNextAddr
0000101E  0C02 0000                 68          CMPI.B      #0,D2
00001022  6700 0188                 69          BEQ         checkContinue
00001026  5302                      70          SUBQ.B      #1,D2
00001028  48A7 2000                 71          MOVEM.W     D2,-(SP)            ;save D2 for next iteration
0000102C                            72          
0000102C                            73          ;print memory location
0000102C  48E7 1200                 74          MOVEM.L     D3/D6,-(SP)
00001030  7C02                      75          MOVEQ.L     #2,D6               ;set as long hex string
00001032  260B                      76          MOVE.L      A3,D3               ;put hex in D3
00001034  6100 1A3A                 77          BSR         outputHex
00001038  4CDF 0048                 78          MOVEM.L     (SP)+,D3/D6
0000103C                            79          
0000103C                            80          ;print ' '
0000103C  48E7 4000                 81          MOVEM.L     D1,-(SP)            ;save D1 to the stack
00001040  123C 0020                 82          MOVE.B      #' ',D1             ;put ascii value of char in D1
00001044  103C 0006                 83          MOVE.B      #6,D0               ;move task 6 into D0
00001048  4E4F                      84          TRAP        #15                 ;prin char
0000104A  4CDF 0002                 85          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
0000104E                            86                  
0000104E                            87          ;handle an odd memory access(instructions will never be misaligned)
0000104E  240B                      88          MOVE.L      A3,D2               ;copy address to D2
00001050  0202 0001                 89          ANDI.B      #%00000001,D2       ;mask everything except the least significant bit
00001054  0C02 0001                 90          CMPI.B      #1,D2               ;compare the least sig bit of the address to one
00001058  6700 15EA                 91          BEQ         handlebytedata      ;the least sig bit will only be one if the insrtuction
0000105C                            92                                          ;is odd(misaligned) and therefore not an instruction
0000105C  7600                      93          MOVEQ.L     #0,D3
0000105E                            94          
0000105E  3213                      95          MOVE.W      (A3),D1             ;copy word from other prog to analyze as instructioninstruction
00001060                            96          
00001060                            97          ***things to save A3,A4,D1(?)***
00001060  48E7 0018                 98          MOVEM.L     A3-A4,-(SP)
00001064  6100 0010                 99          BSR         checkOPcode
00001068  4CDF 1800                100          MOVEM.L     (SP)+,A3-A4
0000106C  D7C7                     101          ADDA.L      D7,A3               ;look past data that was part of the instruction
0000106E                           102          
0000106E  548B                     103          ADDQ.L      #word,A3
00001070  4C9F 0004                104          MOVEM.W     (SP)+,D2            ;restore D2 for next iteration
00001074  60A2                     105          BRA         main_Loop 
00001076                           106  
00001076                           107  *=================================================================================================
00001076                           108  *                                  Search for a valid OP Code
00001076                           109  *=================================================================================================
00001076                           110          
00001076                           111  checkOPcode:
00001076                           112  
00001076                           113  
00001076  7E00                     114          MOVEQ.L     #0,D7
00001078                           115          
00001078  41F9 000010BC            116          LEA         instOPList,A0       ;get instruction signitrue list in A0
0000107E  D1C3                     117          ADDA.L      D3,A0               ;get correct sig         
00001080                           118          
00001080  43F9 000010F8            119          LEA         instMaskList,A1     ;get instruction mask in A1
00001086  D3C3                     120          ADDA.L      D3,A1               ;get correct mast
00001088                           121          
00001088  3401                     122          MOVE.W      D1,D2               ;move instruction into D2 for manipulaiton
0000108A                           123          
0000108A  C451                     124          AND.W       (A1),D2             ;mask instruction
0000108C                           125          
0000108C                           126          
0000108C                           127          
0000108C                           128          
0000108C  B450                     129          CMP.W       (A0),D2             ;compare to sig
0000108E  6700 000C                130          BEQ         match               ;if sig matches branch
00001092  5483                     131          ADDQ.L      #word,D3            ;add to D3 to check for next instruction
00001094  60E0                     132          BRA         checkOPcode
00001096                           133          
00001096                           134  falsePositive:
00001096                           135          
00001096  103C 00FF                136          MOVE.B      #-1,D0
0000109A  4E75                     137          RTS
0000109C                           138  
0000109C                           139  *-------------------------------------------------------------------------------------------------
0000109C                           140  *                      Load instructions from list and jump to that op code
0000109C                           141  *-------------------------------------------------------------------------------------------------
0000109C                           142  
0000109C                           143  match:
0000109C                           144          
0000109C  43F9 00001134            145          LEA         instLabelList,A1    ;get instruction code label
000010A2  D3C3                     146          ADDA.L      D3,A1               ;get correct label
000010A4  D3C3                     147          ADDA.L      D3,A1
000010A6  5483                     148          ADDQ.L      #word,D3            ;add to D3 incase false positive
000010A8  2251                     149          MOVEA.L     (A1),A1
000010AA  48E7 1000                150          MOVEM.L     D3,-(SP)            ;save D3
000010AE  4E91                     151          JSR         (A1)
000010B0  4CDF 0008                152          MOVEM.L     (SP)+,D3            ;restore D3
000010B4  B03C 00FF                153          CMP.B       #-1,D0
000010B8  67BC                     154          BEQ         checkOPcode
000010BA  4E75                     155          RTS
000010BC                           156  
000010BC                           157  *.................................................................................................
000010BC                           158  *                          List Variables for OP Code instructions
000010BC                           159  *.................................................................................................
000010BC                           160  
000010BC= 0040 B000                161  instOPList  DC.W moveaInstruction,eorInstruction
000010C0= B000 8000 0880 0...      162  instOPList2 DC.W cmpInstruction,orInstruction,bclrdataInstruction,bclrInstruction,leaInstruction,divsInstruction,mulsInstruction,rsrlweaInstruction,rsrlregInstruction,asrlweaInstruction,asrlregInstruction,lsrlweaInstruction,lsrlregInstruction
000010DA= 5100 9000 D000 D...      163  instOPList3 DC.W subqInstruction,subInstruction,addaInstruction,addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruct
000010F8                           164      
000010F8= C1C0 F000                165  instMaskList  DC.W moveaMask,eorMask
000010FC= F000 F000 FFC0 F...      166  instMaskList2 DC.W cmpMask,orMask,bclrdataMask,bclrMask,leaMask,divsMask,mulsMask,rsrlweaMask,rsrlregMask,asrlweaMask,asrlregMask,lsrlweaMask,lsrlregMask
00001116= F100 F000 F000 F...      167  instMaskList3 DC.W subqMask,subMask,addaMask,addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
00001134= 000024D8 00001230        168  instLabelList  DC.L MOVEA,EOR
0000113C= 000012D2 00001380 ...    169  instLabelList2 DC.L CMP,OR,BCLRDATA,BCLR,LEA,DIVS,MULS,RSRLWEA,RSRLREG,ASRLWEA,ASRLREG,LSRLWEA,LSRLREG
00001170= 00001A6C 00001B2A ...    170  instLabelList3 DC.L SUBQ,SUB,ADDA,ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
000011AC                           171  
000011AC                           172  
000011AC                           173  *=================================================================================================
000011AC                           174  *    Check for the user wanting to continue / stop displaying another page of the output
000011AC                           175  *=================================================================================================
000011AC                           176  
000011AC                           177  checkContinue:
000011AC                           178          
000011AC  48A7 6040                179          MOVEM.W     D1/D2/A1,-(SP)      ;save reg that are modified just in case
000011B0                           180          
000011B0  43F9 00002E53            181          LEA         continuePrompt,A1   ;move string
000011B6  103C 000E                182          MOVE.B      #14,D0              ;set for task to display null terminated 
000011BA                           183                                          ;string without CR, LF
000011BA  4E4F                     184          TRAP        #15
000011BC                           185          
000011BC                           186          
000011BC  103C 0005                187          MOVE.B      #5,D0               ;set for task to read single char into D1
000011C0  4E4F                     188          TRAP        #15
000011C2                           189          
000011C2  43F9 00002D56            190          LEA         clearLine,A1        ;move string for a CR and LF
000011C8  103C 000E                191          MOVE.B      #14,D0              ;set for task to display null terminated 
000011CC                           192                                          ;string without CR, LF
000011CC  4E4F                     193          TRAP        #15
000011CE                           194          
000011CE                           195          ;if either case of 'S' is entered, stop displaying the output
000011CE  0C01 0073                196          CMPI.B      #'s',D1             ;has the user selected 'S' to stop
000011D2  6700 0012                197          BEQ         checkNextAddr       ;yes, check if user wants to stop, or display more lines
000011D6  0C01 0053                198          CMPI.B      #'S',D1
000011DA  6700 000A                199          BEQ         checkNextAddr
000011DE                           200          
000011DE  4C9F 0206                201          MOVEM.W     (SP)+,D1/D2/A1
000011E2  6000 FE30                202          BRA         screenLoop
000011E6                           203  
000011E6                           204  *-------------------------------------------------------------------------------------------------
000011E6                           205  *            Check for the user wants to enter another address to check, or quit
000011E6                           206  *-------------------------------------------------------------------------------------------------
000011E6                           207  
000011E6                           208  checkNextAddr:
000011E6                           209  
000011E6  43F9 00002E07            210          LEA         nextAddrPrompt,A1   ;move string
000011EC  103C 000E                211          MOVE.B      #14,D0              ;set for task to display null terminated 
000011F0                           212                                          ;string without CR, LF
000011F0  4E4F                     213          TRAP        #15
000011F2                           214          
000011F2                           215          
000011F2  103C 0005                216          MOVE.B      #5,D0               ;set for task to read single char into D1
000011F6  4E4F                     217          TRAP        #15
000011F8                           218          
000011F8  43F9 00002D56            219          LEA         clearLine,A1        ;move string for a CR and LF
000011FE  103C 000E                220          MOVE.B      #14,D0              ;set for task to display null terminated 
00001202                           221                                          ;string without CR, LF
00001202  4E4F                     222          TRAP        #15
00001204                           223          
00001204                           224          ;if either case of 'Q' is entered, quit the program
00001204  0C01 0071                225          CMPI.B      #'q',D1             ;has the user selected 'Q' to quit
00001208  6700 1474                226          BEQ         fin                 ;yes, check if user wants to quit, or check new address
0000120C  0C01 0051                227          CMPI.B      #'Q',D1
00001210  6700 146C                228          BEQ         fin
00001214                           229          
00001214                           230          ;Clear screen for new address
00001214  323C FF00                231          MOVE.W      #$FF00, D1          ;Clear screen value
00001218  103C 000B                232          MOVE.B      #11,D0              ;set for task to clear screen
0000121C  4E4F                     233          TRAP        #15
0000121E                           234          
0000121E  6000 FDE4                235          BRA         prompt_user
00001222                           236  
00001222                           237  *.............................................................................
00001222                           238  * Debug Mode begin: Comment out when done
00001222                           239  *snippet:
00001222                           240  *         NOP
00001222                           241  *         BRA snippet
00001222                           242  *         BRA FarLabel
00001222                           243  *         BEQ snippet
00001222                           244  *         BGT NEG
00001222                           245  *         BSR snippet
00001222                           246  *         MOVEA.W #$5668,A4
00001222                           247  *         NEG.B $3242
00001222                           248  *         NEG.W D2
00001222                           249  *         MOVE.B #$85,D1
00001222                           250  *         ADDI.L #30,D5
00001222                           251  *         RTS
00001222                           252  *         JSR $54
00001222                           253  *         CMPI.W #3,D1
00001222                           254  *         ORI.L  #3,D1
00001222                           255  *         MOVEM.L A3-A4,-(SP)
00001222                           256  *         MOVEM.L (SP)+,D1-A3
00001222                           257  *         ADD.B D1,D2
00001222                           258  *         ADD.B #10,D3
00001222                           259  *         ADDA.W #23,A3
00001222                           260  *         SUB.W D3,D5
00001222                           261  *         SUBQ.B #8,D5
00001222                           262  *         SUBQ.L #1,D5
00001222                           263  *         LSR.B #3,D3
00001222                           264  *         LSL.L #3,D4
00001222                           265  *         LSL.W D1,D1
00001222                           266  *         LSR.B D3,D7
00001222                           267  *         LSR $3563
00001222                           268  *         LSL $486412
00001222                           269  *         ASR.W #3,D3
00001222                           270  *         ASL.L #3,D4
00001222                           271  *         ASL.L D1,D1
00001222                           272  *         ASR.B D3,D7
00001222                           273  *         ASR.W $3563
00001222                           274  *         ASL.W $486412
00001222                           275  *         ROR.L #3,D3
00001222                           276  *         ROL.W #3,D4
00001222                           277  *         ROL.B D1,D1
00001222                           278  *         ROR D3,D7
00001222                           279  *         ROR $3563
00001222                           280  *         ROL $486412
00001222                           281  *         MULS #$4562,D2
00001222                           282  *         DIVS #$4562,D2
00001222                           283  *         LEA leaEAmasks,A1
00001222                           284  *         BCLR D1,D4
00001222                           285  *         BCLR #20,D5
00001222                           286  *         OR.B D1,D2
00001222                           287  *         OR.B #10,D3
00001222                           288  *         CMP.W D2,D5
00001222                           289  *         CMP.L (A3),D4
00001222                           290  *         EOR.W D2,D5
00001222                           291  *         EOR.L D4,(A3)
00001222                           292  *         MOVE.W #$5435,D6
00001222                           293  *         MOVE.L #$463463,D3
00001222                           294  *snippetEnd:
00001222                           295  *         SIMHALT
00001222                           296  * Debug Mode end:   Comment out when done
00001222                           297  *.............................................................................
00001222                           298           
00001222                           299           
00001222= 00 10 18 20 38 39 00     300  eorEA      Dc.B %000000,%010000,%011000,%100000,%111000,%111001,0
00001229= 38 38 38 38 3F 3F 00     301  eorEAmasks DC.B %111000,%111000,%111000,%111000,%111111,%111111,0
00001230                           302  
00001230                           303  
00001230                           304  
00001230                           305  EOR:
00001230                           306          
00001230                           307  
00001230                           308          
00001230  7000                     309          MOVEQ.L #0, D0                  ;clear D0
00001232                           310          
00001232                           311          ;Figure out if EA is source or destination
00001232  3401                     312          MOVE.W D1,D2                    ;copy inst to D2
00001234  EC4A                     313          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001236  0202 0007                314          ANDI.B #%00000111,D2            ;mask out rest of byte
0000123A  0C02 0003                315          CMPI.B #3,D2                    ;compare to 3
0000123E  6F00 FE56                316          BLE falsePositive               ;3 or less is not valid
00001242                           317          
00001242  0C02 0007                318          CMPI.B #%111,D2                 ;compare to 7
00001246  6700 FE4E                319          BEQ falsePositive               ;thats not valid
0000124A  6000 0002                320          BRA validEorEA                  ;all thats left is valid EA size 
0000124E                           321          
0000124E                           322  validEorEA:
0000124E                           323          
0000124E  43F8 1229                324          LEA eorEAmasks,A1               ;load the list of masks
00001252  D3C0                     325          ADDA.L D0,A1                    ;displace to a specific mask
00001254  1A11                     326          MOVE.B (A1),D5                  ;move the mask to D5
00001256                           327          
00001256  0C05 0000                328          CMPI.B #0,D5                    ;check if the mask is 0
0000125A  6700 FE3A                329          BEQ falsePositive               ;branch if it is
0000125E                           330          
0000125E  1401                     331          MOVE.B D1,D2                    ;copy instruction to D2
00001260  C405                     332          AND.B D5,D2                     ;mask D2
00001262                           333          
00001262  43F8 1222                334          LEA eorEA,A1                    ;load the list of valid modes
00001266  D3C0                     335          ADDA.L D0,A1                    ;displace to a specific mode
00001268  1811                     336          MOVE.B (A1),D4                  ;move mode to D4
0000126A  B404                     337          CMP.B D4,D2                     ;compare mode to masked value
0000126C  6700 0006                338          BEQ  eorBody                    ;if its match, its a valid mode and we can procede
00001270                           339          
00001270  5280                     340          ADDQ.L #1,D0                    ;add one to displacement
00001272  60DA                     341          BRA validEorEA                  ;check for next mode
00001274                           342                  
00001274                           343  
00001274                           344  eorBody
00001274                           345  
00001274  43F9 00002D59            346          LEA     eorMessage,A1           ;move string for MOVE
0000127A  103C 000E                347          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000127E                           348                                ;string with CR, LF
0000127E  4E4F                     349          TRAP    #15
00001280                           350          
00001280  6100 0EEA                351          BSR negSize
00001284                           352          
00001284                           353          ;Do Dn
00001284                           354          
00001284  3401                     355          MOVE.W  D1,D2
00001286  E04A                     356          LSR.W   #8,D2                   ;move reg into first byte
00001288  E20A                     357          LSR.B   #1,D2                   ;line it up to least sig bit
0000128A  C43C 0007                358          AND.B   #%00000111,D2           ;force mode to Dn
0000128E  1A02                     359          MOVE.B  D2,D5
00001290  48E7 4000                360          MOVEM.L D1,-(SP)
00001294  6100 15B6                361          BSR     Get_Effective_Address
00001298  4CDF 0002                362          MOVEM.L (SP)+,D1
0000129C                           363          
0000129C                           364          
0000129C                           365          ;print ','
0000129C  48E7 4000                366          MOVEM.L D1,-(SP)                ;save D1 to the stack
000012A0  123C 002C                367          MOVE.B #',',D1                  ;put ascii value of char in D1
000012A4  103C 0006                368          MOVE.B #6,D0                    ;move task 6 into D0
000012A8  4E4F                     369          TRAP #15                        ;prin char
000012AA  4CDF 0002                370          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000012AE                           371          
000012AE                           372          ;Then do EA
000012AE                           373          
000012AE  3401                     374          MOVE.W  D1,D2                   ;check mode
000012B0  C43C 003F                375          AND.B   #%00111111,D2
000012B4  1A02                     376          MOVE.B  D2,D5
000012B6  48E7 4000                377          MOVEM.L D1,-(SP)
000012BA  6100 1590                378          BSR     Get_Effective_Address
000012BE  4CDF 0002                379          MOVEM.L (SP)+,D1
000012C2                           380          
000012C2                           381          
000012C2  43F9 00002D56            382          LEA     clearLine,A1            ;move string for a CR and LF
000012C8  103C 000E                383          MOVE.B  #14,D0                  ;set for task to display null terminated 
000012CC                           384                                ;string without CR, LF
000012CC  4E4F                     385          TRAP    #15
000012CE                           386  
000012CE  7000                     387          MOVEQ.L #0,D0
000012D0  4E75                     388          RTS
000012D2                           389  
000012D2                           390  
000012D2                           391  
000012D2                           392  CMP:
000012D2                           393          
000012D2                           394  
000012D2                           395          
000012D2  7000                     396          MOVEQ.L #0, D0                  ;clear D0
000012D4                           397          
000012D4                           398          ;Figure out if EA is source or destination
000012D4  3401                     399          MOVE.W D1,D2                    ;copy inst to D2
000012D6  EC4A                     400          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
000012D8  0202 0007                401          ANDI.B #%00000111,D2            ;mask out rest of byte
000012DC  0C02 0002                402          CMPI.B #2,D2                    ;compare to 2
000012E0  6F00 0006                403          BLE validCmpEA                  ;2 or less is EA 
000012E4                           404          
000012E4  6000 FDB0                405          BRA falsePositive               ;thats not valid
000012E8                           406          
000012E8                           407  validCmpEA:
000012E8                           408          
000012E8  43F9 000023C3            409          LEA moveSourceEAmasks,A1        ;load the list of masks
000012EE  D3C0                     410          ADDA.L D0,A1                    ;displace to a specific mask
000012F0  1A11                     411          MOVE.B (A1),D5                  ;move the mask to D5
000012F2                           412          
000012F2  0C05 0000                413          CMPI.B #0,D5                    ;check if the mask is 0
000012F6  6700 FD9E                414          BEQ falsePositive               ;branch if it is
000012FA                           415          
000012FA  1401                     416          MOVE.B D1,D2                    ;copy instruction to D2
000012FC  C405                     417          AND.B D5,D2                     ;mask D2
000012FE                           418          
000012FE  43F9 000023BA            419          LEA moveSourceEA,A1             ;load the list of valid modes
00001304  D3C0                     420          ADDA.L D0,A1                    ;displace to a specific mode
00001306  1811                     421          MOVE.B (A1),D4                  ;move mode to D4
00001308  B404                     422          CMP.B D4,D2                     ;compare mode to masked value
0000130A  6700 0006                423          BEQ  cmpBody                    ;if its match, its a valid mode and we can procede
0000130E                           424          
0000130E  5280                     425          ADDQ.L #1,D0                    ;add one to displacement
00001310  60D6                     426          BRA validCmpEA                  ;check for next mode
00001312                           427          
00001312                           428          
00001312                           429          
00001312                           430  cmpBody
00001312                           431  
00001312  43F9 00002D5D            432          LEA     cmpMessage,A1           ;move string for MOVE
00001318  103C 000E                433          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000131C                           434                                ;string with CR, LF
0000131C  4E4F                     435          TRAP    #15
0000131E                           436          
0000131E  6100 0E4C                437          BSR negSize
00001322                           438          
00001322                           439          ;do EA
00001322                           440          
00001322  3401                     441          MOVE.W  D1,D2                   ;check mode
00001324  C43C 003F                442          AND.B   #%00111111,D2
00001328  1A02                     443          MOVE.B  D2,D5
0000132A  48E7 4000                444          MOVEM.L D1,-(SP)
0000132E  6100 151C                445          BSR     Get_Effective_Address
00001332  4CDF 0002                446          MOVEM.L (SP)+,D1
00001336                           447          
00001336                           448          ;print ','
00001336  48E7 4000                449          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000133A  123C 002C                450          MOVE.B #',',D1                  ;put ascii value of char in D1
0000133E  103C 0006                451          MOVE.B #6,D0                    ;move task 6 into D0
00001342  4E4F                     452          TRAP #15                        ;prin char
00001344  4CDF 0002                453          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001348                           454          
00001348                           455          ;Then do Dn
00001348                           456          
00001348  3401                     457          MOVE.W  D1,D2
0000134A  E04A                     458          LSR.W   #8,D2                   ;move reg into first byte
0000134C  E20A                     459          LSR.B   #1,D2                   ;line it up to least sig bit
0000134E  C43C 0007                460          AND.B   #%00000111,D2           ;force mode to Dn
00001352  1A02                     461          MOVE.B  D2,D5
00001354  48E7 4000                462          MOVEM.L D1,-(SP)
00001358  6100 14F2                463          BSR     Get_Effective_Address
0000135C  4CDF 0002                464          MOVEM.L (SP)+,D1
00001360                           465          
00001360  43F9 00002D56            466          LEA     clearLine,A1            ;move string for a CR and LF
00001366  103C 000E                467          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000136A                           468                                ;string without CR, LF
0000136A  4E4F                     469          TRAP    #15
0000136C                           470  
0000136C  7000                     471          MOVEQ.L #0,D0
0000136E  4E75                     472          RTS
00001370                           473  
00001370                           474  
00001370                           475  
00001370= 00 10 18 20 38 39 ...    476  orSourceEA      Dc.B %000000,%010000,%011000,%100000,%111000,%111001,%111100,0
00001378= 38 38 38 38 3F 3F ...    477  orSourceEAmasks DC.B %111000,%111000,%111000,%111000,%111111,%111111,%111111,0
00001380                           478  
00001380                           479  OR:
00001380                           480          
00001380                           481  
00001380                           482          
00001380  7000                     483          MOVEQ.L #0, D0                  ;clear D0
00001382                           484          
00001382                           485          ;Figure out if EA is source or destination
00001382  3401                     486          MOVE.W D1,D2                    ;copy inst to D2
00001384  EC4A                     487          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001386  0202 0007                488          ANDI.B #%00000111,D2            ;mask out rest of byte
0000138A  0C02 0002                489          CMPI.B #2,D2                    ;compare to 2
0000138E  6F00 0016                490          BLE validOrSourceEA             ;2 or less is EA is source
00001392                           491          
00001392  0C02 0007                492          CMPI.B #%111,D2                 ;compare to 7
00001396  6700 FCFE                493          BEQ falsePositive               ;thats not valid
0000139A  0C02 0003                494          CMPI.B #%11,D2                  ;compare to 3
0000139E  6700 FCF6                495          BEQ falsePositive               ;also not valid
000013A2  6000 0028                496          BRA validOrDestEA               ;all thats left is valid EA as Dest 
000013A6                           497          
000013A6                           498  validORSourceEA:
000013A6                           499          
000013A6  43F8 1378                500          LEA orSourceEAmasks,A1          ;load the list of masks
000013AA  D3C0                     501          ADDA.L D0,A1                    ;displace to a specific mask
000013AC  1A11                     502          MOVE.B (A1),D5                  ;move the mask to D5
000013AE                           503          
000013AE  0C05 0000                504          CMPI.B #0,D5                    ;check if the mask is 0
000013B2  6700 FCE2                505          BEQ falsePositive               ;branch if it is
000013B6                           506          
000013B6  1401                     507          MOVE.B D1,D2                    ;copy instruction to D2
000013B8  C405                     508          AND.B D5,D2                     ;mask D2
000013BA                           509          
000013BA  43F8 1370                510          LEA orSourceEA,A1               ;load the list of valid modes
000013BE  D3C0                     511          ADDA.L D0,A1                    ;displace to a specific mode
000013C0  1811                     512          MOVE.B (A1),D4                  ;move mode to D4
000013C2  B404                     513          CMP.B D4,D2                     ;compare mode to masked value
000013C4  6700 0030                514          BEQ  orSource                   ;if its match, its a valid mode and we can procede
000013C8                           515          
000013C8  5280                     516          ADDQ.L #1,D0                    ;add one to displacement
000013CA  60DA                     517          BRA validOrSourceEA             ;check for next mode
000013CC                           518          
000013CC                           519          
000013CC                           520  validOrDestEA:
000013CC                           521          
000013CC  43F9 00001D20            522          LEA addDestEAmasks,A1           ;load the list of masks
000013D2  D3C0                     523          ADDA.L D0,A1                    ;displace to a specific mask
000013D4  1A11                     524          MOVE.B (A1),D5                  ;move the mask to D5
000013D6                           525          
000013D6  0C05 0000                526          CMPI.B #0,D5                    ;check if the mask is 0
000013DA  6700 FCBA                527          BEQ falsePositive               ;branch if it is
000013DE                           528          
000013DE  3401                     529          MOVE.W D1,D2                    ;copy instruction to D2
000013E0  C405                     530          AND.B D5,D2                     ;mask D2
000013E2                           531          
000013E2  43F9 00001D1A            532          LEA addDestEA,A1                ;load the list of valid modes
000013E8  D3C0                     533          ADDA.L D0,A1                    ;displace to a specific mode
000013EA  1811                     534          MOVE.B (A1),D4                  ;move mode to D4
000013EC  B404                     535          CMP.B D4,D2                     ;compare mode to masked value
000013EE  6700 0064                536          BEQ orDest                      ;if its match, its a valid mode and we can procede
000013F2                           537          
000013F2  5280                     538          ADDQ.L #1,D0                    ;add one to displacement
000013F4  60D6                     539          BRA validOrDestEA               ;check for next mode
000013F6                           540          
000013F6                           541  orSource
000013F6                           542  
000013F6  43F9 00002D61            543          LEA     orMessage,A1            ;move string for MOVE
000013FC  103C 000E                544          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001400                           545                                ;string with CR, LF
00001400  4E4F                     546          TRAP    #15
00001402                           547          
00001402  6100 0D68                548          BSR negSize
00001406                           549          
00001406                           550          ;do EA
00001406                           551          
00001406  3401                     552          MOVE.W  D1,D2                   ;check mode
00001408  C43C 003F                553          AND.B   #%00111111,D2
0000140C  1A02                     554          MOVE.B  D2,D5
0000140E  48E7 4000                555          MOVEM.L D1,-(SP)
00001412  6100 1438                556          BSR     Get_Effective_Address
00001416  4CDF 0002                557          MOVEM.L (SP)+,D1
0000141A                           558          
0000141A                           559          ;print ','
0000141A  48E7 4000                560          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000141E  123C 002C                561          MOVE.B #',',D1                  ;put ascii value of char in D1
00001422  103C 0006                562          MOVE.B #6,D0                    ;move task 6 into D0
00001426  4E4F                     563          TRAP #15                        ;prin char
00001428  4CDF 0002                564          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000142C                           565          
0000142C                           566          ;Then do Dn
0000142C                           567          
0000142C  3401                     568          MOVE.W  D1,D2
0000142E  E04A                     569          LSR.W   #8,D2                   ;move reg into first byte
00001430  E20A                     570          LSR.B   #1,D2                   ;line it up to least sig bit
00001432  C43C 0007                571          AND.B   #%00000111,D2           ;force mode to Dn
00001436  1A02                     572          MOVE.B  D2,D5
00001438  48E7 4000                573          MOVEM.L D1,-(SP)
0000143C  6100 140E                574          BSR     Get_Effective_Address
00001440  4CDF 0002                575          MOVEM.L (SP)+,D1
00001444                           576          
00001444  43F9 00002D56            577          LEA     clearLine,A1            ;move string for a CR and LF
0000144A  103C 000E                578          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000144E                           579                                ;string without CR, LF
0000144E  4E4F                     580          TRAP    #15
00001450                           581  
00001450  7000                     582          MOVEQ.L #0,D0
00001452  4E75                     583          RTS
00001454                           584  
00001454                           585  orDest
00001454                           586  
00001454  43F9 00002D61            587          LEA     orMessage,A1            ;move string for MOVE
0000145A  103C 000E                588          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000145E                           589                                ;string with CR, LF
0000145E  4E4F                     590          TRAP    #15
00001460                           591          
00001460  6100 0D0A                592          BSR negSize
00001464                           593          
00001464                           594          ;Do Dn
00001464                           595          
00001464  3401                     596          MOVE.W  D1,D2
00001466  E04A                     597          LSR.W   #8,D2                   ;move reg into first byte
00001468  E20A                     598          LSR.B   #1,D2                   ;line it up to least sig bit
0000146A  C43C 0007                599          AND.B   #%00000111,D2           ;force mode to Dn
0000146E  1A02                     600          MOVE.B  D2,D5
00001470  48E7 4000                601          MOVEM.L D1,-(SP)
00001474  6100 13D6                602          BSR     Get_Effective_Address
00001478  4CDF 0002                603          MOVEM.L (SP)+,D1
0000147C                           604          
0000147C                           605          
0000147C                           606          ;print ','
0000147C  48E7 4000                607          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001480  123C 002C                608          MOVE.B #',',D1                  ;put ascii value of char in D1
00001484  103C 0006                609          MOVE.B #6,D0                    ;move task 6 into D0
00001488  4E4F                     610          TRAP #15                        ;prin char
0000148A  4CDF 0002                611          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000148E                           612          
0000148E                           613          ;Then do EA
0000148E                           614          
0000148E  3401                     615          MOVE.W  D1,D2                   ;check mode
00001490  C43C 003F                616          AND.B   #%00111111,D2
00001494  1A02                     617          MOVE.B  D2,D5
00001496  48E7 4000                618          MOVEM.L D1,-(SP)
0000149A  6100 13B0                619          BSR     Get_Effective_Address
0000149E  4CDF 0002                620          MOVEM.L (SP)+,D1
000014A2                           621          
000014A2                           622          
000014A2  43F9 00002D56            623          LEA     clearLine,A1            ;move string for a CR and LF
000014A8  103C 000E                624          MOVE.B  #14,D0                  ;set for task to display null terminated 
000014AC                           625                                ;string without CR, LF
000014AC  4E4F                     626          TRAP    #15
000014AE                           627  
000014AE  7000                     628          MOVEQ.L #0,D0
000014B0  4E75                     629          RTS
000014B2                           630  
000014B2                           631  
000014B2                           632  
000014B2                           633  
000014B2                           634  BCLRDATA:
000014B2                           635  
000014B2  7000                     636          MOVEQ.L #0, D0                  ;clear D0
000014B4                           637          
000014B4                           638  validBCLRdataModes:
000014B4                           639          
000014B4  43F9 000016F2            640          LEA mulsEAmasks,A1              ;load the list of masks
000014BA  D3C0                     641          ADDA.L D0,A1                    ;displace to a specific mask
000014BC  1A11                     642          MOVE.B (A1),D5                  ;move the mask to D5
000014BE                           643          
000014BE  0C05 0000                644          CMPI.B #0,D5                    ;check if the mask is 0
000014C2  6700 FBD2                645          BEQ falsePositive               ;branch if it is
000014C6                           646          
000014C6  1401                     647          MOVE.B D1,D2                    ;copy instruction to D2
000014C8  C405                     648          AND.B D5,D2                     ;mask D2
000014CA                           649          
000014CA  43F9 000016EA            650          LEA mulsEA,A1                   ;load the list of valid modes
000014D0  D3C0                     651          ADDA.L D0,A1                    ;displace to a specific mode
000014D2  1811                     652          MOVE.B (A1),D4                  ;move mode to D4
000014D4  B404                     653          CMP.B D4,D2                     ;compare mode to masked value
000014D6  6700 0006                654          BEQ  bclrdataBody               ;if its match, its a valid mode and we can procede
000014DA                           655          
000014DA  5280                     656          ADDQ.L #1,D0                    ;add one to displacement
000014DC  60D6                     657          BRA validBCLRdataModes          ;check for next mode
000014DE                           658          
000014DE                           659  bclrdataBody:
000014DE                           660          
000014DE                           661  
000014DE                           662  
000014DE  43F9 00002D64            663          LEA     bclrMessage,A1          ;move string for MOVE
000014E4  103C 000E                664          MOVE.B  #14,D0                  ;set for task to display null terminated 
000014E8                           665                                ;string without CR, LF
000014E8  4E4F                     666          TRAP    #15
000014EA                           667  
000014EA  48E7 C010                668          MOVEM.L D0/D1/A3,-(SP)          ;save D1 and A3
000014EE  5487                     669          ADDQ.L #word,D7                 ;signal there is a word following this instruction
000014F0                           670          
000014F0                           671          ;print '#'
000014F0  48E7 4000                672          MOVEM.L D1,-(SP)                ;save D1 to the stack
000014F4  123C 0023                673          MOVE.B #'#',D1                  ;put ascii value of char in D1
000014F8  103C 0006                674          MOVE.B #6,D0                    ;move task 6 into D0
000014FC  4E4F                     675          TRAP #15                        ;prin char
000014FE  4CDF 0002                676          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001502                           677          
00001502                           678          ;get following word
00001502  548B                     679          ADDQ.L #word,A3
00001504  3213                     680          MOVE.W (A3),D1                  ;move word at (A3)
00001506  0281 0000FFFF            681          ANDI.L #$0000FFFF,D1            ;clear unimportant bit of D1
0000150C                           682          
0000150C                           683          ;print number
0000150C  103C 0003                684          MOVE.B #3,D0
00001510  4E4F                     685          TRAP #15
00001512                           686          
00001512  4CDF 0803                687          MOVEM.L (SP)+,D0/D1/A3          ;restore D1 and A3
00001516                           688  
00001516                           689  
00001516                           690  
00001516                           691          ;print ','
00001516  48E7 4000                692          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000151A  123C 002C                693          MOVE.B #',',D1                  ;put ascii value of char in D1
0000151E  103C 0006                694          MOVE.B #6,D0                    ;move task 6 into D0
00001522  4E4F                     695          TRAP #15                        ;prin char
00001524  4CDF 0002                696          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001528                           697          
00001528                           698          ;do dest EA
00001528  3401                     699          MOVE.W  D1,D2                   ;check mode
0000152A  C43C 003F                700          AND.B   #%00111111,D2
0000152E  1A02                     701          MOVE.B  D2,D5
00001530  48E7 4000                702          MOVEM.L D1,-(SP)
00001534  6100 1316                703          BSR     Get_Effective_Address
00001538  4CDF 0002                704          MOVEM.L (SP)+,D1
0000153C                           705          
0000153C  43F9 00002D56            706          LEA     clearLine,A1            ;move string for a CR and LF
00001542  103C 000E                707          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001546                           708                                ;string without CR, LF
00001546  4E4F                     709          TRAP    #15
00001548                           710  
00001548  7000                     711          MOVEQ.L #0,D0
0000154A  4E75                     712          RTS
0000154C                           713  
0000154C                           714  
0000154C                           715  
0000154C                           716           
0000154C                           717  BCLR:
0000154C                           718  
0000154C  7000                     719          MOVEQ.L #0, D0                  ;clear D0
0000154E                           720          
0000154E                           721  validBCLRModes:
0000154E                           722          
0000154E  43F9 000016F2            723          LEA mulsEAmasks,A1              ;load the list of masks
00001554  D3C0                     724          ADDA.L D0,A1                    ;displace to a specific mask
00001556  1A11                     725          MOVE.B (A1),D5                  ;move the mask to D5
00001558                           726          
00001558  0C05 0000                727          CMPI.B #0,D5                    ;check if the mask is 0
0000155C  6700 FB38                728          BEQ falsePositive               ;branch if it is
00001560                           729          
00001560  1401                     730          MOVE.B D1,D2                    ;copy instruction to D2
00001562  C405                     731          AND.B D5,D2                     ;mask D2
00001564                           732          
00001564  43F9 000016EA            733          LEA mulsEA,A1                   ;load the list of valid modes
0000156A  D3C0                     734          ADDA.L D0,A1                    ;displace to a specific mode
0000156C  1811                     735          MOVE.B (A1),D4                  ;move mode to D4
0000156E  B404                     736          CMP.B D4,D2                     ;compare mode to masked value
00001570  6700 0006                737          BEQ  bclrBody                   ;if its match, its a valid mode and we can procede
00001574                           738          
00001574  5280                     739          ADDQ.L #1,D0                    ;add one to displacement
00001576  60D6                     740          BRA validBCLRModes              ;check for next mode
00001578                           741          
00001578                           742  bclrBody:
00001578                           743          
00001578                           744  
00001578                           745  
00001578  43F9 00002D64            746          LEA     bclrMessage,A1          ;move string for MOVE
0000157E  103C 000E                747          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001582                           748                                ;string without CR, LF
00001582  4E4F                     749          TRAP    #15
00001584                           750  
00001584                           751          ;do source EA
00001584  3401                     752          MOVE.W  D1,D2                   ;check mode
00001586  C43C 003F                753          AND.B   #%00111111,D2
0000158A  1A02                     754          MOVE.B  D2,D5
0000158C  48E7 4000                755          MOVEM.L D1,-(SP)
00001590  6100 12BA                756          BSR     Get_Effective_Address
00001594  4CDF 0002                757          MOVEM.L (SP)+,D1
00001598                           758  
00001598                           759          ;print ','
00001598  48E7 4000                760          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000159C  123C 002C                761          MOVE.B #',',D1                  ;put ascii value of char in D1
000015A0  103C 0006                762          MOVE.B #6,D0                    ;move task 6 into D0
000015A4  4E4F                     763          TRAP #15                        ;prin char
000015A6  4CDF 0002                764          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000015AA                           765          
000015AA                           766          ;do dest data reg
000015AA  3401                     767          MOVE.W  D1,D2                   ;check mode
000015AC  E04A                     768          LSR.W #8,D2                     ;shift reg over
000015AE  E20A                     769          LSR.B #1,D2
000015B0  C43C 0007                770          AND.B   #%00000111,D2           ;force recognition as a Dn
000015B4  1A02                     771          MOVE.B  D2,D5
000015B6  48E7 4000                772          MOVEM.L D1,-(SP)
000015BA  6100 1290                773          BSR     Get_Effective_Address
000015BE  4CDF 0002                774          MOVEM.L (SP)+,D1
000015C2                           775          
000015C2  43F9 00002D56            776          LEA     clearLine,A1            ;move string for a CR and LF
000015C8  103C 000E                777          MOVE.B  #14,D0                  ;set for task to display null terminated 
000015CC                           778                                ;string without CR, LF
000015CC  4E4F                     779          TRAP    #15
000015CE                           780  
000015CE  7000                     781          MOVEQ.L #0,D0
000015D0  4E75                     782          RTS
000015D2                           783  
000015D2                           784           
000015D2                           785  
000015D2= 10 38 39 00              786  leaEA        DC.B %010000,%111000,%111001,0
000015D6= 38 3F 3F 00              787  leaEAmasks   DC.B %111000,%111111,%111111,0
000015DA                           788          
000015DA                           789  LEA:
000015DA                           790  
000015DA  7000                     791          MOVEQ.L #0, D0                  ;clear D0
000015DC                           792          
000015DC                           793  validLeaModes:
000015DC                           794          
000015DC  43F8 15D6                795          LEA leaEAmasks,A1               ;load the list of masks
000015E0  D3C0                     796          ADDA.L D0,A1                    ;displace to a specific mask
000015E2  1A11                     797          MOVE.B (A1),D5                  ;move the mask to D5
000015E4                           798          
000015E4  0C05 0000                799          CMPI.B #0,D5                    ;check if the mask is 0
000015E8  6700 FAAC                800          BEQ falsePositive               ;branch if it is
000015EC                           801          
000015EC  1401                     802          MOVE.B D1,D2                    ;copy instruction to D2
000015EE  C405                     803          AND.B D5,D2                     ;mask D2
000015F0                           804          
000015F0  43F8 15D2                805          LEA leaEA,A1                    ;load the list of valid modes
000015F4  D3C0                     806          ADDA.L D0,A1                    ;displace to a specific mode
000015F6  1811                     807          MOVE.B (A1),D4                  ;move mode to D4
000015F8  B404                     808          CMP.B D4,D2                     ;compare mode to masked value
000015FA  6700 0006                809          BEQ  leaBody                    ;if its match, its a valid mode and we can procede
000015FE                           810          
000015FE  5280                     811          ADDQ.L #1,D0                    ;add one to displacement
00001600  60DA                     812          BRA validLeaModes               ;check for next mode
00001602                           813          
00001602                           814  leaBody:
00001602                           815          
00001602                           816  
00001602                           817  
00001602  43F9 00002D6A            818          LEA     leaMessage,A1           ;move string for MOVE
00001608  103C 000E                819          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000160C                           820                                ;string without CR, LF
0000160C  4E4F                     821          TRAP    #15
0000160E                           822  
0000160E                           823          ;do source EA
0000160E  3401                     824          MOVE.W  D1,D2                   ;check mode
00001610  C43C 003F                825          AND.B   #%00111111,D2
00001614  1A02                     826          MOVE.B  D2,D5
00001616  48E7 4000                827          MOVEM.L D1,-(SP)
0000161A  6100 1230                828          BSR     Get_Effective_Address
0000161E  4CDF 0002                829          MOVEM.L (SP)+,D1
00001622                           830  
00001622                           831          ;print ','
00001622  48E7 4000                832          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001626  123C 002C                833          MOVE.B #',',D1                  ;put ascii value of char in D1
0000162A  103C 0006                834          MOVE.B #6,D0                    ;move task 6 into D0
0000162E  4E4F                     835          TRAP #15                        ;prin char
00001630  4CDF 0002                836          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001634                           837          
00001634                           838          ;do dest addr reg
00001634  3401                     839          MOVE.W  D1,D2                   ;check mode
00001636  E04A                     840          LSR.W #8,D2                     ;shift reg over
00001638  E20A                     841          LSR.B #1,D2
0000163A  C43C 0007                842          AND.B   #%00000111,D2           ;force recognition as a An
0000163E  5002                     843          ADDQ.B #%1000,D2
00001640  1A02                     844          MOVE.B  D2,D5
00001642  48E7 4000                845          MOVEM.L D1,-(SP)
00001646  6100 1204                846          BSR     Get_Effective_Address
0000164A  4CDF 0002                847          MOVEM.L (SP)+,D1
0000164E                           848          
0000164E  43F9 00002D56            849          LEA     clearLine,A1            ;move string for a CR and LF
00001654  103C 000E                850          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001658                           851                                ;string without CR, LF
00001658  4E4F                     852          TRAP    #15
0000165A                           853  
0000165A  7000                     854          MOVEQ.L #0,D0
0000165C  4E75                     855          RTS
0000165E                           856  
0000165E                           857  
0000165E                           858  
0000165E                           859  DIVS:
0000165E                           860  
0000165E  7000                     861          MOVEQ.L #0, D0                  ;clear D0
00001660                           862          
00001660                           863  validDivsModes:
00001660                           864          
00001660  43F9 000016F2            865          LEA mulsEAmasks,A1              ;load the list of masks
00001666  D3C0                     866          ADDA.L D0,A1                    ;displace to a specific mask
00001668  1A11                     867          MOVE.B (A1),D5                  ;move the mask to D5
0000166A                           868          
0000166A  0C05 0000                869          CMPI.B #0,D5                    ;check if the mask is 0
0000166E  6700 FA26                870          BEQ falsePositive               ;branch if it is
00001672                           871          
00001672  1401                     872          MOVE.B D1,D2                    ;copy instruction to D2
00001674  C405                     873          AND.B D5,D2                     ;mask D2
00001676                           874          
00001676  43F9 000016EA            875          LEA mulsEA,A1                   ;load the list of valid modes
0000167C  D3C0                     876          ADDA.L D0,A1                    ;displace to a specific mode
0000167E  1811                     877          MOVE.B (A1),D4                  ;move mode to D4
00001680  B404                     878          CMP.B D4,D2                     ;compare mode to masked value
00001682  6700 0006                879          BEQ  divsBody                   ;if its match, its a valid mode and we can procede
00001686                           880          
00001686  5280                     881          ADDQ.L #1,D0                    ;add one to displacement
00001688  60D6                     882          BRA validDivsModes              ;check for next mode
0000168A                           883          
0000168A                           884  divsBody:
0000168A                           885          
0000168A                           886  
0000168A                           887  
0000168A  43F9 00002D6F            888          LEA     divsMessage,A1          ;move string for MOVE
00001690  103C 000E                889          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001694                           890                                ;string without CR, LF
00001694  4E4F                     891          TRAP    #15
00001696                           892          
00001696                           893          ;set size to word
00001696  7C01                     894          MOVEQ.L #1,D6
00001698  6100 1350                895          BSR printSize
0000169C                           896          
0000169C                           897          ;do source EA
0000169C  3401                     898          MOVE.W  D1,D2                   ;check mode
0000169E  C43C 003F                899          AND.B   #%00111111,D2
000016A2  1A02                     900          MOVE.B  D2,D5
000016A4  48E7 4000                901          MOVEM.L D1,-(SP)
000016A8  6100 11A2                902          BSR     Get_Effective_Address
000016AC  4CDF 0002                903          MOVEM.L (SP)+,D1
000016B0                           904  
000016B0                           905          ;print ','
000016B0  48E7 4000                906          MOVEM.L D1,-(SP)                ;save D1 to the stack
000016B4  123C 002C                907          MOVE.B #',',D1                  ;put ascii value of char in D1
000016B8  103C 0006                908          MOVE.B #6,D0                    ;move task 6 into D0
000016BC  4E4F                     909          TRAP #15                        ;prin char
000016BE  4CDF 0002                910          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000016C2                           911          
000016C2                           912          ;do dest data reg
000016C2  3401                     913          MOVE.W  D1,D2                   ;check mode
000016C4  E04A                     914          LSR.W #8,D2                     ;shift reg over
000016C6  E20A                     915          LSR.B #1,D2
000016C8  C43C 0007                916          AND.B   #%00000111,D2           ;force recognition as a Dn
000016CC  1A02                     917          MOVE.B  D2,D5
000016CE  48E7 4000                918          MOVEM.L D1,-(SP)
000016D2  6100 1178                919          BSR     Get_Effective_Address
000016D6  4CDF 0002                920          MOVEM.L (SP)+,D1
000016DA                           921          
000016DA  43F9 00002D56            922          LEA     clearLine,A1            ;move string for a CR and LF
000016E0  103C 000E                923          MOVE.B  #14,D0                  ;set for task to display null terminated 
000016E4                           924                                ;string without CR, LF
000016E4  4E4F                     925          TRAP    #15
000016E6                           926  
000016E6  7000                     927          MOVEQ.L #0,D0
000016E8  4E75                     928          RTS
000016EA                           929  
000016EA                           930  
000016EA                           931  
000016EA                           932  
000016EA= 00 10 18 20 38 39 ...    933  mulsEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,%111100,0
000016F2= 38 38 38 38 3F 3F ...    934  mulsEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,%111111,0
000016FA                           935          
000016FA                           936  MULS:
000016FA                           937  
000016FA  7000                     938          MOVEQ.L #0, D0                  ;clear D0
000016FC                           939          
000016FC                           940  validMulsModes:
000016FC                           941          
000016FC  43F8 16F2                942          LEA mulsEAmasks,A1              ;load the list of masks
00001700  D3C0                     943          ADDA.L D0,A1                    ;displace to a specific mask
00001702  1A11                     944          MOVE.B (A1),D5                  ;move the mask to D5
00001704                           945          
00001704  0C05 0000                946          CMPI.B #0,D5                    ;check if the mask is 0
00001708  6700 F98C                947          BEQ falsePositive               ;branch if it is
0000170C                           948          
0000170C  1401                     949          MOVE.B D1,D2                    ;copy instruction to D2
0000170E  C405                     950          AND.B D5,D2                     ;mask D2
00001710                           951          
00001710  43F8 16EA                952          LEA mulsEA,A1                   ;load the list of valid modes
00001714  D3C0                     953          ADDA.L D0,A1                    ;displace to a specific mode
00001716  1811                     954          MOVE.B (A1),D4                  ;move mode to D4
00001718  B404                     955          CMP.B D4,D2                     ;compare mode to masked value
0000171A  6700 0006                956          BEQ  mulsBody                   ;if its match, its a valid mode and we can procede
0000171E                           957          
0000171E  5280                     958          ADDQ.L #1,D0                    ;add one to displacement
00001720  60DA                     959          BRA validMulsModes              ;check for next mode
00001722                           960          
00001722                           961  mulsBody:
00001722                           962          
00001722                           963  
00001722                           964  
00001722  43F9 00002D74            965          LEA     mulsMessage,A1          ;move string for MOVE
00001728  103C 000E                966          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000172C                           967                                ;string without CR, LF
0000172C  4E4F                     968          TRAP    #15
0000172E                           969          
0000172E                           970          ;set size to word
0000172E  7C01                     971          MOVEQ.L #1,D6
00001730  6100 12B8                972          BSR printSize
00001734                           973  
00001734                           974          ;do source EA
00001734  3401                     975          MOVE.W  D1,D2                   ;check mode
00001736  C43C 003F                976          AND.B   #%00111111,D2
0000173A  1A02                     977          MOVE.B  D2,D5
0000173C  48E7 4000                978          MOVEM.L D1,-(SP)
00001740  6100 110A                979          BSR     Get_Effective_Address
00001744  4CDF 0002                980          MOVEM.L (SP)+,D1
00001748                           981  
00001748                           982          ;print ','
00001748  48E7 4000                983          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000174C  123C 002C                984          MOVE.B #',',D1                  ;put ascii value of char in D1
00001750  103C 0006                985          MOVE.B #6,D0                    ;move task 6 into D0
00001754  4E4F                     986          TRAP #15                        ;prin char
00001756  4CDF 0002                987          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000175A                           988          
0000175A                           989          ;do dest data reg
0000175A  3401                     990          MOVE.W  D1,D2                   ;check mode
0000175C  E04A                     991          LSR.W #8,D2                     ;shift reg over
0000175E  E20A                     992          LSR.B #1,D2
00001760  C43C 0007                993          AND.B   #%00000111,D2           ;force recognition as a Dn
00001764  1A02                     994          MOVE.B  D2,D5
00001766  48E7 4000                995          MOVEM.L D1,-(SP)
0000176A  6100 10E0                996          BSR     Get_Effective_Address
0000176E  4CDF 0002                997          MOVEM.L (SP)+,D1
00001772                           998          
00001772  43F9 00002D56            999          LEA     clearLine,A1            ;move string for a CR and LF
00001778  103C 000E               1000          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000177C                          1001                                ;string without CR, LF
0000177C  4E4F                    1002          TRAP    #15
0000177E                          1003  
0000177E  7000                    1004          MOVEQ.L #0,D0
00001780  4E75                    1005          RTS
00001782                          1006  
00001782                          1007  
00001782                          1008  
00001782                          1009  RSRLWEA:
00001782                          1010          
00001782                          1011  
00001782                          1012          
00001782  7000                    1013          MOVEQ.L #0, D0                  ;clear D0
00001784                          1014          
00001784                          1015  validRSRL:
00001784                          1016          
00001784  43F9 000018D4           1017          LEA lsrlEAmasks,A1              ;load the list of masks
0000178A  D3C0                    1018          ADDA.L D0,A1                    ;displace to a specific mask
0000178C  1A11                    1019          MOVE.B (A1),D5                  ;move the mask to D5
0000178E                          1020          
0000178E  0C05 0000               1021          CMPI.B #0,D5                    ;check if the mask is 0
00001792  6700 F902               1022          BEQ falsePositive               ;branch if it is
00001796                          1023          
00001796  1401                    1024          MOVE.B D1,D2                    ;copy instruction to D2
00001798  C405                    1025          AND.B D5,D2                     ;mask D2
0000179A                          1026          
0000179A  43F9 000018CE           1027          LEA lsrlEA,A1                   ;load the list of valid modes
000017A0  D3C0                    1028          ADDA.L D0,A1                    ;displace to a specific mode
000017A2  1811                    1029          MOVE.B (A1),D4                  ;move mode to D4
000017A4  B404                    1030          CMP.B D4,D2                     ;compare mode to masked value
000017A6  6700 0006               1031          BEQ  rsrlweaCheckDirection      ;if its match, its a valid mode and we can procede
000017AA                          1032          
000017AA  5280                    1033          ADDQ.L #1,D0                    ;add one to displacement
000017AC  60D6                    1034          BRA validRSRL                   ;check for next mode
000017AE                          1035  
000017AE                          1036  rsrlweaCheckDirection:
000017AE                          1037          ;Figure out which direction we are going
000017AE  3401                    1038          MOVE.W D1,D2                    ;copy inst to D2
000017B0  E04A                    1039          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
000017B2  0202 0001               1040          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
000017B6  0C02 0000               1041          CMPI.B #0,D2                    ;compare bit to zero
000017BA  6700 0006               1042          BEQ RSREA                       ;if zero, right
000017BE  6000 0012               1043          BRA RSLEA                       ;else, its left
000017C2                          1044  
000017C2                          1045  RSREA:
000017C2                          1046  
000017C2  43F9 00002D7D           1047          LEA     rsrMessage,A1           ;move string for MOVE
000017C8  103C 000E               1048          MOVE.B  #14,D0                  ;set for task to display null terminated 
000017CC                          1049                                ;string with CR, LF
000017CC  4E4F                    1050          TRAP    #15
000017CE  6000 0166               1051          BRA lsrlweaBody
000017D2                          1052          
000017D2                          1053  RSLEA:
000017D2                          1054          
000017D2  43F9 00002D79           1055          LEA     rslMessage,A1           ;move string for MOVE
000017D8  103C 000E               1056          MOVE.B  #14,D0                  ;set for task to display null terminated 
000017DC                          1057                                ;string with CR, LF
000017DC  4E4F                    1058          TRAP    #15
000017DE  6000 0156               1059          BRA lsrlweaBody        
000017E2                          1060          
000017E2                          1061  
000017E2                          1062  
000017E2                          1063  RSRLREG:
000017E2                          1064          
000017E2                          1065  
000017E2                          1066          
000017E2  7000                    1067          MOVEQ.L #0, D0                  ;clear D0
000017E4                          1068          
000017E4                          1069          ;check valid size field
000017E4  3401                    1070          MOVE.W D1,D2                    ;copy inst to D2
000017E6  EC4A                    1071          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
000017E8  0202 0003               1072          ANDI.B #%00000011,D2            ;mask out rest of byte
000017EC  0C02 0003               1073          CMPI.B #%11,D2                  ;compare to 3
000017F0  6700 F8A4               1074          BEQ falsePositive               ;invalid size
000017F4                          1075  
000017F4                          1076          
000017F4                          1077          ;Figure out which direction we are going
000017F4  3401                    1078          MOVE.W D1,D2                    ;copy inst to D2
000017F6  E04A                    1079          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
000017F8  0202 0001               1080          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
000017FC  0C02 0000               1081          CMPI.B #0,D2                    ;compare bit to zero
00001800  6700 0006               1082          BEQ RSRreg                      ;if zero, right
00001804  6000 0012               1083          BRA RSLreg                      ;else, its left        
00001808                          1084          
00001808                          1085  RSRreg:
00001808                          1086  
00001808  43F9 00002D7D           1087          LEA     rsrMessage,A1           ;move string for MOVE
0000180E  103C 000E               1088          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001812                          1089                                ;string with CR, LF
00001812  4E4F                    1090          TRAP    #15
00001814  6000 019C               1091          BRA LSRLregBody
00001818                          1092          
00001818                          1093  RSLreg:
00001818                          1094          
00001818  43F9 00002D79           1095          LEA     rslMessage,A1           ;move string for MOVE
0000181E  103C 000E               1096          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001822                          1097                                ;string with CR, LF
00001822  4E4F                    1098          TRAP    #15
00001824  6000 018C               1099          BRA LSRLregBody
00001828                          1100  
00001828                          1101       
00001828                          1102  
00001828                          1103  ASRLWEA:
00001828                          1104          
00001828                          1105  
00001828                          1106          
00001828  7000                    1107          MOVEQ.L #0, D0                  ;clear D0
0000182A                          1108          
0000182A                          1109  validASRL:
0000182A                          1110          
0000182A  43F9 000018D4           1111          LEA lsrlEAmasks,A1              ;load the list of masks
00001830  D3C0                    1112          ADDA.L D0,A1                    ;displace to a specific mask
00001832  1A11                    1113          MOVE.B (A1),D5                  ;move the mask to D5
00001834                          1114          
00001834  0C05 0000               1115          CMPI.B #0,D5                    ;check if the mask is 0
00001838  6700 F85C               1116          BEQ falsePositive               ;branch if it is
0000183C                          1117          
0000183C  1401                    1118          MOVE.B D1,D2                    ;copy instruction to D2
0000183E  C405                    1119          AND.B D5,D2                     ;mask D2
00001840                          1120          
00001840  43F9 000018CE           1121          LEA lsrlEA,A1                   ;load the list of valid modes
00001846  D3C0                    1122          ADDA.L D0,A1                    ;displace to a specific mode
00001848  1811                    1123          MOVE.B (A1),D4                  ;move mode to D4
0000184A  B404                    1124          CMP.B D4,D2                     ;compare mode to masked value
0000184C  6700 0006               1125          BEQ  asrlweaCheckDirection      ;if its match, its a valid mode and we can procede
00001850                          1126          
00001850  5280                    1127          ADDQ.L #1,D0                    ;add one to displacement
00001852  60D6                    1128          BRA validASRL                   ;check for next mode
00001854                          1129  
00001854                          1130  asrlweaCheckDirection:
00001854                          1131          ;Figure out which direction we are going
00001854  3401                    1132          MOVE.W D1,D2                    ;copy inst to D2
00001856  E04A                    1133          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
00001858  0202 0001               1134          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
0000185C  0C02 0000               1135          CMPI.B #0,D2                    ;compare bit to zero
00001860  6700 0006               1136          BEQ ASREA                       ;if zero, right
00001864  6000 0012               1137          BRA ASLEA                       ;else, its left
00001868                          1138  
00001868                          1139  ASREA:
00001868                          1140  
00001868  43F9 00002D85           1141          LEA     asrMessage,A1           ;move string for MOVE
0000186E  103C 000E               1142          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001872                          1143                                ;string with CR, LF
00001872  4E4F                    1144          TRAP    #15
00001874  6000 00C0               1145          BRA lsrlweaBody
00001878                          1146          
00001878                          1147  ASLEA:
00001878                          1148          
00001878  43F9 00002D81           1149          LEA     aslMessage,A1           ;move string for MOVE
0000187E  103C 000E               1150          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001882                          1151                                ;string with CR, LF
00001882  4E4F                    1152          TRAP    #15
00001884  6000 00B0               1153          BRA lsrlweaBody        
00001888                          1154          
00001888                          1155  
00001888                          1156  
00001888                          1157  ASRLREG:
00001888                          1158          
00001888                          1159  
00001888                          1160          
00001888  7000                    1161          MOVEQ.L #0, D0                  ;clear D0
0000188A                          1162          
0000188A                          1163          ;check valid size field
0000188A  3401                    1164          MOVE.W D1,D2                    ;copy inst to D2
0000188C  EC4A                    1165          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
0000188E  0202 0003               1166          ANDI.B #%00000011,D2            ;mask out rest of byte
00001892  0C02 0003               1167          CMPI.B #%11,D2                  ;compare to 3
00001896  6700 F7FE               1168          BEQ falsePositive               ;invalid size
0000189A                          1169  
0000189A                          1170          
0000189A                          1171          ;Figure out which direction we are going
0000189A  3401                    1172          MOVE.W D1,D2                    ;copy inst to D2
0000189C  E04A                    1173          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
0000189E  0202 0001               1174          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
000018A2  0C02 0000               1175          CMPI.B #0,D2                    ;compare bit to zero
000018A6  6700 0006               1176          BEQ ASRreg                      ;if zero, right
000018AA  6000 0012               1177          BRA ASLreg                      ;else, its left        
000018AE                          1178          
000018AE                          1179  ASRreg:
000018AE                          1180  
000018AE  43F9 00002D85           1181          LEA     asrMessage,A1           ;move string for MOVE
000018B4  103C 000E               1182          MOVE.B  #14,D0                  ;set for task to display null terminated 
000018B8                          1183                                ;string with CR, LF
000018B8  4E4F                    1184          TRAP    #15
000018BA  6000 00F6               1185          BRA LSRLregBody
000018BE                          1186          
000018BE                          1187  ASLreg:
000018BE                          1188          
000018BE  43F9 00002D81           1189          LEA     aslMessage,A1           ;move string for MOVE
000018C4  103C 000E               1190          MOVE.B  #14,D0                  ;set for task to display null terminated 
000018C8                          1191                                ;string with CR, LF
000018C8  4E4F                    1192          TRAP    #15
000018CA  6000 00E6               1193          BRA LSRLregBody
000018CE                          1194  
000018CE                          1195  
000018CE= 10 18 20 38 39 00       1196  lsrlEA        DC.B %010000,%011000,%100000,%111000,%111001,0
000018D4= 38 38 38 3F 3F 00       1197  lsrlEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0       
000018DA                          1198  
000018DA                          1199  LSRLWEA:
000018DA                          1200          
000018DA                          1201  
000018DA                          1202          
000018DA  7000                    1203          MOVEQ.L #0, D0                  ;clear D0
000018DC                          1204          
000018DC                          1205  validLSRL:
000018DC                          1206          
000018DC  43F8 18D4               1207          LEA lsrlEAmasks,A1              ;load the list of masks
000018E0  D3C0                    1208          ADDA.L D0,A1                    ;displace to a specific mask
000018E2  1A11                    1209          MOVE.B (A1),D5                  ;move the mask to D5
000018E4                          1210          
000018E4  0C05 0000               1211          CMPI.B #0,D5                    ;check if the mask is 0
000018E8  6700 F7AC               1212          BEQ falsePositive               ;branch if it is
000018EC                          1213          
000018EC  1401                    1214          MOVE.B D1,D2                    ;copy instruction to D2
000018EE  C405                    1215          AND.B D5,D2                     ;mask D2
000018F0                          1216          
000018F0  43F8 18CE               1217          LEA lsrlEA,A1                   ;load the list of valid modes
000018F4  D3C0                    1218          ADDA.L D0,A1                    ;displace to a specific mode
000018F6  1811                    1219          MOVE.B (A1),D4                  ;move mode to D4
000018F8  B404                    1220          CMP.B D4,D2                     ;compare mode to masked value
000018FA  6700 0006               1221          BEQ  lsrlweaCheckDirection      ;if its match, its a valid mode and we can procede
000018FE                          1222          
000018FE  5280                    1223          ADDQ.L #1,D0                    ;add one to displacement
00001900  60DA                    1224          BRA validLSRL                   ;check for next mode
00001902                          1225  
00001902                          1226  lsrlweaCheckDirection:
00001902                          1227          ;Figure out which direction we are going
00001902  3401                    1228          MOVE.W D1,D2                    ;copy inst to D2
00001904  E04A                    1229          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
00001906  0202 0001               1230          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
0000190A  0C02 0000               1231          CMPI.B #0,D2                    ;compare bit to zero
0000190E  6700 0006               1232          BEQ LSREA                       ;if zero, right
00001912  6000 0012               1233          BRA LSLEA                       ;else, its left
00001916                          1234  
00001916                          1235  LSREA:
00001916                          1236  
00001916  43F9 00002D8D           1237          LEA     lsrMessage,A1           ;move string for MOVE
0000191C  103C 000E               1238          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001920                          1239                                ;string with CR, LF
00001920  4E4F                    1240          TRAP    #15
00001922  6000 0012               1241          BRA lsrlweaBody
00001926                          1242          
00001926                          1243  LSLEA:
00001926                          1244          
00001926  43F9 00002D89           1245          LEA     lslMessage,A1           ;move string for MOVE
0000192C  103C 000E               1246          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001930                          1247                                ;string with CR, LF
00001930  4E4F                    1248          TRAP    #15
00001932  6000 0002               1249          BRA lsrlweaBody        
00001936                          1250          
00001936                          1251  lsrlweaBody:
00001936                          1252          
00001936                          1253          ;print ' '
00001936  48E7 4000               1254          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000193A  123C 0020               1255          MOVE.B #' ',D1                  ;put ascii value of char in D1
0000193E  103C 0006               1256          MOVE.B #6,D0                    ;move task 6 into D0
00001942  4E4F                    1257          TRAP #15                        ;print char
00001944  4CDF 0002               1258          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001948                          1259          
00001948  3401                    1260          MOVE.W  D1,D2                   ;check mode
0000194A  C43C 003F               1261          AND.B   #%00111111,D2
0000194E  1A02                    1262          MOVE.B  D2,D5
00001950  48E7 4000               1263          MOVEM.L D1,-(SP)
00001954  6100 0EF6               1264          BSR     Get_Effective_Address
00001958  4CDF 0002               1265          MOVEM.L (SP)+,D1
0000195C                          1266          
0000195C                          1267          
0000195C  43F9 00002D56           1268          LEA     clearLine,A1            ;move string for a CR and LF
00001962  103C 000E               1269          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001966                          1270                                ;string without CR, LF
00001966  4E4F                    1271          TRAP    #15
00001968                          1272  
00001968  7000                    1273          MOVEQ.L #0,D0
0000196A  4E75                    1274          RTS
0000196C                          1275  
0000196C                          1276  
0000196C                          1277  LSRLREG:
0000196C                          1278          
0000196C                          1279  
0000196C                          1280          
0000196C  7000                    1281          MOVEQ.L #0, D0                  ;clear D0
0000196E                          1282          
0000196E                          1283          ;check valid size field
0000196E  3401                    1284          MOVE.W D1,D2                    ;copy inst to D2
00001970  EC4A                    1285          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
00001972  0202 0003               1286          ANDI.B #%00000011,D2            ;mask out rest of byte
00001976  0C02 0003               1287          CMPI.B #%11,D2                  ;compare to 3
0000197A  6700 F71A               1288          BEQ falsePositive               ;invalid size
0000197E                          1289  
0000197E                          1290          
0000197E                          1291          ;Figure out which direction we are going
0000197E  3401                    1292          MOVE.W D1,D2                    ;copy inst to D2
00001980  E04A                    1293          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
00001982  0202 0001               1294          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
00001986  0C02 0000               1295          CMPI.B #0,D2                    ;compare bit to zero
0000198A  6700 0006               1296          BEQ LSRreg                      ;if zero, right
0000198E  6000 0012               1297          BRA LSLreg                      ;else, its left        
00001992                          1298          
00001992                          1299  LSRreg:
00001992                          1300  
00001992  43F9 00002D8D           1301          LEA     lsrMessage,A1           ;move string for MOVE
00001998  103C 000E               1302          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000199C                          1303                                ;string with CR, LF
0000199C  4E4F                    1304          TRAP    #15
0000199E  6000 0012               1305          BRA LSRLregBody
000019A2                          1306          
000019A2                          1307  LSLreg:
000019A2                          1308          
000019A2  43F9 00002D89           1309          LEA     lslMessage,A1           ;move string for MOVE
000019A8  103C 000E               1310          MOVE.B  #14,D0                  ;set for task to display null terminated 
000019AC                          1311                                ;string with CR, LF
000019AC  4E4F                    1312          TRAP    #15
000019AE  6000 0002               1313          BRA LSRLregBody
000019B2                          1314          
000019B2                          1315  LSRLregBody:
000019B2                          1316          
000019B2  6100 07B8               1317          BSR negSize        
000019B6                          1318              
000019B6                          1319          ;check i/r
000019B6  48E7 4000               1320          MOVEM.L D1,-(SP)
000019BA  6100 003C               1321          BSR LSRLcheckIR
000019BE  4CDF 0002               1322          MOVEM.L (SP)+,D1
000019C2                          1323          
000019C2                          1324          ;print ','
000019C2  48E7 4000               1325          MOVEM.L D1,-(SP)                ;save D1 to the stack
000019C6  123C 002C               1326          MOVE.B #',',D1                  ;put ascii value of char in D1
000019CA  103C 0006               1327          MOVE.B #6,D0                    ;move task 6 into D0
000019CE  4E4F                    1328          TRAP #15                        ;prin char
000019D0  4CDF 0002               1329          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000019D4                          1330          
000019D4  3401                    1331          MOVE.W  D1,D2                   ;check mode
000019D6  C43C 0007               1332          AND.B   #%00000111,D2
000019DA  1A02                    1333          MOVE.B  D2,D5
000019DC  48E7 4000               1334          MOVEM.L D1,-(SP)
000019E0  6100 0E6A               1335          BSR     Get_Effective_Address
000019E4  4CDF 0002               1336          MOVEM.L (SP)+,D1
000019E8                          1337          
000019E8                          1338          
000019E8  43F9 00002D56           1339          LEA     clearLine,A1            ;move string for a CR and LF
000019EE  103C 000E               1340          MOVE.B  #14,D0                  ;set for task to display null terminated 
000019F2                          1341                                ;string without CR, LF
000019F2  4E4F                    1342          TRAP    #15
000019F4                          1343  
000019F4  7000                    1344          MOVEQ.L #0,D0
000019F6  4E75                    1345          RTS
000019F8                          1346  
000019F8                          1347  LSRLcheckIR:
000019F8                          1348  
000019F8  1401                    1349          MOVE.B D1,D2                    ;move inst to D2
000019FA  EA0A                    1350          LSR.B  #5,D2
000019FC  C43C 0001               1351          AND.B  #%00000001,D2
00001A00  0C02 0000               1352          CMPI.B #0,D2
00001A04  6700 0008               1353          BEQ  LSRLcheckI
00001A08  6000 0038               1354          BRA  LSRLcheckR
00001A0C                          1355  LSRLcheckIRreturn:
00001A0C  4E75                    1356          RTS
00001A0E                          1357          
00001A0E                          1358  LSRLcheckI:
00001A0E                          1359          ;print '#'
00001A0E  48E7 4000               1360          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001A12  123C 0023               1361          MOVE.B #'#',D1                  ;put ascii value of '#' in D1
00001A16  103C 0006               1362          MOVE.B #6,D0                    ;move task 6 into D0
00001A1A  4E4F                    1363          TRAP #15                        ;prin char
00001A1C  4CDF 0002               1364          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001A20                          1365          
00001A20                          1366          
00001A20                          1367          ;print number
00001A20  48E7 4000               1368          MOVEM.L D1,-(SP)
00001A24  3401                    1369          MOVE.W D1,D2                    ;copy inst to d2
00001A26  E04A                    1370          LSR.W #8,D2                     ;shift data section
00001A28  E20A                    1371          LSR.B #1,D2
00001A2A  C43C 0007               1372          AND.B #%00000111,D2             ;mask out rest of data
00001A2E  6100 00EC               1373          BSR ZeroToEight                 ;handle zero
00001A32  7200                    1374          MOVEQ.L #0,D1                   ;clear D1
00001A34  1202                    1375          MOVE.B D2,D1                    ;move number to display into D1
00001A36  103C 0003               1376          MOVE.B #3,D0                    ;move task 3 to D0
00001A3A  4E4F                    1377          TRAP #15
00001A3C  4CDF 0002               1378          MOVEM.L (SP)+,D1
00001A40  60CA                    1379          BRA LSRLcheckIRreturn
00001A42                          1380          
00001A42                          1381  LSRLcheckR:
00001A42  3401                    1382          MOVE.W D1,D2                    ;copy inst to d2
00001A44  E04A                    1383          LSR.W #8,D2                     ;shift data section
00001A46  E20A                    1384          LSR.B #1,D2
00001A48  C43C 0007               1385          AND.B #%00000111,D2             ;mask out rest of data
00001A4C  1A02                    1386          MOVE.B D2,D5                    ;force Dn
00001A4E  48E7 4000               1387          MOVEM.L D1,-(SP)
00001A52  6100 0DF8               1388          BSR     Get_Effective_Address
00001A56  4CDF 0002               1389          MOVEM.L (SP)+,D1
00001A5A  60B0                    1390          BRA LSRLcheckIRreturn
00001A5C                          1391          
00001A5C= 00 08 10 18 20 38 ...   1392  subqEA        DC.B %000000,%001000,%010000,%011000,%100000,%111000,%111001,0
00001A64= 38 38 38 38 38 3F ...   1393  subqEAmasks   DC.B %111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001A6C                          1394  
00001A6C                          1395  SUBQ:
00001A6C                          1396          
00001A6C                          1397  
00001A6C                          1398          
00001A6C  7000                    1399          MOVEQ.L #0, D0                  ;clear D0
00001A6E                          1400          
00001A6E                          1401          ;check valid size field
00001A6E  3401                    1402          MOVE.W D1,D2                    ;copy inst to D2
00001A70  EC4A                    1403          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
00001A72  0202 0003               1404          ANDI.B #%00000011,D2            ;mask out rest of byte
00001A76  0C02 0003               1405          CMPI.B #%11,D2                  ;compare to 3
00001A7A  6700 F61A               1406          BEQ falsePositive               ;invalid size
00001A7E                          1407          
00001A7E                          1408  validSubq:
00001A7E                          1409          
00001A7E  43F8 1A64               1410          LEA subqEAmasks,A1              ;load the list of masks
00001A82  D3C0                    1411          ADDA.L D0,A1                    ;displace to a specific mask
00001A84  1A11                    1412          MOVE.B (A1),D5                  ;move the mask to D5
00001A86                          1413          
00001A86  0C05 0000               1414          CMPI.B #0,D5                    ;check if the mask is 0
00001A8A  6700 F60A               1415          BEQ falsePositive               ;branch if it is
00001A8E                          1416          
00001A8E  1401                    1417          MOVE.B D1,D2                    ;copy instruction to D2
00001A90  C405                    1418          AND.B D5,D2                     ;mask D2
00001A92                          1419          
00001A92  43F8 1A5C               1420          LEA subqEA,A1                   ;load the list of valid modes
00001A96  D3C0                    1421          ADDA.L D0,A1                    ;displace to a specific mode
00001A98  1811                    1422          MOVE.B (A1),D4                  ;move mode to D4
00001A9A  B404                    1423          CMP.B D4,D2                     ;compare mode to masked value
00001A9C  6700 0006               1424          BEQ  subqBody                   ;if its match, its a valid mode and we can procede
00001AA0                          1425          
00001AA0  5280                    1426          ADDQ.L #1,D0                    ;add one to displacement
00001AA2  60DA                    1427          BRA validSubq                   ;check for next mode
00001AA4                          1428          
00001AA4                          1429          
00001AA4                          1430  subqBody
00001AA4                          1431  
00001AA4  43F9 00002D91           1432          LEA     subqMessage,A1          ;move string for MOVE
00001AAA  103C 000E               1433          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001AAE                          1434                                ;string with CR, LF
00001AAE  4E4F                    1435          TRAP    #15
00001AB0                          1436          
00001AB0  6100 06BA               1437          BSR negSize
00001AB4                          1438          
00001AB4                          1439          ;immediate data
00001AB4                          1440          
00001AB4                          1441          ;print '#'
00001AB4  48E7 4000               1442          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001AB8  123C 0023               1443          MOVE.B #'#',D1                  ;put ascii value of '#' in D1
00001ABC  103C 0006               1444          MOVE.B #6,D0                    ;move task 6 into D0
00001AC0  4E4F                    1445          TRAP #15                        ;prin char
00001AC2  4CDF 0002               1446          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001AC6                          1447          
00001AC6                          1448          ;print number
00001AC6  48E7 4000               1449          MOVEM.L D1,-(SP)
00001ACA  3401                    1450          MOVE.W D1,D2                    ;copy inst to d2
00001ACC  E04A                    1451          LSR.W #8,D2                     ;shift data section
00001ACE  E20A                    1452          LSR.B #1,D2
00001AD0  C43C 0007               1453          AND.B #%00000111,D2             ;mask out rest of data
00001AD4  6100 0046               1454          BSR ZeroToEight                 ;handle zero
00001AD8  7200                    1455          MOVEQ.L #0,D1                   ;clear D1
00001ADA  1202                    1456          MOVE.B D2,D1                    ;move number to display into D1
00001ADC  103C 0003               1457          MOVE.B #3,D0                    ;move task 3 to D0
00001AE0  4E4F                    1458          TRAP #15
00001AE2  4CDF 0002               1459          MOVEM.L (SP)+,D1
00001AE6                          1460          
00001AE6                          1461          ;print ','
00001AE6  48E7 4000               1462          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001AEA  123C 002C               1463          MOVE.B #',',D1                  ;put ascii value of char in D1
00001AEE  103C 0006               1464          MOVE.B #6,D0                    ;move task 6 into D0
00001AF2  4E4F                    1465          TRAP #15                        ;prin char
00001AF4  4CDF 0002               1466          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001AF8                          1467          
00001AF8                          1468          ;Then do EA
00001AF8                          1469          
00001AF8  3401                    1470          MOVE.W  D1,D2                   ;check mode
00001AFA  C43C 003F               1471          AND.B   #%00111111,D2
00001AFE  1A02                    1472          MOVE.B  D2,D5
00001B00  48E7 4000               1473          MOVEM.L D1,-(SP)
00001B04  6100 0D46               1474          BSR     Get_Effective_Address
00001B08  4CDF 0002               1475          MOVEM.L (SP)+,D1
00001B0C                          1476          
00001B0C  43F9 00002D56           1477          LEA     clearLine,A1            ;move string for a CR and LF
00001B12  103C 000E               1478          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001B16                          1479                                ;string without CR, LF
00001B16  4E4F                    1480          TRAP    #15
00001B18                          1481  
00001B18  7000                    1482          MOVEQ.L #0,D0
00001B1A  4E75                    1483          RTS
00001B1C                          1484          
00001B1C                          1485  ZeroToEight:
00001B1C                          1486          
00001B1C  0C02 0000               1487          CMPI.B #0,D2
00001B20  6700 0004               1488          BEQ toEight
00001B24                          1489  ZeroToEightReturn:
00001B24                          1490          
00001B24  4E75                    1491          RTS
00001B26                          1492  toEight:
00001B26                          1493          
00001B26  5002                    1494          ADDQ.B #8,D2
00001B28  60FA                    1495          BRA ZeroToEightReturn
00001B2A                          1496  
00001B2A                          1497      
00001B2A                          1498  SUB:
00001B2A                          1499          
00001B2A                          1500  
00001B2A                          1501          
00001B2A  7000                    1502          MOVEQ.L #0, D0                  ;clear D0
00001B2C                          1503          
00001B2C                          1504          ;Figure out if EA is source or destination
00001B2C  3401                    1505          MOVE.W D1,D2                    ;copy inst to D2
00001B2E  EC4A                    1506          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001B30  0202 0007               1507          ANDI.B #%00000111,D2            ;mask out rest of byte
00001B34  0C02 0002               1508          CMPI.B #2,D2                    ;compare to 2
00001B38  6F00 0016               1509          BLE validSubSourceEA            ;2 or less is EA is source
00001B3C                          1510          
00001B3C  0C02 0007               1511          CMPI.B #%111,D2                 ;compare to 7
00001B40  6700 F554               1512          BEQ falsePositive               ;thats not valid
00001B44  0C02 0003               1513          CMPI.B #%11,D2                  ;compare to 3
00001B48  6700 F54C               1514          BEQ falsePositive               ;also not valid
00001B4C  6000 002C               1515          BRA validSubDestEA              ;all thats left is valid EA as Dest 
00001B50                          1516          
00001B50                          1517  validSubSourceEA:
00001B50                          1518          
00001B50  43F9 000023C3           1519          LEA moveSourceEAmasks,A1        ;load the list of masks
00001B56  D3C0                    1520          ADDA.L D0,A1                    ;displace to a specific mask
00001B58  1A11                    1521          MOVE.B (A1),D5                  ;move the mask to D5
00001B5A                          1522          
00001B5A  0C05 0000               1523          CMPI.B #0,D5                    ;check if the mask is 0
00001B5E  6700 F536               1524          BEQ falsePositive               ;branch if it is
00001B62                          1525          
00001B62  1401                    1526          MOVE.B D1,D2                    ;copy instruction to D2
00001B64  C405                    1527          AND.B D5,D2                     ;mask D2
00001B66                          1528          
00001B66  43F9 000023BA           1529          LEA moveSourceEA,A1             ;load the list of valid modes
00001B6C  D3C0                    1530          ADDA.L D0,A1                    ;displace to a specific mode
00001B6E  1811                    1531          MOVE.B (A1),D4                  ;move mode to D4
00001B70  B404                    1532          CMP.B D4,D2                     ;compare mode to masked value
00001B72  6700 0030               1533          BEQ  subSource                  ;if its match, its a valid mode and we can procede
00001B76                          1534          
00001B76  5280                    1535          ADDQ.L #1,D0                    ;add one to displacement
00001B78  60D6                    1536          BRA validSubSourceEA            ;check for next mode
00001B7A                          1537          
00001B7A                          1538          
00001B7A                          1539  validSubDestEA:
00001B7A                          1540          
00001B7A  43F9 00001D20           1541          LEA addDestEAmasks,A1           ;load the list of masks
00001B80  D3C0                    1542          ADDA.L D0,A1                    ;displace to a specific mask
00001B82  1A11                    1543          MOVE.B (A1),D5                  ;move the mask to D5
00001B84                          1544          
00001B84  0C05 0000               1545          CMPI.B #0,D5                    ;check if the mask is 0
00001B88  6700 F50C               1546          BEQ falsePositive               ;branch if it is
00001B8C                          1547          
00001B8C  3401                    1548          MOVE.W D1,D2                    ;copy instruction to D2
00001B8E  C405                    1549          AND.B D5,D2                     ;mask D2
00001B90                          1550          
00001B90  43F9 00001D1A           1551          LEA addDestEA,A1                ;load the list of valid modes
00001B96  D3C0                    1552          ADDA.L D0,A1                    ;displace to a specific mode
00001B98  1811                    1553          MOVE.B (A1),D4                  ;move mode to D4
00001B9A  B404                    1554          CMP.B D4,D2                     ;compare mode to masked value
00001B9C  6700 0064               1555          BEQ subDest                     ;if its match, its a valid mode and we can procede
00001BA0                          1556          
00001BA0  5280                    1557          ADDQ.L #1,D0                    ;add one to displacement
00001BA2  60D6                    1558          BRA validSubDestEA              ;check for next mode
00001BA4                          1559          
00001BA4                          1560  subSource
00001BA4                          1561  
00001BA4  43F9 00002D96           1562          LEA     subMessage,A1           ;move string for MOVE
00001BAA  103C 000E               1563          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001BAE                          1564                                ;string with CR, LF
00001BAE  4E4F                    1565          TRAP    #15
00001BB0                          1566          
00001BB0  6100 05BA               1567          BSR negSize
00001BB4                          1568          
00001BB4                          1569          ;do EA
00001BB4                          1570          
00001BB4  3401                    1571          MOVE.W  D1,D2                   ;check mode
00001BB6  C43C 003F               1572          AND.B   #%00111111,D2
00001BBA  1A02                    1573          MOVE.B  D2,D5
00001BBC  48E7 4000               1574          MOVEM.L D1,-(SP)
00001BC0  6100 0C8A               1575          BSR     Get_Effective_Address
00001BC4  4CDF 0002               1576          MOVEM.L (SP)+,D1
00001BC8                          1577          
00001BC8                          1578          ;print ','
00001BC8  48E7 4000               1579          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001BCC  123C 002C               1580          MOVE.B #',',D1                  ;put ascii value of char in D1
00001BD0  103C 0006               1581          MOVE.B #6,D0                    ;move task 6 into D0
00001BD4  4E4F                    1582          TRAP #15                        ;prin char
00001BD6  4CDF 0002               1583          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001BDA                          1584          
00001BDA                          1585          ;Then do Dn
00001BDA                          1586          
00001BDA  3401                    1587          MOVE.W  D1,D2
00001BDC  E04A                    1588          LSR.W   #8,D2                   ;move reg into first byte
00001BDE  E20A                    1589          LSR.B   #1,D2                   ;line it up to least sig bit
00001BE0  C43C 0007               1590          AND.B   #%00000111,D2           ;force mode to Dn
00001BE4  1A02                    1591          MOVE.B  D2,D5
00001BE6  48E7 4000               1592          MOVEM.L D1,-(SP)
00001BEA  6100 0C60               1593          BSR     Get_Effective_Address
00001BEE  4CDF 0002               1594          MOVEM.L (SP)+,D1
00001BF2                          1595          
00001BF2  43F9 00002D56           1596          LEA     clearLine,A1            ;move string for a CR and LF
00001BF8  103C 000E               1597          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001BFC                          1598          ;string without CR, LF
00001BFC  4E4F                    1599          TRAP    #15
00001BFE                          1600  
00001BFE  7000                    1601          MOVEQ.L #0,D0
00001C00  4E75                    1602          RTS
00001C02                          1603  
00001C02                          1604  subDest
00001C02                          1605  
00001C02  43F9 00002D96           1606          LEA     subMessage,A1           ;move string for MOVE
00001C08  103C 000E               1607          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001C0C                          1608                                          ;string with CR, LF
00001C0C  4E4F                    1609          TRAP    #15
00001C0E                          1610          
00001C0E  6100 055C               1611          BSR negSize
00001C12                          1612          
00001C12                          1613          ;Do Dn
00001C12                          1614          
00001C12  3401                    1615          MOVE.W  D1,D2
00001C14  E04A                    1616          LSR.W   #8,D2                   ;move reg into first byte
00001C16  E20A                    1617          LSR.B   #1,D2                   ;line it up to least sig bit
00001C18  C43C 0007               1618          AND.B   #%00000111,D2           ;force mode to Dn
00001C1C  1A02                    1619          MOVE.B  D2,D5
00001C1E  48E7 4000               1620          MOVEM.L D1,-(SP)
00001C22  6100 0C28               1621          BSR     Get_Effective_Address
00001C26  4CDF 0002               1622          MOVEM.L (SP)+,D1
00001C2A                          1623          
00001C2A                          1624          
00001C2A                          1625          ;print ','
00001C2A  48E7 4000               1626          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001C2E  123C 002C               1627          MOVE.B #',',D1                  ;put ascii value of char in D1
00001C32  103C 0006               1628          MOVE.B #6,D0                    ;move task 6 into D0
00001C36  4E4F                    1629          TRAP #15                        ;prin char
00001C38  4CDF 0002               1630          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001C3C                          1631          
00001C3C                          1632          ;Then do EA
00001C3C                          1633          
00001C3C  3401                    1634          MOVE.W  D1,D2                   ;check mode
00001C3E  C43C 003F               1635          AND.B   #%00111111,D2
00001C42  1A02                    1636          MOVE.B  D2,D5
00001C44  48E7 4000               1637          MOVEM.L D1,-(SP)
00001C48  6100 0C02               1638          BSR     Get_Effective_Address
00001C4C  4CDF 0002               1639          MOVEM.L (SP)+,D1
00001C50                          1640          
00001C50                          1641          
00001C50  43F9 00002D56           1642          LEA     clearLine,A1            ;move string for a CR and LF
00001C56  103C 000E               1643          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001C5A                          1644          ;string without CR, LF
00001C5A  4E4F                    1645          TRAP    #15
00001C5C                          1646  
00001C5C  7000                    1647          MOVEQ.L #0,D0
00001C5E  4E75                    1648          RTS
00001C60                          1649  
00001C60                          1650  
00001C60                          1651  ADDA:
00001C60                          1652          
00001C60                          1653  
00001C60                          1654          
00001C60  7000                    1655          MOVEQ.L #0, D0                  ;clear D0
00001C62                          1656          
00001C62                          1657          ;check opmode field
00001C62  3401                    1658          MOVE.W D1,D2                    ;copy inst to D2
00001C64  EC4A                    1659          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001C66  0202 0007               1660          ANDI.B #%00000111,D2            ;mask out rest of byte
00001C6A  0C02 0007               1661          CMPI.B #%111,D2                 ;compare to 7
00001C6E  6700 000E               1662          BEQ validAdda                   ;thats valid
00001C72  0C02 0003               1663          CMPI.B #%11,D2                  ;compare to 3
00001C76  6700 0006               1664          BEQ validAdda                   ;also valid
00001C7A  6000 F41A               1665          BRA falsePositive               ;all thats left is invalid 
00001C7E                          1666          
00001C7E                          1667  validAdda:
00001C7E                          1668          
00001C7E  43F9 000023C3           1669          LEA moveSourceEAmasks,A1        ;load the list of masks
00001C84  D3C0                    1670          ADDA.L D0,A1                    ;displace to a specific mask
00001C86  1A11                    1671          MOVE.B (A1),D5                  ;move the mask to D5
00001C88                          1672          
00001C88  0C05 0000               1673          CMPI.B #0,D5                    ;check if the mask is 0
00001C8C  6700 F408               1674          BEQ falsePositive               ;branch if it is
00001C90                          1675          
00001C90  1401                    1676          MOVE.B D1,D2                    ;copy instruction to D2
00001C92  C405                    1677          AND.B D5,D2                     ;mask D2
00001C94                          1678          
00001C94  43F9 000023BA           1679          LEA moveSourceEA,A1             ;load the list of valid modes
00001C9A  D3C0                    1680          ADDA.L D0,A1                    ;displace to a specific mode
00001C9C  1811                    1681          MOVE.B (A1),D4                  ;move mode to D4
00001C9E  B404                    1682          CMP.B D4,D2                     ;compare mode to masked value
00001CA0  6700 0006               1683          BEQ  addaBody                   ;if its match, its a valid mode and we can procede
00001CA4                          1684          
00001CA4  5280                    1685          ADDQ.L #1,D0                    ;add one to displacement
00001CA6  60D6                    1686          BRA validAdda                   ;check for next mode
00001CA8                          1687          
00001CA8                          1688          
00001CA8                          1689  addaBody
00001CA8                          1690  
00001CA8  43F9 00002D9A           1691          LEA     addaMessage,A1          ;move string for MOVE
00001CAE  103C 000E               1692          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001CB2                          1693          ;string with CR, LF
00001CB2  4E4F                    1694          TRAP    #15
00001CB4                          1695          
00001CB4                          1696          ;size
00001CB4  48E7 4000               1697          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001CB8                          1698          ;make it look like NEG's size
00001CB8  E449                    1699          LSR.W #2,D1                     ;shift opmode bits over to use them as size
00001CBA  C23C 007F               1700          AND.B #%01111111,D1             ;clear bit next to size
00001CBE  0641 0040               1701          ADDI.W #%01000000,D1            ;add 1 to size to make it look like a word or long
00001CC2  6100 04A8               1702          BSR negSize
00001CC6  4CDF 0002               1703          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001CCA                          1704          
00001CCA                          1705          ;do EA
00001CCA                          1706          
00001CCA  3401                    1707          MOVE.W  D1,D2                   ;check mode
00001CCC  C43C 003F               1708          AND.B   #%00111111,D2
00001CD0  1A02                    1709          MOVE.B  D2,D5
00001CD2  48E7 4000               1710          MOVEM.L D1,-(SP)
00001CD6  6100 0B74               1711          BSR     Get_Effective_Address
00001CDA  4CDF 0002               1712          MOVEM.L (SP)+,D1
00001CDE                          1713          
00001CDE                          1714          ;print ','
00001CDE  48E7 4000               1715          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001CE2  123C 002C               1716          MOVE.B #',',D1                  ;put ascii value of char in D1
00001CE6  103C 0006               1717          MOVE.B #6,D0                    ;move task 6 into D0
00001CEA  4E4F                    1718          TRAP #15                        ;prin char
00001CEC  4CDF 0002               1719          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001CF0                          1720          
00001CF0                          1721          ;Then do Dn
00001CF0                          1722          
00001CF0  3401                    1723          MOVE.W  D1,D2
00001CF2  E04A                    1724          LSR.W   #8,D2                   ;move reg into first byte
00001CF4  E20A                    1725          LSR.B   #1,D2                   ;line it up to least sig bit
00001CF6  C43C 0007               1726          AND.B   #%00000111,D2           ;force mode to An
00001CFA  5002                    1727          ADDI.B  #%00001000,D2 
00001CFC  1A02                    1728          MOVE.B  D2,D5
00001CFE  48E7 4000               1729          MOVEM.L D1,-(SP)
00001D02  6100 0B48               1730          BSR     Get_Effective_Address
00001D06  4CDF 0002               1731          MOVEM.L (SP)+,D1
00001D0A                          1732          
00001D0A  43F9 00002D56           1733          LEA     clearLine,A1            ;move string for a CR and LF
00001D10  103C 000E               1734          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001D14                          1735          ;string without CR, LF
00001D14  4E4F                    1736          TRAP    #15
00001D16                          1737  
00001D16  7000                    1738          MOVEQ.L #0,D0
00001D18  4E75                    1739          RTS
00001D1A                          1740  
00001D1A                          1741  
00001D1A                          1742      
00001D1A= 10 18 20 38 39 00       1743  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
00001D20= 38 38 38 3F 3F 00       1744  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
00001D26                          1745  
00001D26                          1746  ADD:
00001D26                          1747          
00001D26                          1748  
00001D26                          1749          
00001D26  7000                    1750          MOVEQ.L #0, D0                  ;clear D0
00001D28                          1751          
00001D28                          1752          ;Figure out if EA is source or destination
00001D28  3401                    1753          MOVE.W D1,D2                    ;copy inst to D2
00001D2A  EC4A                    1754          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001D2C  0202 0007               1755          ANDI.B #%00000111,D2            ;mask out rest of byte
00001D30  0C02 0002               1756          CMPI.B #2,D2                    ;compare to 2
00001D34  6F00 0016               1757          BLE validAddSourceEA            ;2 or less is EA is source
00001D38                          1758          
00001D38  0C02 0007               1759          CMPI.B #%111,D2                 ;compare to 7
00001D3C  6700 F358               1760          BEQ falsePositive               ;thats not valid
00001D40  0C02 0003               1761          CMPI.B #%11,D2                  ;compare to 3
00001D44  6700 F350               1762          BEQ falsePositive               ;also not valid
00001D48  6000 002C               1763          BRA validAddDestEA              ;all thats left is valid EA as Dest 
00001D4C                          1764          
00001D4C                          1765  validAddSourceEA:
00001D4C                          1766          
00001D4C  43F9 000023C3           1767          LEA moveSourceEAmasks,A1        ;load the list of masks
00001D52  D3C0                    1768          ADDA.L D0,A1                    ;displace to a specific mask
00001D54  1A11                    1769          MOVE.B (A1),D5                  ;move the mask to D5
00001D56                          1770          
00001D56  0C05 0000               1771          CMPI.B #0,D5                    ;check if the mask is 0
00001D5A  6700 F33A               1772          BEQ falsePositive               ;branch if it is
00001D5E                          1773          
00001D5E  1401                    1774          MOVE.B D1,D2                    ;copy instruction to D2
00001D60  C405                    1775          AND.B D5,D2                     ;mask D2
00001D62                          1776          
00001D62  43F9 000023BA           1777          LEA moveSourceEA,A1             ;load the list of valid modes
00001D68  D3C0                    1778          ADDA.L D0,A1                    ;displace to a specific mode
00001D6A  1811                    1779          MOVE.B (A1),D4                  ;move mode to D4
00001D6C  B404                    1780          CMP.B D4,D2                     ;compare mode to masked value
00001D6E  6700 002C               1781          BEQ  addSource                  ;if its match, its a valid mode and we can procede
00001D72                          1782          
00001D72  5280                    1783          ADDQ.L #1,D0                    ;add one to displacement
00001D74  60D6                    1784          BRA validAddSourceEA            ;check for next mode
00001D76                          1785          
00001D76                          1786          
00001D76                          1787  validAddDestEA:
00001D76                          1788          
00001D76  43F8 1D20               1789          LEA addDestEAmasks,A1           ;load the list of masks
00001D7A  D3C0                    1790          ADDA.L D0,A1                    ;displace to a specific mask
00001D7C  1A11                    1791          MOVE.B (A1),D5                  ;move the mask to D5
00001D7E                          1792          
00001D7E  0C05 0000               1793          CMPI.B #0,D5                    ;check if the mask is 0
00001D82  6700 F312               1794          BEQ falsePositive               ;branch if it is
00001D86                          1795          
00001D86  3401                    1796          MOVE.W D1,D2                    ;copy instruction to D2
00001D88  C405                    1797          AND.B D5,D2                     ;mask D2
00001D8A                          1798          
00001D8A  43F8 1D1A               1799          LEA addDestEA,A1                ;load the list of valid modes
00001D8E  D3C0                    1800          ADDA.L D0,A1                    ;displace to a specific mode
00001D90  1811                    1801          MOVE.B (A1),D4                  ;move mode to D4
00001D92  B404                    1802          CMP.B D4,D2                     ;compare mode to masked value
00001D94  6700 0064               1803          BEQ addDest                     ;if its match, its a valid mode and we can procede
00001D98                          1804          
00001D98  5280                    1805          ADDQ.L #1,D0                    ;add one to displacement
00001D9A  60DA                    1806          BRA validAddDestEA              ;check for next mode
00001D9C                          1807          
00001D9C                          1808  addSource
00001D9C                          1809  
00001D9C  43F9 00002D9F           1810          LEA     addMessage,A1           ;move string for MOVE
00001DA2  103C 000E               1811          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001DA6                          1812          ;string with CR, LF
00001DA6  4E4F                    1813          TRAP    #15
00001DA8                          1814          
00001DA8  6100 03C2               1815          BSR negSize
00001DAC                          1816          
00001DAC                          1817          ;do EA
00001DAC                          1818          
00001DAC  3401                    1819          MOVE.W  D1,D2                   ;check mode
00001DAE  C43C 003F               1820          AND.B   #%00111111,D2
00001DB2  1A02                    1821          MOVE.B  D2,D5
00001DB4  48E7 4000               1822          MOVEM.L D1,-(SP)
00001DB8  6100 0A92               1823          BSR     Get_Effective_Address
00001DBC  4CDF 0002               1824          MOVEM.L (SP)+,D1
00001DC0                          1825          
00001DC0                          1826          ;print ','
00001DC0  48E7 4000               1827          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001DC4  123C 002C               1828          MOVE.B #',',D1                  ;put ascii value of char in D1
00001DC8  103C 0006               1829          MOVE.B #6,D0                    ;move task 6 into D0
00001DCC  4E4F                    1830          TRAP #15                        ;prin char
00001DCE  4CDF 0002               1831          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001DD2                          1832          
00001DD2                          1833          ;Then do Dn
00001DD2                          1834          
00001DD2  3401                    1835          MOVE.W  D1,D2
00001DD4  E04A                    1836          LSR.W   #8,D2                   ;move reg into first byte
00001DD6  E20A                    1837          LSR.B   #1,D2                   ;line it up to least sig bit
00001DD8  C43C 0007               1838          AND.B   #%00000111,D2           ;force mode to Dn
00001DDC  1A02                    1839          MOVE.B  D2,D5
00001DDE  48E7 4000               1840          MOVEM.L D1,-(SP)
00001DE2  6100 0A68               1841          BSR     Get_Effective_Address
00001DE6  4CDF 0002               1842          MOVEM.L (SP)+,D1
00001DEA                          1843          
00001DEA  43F9 00002D56           1844          LEA     clearLine,A1            ;move string for a CR and LF
00001DF0  103C 000E               1845          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001DF4                          1846                                ;string without CR, LF
00001DF4  4E4F                    1847          TRAP    #15
00001DF6                          1848  
00001DF6  7000                    1849          MOVEQ.L #0,D0
00001DF8  4E75                    1850          RTS
00001DFA                          1851  
00001DFA                          1852  addDest
00001DFA                          1853  
00001DFA  43F9 00002D9F           1854          LEA     addMessage,A1           ;move string for MOVE
00001E00  103C 000E               1855          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001E04                          1856                                          ;string with CR, LF
00001E04  4E4F                    1857          TRAP    #15
00001E06                          1858          
00001E06  6100 0364               1859          BSR negSize
00001E0A                          1860          
00001E0A                          1861          ;Do Dn
00001E0A                          1862          
00001E0A  3401                    1863          MOVE.W  D1,D2
00001E0C  E04A                    1864          LSR.W   #8,D2                   ;move reg into first byte
00001E0E  E20A                    1865          LSR.B   #1,D2                   ;line it up to least sig bit
00001E10  C43C 0007               1866          AND.B   #%00000111,D2           ;force mode to Dn
00001E14  1A02                    1867          MOVE.B  D2,D5
00001E16  48E7 4000               1868          MOVEM.L D1,-(SP)
00001E1A  6100 0A30               1869          BSR     Get_Effective_Address
00001E1E  4CDF 0002               1870          MOVEM.L (SP)+,D1
00001E22                          1871          
00001E22                          1872          
00001E22                          1873          ;print ','
00001E22  48E7 4000               1874          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001E26  123C 002C               1875          MOVE.B #',',D1                  ;put ascii value of char in D1
00001E2A  103C 0006               1876          MOVE.B #6,D0                    ;move task 6 into D0
00001E2E  4E4F                    1877          TRAP #15                        ;prin char
00001E30  4CDF 0002               1878          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001E34                          1879          
00001E34                          1880          ;Then do EA
00001E34                          1881          
00001E34  3401                    1882          MOVE.W  D1,D2                   ;check mode
00001E36  C43C 003F               1883          AND.B   #%00111111,D2
00001E3A  1A02                    1884          MOVE.B  D2,D5
00001E3C  48E7 4000               1885          MOVEM.L D1,-(SP)
00001E40  6100 0A0A               1886          BSR     Get_Effective_Address
00001E44  4CDF 0002               1887          MOVEM.L (SP)+,D1
00001E48                          1888          
00001E48                          1889          
00001E48  43F9 00002D56           1890          LEA     clearLine,A1            ;move string for a CR and LF
00001E4E  103C 000E               1891          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001E52                          1892                                          ;string without CR, LF
00001E52  4E4F                    1893          TRAP    #15
00001E54                          1894  
00001E54  7000                    1895          MOVEQ.L #0,D0
00001E56  4E75                    1896          RTS
00001E58                          1897  
00001E58                          1898  
00001E58= 10 20 38 39 00          1899  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
00001E5D= 38 38 3F 3F 00          1900  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
00001E62                          1901  
00001E62= 10 18 38 39 00          1902  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
00001E67= 38 38 3F 3F 00          1903  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
00001E6C                          1904  
00001E6C                          1905  MOVEM:
00001E6C                          1906          
00001E6C                          1907  
00001E6C                          1908          
00001E6C  7000                    1909          MOVEQ.L #0, D0                  ;clear D0
00001E6E                          1910          
00001E6E                          1911          ;Figure out which direction we are going
00001E6E  3401                    1912          MOVE.W D1,D2                    ;copy inst to D2
00001E70  E64A                    1913          LSR.W #3,D2                     ;shift direction bit into most sig bit of first byte
00001E72  0202 0080               1914          ANDI.B #%10000000,D2            ;mask out everything but direction bit in first byte
00001E76  0C02 0000               1915          CMPI.B #0,D2                    ;compare bit to zero
00001E7A  6700 0006               1916          BEQ validRegToMem               ;if zero, reg to mem
00001E7E  6000 0028               1917          BRA validMemToReg               ;else, its mem to reg
00001E82                          1918          
00001E82                          1919  validRegToMem:
00001E82                          1920          
00001E82  43F8 1E5D               1921          LEA movemRegToMemEAmasks,A1     ;load the list of masks
00001E86  D3C0                    1922          ADDA.L D0,A1                    ;displace to a specific mask
00001E88  1A11                    1923          MOVE.B (A1),D5                  ;move the mask to D5
00001E8A                          1924          
00001E8A  0C05 0000               1925          CMPI.B #0,D5                    ;check if the mask is 0
00001E8E  6700 F206               1926          BEQ falsePositive               ;branch if it is
00001E92                          1927          
00001E92  1401                    1928          MOVE.B D1,D2                    ;copy instruction to D2
00001E94  C405                    1929          AND.B D5,D2                     ;mask D2
00001E96                          1930          
00001E96  43F8 1E58               1931          LEA movemRegToMemEA,A1          ;load the list of valid modes
00001E9A  D3C0                    1932          ADDA.L D0,A1                    ;displace to a specific mode
00001E9C  1811                    1933          MOVE.B (A1),D4                  ;move mode to D4
00001E9E  B404                    1934          CMP.B D4,D2                     ;compare mode to masked value
00001EA0  6700 002C               1935          BEQ  movemPre                   ;if its match, its a valid mode and we can procede
00001EA4                          1936          
00001EA4  5280                    1937          ADDQ.L #1,D0                    ;add one to displacement
00001EA6  60DA                    1938          BRA validRegToMem               ;check for next mode
00001EA8                          1939          
00001EA8                          1940          
00001EA8                          1941  validMemToReg:
00001EA8                          1942          
00001EA8  43F8 1E67               1943          LEA movemMemToRegEAmasks,A1     ;load the list of masks
00001EAC  D3C0                    1944          ADDA.L D0,A1                    ;displace to a specific mask
00001EAE  1A11                    1945          MOVE.B (A1),D5                  ;move the mask to D5
00001EB0                          1946          
00001EB0  0C05 0000               1947          CMPI.B #0,D5                    ;check if the mask is 0
00001EB4  6700 F1E0               1948          BEQ falsePositive               ;branch if it is
00001EB8                          1949          
00001EB8  3401                    1950          MOVE.W D1,D2                    ;copy instruction to D2
00001EBA  C405                    1951          AND.B D5,D2                     ;mask D2
00001EBC                          1952          
00001EBC  43F8 1E62               1953          LEA movemMemToRegEA,A1          ;load the list of valid modes
00001EC0  D3C0                    1954          ADDA.L D0,A1                    ;displace to a specific mode
00001EC2  1811                    1955          MOVE.B (A1),D4                  ;move mode to D4
00001EC4  B404                    1956          CMP.B D4,D2                     ;compare mode to masked value
00001EC6  6700 0062               1957          BEQ movemPost                   ;if its match, its a valid mode and we can procede
00001ECA                          1958          
00001ECA  5280                    1959          ADDQ.L #1,D0                    ;add one to displacement
00001ECC  60DA                    1960          BRA validMemToReg               ;check for next mode
00001ECE                          1961  
00001ECE                          1962  movemPre:
00001ECE                          1963  
00001ECE  43F9 00002DA3           1964          LEA     movemMessage,A1         ;move string for MOVE
00001ED4  103C 000E               1965          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001ED8                          1966                                          ;string with CR, LF
00001ED8  4E4F                    1967          TRAP    #15
00001EDA                          1968          
00001EDA                          1969          ;size
00001EDA  48E7 4000               1970          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001EDE                          1971          ;make it look like NEG's size
00001EDE  C23C 007F               1972          AND.B #%01111111,D1             ;clear bit next to size
00001EE2  0641 0040               1973          ADDI.W #%01000000,D1            ;add 1 to size to make it look like a word or long
00001EE6  6100 0284               1974          BSR negSize
00001EEA  4CDF 0002               1975          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001EEE                          1976          
00001EEE                          1977          
00001EEE                          1978          ;show list
00001EEE                          1979          
00001EEE  6100 00E6               1980          BSR outputPreIncrement     
00001EF2                          1981          
00001EF2  5487                    1982          ADDQ.L #word,D7                 ;read past the register list mask(word) following
00001EF4                          1983                                          ;the instruction
00001EF4                          1984          
00001EF4                          1985          ;print ','
00001EF4  48E7 4000               1986          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001EF8  123C 002C               1987          MOVE.B #',',D1                  ;put ascii value of char in D1
00001EFC  103C 0006               1988          MOVE.B #6,D0                    ;move task 6 into D0
00001F00  4E4F                    1989          TRAP #15                        ;prin char
00001F02  4CDF 0002               1990          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001F06                          1991          
00001F06  3401                    1992          MOVE.W  D1,D2                   ;check mode
00001F08  C43C 003F               1993          AND.B   #%00111111,D2
00001F0C  1A02                    1994          MOVE.B  D2,D5
00001F0E  48E7 4000               1995          MOVEM.L D1,-(SP)
00001F12  6100 0938               1996          BSR     Get_Effective_Address
00001F16  4CDF 0002               1997          MOVEM.L (SP)+,D1
00001F1A                          1998          
00001F1A                          1999          
00001F1A  43F9 00002D56           2000          LEA     clearLine,A1            ;move string for a CR and LF
00001F20  103C 000E               2001          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001F24                          2002                                          ;string without CR, LF
00001F24  4E4F                    2003          TRAP    #15
00001F26                          2004  
00001F26  7000                    2005          MOVEQ.L #0,D0
00001F28  4E75                    2006          RTS
00001F2A                          2007          
00001F2A                          2008  movemPost:
00001F2A                          2009  
00001F2A  43F9 00002DA3           2010          LEA     movemMessage,A1         ;move string for MOVE
00001F30  103C 000E               2011          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001F34                          2012                                          ;string with CR, LF
00001F34  4E4F                    2013          TRAP    #15
00001F36                          2014          
00001F36                          2015          ;size
00001F36  48E7 4000               2016          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001F3A                          2017          ;make it look like NEG's size
00001F3A  C23C 007F               2018          AND.B #%01111111,D1             ;clear bit next to size
00001F3E  0641 0040               2019          ADDI.W #%01000000,D1            ;add 1 to size to make it look like a word or long
00001F42  6100 0228               2020          BSR negSize
00001F46  4CDF 0002               2021          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001F4A                          2022  
00001F4A  3401                    2023          MOVE.W  D1,D2                   ;check mode
00001F4C  C43C 003F               2024          AND.B   #%00111111,D2
00001F50  1A02                    2025          MOVE.B  D2,D5
00001F52  48E7 4000               2026          MOVEM.L D1,-(SP)
00001F56  6100 08F4               2027          BSR     Get_Effective_Address
00001F5A  4CDF 0002               2028          MOVEM.L (SP)+,D1
00001F5E                          2029          
00001F5E                          2030          
00001F5E                          2031          ;print ','
00001F5E  48E7 4000               2032          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001F62  123C 002C               2033          MOVE.B #',',D1                  ;put ascii value of char in D1
00001F66  103C 0006               2034          MOVE.B #6,D0                    ;move task 6 into D0
00001F6A  4E4F                    2035          TRAP #15                        ;prin char
00001F6C  4CDF 0002               2036          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001F70                          2037          
00001F70                          2038  
00001F70                          2039          
00001F70                          2040          ;show list
00001F70  6100 0102               2041          BSR outputPostIncrement        
00001F74                          2042          
00001F74  5487                    2043          ADDQ.L #word,D7                 ;read past the register list mask(word) following
00001F76                          2044                                          ;the instruction
00001F76                          2045          
00001F76  43F9 00002D56           2046          LEA     clearLine,A1            ;move string for a CR and LF
00001F7C  103C 000E               2047          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001F80                          2048                                          ;string without CR, LF
00001F80  4E4F                    2049          TRAP    #15
00001F82                          2050  
00001F82  7000                    2051          MOVEQ.L #0,D0
00001F84  4E75                    2052          RTS
00001F86                          2053  
00001F86= 00000000 00000000 ...   2054  movemRegListBuffer DC.L 0,0,0,0,0,0,0,0,0,0,0,0 
00001FB6                          2055                                          ;max of 16 regs @ 2 bytes each, 
00001FB6                          2056                                          ;15 possible '/' @ a byte
00001FB6                          2057                                          ;byte for null terminator
00001FB6                          2058                                          ; 48 bytes = 12 longs 
00001FB6                          2059                              
00001FB6= 41 37 41 36 41 35 ...   2060  movemPostRegList DC.B 'A7','A6','A5','A4','A3','A2','A1','A0','D7','D6','D5','D4','D3','D2','D1','D0'
00001FD6                          2061  movemPreRegList ;should be location after PostList
00001FD6                          2062          
00001FD6                          2063  outputPreincrement:
00001FD6  548B                    2064             ADDQ.L #word,A3
00001FD8  3413                    2065          MOVE.W (A3),D2
00001FDA  7600                    2066          MOVEQ.L #0,D3
00001FDC  47F8 1F86               2067          LEA movemRegListBuffer,A3
00001FE0  49F8 1FD6               2068          LEA movemPreRegList,A4        
00001FE4  558C                    2069          SUBQ.L #word,A4
00001FE6                          2070          
00001FE6  6100 00E8               2071          BSR checkPreRegAdd              ;1
00001FEA                          2072          
00001FEA  558C                    2073          SUBQ.L #word,A4
00001FEC                          2074          
00001FEC  6100 00E2               2075          BSR checkPreRegAdd              ;2
00001FF0  558C                    2076          SUBQ.L #word,A4
00001FF2  6100 00DC               2077          BSR checkPreRegAdd              ;3
00001FF6  558C                    2078          SUBQ.L #word,A4
00001FF8  6100 00D6               2079          BSR checkPreRegAdd              ;4
00001FFC  558C                    2080          SUBQ.L #word,A4
00001FFE  6100 00D0               2081          BSR checkPreRegAdd              ;5
00002002  558C                    2082          SUBQ.L #word,A4
00002004  6100 00CA               2083          BSR checkPreRegAdd              ;6
00002008  558C                    2084          SUBQ.L #word,A4
0000200A  6100 00C4               2085          BSR checkPreRegAdd              ;7
0000200E  558C                    2086          SUBQ.L #word,A4
00002010  6100 00BE               2087          BSR checkPreRegAdd              ;8
00002014  558C                    2088          SUBQ.L #word,A4
00002016  6100 00B8               2089          BSR checkPreRegAdd              ;9
0000201A  558C                    2090          SUBQ.L #word,A4
0000201C  6100 00B2               2091          BSR checkPreRegAdd              ;10
00002020  558C                    2092          SUBQ.L #word,A4
00002022  6100 00AC               2093          BSR checkPreRegAdd              ;11
00002026  558C                    2094          SUBQ.L #word,A4
00002028  6100 00A6               2095          BSR checkPreRegAdd              ;12
0000202C  558C                    2096          SUBQ.L #word,A4
0000202E  6100 00A0               2097          BSR checkPreRegAdd              ;13
00002032  558C                    2098          SUBQ.L #word,A4
00002034  6100 009A               2099          BSR checkPreRegAdd              ;14
00002038  558C                    2100          SUBQ.L #word,A4
0000203A  6100 0094               2101          BSR checkPreRegAdd              ;15
0000203E  558C                    2102          SUBQ.L #word,A4
00002040  6100 008E               2103          BSR checkPreRegAdd              ;16
00002044                          2104          
00002044  16BC 0000               2105          MOVE.B #0,(A3)
00002048  43F8 1F86               2106          LEA     movemRegListBuffer,A1   ;move string for MOVE
0000204C  103C 000E               2107          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002050                          2108                                          ;string without CR, LF
00002050  4E4F                    2109          TRAP    #15 
00002052                          2110          
00002052  4E75                    2111          RTS
00002054                          2112          
00002054                          2113  checkPostRegAdd:
00002054  E342                    2114          ASL.W #1,D2
00002056  6500 0004               2115          BCS PostRegAdd
0000205A                          2116  addPostRegDone:
0000205A  4E75                    2117          RTS
0000205C                          2118          
0000205C                          2119  PostRegAdd:
0000205C  4BF8 1F86               2120          LEA movemRegListBuffer,A5
00002060  BBCB                    2121          CMP.L A3,A5
00002062  6600 000A               2122          BNE postAddBackslash
00002066                          2123  PostRegAddDone:
00002066  16DC                    2124          MOVE.B (A4)+,(A3)+
00002068  16D4                    2125          MOVE.B (A4),(A3)+
0000206A  538C                    2126          SUBQ.L #byte,A4
0000206C  60EC                    2127          BRA addPostRegDone
0000206E                          2128          
0000206E                          2129  postAddBackslash:
0000206E  16FC 002F               2130          MOVE.B #'/',(A3)+
00002072  60F2                    2131          BRA PostRegAddDone
00002074                          2132          
00002074                          2133  
00002074                          2134  outputPostincrement:
00002074  548B                    2135          ADDQ.L #word,A3
00002076  3413                    2136          MOVE.W (A3),D2
00002078  7600                    2137          MOVEQ.L #0,D3
0000207A  47F8 1F86               2138          LEA movemRegListBuffer,A3
0000207E  49F8 1FB6               2139          LEA movemPostRegList,A4
00002082                          2140          
00002082  61D0                    2141          BSR checkPostRegAdd             ;1
00002084  548C                    2142          ADDQ.L #word,A4
00002086  61CC                    2143          BSR checkPostRegAdd             ;2
00002088  548C                    2144          ADDQ.L #word,A4
0000208A  61C8                    2145          BSR checkPostRegAdd             ;3
0000208C  548C                    2146          ADDQ.L #word,A4
0000208E  61C4                    2147          BSR checkPostRegAdd             ;4
00002090  548C                    2148          ADDQ.L #word,A4
00002092  61C0                    2149          BSR checkPostRegAdd             ;5
00002094  548C                    2150          ADDQ.L #word,A4
00002096  61BC                    2151          BSR checkPostRegAdd             ;6
00002098  548C                    2152          ADDQ.L #word,A4
0000209A  61B8                    2153          BSR checkPostRegAdd             ;7
0000209C  548C                    2154          ADDQ.L #word,A4
0000209E  61B4                    2155          BSR checkPostRegAdd             ;8
000020A0  548C                    2156          ADDQ.L #word,A4
000020A2  61B0                    2157          BSR checkPostRegAdd             ;9
000020A4  548C                    2158          ADDQ.L #word,A4
000020A6  61AC                    2159          BSR checkPostRegAdd             ;10
000020A8  548C                    2160          ADDQ.L #word,A4
000020AA  61A8                    2161          BSR checkPostRegAdd             ;11
000020AC  548C                    2162          ADDQ.L #word,A4
000020AE  61A4                    2163          BSR checkPostRegAdd             ;12
000020B0  548C                    2164          ADDQ.L #word,A4
000020B2  61A0                    2165          BSR checkPostRegAdd             ;13
000020B4  548C                    2166          ADDQ.L #word,A4
000020B6  619C                    2167          BSR checkPostRegAdd             ;14
000020B8  548C                    2168          ADDQ.L #word,A4
000020BA  6198                    2169          BSR checkPostRegAdd             ;15
000020BC  548C                    2170          ADDQ.L #word,A4
000020BE  6194                    2171          BSR checkPostRegAdd             ;16
000020C0                          2172          
000020C0  16BC 0000               2173          MOVE.B #0,(A3)
000020C4  43F8 1F86               2174          LEA     movemRegListBuffer,A1   ;move string for MOVE
000020C8  103C 000E               2175          MOVE.B  #14,D0                  ;set for task to display null terminated 
000020CC                          2176                               ;string without CR, LF
000020CC  4E4F                    2177          TRAP    #15 
000020CE                          2178          
000020CE  4E75                    2179          RTS
000020D0                          2180          
000020D0                          2181  checkPreRegAdd:
000020D0  E342                    2182          ASL.W #1,D2
000020D2  6500 0004               2183          BCS PreRegAdd
000020D6                          2184  addPreRegDone:
000020D6  4E75                    2185          RTS
000020D8                          2186          
000020D8                          2187  PreRegAdd:
000020D8  4BF8 1F86               2188          LEA movemRegListBuffer,A5
000020DC  BBCB                    2189          CMP.L A3,A5
000020DE  6600 000A               2190          BNE preAddBackslash
000020E2                          2191  PreRegAddDone:
000020E2  16DC                    2192          MOVE.B (A4)+,(A3)+
000020E4  16D4                    2193          MOVE.B (A4),(A3)+
000020E6  538C                    2194          SUBQ.L #byte,A4
000020E8  60EC                    2195          BRA addPreRegDone
000020EA                          2196          
000020EA                          2197  preAddBackslash:
000020EA  16FC 002F               2198          MOVE.B #'/',(A3)+
000020EE  6000 FF76               2199          BRA PostRegAddDone
000020F2                          2200  
000020F2                          2201      
000020F2= 00 10 18 20 28 38 ...   2202  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
000020FA= 38 38 38 38 38 3F ...   2203  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
00002102                          2204     
00002102                          2205  NEG:            
00002102                          2206       
00002102  7000                    2207          MOVEQ.L #0, D0                  ;clear D0
00002104                          2208          
00002104                          2209  validNegModes:
00002104                          2210          
00002104  43F8 20FA               2211          LEA NegEAmasks,A1               ;load the list of masks
00002108  D3C0                    2212          ADDA.L D0,A1                    ;displace to a specific mask
0000210A  1A11                    2213          MOVE.B (A1),D5                  ;move the mask to D5
0000210C                          2214          
0000210C  0C05 0000               2215          CMPI.B #0,D5                    ;check if the mask is 0
00002110  6700 EF84               2216          BEQ falsePositive               ;branch if it is
00002114                          2217          
00002114  1401                    2218          MOVE.B D1,D2                    ;copy instruction to D2
00002116  C405                    2219          AND.B D5,D2                     ;mask D2
00002118  43F8 20F2               2220          LEA NegEA,A1                    ;load the list of valid modes
0000211C  D3C0                    2221          ADDA.L D0,A1                    ;displace to a specific mode
0000211E  1811                    2222          MOVE.B (A1),D4                  ;move mode to D4
00002120  B404                    2223          CMP.B D4,D2                     ;compare mode to masked value
00002122  6700 0006               2224          BEQ NegBody                     ;if its match, its a valid mode and we can procede
00002126                          2225          
00002126  5280                    2226          ADDQ.L #1,D0                    ;add one to displacement
00002128  60DA                    2227          BRA validNegModes               ;check for next mode
0000212A                          2228          
0000212A                          2229  NegBody:
0000212A                          2230  
0000212A                          2231  
0000212A  3401                    2232          MOVE.W  D1,D2                   ;copy inst to D2
0000212C  C47C 0600               2233          AND.W  #%0011000000000,D2       ;mask word for size
00002130  0C42 0000               2234          CMPI.W #0,D2                    ;0 is the only non valid size
00002134  6700 EF60               2235          BEQ falsePositive               ; zero is not valid
00002138                          2236  
00002138  43F9 00002DCD           2237          LEA     negMessage,A1           ;move string for NEG info
0000213E  103C 000E               2238          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002142                          2239                                ;string without CR, LF
00002142  4E4F                    2240          TRAP    #15
00002144                          2241          
00002144  6100 0026               2242          BSR NegSize
00002148                          2243          
00002148  3401                    2244          MOVE.W D1,D2
0000214A  C47C 003F               2245          AND #%000000000111111,D2
0000214E  1A02                    2246          MOVE.B D2,D5
00002150                          2247          
00002150  48E7 4000               2248          MOVEM.L D1,-(SP)
00002154  6100 06F6               2249          BSR     Get_Effective_Address
00002158  4CDF 0002               2250          MOVEM.L (SP)+,D1
0000215C                          2251          
0000215C                          2252                
0000215C                          2253          
0000215C                          2254  NEGdone:
0000215C                          2255  
0000215C  43F9 00002D56           2256          LEA     clearLine,A1            ;move string for a CR and LF
00002162  103C 000E               2257          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002166                          2258                                          ;string without CR, LF
00002166  4E4F                    2259          TRAP    #15
00002168  7000                    2260          MOVEQ.L #0,D0
0000216A  4E75                    2261          RTS
0000216C                          2262          
0000216C                          2263  NegSize:
0000216C  3401                    2264          MOVE.W  D1,D2                   ;copy inst to D2
0000216E  EC4A                    2265          LSR.W #6,D2                     ;shift size over to first byte
00002170  C4BC 00000003           2266          AND.L  #%11,D2                  ;mask word for size
00002176  2C02                    2267          MOVE.L D2,D6                    ;size does not need to be translated,
00002178                          2268                                          ;so moved directly to D6
00002178                          2269          
00002178  6100 0870               2270          BSR printSize
0000217C                          2271          
0000217C  4E75                    2272          RTS
0000217E                          2273          
0000217E                          2274          
0000217E                          2275   ADDI:            
0000217E                          2276       
0000217E  7000                    2277          MOVEQ.L #0, D0                  ;clear D0
00002180                          2278          
00002180                          2279  validAddiModes:
00002180                          2280          
00002180                          2281          
00002180  43F9 000022A5           2282          LEA cmpiEAmasks,A1              ;load the list of masks
00002186  D3C0                    2283          ADDA.L D0,A1                    ;displace to a specific mask
00002188  1A11                    2284          MOVE.B (A1),D5                  ;move the mask to D5
0000218A                          2285          
0000218A  0C05 0000               2286          CMPI.B #0,D5                    ;check if the mask is 0
0000218E  6700 EF06               2287          BEQ falsePositive               ;branch if it is
00002192                          2288          
00002192  1401                    2289          MOVE.B D1,D2                    ;copy instruction to D2
00002194  C405                    2290          AND.B D5,D2                     ;mask D2
00002196  43F9 0000229E           2291          LEA cmpiEA,A1                   ;load the list of valid modes
0000219C  D3C0                    2292          ADDA.L D0,A1                    ;displace to a specific mode
0000219E  1811                    2293          MOVE.B (A1),D4                  ;move mode to D4
000021A0  B404                    2294          CMP.B D4,D2                     ;compare mode to masked value
000021A2  6700 0006               2295          BEQ addiBody                    ;if its match, its a valid mode and we can procede
000021A6                          2296          
000021A6  5280                    2297          ADDQ.L #1,D0                    ;add one to displacement
000021A8  60D6                    2298          BRA validAddiModes              ;check for next mode
000021AA                          2299          
000021AA                          2300  addiBody:
000021AA                          2301  
000021AA                          2302  
000021AA  3401                    2303          MOVE.W  D1,D2                   ;copy inst to D2
000021AC  C47C 00C0               2304          AND.W  #%0000000011000000,D2    ;mask word for size
000021B0  0C42 00C0               2305          CMPI.W #%0000000011000000,D2    ;11 is the only non valid size
000021B4  6700 EEE0               2306          BEQ falsePositive
000021B8                          2307  
000021B8  43F9 00002DA9           2308          LEA     addiMessage,A1          ;move string for NEG info
000021BE  103C 000E               2309          MOVE.B  #14,D0                  ;set for task to display null terminated 
000021C2                          2310                                ;string without CR, LF
000021C2  4E4F                    2311          TRAP    #15
000021C4                          2312          
000021C4  61A6                    2313          BSR NegSize
000021C6                          2314          
000021C6                          2315          ;go to Effective_Address for immediate data
000021C6  743C                    2316          MOVE.L #%00111100,D2
000021C8  2A02                    2317          MOVE.L D2,D5
000021CA  48E7 4000               2318          MOVEM.L D1,-(SP)
000021CE  6100 067C               2319          BSR     Get_Effective_Address
000021D2  4CDF 0002               2320          MOVEM.L (SP)+,D1
000021D6                          2321          
000021D6                          2322          ;print ','
000021D6  48E7 4000               2323          MOVEM.L D1,-(SP)                ;save D1 to the stack
000021DA  123C 002C               2324          MOVE.B #',',D1                  ;put ascii value of char in D1
000021DE  103C 0006               2325          MOVE.B #6,D0                    ;move task 6 into D0
000021E2  4E4F                    2326          TRAP #15                        ;prin char
000021E4  4CDF 0002               2327          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000021E8                          2328          
000021E8  3401                    2329          MOVE.W D1,D2                    ;copy inst to D2
000021EA  C47C 003F               2330          AND #%000000000111111,D2        ;and out everything but modes and regs
000021EE  1A02                    2331          MOVE.B D2,D5                    ; copy to D5 for following BSR
000021F0                          2332          
000021F0  48E7 4000               2333          MOVEM.L D1,-(SP)
000021F4  6100 0656               2334          BSR     Get_Effective_Address
000021F8  4CDF 0002               2335          MOVEM.L (SP)+,D1
000021FC                          2336          
000021FC                          2337                
000021FC                          2338          
000021FC                          2339  addidone:
000021FC                          2340  
000021FC  43F9 00002D56           2341          LEA     clearLine,A1            ;move string for a CR and LF
00002202  103C 000E               2342          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002206                          2343                                          ;string without CR, LF
00002206  4E4F                    2344          TRAP    #15
00002208  7000                    2345          MOVEQ.L #0,D0
0000220A  4E75                    2346          RTS
0000220C                          2347    
0000220C                          2348  ORI:            
0000220C                          2349       
0000220C  7000                    2350          MOVEQ.L #0, D0                  ;clear D0
0000220E                          2351          
0000220E                          2352  validOriModes:
0000220E                          2353          
0000220E                          2354          
0000220E  43F9 000022A5           2355          LEA cmpiEAmasks,A1              ;load the list of masks
00002214  D3C0                    2356          ADDA.L D0,A1                    ;displace to a specific mask
00002216  1A11                    2357          MOVE.B (A1),D5                  ;move the mask to D5
00002218                          2358          
00002218  0C05 0000               2359          CMPI.B #0,D5                    ;check if the mask is 0
0000221C  6700 EE78               2360          BEQ falsePositive               ;branch if it is
00002220                          2361          
00002220  1401                    2362          MOVE.B D1,D2                    ;copy instruction to D2
00002222  C405                    2363          AND.B D5,D2                     ;mask D2
00002224  43F9 0000229E           2364          LEA cmpiEA,A1                   ;load the list of valid modes
0000222A  D3C0                    2365          ADDA.L D0,A1                    ;displace to a specific mode
0000222C  1811                    2366          MOVE.B (A1),D4                  ;move mode to D4
0000222E  B404                    2367          CMP.B D4,D2                     ;compare mode to masked value
00002230  6700 0006               2368          BEQ oriBody                     ;if its match, its a valid mode and we can procede
00002234                          2369          
00002234  5280                    2370          ADDQ.L #1,D0                    ;add one to displacement
00002236  60D6                    2371          BRA validOriModes               ;check for next mode
00002238                          2372          
00002238                          2373  oriBody:
00002238                          2374  
00002238                          2375  
00002238  3401                    2376          MOVE.W  D1,D2                   ;copy inst to D2
0000223A  C47C 00C0               2377          AND.W  #%0000000011000000,D2    ;mask word for size
0000223E  0C42 00C0               2378          CMPI.W #%0000000011000000,D2    ;11 is the only non valid size
00002242  6700 EE52               2379          BEQ falsePositive
00002246                          2380  
00002246  43F9 00002DAE           2381          LEA     oriMessage,A1           ;move string for NEG info
0000224C  103C 000E               2382          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002250                          2383                                ;string without CR, LF
00002250  4E4F                    2384          TRAP    #15
00002252                          2385          
00002252  6100 FF18               2386          BSR negSize
00002256                          2387          
00002256                          2388          ;go to Effective_Address for immediate data
00002256  143C 003C               2389          MOVE.B #%00111100,D2
0000225A  1A02                    2390          MOVE.B D2,D5
0000225C  48E7 4000               2391          MOVEM.L D1,-(SP)
00002260  6100 05EA               2392          BSR     Get_Effective_Address
00002264  4CDF 0002               2393          MOVEM.L (SP)+,D1
00002268                          2394          
00002268                          2395          ;print ','
00002268  48E7 4000               2396          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000226C  123C 002C               2397          MOVE.B #',',D1                  ;put ascii value of char in D1
00002270  103C 0006               2398          MOVE.B #6,D0                    ;move task 6 into D0
00002274  4E4F                    2399          TRAP #15                        ;print char
00002276  4CDF 0002               2400          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000227A                          2401          
0000227A  3401                    2402          MOVE.W D1,D2                    ;copy inst to D2
0000227C  C47C 003F               2403          AND #%000000000111111,D2        ;and out everything but modes and regs
00002280  1A02                    2404          MOVE.B D2,D5                    ; copy to D5 for following BSR
00002282                          2405          
00002282  48E7 4000               2406          MOVEM.L D1,-(SP)
00002286  6100 05C4               2407          BSR     Get_Effective_Address
0000228A  4CDF 0002               2408          MOVEM.L (SP)+,D1
0000228E                          2409          
0000228E                          2410                
0000228E                          2411          
0000228E                          2412  oridone:
0000228E                          2413  
0000228E  43F9 00002D56           2414          LEA     clearLine,A1            ;move string for a CR and LF
00002294  103C 000E               2415          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002298                          2416                                          ;string without CR, LF
00002298  4E4F                    2417          TRAP    #15
0000229A  7000                    2418          MOVEQ.L #0,D0
0000229C  4E75                    2419          RTS
0000229E                          2420  
0000229E                          2421          
0000229E                          2422          
0000229E= 20 18 00 10 38 39 00    2423  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
000022A5= 38 38 38 38 3F 3F 00    2424  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
000022AC                          2425     
000022AC                          2426  CMPI:            
000022AC                          2427       
000022AC  7000                    2428          MOVEQ.L #0, D0                  ;clear D0
000022AE                          2429          
000022AE                          2430  validCmpiModes:
000022AE                          2431          
000022AE                          2432          
000022AE  43F8 22A5               2433          LEA cmpiEAmasks,A1              ;load the list of masks
000022B2  D3C0                    2434          ADDA.L D0,A1                    ;displace to a specific mask
000022B4  1A11                    2435          MOVE.B (A1),D5                  ;move the mask to D5
000022B6                          2436          
000022B6  0C05 0000               2437          CMPI.B #0,D5                    ;check if the mask is 0
000022BA  6700 EDDA               2438          BEQ falsePositive               ;branch if it is
000022BE                          2439          
000022BE  1401                    2440          MOVE.B D1,D2                    ;copy instruction to D2
000022C0  C405                    2441          AND.B D5,D2                     ;mask D2
000022C2  43F8 229E               2442          LEA cmpiEA,A1                   ;load the list of valid modes
000022C6  D3C0                    2443          ADDA.L D0,A1                    ;displace to a specific mode
000022C8  1811                    2444          MOVE.B (A1),D4                  ;move mode to D4
000022CA  B404                    2445          CMP.B D4,D2                     ;compare mode to masked value
000022CC  6700 0006               2446          BEQ CMPIBody                    ;if its match, its a valid mode and we can procede
000022D0                          2447          
000022D0  5280                    2448          ADDQ.L #1,D0                    ;add one to displacement
000022D2  60DA                    2449          BRA validCmpiModes              ;check for next mode
000022D4                          2450          
000022D4                          2451  CMPIBody:
000022D4                          2452  
000022D4                          2453  
000022D4  3401                    2454          MOVE.W  D1,D2                   ;copy inst to D2
000022D6  C47C 00C0               2455          AND.W  #%0000000011000000,D2    ;mask word for size
000022DA  0C42 00C0               2456          CMPI.W #%0000000011000000,D2    ;11 is the only non valid size
000022DE  6700 EDB6               2457          BEQ falsePositive
000022E2                          2458  
000022E2  43F9 00002DB2           2459          LEA     cmpiMessage,A1          ;move string for NEG info
000022E8  103C 000E               2460          MOVE.B  #14,D0                  ;set for task to display null terminated 
000022EC                          2461                                ;string without CR, LF
000022EC  4E4F                    2462          TRAP    #15
000022EE                          2463          
000022EE  6100 FE7C               2464          BSR negSize
000022F2                          2465          
000022F2                          2466          ;go to Effective_Address for immediate data
000022F2  143C 003C               2467          MOVE.B #%00111100,D2
000022F6  1A02                    2468          MOVE.B D2,D5
000022F8  48E7 4000               2469          MOVEM.L D1,-(SP)
000022FC  6100 054E               2470          BSR     Get_Effective_Address
00002300  4CDF 0002               2471          MOVEM.L (SP)+,D1
00002304                          2472          
00002304                          2473          ;print ','
00002304  48E7 4000               2474          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002308  123C 002C               2475          MOVE.B #',',D1                  ;put ascii value of char in D1
0000230C  103C 0006               2476          MOVE.B #6,D0                    ;move task 6 into D0
00002310  4E4F                    2477          TRAP #15                        ;prin char
00002312  4CDF 0002               2478          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002316                          2479          
00002316  3401                    2480          MOVE.W D1,D2                    ;copy inst to D2
00002318  C47C 003F               2481          AND #%000000000111111,D2        ;and out everything but modes and regs
0000231C  1A02                    2482          MOVE.B D2,D5                    ; copy to D5 for following BSR
0000231E                          2483          
0000231E  48E7 4000               2484          MOVEM.L D1,-(SP)
00002322  6100 0528               2485          BSR     Get_Effective_Address
00002326  4CDF 0002               2486          MOVEM.L (SP)+,D1
0000232A                          2487          
0000232A                          2488                
0000232A                          2489          
0000232A                          2490  CMPidone:
0000232A                          2491  
0000232A  43F9 00002D56           2492          LEA     clearLine,A1            ;move string for a CR and LF
00002330  103C 000E               2493          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002334                          2494                                ;string without CR, LF
00002334  4E4F                    2495          TRAP    #15
00002336  7000                    2496          MOVEQ.L #0,D0
00002338  4E75                    2497          RTS
0000233A                          2498  
0000233A                          2499          
0000233A= 10 38 39 00             2500  JsrEA        DC.B %010000, %111000, %111001,0
0000233E= 38 3F 3F 00             2501  JsrEAmasks   DC.B %111000, %111111, %111111,0
00002342                          2502     
00002342                          2503  JSR:            
00002342                          2504       
00002342  7000                    2505          MOVEQ.L #0, D0                  ;clear D0
00002344                          2506          
00002344                          2507  validJsrModes:
00002344                          2508          
00002344  43F8 233E               2509          LEA JsrEAmasks,A1               ;load the list of masks
00002348  D3C0                    2510          ADDA.L D0,A1                    ;displace to a specific mask
0000234A  1A11                    2511          MOVE.B (A1),D5                  ;move the mask to D5
0000234C                          2512          
0000234C  0C05 0000               2513          CMPI.B #0,D5                    ;check if the mask is 0
00002350  6700 ED44               2514          BEQ falsePositive               ;branch if it is
00002354                          2515          
00002354  1401                    2516          MOVE.B D1,D2                    ;copy instruction to D2
00002356  C405                    2517          AND.B D5,D2                     ;mask D2
00002358  43F8 233A               2518          LEA JsrEA,A1                    ;load the list of valid modes
0000235C  D3C0                    2519          ADDA.L D0,A1                    ;displace to a specific mode
0000235E  1811                    2520          MOVE.B (A1),D4                  ;move mode to D4
00002360  B404                    2521          CMP.B D4,D2                     ;compare mode to masked value
00002362  6700 0006               2522          BEQ JsrBody                     ;if its match, its a valid mode and we can procede
00002366                          2523          
00002366  5280                    2524          ADDQ.L #1,D0                    ;add one to displacement
00002368  60DA                    2525          BRA validJsrModes               ;check for next mode
0000236A                          2526          
0000236A                          2527  JsrBody:
0000236A                          2528  
0000236A                          2529  
0000236A  43F9 00002DB7           2530          LEA     jsrMessage,A1           ;move string for NEG info
00002370  103C 000E               2531          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002374                          2532                                ;string without CR, LF
00002374  4E4F                    2533          TRAP    #15
00002376                          2534          
00002376  3401                    2535          MOVE.W D1,D2                    ;copy inst to D2
00002378  C47C 003F               2536          AND #%000000000111111,D2        ;and out everything but modes and regs
0000237C  1A02                    2537          MOVE.B D2,D5                    ; copy to D5 for following BSR
0000237E                          2538          
0000237E  48E7 4000               2539          MOVEM.L D1,-(SP)
00002382  6100 04C8               2540          BSR     Get_Effective_Address
00002386  4CDF 0002               2541          MOVEM.L (SP)+,D1
0000238A                          2542          
0000238A                          2543                
0000238A                          2544          
0000238A                          2545  Jsrdone:
0000238A                          2546  
0000238A  43F9 00002D56           2547          LEA     clearLine,A1            ;move string for a CR and LF
00002390  103C 000E               2548          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002394                          2549                                ;string without CR, LF
00002394  4E4F                    2550          TRAP    #15
00002396  7000                    2551          MOVEQ.L #0,D0
00002398  4E75                    2552          RTS
0000239A                          2553  
0000239A                          2554  
0000239A                          2555          
0000239A                          2556  NOP:
0000239A                          2557  
0000239A  43F9 00002DC1           2558          LEA     nopMessage,A1           ;move string for NOP info
000023A0  103C 000D               2559          MOVE.B  #13,D0                  ;set for task to display null terminated 
000023A4                          2560                                          ;string with CR, LF
000023A4  4E4F                    2561          TRAP    #15
000023A6                          2562          
000023A6  7000                    2563          MOVEQ.L #0,D0
000023A8  4E75                    2564          RTS
000023AA                          2565          
000023AA                          2566  RTS:
000023AA                          2567          
000023AA  43F9 00002DBC           2568          LEA     rtsMessage,A1           ;move string for rts info
000023B0  103C 000D               2569          MOVE.B  #13,D0                  ;set for task to display null terminated 
000023B4                          2570                                          ;string with CR, LF
000023B4  4E4F                    2571          TRAP    #15  
000023B6                          2572     
000023B6  7000                    2573          MOVEQ.L #0,D0
000023B8  4E75                    2574          RTS   
000023BA                          2575  
000023BA= 3C 08 00 10 18 20 ...   2576  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
000023C3= 3F 38 38 38 38 38 ...   2577  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
000023CC                          2578  
000023CC= 00 10 18 20 38 39 00    2579  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
000023D3= 38 38 38 38 3F 3F 00    2580  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
000023DA                          2581  
000023DA                          2582  MOVE:
000023DA                          2583          
000023DA                          2584  
000023DA                          2585          
000023DA  7000                    2586          MOVEQ.L #0, D0                  ;clear D0
000023DC                          2587          
000023DC                          2588  validMoveSourceModes:
000023DC                          2589          
000023DC  43F8 23C3               2590          LEA moveSourceEAmasks,A1        ;load the list of masks
000023E0  D3C0                    2591          ADDA.L D0,A1                    ;displace to a specific mask
000023E2  1A11                    2592          MOVE.B (A1),D5                  ;move the mask to D5
000023E4                          2593          
000023E4  0C05 0000               2594          CMPI.B #0,D5                    ;check if the mask is 0
000023E8  6700 ECAC               2595          BEQ falsePositive               ;branch if it is
000023EC                          2596          
000023EC  1401                    2597          MOVE.B D1,D2                    ;copy instruction to D2
000023EE  C405                    2598          AND.B D5,D2                     ;mask D2
000023F0                          2599          
000023F0  43F8 23BA               2600          LEA moveSourceEA,A1             ;load the list of valid modes
000023F4  D3C0                    2601          ADDA.L D0,A1                    ;displace to a specific mode
000023F6  1811                    2602          MOVE.B (A1),D4                  ;move mode to D4
000023F8  B404                    2603          CMP.B D4,D2                     ;compare mode to masked value
000023FA  6700 0006               2604          BEQ  checkMoveDest              ;if its match, its a valid mode and we can procede
000023FE                          2605          
000023FE  5280                    2606          ADDQ.L #1,D0                    ;add one to displacement
00002400  60DA                    2607          BRA validMoveSourceModes        ;check for next mode
00002402                          2608          
00002402                          2609  checkMoveDest:
00002402  7000                    2610          MOVEQ.L #0, D0                  ;clear D0
00002404                          2611          
00002404                          2612  validMoveDestModes:
00002404                          2613          
00002404  43F8 23D3               2614          LEA moveDestEAmasks,A1          ;load the list of masks
00002408  D3C0                    2615          ADDA.L D0,A1                    ;displace to a specific mask
0000240A  1A11                    2616          MOVE.B (A1),D5                  ;move the mask to D5
0000240C                          2617          
0000240C  0C05 0000               2618          CMPI.B #0,D5                    ;check if the mask is 0
00002410  6700 EC84               2619          BEQ falsePositive               ;branch if it is
00002414                          2620          
00002414  3401                    2621          MOVE.W D1,D2                    ;copy instruction to D2
00002416  EC4A                    2622          LSR.W #6,D2                     ;move mode
00002418  6100 0702               2623          BSR switchModeAndReg            ;switch register and mode
0000241C  C405                    2624          AND.B D5,D2                     ;mask D2
0000241E                          2625          
0000241E  43F8 23CC               2626          LEA moveDestEA,A1               ;load the list of valid modes
00002422  D3C0                    2627          ADDA.L D0,A1                    ;displace to a specific mode
00002424  1811                    2628          MOVE.B (A1),D4                  ;move mode to D4
00002426  B404                    2629          CMP.B D4,D2                     ;compare mode to masked value
00002428  6700 0006               2630          BEQ moveBody                    ;if its match, its a valid mode and we can procede
0000242C                          2631          
0000242C  5280                    2632          ADDQ.L #1,D0                    ;add one to displacement
0000242E  60D4                    2633          BRA validMoveDestModes          ;check for next mode
00002430                          2634          
00002430                          2635  moveBody
00002430  3401                    2636          MOVE.W  D1,D2                   ;copy inst to D2
00002432  C47C 3000               2637          AND.W  #%0011000000000000,D2    ;mask word for size
00002436  0C42 0000               2638          CMPI.W #0,D2                    ;0 is the only non valid size
0000243A  6700 EC5A               2639          BEQ falsePositive               ; if zero, this is not move
0000243E                          2640  
0000243E  43F9 00002DC6           2641          LEA     moveMessage,A1          ;move string for MOVE
00002444  103C 000E               2642          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002448                          2643                                ;string with CR, LF
00002448  4E4F                    2644          TRAP    #15
0000244A                          2645          
0000244A  6100 0052               2646          BSR moveSize
0000244E                          2647          
0000244E  3401                    2648          MOVE.W  D1,D2                   ;check source mode
00002450  C43C 003F               2649          AND.B   #%00111111,D2
00002454  1A02                    2650          MOVE.B  D2,D5
00002456  48E7 4000               2651          MOVEM.L D1,-(SP)
0000245A  6100 03F0               2652          BSR     Get_Effective_Address
0000245E  4CDF 0002               2653          MOVEM.L (SP)+,D1
00002462                          2654          
00002462                          2655          ;print ','
00002462  48E7 4000               2656          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002466  123C 002C               2657          MOVE.B #',',D1                  ;put ascii value of char in D1
0000246A  103C 0006               2658          MOVE.B #6,D0                    ;move task 6 into D0
0000246E  4E4F                    2659          TRAP #15                        ;prin char
00002470  4CDF 0002               2660          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002474                          2661          
00002474  3401                    2662          MOVE.W  D1,D2                   ;check dest mode
00002476  EC4A                    2663          LSR.W   #6,D2
00002478  6100 06A2               2664          BSR  switchModeAndReg
0000247C  C43C 003F               2665          AND.B   #%00111111,D2
00002480  1A02                    2666          MOVE.B  D2,D5
00002482  48E7 4000               2667          MOVEM.L D1,-(SP)
00002486  6100 03C4               2668          BSR     Get_Effective_Address
0000248A  4CDF 0002               2669          MOVEM.L (SP)+,D1
0000248E                          2670          
0000248E                          2671          
0000248E                          2672          
0000248E  43F9 00002D56           2673          LEA     clearLine,A1            ;move string for a CR and LF
00002494  103C 000E               2674          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002498                          2675                                ;string without CR, LF
00002498  4E4F                    2676          TRAP    #15
0000249A                          2677  
0000249A  7000                    2678          MOVEQ.L #0,D0
0000249C  4E75                    2679          RTS
0000249E                          2680          
0000249E                          2681  moveSize:
0000249E  3401                    2682          MOVE.W  D1,D2                   ;copy inst to D2
000024A0  E04A                    2683          LSR.W   #8,D2                   ;shift size
000024A2  E80A                    2684          LSR.B   #4,D2
000024A4  C4BC 00000003           2685          AND.L  #%11,D2                  ;mask for size
000024AA  7C00                    2686          MOVEQ.L #0,D6                   ;clear D6
000024AC  0C42 0002               2687          CMPI.W #2,D2                    ;compare and then branch depending on size
000024B0  6700 001C               2688          BEQ moveSizeLong
000024B4  6E00 0012               2689          BGT moveSizeWord
000024B8  6D00 0008               2690          BLT moveSizeByte
000024BC                          2691  moveSizeDone:        
000024BC  6100 052C               2692          BSR printSize
000024C0  4E75                    2693          RTS
000024C2                          2694          
000024C2                          2695  moveSizeByte:
000024C2  1C3C 0000               2696          MOVE.B #0,D6
000024C6  60F4                    2697          BRA moveSizeDone
000024C8                          2698          
000024C8                          2699  moveSizeWord:
000024C8  1C3C 0001               2700          MOVE.B #1,D6
000024CC  60EE                    2701          BRA moveSizeDone
000024CE                          2702          
000024CE                          2703  moveSizeLong:
000024CE  1C3C 0002               2704          MOVE.B #2,D6
000024D2  60E8                    2705          BRA moveSizeDone
000024D4                          2706          
000024D4= 08 00                   2707  moveADestEA        DC.B %001000,0
000024D6= 38 00                   2708  moveADestEAmasks   DC.B %111000,0
000024D8                          2709          
000024D8                          2710  MOVEA:
000024D8                          2711  
000024D8  7000                    2712          MOVEQ.L #0, D0                  ;clear D0
000024DA                          2713          
000024DA                          2714  validMoveAModes:
000024DA                          2715          
000024DA  43F8 23C3               2716          LEA moveSourceEAmasks,A1        ;load the list of masks
000024DE  D3C0                    2717          ADDA.L D0,A1                    ;displace to a specific mask
000024E0  1A11                    2718          MOVE.B (A1),D5                  ;move the mask to D5
000024E2                          2719          
000024E2  0C05 0000               2720          CMPI.B #0,D5                    ;check if the mask is 0
000024E6  6700 EBAE               2721          BEQ falsePositive               ;branch if it is
000024EA                          2722          
000024EA  1401                    2723          MOVE.B D1,D2                    ;copy instruction to D2
000024EC  C405                    2724          AND.B D5,D2                     ;mask D2
000024EE                          2725          
000024EE  43F8 23BA               2726          LEA moveSourceEA,A1             ;load the list of valid modes
000024F2  D3C0                    2727          ADDA.L D0,A1                    ;displace to a specific mode
000024F4  1811                    2728          MOVE.B (A1),D4                  ;move mode to D4
000024F6  B404                    2729          CMP.B D4,D2                     ;compare mode to masked value
000024F8  6700 0006               2730          BEQ  moveABody                  ;if its match, its a valid mode and we can procede
000024FC                          2731          
000024FC  5280                    2732          ADDQ.L #1,D0                    ;add one to displacement
000024FE  60DA                    2733          BRA validMoveAModes             ;check for next mode
00002500                          2734          
00002500                          2735  moveABody:
00002500  3401                    2736          MOVE.W  D1,D2                   ;copy inst to D2
00002502  C47C 3000               2737          AND.W  #%0011000000000000,D2    ;mask word for size
00002506  0C42 0000               2738          CMPI.W #0,D2                    ;0 is the non valid size
0000250A  6700 EB8A               2739          BEQ falsePositive               ; if zero, this is not move
0000250E  0C42 1000               2740          CMPI.W #%0001000000000000,D2
00002512  6700 EB82               2741          BEQ falsePositive               ; if byte, this is not movea
00002516                          2742  
00002516                          2743  
00002516  43F9 00002DD7           2744          LEA     moveAMessage,A1         ;move string for MOVE
0000251C  103C 000E               2745          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002520                          2746                                ;string without CR, LF
00002520  4E4F                    2747          TRAP    #15
00002522                          2748  
00002522  6100 FF7A               2749          BSR moveSize
00002526                          2750          
00002526                          2751          ;Do EA
00002526                          2752          
00002526  3401                    2753          MOVE.W  D1,D2                   ;check mode
00002528  C43C 003F               2754          AND.B   #%00111111,D2
0000252C  1A02                    2755          MOVE.B  D2,D5
0000252E  48E7 4000               2756          MOVEM.L D1,-(SP)
00002532  6100 0318               2757          BSR     Get_Effective_Address
00002536  4CDF 0002               2758          MOVEM.L (SP)+,D1
0000253A                          2759          
0000253A                          2760          
0000253A                          2761          ;print ','
0000253A  48E7 4000               2762          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000253E  123C 002C               2763          MOVE.B #',',D1                  ;put ascii value of char in D1
00002542  103C 0006               2764          MOVE.B #6,D0                    ;move task 6 into D0
00002546  4E4F                    2765          TRAP #15                        ;prin char
00002548  4CDF 0002               2766          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000254C                          2767          
0000254C                          2768          
0000254C                          2769          ;Then do An
0000254C                          2770          
0000254C  3401                    2771          MOVE.W  D1,D2
0000254E  E04A                    2772          LSR.W   #8,D2                   ;move reg into first byte
00002550  E20A                    2773          LSR.B   #1,D2                   ;line it up to least sig bit
00002552  C43C 0007               2774          AND.B   #%00000111,D2           ;force mode to An
00002556  5002                    2775          ADDQ.B  #8,D2
00002558  1A02                    2776          MOVE.B  D2,D5
0000255A  48E7 4000               2777          MOVEM.L D1,-(SP)
0000255E  6100 02EC               2778          BSR     Get_Effective_Address
00002562  4CDF 0002               2779          MOVEM.L (SP)+,D1
00002566                          2780          
00002566  43F9 00002D56           2781          LEA     clearLine,A1            ;move string for a CR and LF
0000256C  103C 000E               2782          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002570                          2783                                ;string without CR, LF
00002570  4E4F                    2784          TRAP    #15
00002572                          2785  
00002572  7000                    2786          MOVEQ.L #0,D0
00002574  4E75                    2787          RTS
00002576                          2788  
00002576                          2789             
00002576                          2790  Bcc:
00002576                          2791          
00002576  48E7 4000               2792          MOVEM.L D1,-(SP)
0000257A  43F9 00002DCB           2793          LEA     bccMessage,A1           ;move string for BRA info
00002580  103C 000E               2794          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002584                          2795                                ;string without CR, LF
00002584  4E4F                    2796          TRAP    #15
00002586                          2797          
00002586  7000                    2798          MOVEQ.L #0,D0                   ;clear D0
00002588  3401                    2799          MOVE.W  D1,D2                   ;move instruction into D2 for manipulaiton
0000258A  E04A                    2800          LSR.W   #8,D2
0000258C  C47C 000F               2801          AND.W   #$0F,D2                 ;mask instruction
00002590                          2802          
00002590                          2803  checkCC:        
00002590  41F9 00002CDE           2804          LEA     bccList,A0              ;get condition code signature list in A0
00002596  D1C0                    2805          ADDA.L  D0,A0                   ;get correct sig         
00002598  B410                    2806          CMP.B   (A0),D2                 ;compare to sig
0000259A  6700 0006               2807          BEQ     foundCC                 ;if sig matches branch
0000259E  5200                    2808          ADDQ.B  #byte,D0
000025A0  60EE                    2809          BRA     checkCC
000025A2                          2810  foundCC:
000025A2  43F9 00002CEE           2811          LEA     conditionCodeMessage,A1 ;get condition code message in A1
000025A8  C0FC 0004               2812          MULU.W  #long,D0                ;adjust size of D0 for a long
000025AC  D3C0                    2813          ADDA.L  D0,A1                   ;get correct message location
000025AE  2251                    2814          MOVEA.L (A1),A1                 ;get correct message
000025B0                          2815          
000025B0  103C 000E               2816          MOVE.B  #14,D0                  ;set for task to display null terminated 
000025B4                          2817                                ;string without CR, LF
000025B4  4E4F                    2818          TRAP    #15
000025B6                          2819  
000025B6                          2820          
000025B6                          2821          
000025B6  548B                    2822          ADDQ.L  #word,A3                ;move past instruction in case long displacement
000025B8  C27C 00FF               2823          AND.W   #$00FF,D1               ;check for word sized displacement
000025BC                          2824          
000025BC  B23C 0000               2825          CMP.B   #$0,D1
000025C0  6700 0028               2826          BEQ     BccWord
000025C4                          2827          
000025C4  B23C 00FF               2828          CMP.B   #$FF,D1 check for long sized displacement
000025C8  6700 002A               2829          BEQ     BccLong
000025CC                          2830          
000025CC                          2831  BccByte:
000025CC                          2832          
000025CC  1201                    2833          MOVE.B D1,D1                    ;lazy check if negative
000025CE                          2834          
000025CE  6B00 000E               2835          BMI signExtendByte
000025D2                          2836          
000025D2  C2BC 000000FF           2837          AND.L #$000000FF,D1             ;mask out rest of reg just in case
000025D8                          2838          
000025D8  7E00                    2839          MOVEQ.L #0,D7                   ;pass back no extra data followed
000025DA  6000 0020               2840          BRA     BccDone
000025DE                          2841          
000025DE                          2842  signExtendByte:        
000025DE                          2843          
000025DE  82BC FFFFFF00           2844          OR.L #$FFFFFF00,D1              ;extend to long by set all bits not part of the
000025E4                          2845                             ;least significant byte
000025E4                          2846          
000025E4  7E00                    2847          MOVEQ.L #0,D7                   ;pass back no extra data followed
000025E6  6000 0014               2848          BRA     BccDone
000025EA                          2849  
000025EA                          2850  BccWord:
000025EA  3253                    2851          MOVEA.W  (A3),A1                ;sign extend word
000025EC  2209                    2852          MOVE.L   A1,D1
000025EE  7E02                    2853          MOVEQ.L #word,D7                ;pass back an extra word followed
000025F0  6000 000A               2854          BRA     BccDone
000025F4                          2855  BccLong:
000025F4  2213                    2856          MOVE.L  (A3),D1 
000025F6  7E04                    2857          MOVEQ.L #long,D7                ;pass back an extra long followed
000025F8  6000 0002               2858          BRA     BccDone
000025FC                          2859  BccDone:
000025FC                          2860  
000025FC  303C 0003               2861          MOVE.W  #3,D0                   ;put task #15 in D0
00002600  4E4F                    2862          TRAP    #15
00002602                          2863          
00002602  43F9 00002D56           2864          LEA     clearLine,A1            ;move string for a CR and LF
00002608  103C 000E               2865          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000260C                          2866                                ;string without CR, LF
0000260C  4E4F                    2867          TRAP    #15
0000260E                          2868          
0000260E  4CDF 0002               2869          MOVEM.L (SP)+,D1
00002612  7000                    2870          MOVEQ.L #0,D0
00002614  4E75                    2871          RTS
00002616                          2872          
00002616                          2873          
00002616                          2874  unknownOpCode:
00002616  43F9 00002DD1           2875          LEA     dataMessage,A1          ;move string for data info
0000261C  103C 000E               2876          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002620                          2877                                ;string without CR, LF
00002620  4E4F                    2878          TRAP    #15
00002622                          2879          
00002622                          2880          ;print word in D1
00002622  48E7 1200               2881          MOVEM.L D6/D3,-(SP)
00002626  1C3C 0001               2882          MOVE.B #1,D6                    ;put size of word in D6
0000262A  2601                    2883          MOVE.L D1,D3                    ;move data at D1 to D3
0000262C  6100 0442               2884          BSR outputHex
00002630  4CDF 0048               2885          MOVEM.L (SP)+,D6/D3
00002634                          2886          
00002634  43F9 00002D56           2887          LEA     clearLine,A1            ;move string for a CR and LF
0000263A  103C 000E               2888          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000263E                          2889                                ;string without CR, LF
0000263E  4E4F                    2890          TRAP    #15
00002640                          2891          
00002640  7000                    2892          MOVEQ.L #0,D0
00002642  4E75                    2893          RTS
00002644                          2894          
00002644                          2895  handlebytedata:
00002644                          2896  
00002644  43F9 00002DD1           2897          LEA     dataMessage,A1          ;move string for data info
0000264A  103C 000E               2898          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000264E                          2899                                ;string without CR, LF
0000264E  4E4F                    2900          TRAP    #15
00002650                          2901          
00002650  1213                    2902          MOVE.B (A3),D1                  ;copy word from other prog to analyze as instruction
00002652                          2903          
00002652  E049                    2904          LSR.W   #8,D1                   ;shift the word read into D1 by a byte
00002654                          2905          
00002654  48E7 1200               2906          MOVEM.L D6/D3,-(SP)
00002658  1C3C 0000               2907          MOVE.B #0,D6                    ;put size of byte in D6
0000265C  1601                    2908          MOVE.B D1,D3                    ;move data at D1 to D3
0000265E  6100 0410               2909          BSR outputHex
00002662  4CDF 0048               2910          MOVEM.L (SP)+,D6/D3
00002666                          2911          
00002666  43F9 00002D56           2912          LEA     clearLine,A1            ;move string for a CR and LF
0000266C  103C 000E               2913          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002670                          2914                                ;string without CR, LF
00002670  4E4F                    2915          TRAP    #15
00002672                          2916          
00002672  4C9F 0004               2917          MOVEM.W (SP)+,D2                ;restore D2 for next iteration in main loop
00002676  7000                    2918          MOVEQ.L #0,D0
00002678                          2919          
00002678  528B                    2920          ADDQ.L  #byte,A3
0000267A  6000 E99C               2921          BRA main_Loop
0000267E                          2922  
0000267E                          2923          
0000267E                          2924          
0000267E                          2925  fin:
0000267E  43F9 00002E98           2926          LEA     thankyouMessage,A1      ;move string for MOVE
00002684  103C 000E               2927          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002688                          2928                                ;string without CR, LF
00002688  4E4F                    2929          TRAP    #15
0000268A                          2930          
0000268A                          2931          
0000268A  FFFF FFFF               2932          simhalt
0000268E                          2933          
0000268E                          2934  
0000268E                          2935  *******************************************************************************
0000268E                          2936  *                            SUB ROUTINES
0000268E                          2937  *******************************************************************************
0000268E                          2938  
0000268E                          2939  *******************************************************************************
0000268E                          2940  *                          IO ROLE ROUTINES
0000268E                          2941  *******************************************************************************
0000268E                          2942  
0000268E                          2943  *==========================================================================
0000268E                          2944  *                   Enter / Validate beginning address 
0000268E                          2945  *==========================================================================
0000268E                          2946   
0000268E                          2947  begin_address:
0000268E                          2948  
0000268E                          2949         
0000268E  43F9 00002B30           2950          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00002694  2239 00002B30           2951          MOVE.L      slPrompt,D1         ;Load display length to D1
0000269A  700E                    2952          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
0000269C  4E4F                    2953          TRAP        #15                 ;Perform task 14 (display)
0000269E                          2954          
0000269E  43F9 00002EB6           2955          LEA         startLocation,A1    ;Load address to store user input
000026A4  103C 0002               2956          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
000026A8  4E4F                    2957          TRAP        #15                 ;Perform task 2 (input)
000026AA                          2958          
000026AA                          2959          ;CMP.B       #27,(A1)            ;Check for ESC entered
000026AA                          2960          ;BEQ         address_Exit        ;Exit condition
000026AA                          2961                  
000026AA  0C11 0071               2962          CMP.B       #113,(A1)            ;Check for 'q' entered
000026AE  6700 006C               2963          BEQ         address_Exit
000026B2                          2964          
000026B2                          2965          
000026B2  0C11 0051               2966          CMP.B       #81,(A1)            ;Check for 'Q' entered
000026B6  6700 0064               2967          BEQ         address_Exit 
000026BA                          2968          
000026BA  6100 0068               2969          BSR         enter_addr_edit_all
000026BE  B67C FFFF               2970          CMP.W       #-1,D3              ;Did the edit pass?
000026C2  67CA                    2971          BEQ         begin_address       ;No, loop and ask for correct input
000026C4                          2972          
000026C4  2643                    2973          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
000026C6                          2974          
000026C6  43F9 00002C9C           2975          LEA         spc,A1              ;Load address for starting loaction prompt
000026CC  1239 00002C9D           2976          MOVE.B      spc_len,D1          ;Load empty line length
000026D2  7000                    2977          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
000026D4  4E4F                    2978          TRAP        #15                 ;Perform task 14 (display)
000026D6  6000 0002               2979          BRA         end_address
000026DA                          2980  
000026DA                          2981  *===========================================================================
000026DA                          2982  *                   Enter / Validate ending address 
000026DA                          2983  *===========================================================================
000026DA                          2984  
000026DA                          2985  end_address:
000026DA                          2986          
000026DA  43F9 00002B75           2987          LEA         elPrompt,A1         ;Load address for ending loaction prompt
000026E0                          2988          ;MOVE.L     elPrompt,D1         ;Load display length to D1
000026E0  7250                    2989          MOVE.L      #80,D1              ;did not like previous command, do not know why, it should have worked
000026E2  700E                    2990          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
000026E4  4E4F                    2991          TRAP        #15                 ;Perform task 14 (display)
000026E6                          2992          
000026E6  43F9 00002EBA           2993          LEA         endLocation,A1      ;Load address to store user input
000026EC  103C 0002               2994          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
000026F0  4E4F                    2995          TRAP        #15                 ;Perform task 2 (input)
000026F2                          2996          
000026F2                          2997          ;CMP.B       #27,(A1)            ;Check for ESC entered
000026F2                          2998          ;BEQ         address_Exit        ;Exit condition 
000026F2                          2999                  
000026F2  0C11 0071               3000          CMP.B       #113,(A1)            ;Check for 'q' entered
000026F6  6700 0024               3001          BEQ         address_Exit
000026FA                          3002                 
000026FA  0C11 0051               3003          CMP.B       #81,(A1)            ;Check for 'Q' entered
000026FE  6700 001C               3004          BEQ         address_Exit 
00002702                          3005          
00002702                          3006          
00002702  6100 0020               3007          BSR         enter_addr_edit_all
00002706  B67C FFFF               3008          CMP.W       #-1,D3              ;Did the edit pass?
0000270A  67CE                    3009          BEQ         end_address         ;No, loop and ask for correct input
0000270C                          3010          
0000270C  6100 0122               3011          BSR         enter_addr_edit_to  ;Test for to address less than from address
00002710  B67C FFFF               3012          CMP.W       #-1,D3              ;Did the edit pass?
00002714  67C4                    3013          BEQ         end_address         ;No, loop and ask for correct input
00002716                          3014  
00002716                          3015  
00002716  2843                    3016          MOVEA.L     D3,A4               ;Ending address gets stored in A4
00002718  6000 0008               3017          BRA         address_done
0000271C                          3018  
0000271C                          3019  address_Exit:
0000271C                          3020  
0000271C  76FF                    3021          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000271E  6000 0002               3022          BRA         address_done
00002722                          3023          
00002722                          3024  address_done:
00002722                          3025  
00002722  4E75                    3026          RTS    
00002724                          3027  
00002724                          3028  *==============================================================================
00002724                          3029  * enter_addr_edit_all - Enter address edit check to edit all errors  
00002724                          3030  *                       using multiple different error checking routines.
00002724                          3031  *
00002724                          3032  * Parameters -
00002724                          3033  *   Input   A1      The data that needs checked.
00002724                          3034  *   Input   D1      The number of characters input     
00002724                          3035  *   Output  D3      Returns '-1' when there is an error.
00002724                          3036  *==============================================================================
00002724                          3037  
00002724                          3038  enter_addr_edit_all
00002724                          3039  
00002724                          3040  *------------------------------------------------------------------------------
00002724                          3041  * Test for odd number of characters entered, not allowed
00002724                          3042  *------------------------------------------------------------------------------
00002724                          3043         
00002724  6100 0024               3044          BSR         ck_boundry          ;check if the input is on a odd / even boundry
00002728  B67C FFFF               3045          CMP.W       #-1,D3              ;Is the address odd?
0000272C  6700 001A               3046          BEQ         enter_addr_edit_all_exit     ;No, return
00002730                          3047  
00002730                          3048  *------------------------------------------------------------------------------
00002730                          3049  * Ttest for character entered all being valid address characters
00002730                          3050  * Note: lower case a-f, gets converted to upper case A-F in D3
00002730                          3051  *------------------------------------------------------------------------------
00002730                          3052          
00002730  6100 0062               3053          BSR         parseHexString      ;check if the input contains valid Hex characters
00002734  B67C FFFF               3054          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
00002738  6700 000E               3055          BEQ         enter_addr_edit_all_exit     ;No, return
0000273C                          3056  
0000273C                          3057  *------------------------------------------------------------------------------
0000273C                          3058  * Verify that the address entered is witin the range defined in the Equate
0000273C                          3059  *------------------------------------------------------------------------------        
0000273C                          3060          
0000273C  6100 00C8               3061          BSR         ck_addr_range       ;is address entered witin the range 
00002740                          3062                                          ;   as defined in the Equate? 
00002740  B67C FFFF               3063          CMP.W       #-1,D3              ;is the address  valid?
00002744  6700 0002               3064          BEQ         enter_addr_edit_all_exit     ;No, return
00002748                          3065  
00002748                          3066  enter_addr_edit_all_exit:
00002748                          3067  
00002748  4E75                    3068          RTS                             ;return
0000274A                          3069  
0000274A                          3070  *==============================================================================
0000274A                          3071  * ck_boundry - Check the size of the data characters input and determine
0000274A                          3072  *              if an odd number of characters was entered
0000274A                          3073  *
0000274A                          3074  * Parameters -
0000274A                          3075  *   Input   A1      The data that needs checked for odd length.
0000274A                          3076  *   Input   D1      The number of characters input     
0000274A                          3077  *   Output  D3      Returns '-1' when there is an odd length.
0000274A                          3078  *==============================================================================
0000274A                          3079  
0000274A                          3080  ck_boundry:
0000274A                          3081  
0000274A  4243                    3082          CLR.W       D3                  ;Clear the return
0000274C                          3083  
0000274C  B23C 0000               3084          CMP.B       #0,D1               ;Check for nothing entered
00002750  6700 002E               3085          BEQ         ck_size_error       ;Number of characters entered must be 
00002754                          3086                                          ;greater than 0  
00002754                          3087          
00002754                          3088          
00002754                          3089          * The program will branch to ck_size_error if D1 is greater than #8        
00002754  B23C 0008               3090          CMP.B       #8,D1               ;Check for more than 8 characters entered
00002758  6E00 0026               3091          BGT         ck_size_error       ;Number of characters entered must be less
0000275C                          3092                                          ;than 9
0000275C                          3093          
0000275C  7402                    3094          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
0000275E  82C2                    3095          DIVU        D2,D1               ;Divide address by 2
00002760  4841                    3096          SWAP        D1                  ;get remainder
00002762  B23C 0001               3097          CMP.B       #$01,D1             ;Check for remainder of 1
00002766  6700 0004               3098          BEQ         ck_boundry_error    ;Number of characters entered must be an 
0000276A                          3099                                          ;even number   
0000276A                          3100    
0000276A  4E75                    3101          RTS                             ;return
0000276C                          3102  
0000276C                          3103  *------------------------------------------------------------------------------
0000276C                          3104  * ck_boundry_error - An odd number of characters was entered
0000276C                          3105  *                  - Load error message and display it
0000276C                          3106  *                  - Return error condition
0000276C                          3107  *------------------------------------------------------------------------------
0000276C                          3108          
0000276C                          3109  ck_boundry_error:
0000276C                          3110  
0000276C  43F9 00002C45           3111          LEA         even_msg,A1         ;Load odd error message into A1
00002772  2239 00002C45           3112          MOVE.L      even_msg,D1         ;Load error length to D1
00002778                          3113          
00002778  7000                    3114          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
0000277A                          3115                                          ; n is D1.W with CR, LF. 
0000277A  4E4F                    3116          TRAP #15                        ;Display the error message
0000277C  76FF                    3117          MOVE.L #-1,D3                   ;Load -1 into return parameter
0000277E  4E75                    3118          RTS                             ;Return
00002780                          3119          
00002780                          3120  *------------------------------------------------------------------------------
00002780                          3121  * ck_size_error -   The number of characters entered must be more than zero
00002780                          3122  *                  - Load error message and display it
00002780                          3123  *                  - Return error condition
00002780                          3124  *------------------------------------------------------------------------------
00002780                          3125          
00002780                          3126  ck_size_error:
00002780                          3127  
00002780  43F9 00002BB8           3128          LEA         invalidMsg,A1       ;Load invalid range message into A1
00002786  2239 00002BB8           3129          MOVE.L      invalidMsg,D1       ;Load error length to D1
0000278C                          3130          
0000278C  7000                    3131          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
0000278E                          3132                                          ; n is D1.W with CR, LF. 
0000278E  4E4F                    3133          TRAP        #15                 ;Display the error message
00002790  76FF                    3134          MOVE.L      #-1,D3              ;Load -1 into return parameter
00002792  4E75                    3135          RTS                             ;Return        
00002794                          3136  
00002794                          3137  *==============================================================================
00002794                          3138  * parseHexString - Converts user input string into a valid memory address
00002794                          3139  *                - Stores parsed address data into D3
00002794                          3140  *                - Stores good/bad (1/0) data in D4 
00002794                          3141  *
00002794                          3142  * Hex values are stored as bytes in D2, the ASCII chart shows their value
00002794                          3143  *   The ASCII chart values we care about are in the ranges of: 
00002794                          3144  *                            Hex            Decimal
00002794                          3145  *       No Value           NULL = 0         0
00002794                          3146  *       Numeric Values:     0-9 = 30-39     48-57
00002794                          3147  *       Upper Case letters: A-F = 41-46     65-70
00002794                          3148  *       Lower Case letterc: a-f = 61-66     97-102
00002794                          3149  
00002794                          3150  * Parameters -
00002794                          3151  *   Input   A1      The data that needs checked for valid input.
00002794                          3152  *   Output  D3      The return value, '-1' for error
00002794                          3153  *==============================================================================
00002794                          3154  
00002794                          3155  parseHexString:
00002794                          3156  
00002794                          3157  * setup any initializing item that do not get looped through
00002794  4243                    3158          CLR.W       D3                  ;Clear the return
00002796                          3159  
00002796                          3160          
00002796                          3161  *------------------------------------------------------------------------------
00002796                          3162  * NextHex - Loop through all bytes and vaildate the input
00002796                          3163  * Parameters -
00002796                          3164  *   Input   A1      The data that needs checked for valid input.
00002796                          3165  *   Output  D3      The return value, '-1' for error
00002796                          3166  *------------------------------------------------------------------------------
00002796                          3167          
00002796                          3168  NextHex:
00002796                          3169  
00002796  1419                    3170          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00002798  B43C 0000               3171          CMP.B       #0,D2               ;Check character for null 
0000279C  6700 0066               3172          BEQ         NextHexReturn       ;Character is null (end of input)
000027A0                          3173          
000027A0                          3174  *................................................................................
000027A0                          3175  *  Check decimal values 0-9 by testing hexadecimal values 30-39
000027A0                          3176  *................................................................................
000027A0                          3177                  
000027A0                          3178          * The program will branch to hex_range_error if D2 is less than #30
000027A0  B43C 0030               3179          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
000027A4  6D00 0048               3180          BLT         hex_range_error     ;Branch to handle range error hexidecimal
000027A8                          3181                                          ;processing
000027A8                          3182          
000027A8                          3183          * The program will branch to UcaseHex if D2 is greater than #39
000027A8  B43C 0039               3184          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
000027AC  6E00 000A               3185          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
000027B0                          3186          
000027B0                          3187          *a valid number was found within this range
000027B0  0402 0030               3188          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
000027B4  6000 0032               3189          BRA         NextHexDone         ;Done parsing this byte
000027B8                          3190  
000027B8                          3191  
000027B8                          3192  *..............................................................................
000027B8                          3193  *  Check upper case values A-F by testing hexadecimal values 41-46
000027B8                          3194  *..............................................................................
000027B8                          3195  
000027B8                          3196  UcaseHex:
000027B8                          3197  
000027B8                          3198          * The program will branch to hex_range_error if D2 is less than #41
000027B8  B43C 0041               3199          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
000027BC  6D00 0030               3200          BLT         hex_range_error     ;Branch to handle range error hexidecimal
000027C0                          3201                                          ;processing
000027C0                          3202          
000027C0  B43C 0046               3203          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
000027C4  6E00 000A               3204          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
000027C8                          3205                                          ;processing
000027C8                          3206          
000027C8                          3207          *a valid number was found within this range
000027C8  0402 0037               3208          SUBI.B      #55,D2              ;Change uppercase character to actual value
000027CC  6000 001A               3209          BRA         NextHexDone         ;Done parsing this byte
000027D0                          3210  
000027D0                          3211  
000027D0                          3212  *..............................................................................
000027D0                          3213  *  Check lower case values a-f by testing hexadecimal values 61-66
000027D0                          3214  *..............................................................................
000027D0                          3215  
000027D0                          3216  LcaseHex
000027D0                          3217          
000027D0                          3218          * The program will branch to hex_range_error if D2 is less than #61
000027D0  B43C 0061               3219          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
000027D4  6D00 0018               3220          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
000027D8                          3221                                          ;processing
000027D8                          3222  
000027D8  B43C 0066               3223          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
000027DC  6E00 0010               3224          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
000027E0                          3225                                          ;processing
000027E0                          3226  
000027E0                          3227          *a valid number was found within this range
000027E0  0402 0057               3228          SUBI.B      #87,D2              ;Change lowercase character to actual value
000027E4  6000 0002               3229          BRA         NextHexDone         ;Done parsing this byte
000027E8                          3230  
000027E8                          3231  NextHexDone:
000027E8                          3232  
000027E8  E983                    3233          ASL.L       #4,D3               ; Make rooom for new byte in the return register
000027EA  D602                    3234          ADD.B       D2,D3               ; Move the new byte into the return register
000027EC  60A8                    3235          BRA         NextHex             ; We're ready to parse the next byte
000027EE                          3236          
000027EE                          3237  *-------------------------------------------------------------------------------------
000027EE                          3238  * hex_range_error -  A character entered was within the valid range for a hex address
000027EE                          3239  *                 -  Load error message and display it
000027EE                          3240  *                 -  Return error condition
000027EE                          3241  *-------------------------------------------------------------------------------------
000027EE                          3242          
000027EE                          3243  hex_range_error:
000027EE                          3244  
000027EE  43F9 00002BFD           3245          LEA         invCharMsg,A1       ;Load invalid range message into A1
000027F4  2239 00002BFD           3246          MOVE.L      invCharMsg,D1       ;Load error length to D1
000027FA                          3247          
000027FA  7000                    3248          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
000027FC                          3249                                          ; n is D1.W with CR, LF. 
000027FC  4E4F                    3250          TRAP        #15                 ;Display the error message
000027FE  76FF                    3251          MOVE.L      #-1,D3              ;Load -1 into return parameter
00002800  6000 0002               3252          BRA         NextHexReturn
00002804                          3253          
00002804                          3254  NextHexReturn:
00002804                          3255          
00002804  4E75                    3256          RTS                             ;Return      
00002806                          3257  
00002806                          3258  
00002806                          3259  *===============================================================================
00002806                          3260  * ck_addr_range - check the address input is within a valid memory address range
00002806                          3261  *                - Parsed address data into D3
00002806                          3262  *
00002806                          3263  * Parameters -
00002806                          3264  *   Input   A1      The data that needs checked for valid address.
00002806                          3265  *   Output  D3      The return value, '-1' for error
00002806                          3266  *===============================================================================
00002806                          3267  
00002806                          3268  
00002806                          3269  ck_addr_range:   
00002806                          3270  
00002806                          3271  *------------------------------------------------------------------------------
00002806                          3272  * Verify that the address entered is witin the 
00002806                          3273  * beginning range ('begin') as defined in the Equate
00002806                          3274  *------------------------------------------------------------------------------   
00002806                          3275              
00002806  7C00                    3276          MOVE.L      #begin,D6           * Load minimum starting address
00002808  B686                    3277          CMP.L       D6,D3               * Is input at or above minimum?
0000280A  6D00 0012               3278          BLT         ck_addr_range_error 
0000280E                          3279          
0000280E                          3280  *------------------------------------------------------------------------------
0000280E                          3281  * Verify that the address entered is witin the 
0000280E                          3282  * ending range ('end') as defined in the Equate
0000280E                          3283  *------------------------------------------------------------------------------
0000280E                          3284          
0000280E  2C3C 00FFFFFE           3285          MOVE.L      #end,D6             * Load maximum starting address
00002814  B686                    3286          CMP.L       D6,D3               * Is input at or below maximum?
00002816  6E00 0006               3287          BGT         ck_addr_range_error 
0000281A  6000 0012               3288          BRA         ck_addr_done        ;done checking
0000281E                          3289          
0000281E                          3290  *..............................................................................
0000281E                          3291  * ck_addr_range_error -  A address entered is not within the 
0000281E                          3292  *                        valid range for a hex address
0000281E                          3293  *..............................................................................
0000281E                          3294          
0000281E                          3295  ck_addr_range_error
0000281E                          3296  
0000281E  43F9 00002BB8           3297          LEA         invalidMsg,A1       ;Load invalid range message into A1
00002824                          3298          
00002824  700D                    3299          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
00002826                          3300                                          ;with CR, LF. 
00002826  4E4F                    3301          TRAP        #15                 ;Display the error message
00002828  76FF                    3302          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000282A  6000 0002               3303          BRA         ck_addr_done 
0000282E                          3304  
0000282E                          3305  ck_addr_done:
0000282E                          3306  
0000282E  4E75                    3307          RTS                             ;Return
00002830                          3308          
00002830                          3309  *------------------------------------------------------------------------------
00002830                          3310  * enter_addr_edit_to -  Test for to date coming before a from date
00002830                          3311  *                    - Return error condition
00002830                          3312  *------------------------------------------------------------------------------
00002830                          3313  
00002830                          3314  enter_addr_edit_to
00002830                          3315  
00002830                          3316          ;MOVE.L      (A3),D6             * Load starting address
00002830                          3317          
00002830  2C43                    3318          MOVEA.L     D3,A6               ;Ending address gets stored in A6 for compare
00002832  BDCB                    3319          CMPA.L      A3,A6               * Is input at or above minimum?
00002834  6D00 0004               3320          BLT         enter_addr_edit_to_error 
00002838                          3321          
00002838                          3322  
00002838                          3323  enter_addr_edit_to_return
00002838                          3324  
00002838  4E75                    3325          RTS
0000283A                          3326          
0000283A                          3327  *------------------------------------------------------------------------------
0000283A                          3328  * enter_addr_edit_to_error - To address can not be before from address
0000283A                          3329  *                          - Load error message and display it
0000283A                          3330  *                          - Return error condition
0000283A                          3331  *------------------------------------------------------------------------------
0000283A                          3332          
0000283A                          3333  enter_addr_edit_to_error:
0000283A                          3334  
0000283A  43F9 00002C66           3335          LEA         to_from_err,A1      ;Load to address error message into A1
00002840  7250                    3336          MOVE.L      #80,D1              ;Load to address error length to D1
00002842                          3337          
00002842  7000                    3338          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00002844                          3339                                          ; n is D1.W with CR, LF. 
00002844  4E4F                    3340          TRAP #15                        ;Display the error message
00002846  76FF                    3341          MOVE.L #-1,D3                   ;Load -1 into return parameter
00002848  4E75                    3342          RTS                             ;Return
0000284A                          3343          
0000284A                          3344   
0000284A                          3345  *******************************************************************************
0000284A                          3346  *                          OP CODE ROLE ROUTINES
0000284A                          3347  *******************************************************************************
0000284A                          3348  
0000284A                          3349  process_op_codes:
0000284A                          3350  
0000284A                          3351  
0000284A                          3352  
0000284A                          3353  process_op_codes_exit:
0000284A                          3354  
0000284A  4E75                    3355          RTS
0000284C                          3356  
0000284C                          3357  
0000284C                          3358  *******************************************************************************
0000284C                          3359  *                    Effective Addressing ROLE ROUTINES
0000284C                          3360  *******************************************************************************
0000284C                          3361  
0000284C                          3362  Get_Effective_Address:
0000284C                          3363  
0000284C  48E7 0200               3364          MOVEM.L D6,-(SP)                ;save D6 data
00002850  1C05                    3365          MOVE.B      D5,D6
00002852  E60E                    3366          LSR.B       #3,D6               ;mode
00002854  CA3C 0007               3367          And.B       #%00000111,D5       ;register
00002858                          3368          
00002858  BC3C 0000               3369          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
0000285C  6700 004A               3370          BEQ         Data_Reg_Direct
00002860                          3371          
00002860  BC3C 0001               3372          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
00002864  6700 005C               3373          BEQ         Addr_Reg_Direct
00002868                          3374          
00002868  BC3C 0002               3375          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
0000286C  6700 006E               3376          BEQ         Addr_Reg_Indirect
00002870                          3377          
00002870  BC3C 0003               3378          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
00002874  6700 0098               3379          BEQ         Addr_Reg_Indirect_Inc
00002878                          3380          
00002878  BC3C 0004               3381          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
0000287C  6700 00CE               3382          BEQ         Addr_Reg_Indirect_Dec
00002880                          3383          
00002880  BC3C 0007               3384          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
00002884  6700 0006               3385          BEQ         Get_Effective_Address_Other
00002888                          3386          
00002888  6000 015A               3387          BRA         invalidEA
0000288C                          3388          
0000288C                          3389  Get_Effective_Address_Other:        
0000288C                          3390          
0000288C  BA3C 0000               3391          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00002890  6700 00F8               3392          BEQ Addr_Abs_Short
00002894                          3393          
00002894  BA3C 0001               3394          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
00002898  6700 010A               3395          BEQ Addr_Abs_Long
0000289C                          3396          
0000289C  BA3C 0004               3397          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
000028A0  6700 011C               3398          BEQ Addr_Immediate_Data
000028A4                          3399          
000028A4  6000 013E               3400          BRA         invalidEA
000028A8                          3401          
000028A8                          3402  Data_Reg_Direct:                        ;case 0(0000)
000028A8                          3403  
000028A8  43F9 00002DFD           3404          LEA         letterD,A1          ;output 'D' for data register
000028AE  103C 000E               3405          MOVE.B      #14,D0              ;set for task to display null terminated 
000028B2  4E4F                    3406          TRAP        #15                 ;string without CR, LF
000028B4                          3407                          
000028B4  4281                    3408          CLR.L       D1
000028B6  1205                    3409          MOVE.B      D5,D1               ;move register number for display into D1
000028B8  103C 0003               3410          MOVE.B      #3,D0               ;set for task to display null terminated 
000028BC  4E4F                    3411          TRAP        #15                 ;string without CR, LF
000028BE                          3412                 
000028BE  6000 0124               3413          BRA         Get_Effective_Address_Exit  ;return
000028C2                          3414          
000028C2                          3415          
000028C2                          3416  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
000028C2                          3417        
000028C2  43F9 00002DFB           3418          LEA         letterA,A1          ;output 'A' for address register
000028C8  103C 000E               3419          MOVE.B      #14,D0              ;set for task to display null terminated 
000028CC  4E4F                    3420          TRAP        #15                 ;string without CR, LF
000028CE                          3421          
000028CE  4281                    3422          CLR.L       D1
000028D0  1205                    3423          MOVE.B      D5,D1               ;move register number for display into D1
000028D2  103C 0003               3424          MOVE.B      #3,D0               ;set for task to display null terminated 
000028D6  4E4F                    3425          TRAP        #15                 ;string without CR, LF
000028D8                          3426          
000028D8  6000 010A               3427          BRA         Get_Effective_Address_Exit  ;return
000028DC                          3428  
000028DC                          3429  
000028DC                          3430  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
000028DC                          3431          
000028DC  43F9 00002E03           3432          LEA         lprn,A1             ;output 'D' for data register
000028E2  103C 000E               3433          MOVE.B      #14,D0              ;set for task to display null terminated 
000028E6  4E4F                    3434          TRAP        #15                 ;string without CR, LF
000028E8                          3435  
000028E8  43F9 00002DFB           3436          LEA         letterA,A1          ;output 'A' for address register
000028EE  103C 000E               3437          MOVE.B      #14,D0              ;set for task to display null terminated 
000028F2  4E4F                    3438          TRAP        #15                 ;string without CR, LF
000028F4                          3439          
000028F4  4281                    3440          CLR.L       D1
000028F6  1205                    3441          MOVE.B      D5,D1               ;move register number for display into D1
000028F8  103C 0003               3442          MOVE.B      #3,D0               ;set for task to display null terminated 
000028FC  4E4F                    3443          TRAP        #15                 ;string without CR, LF
000028FE                          3444  
000028FE  43F9 00002E05           3445          LEA         rprn,A1             ;output 'D' for data register
00002904  103C 000E               3446          MOVE.B      #14,D0              ;set for task to display null terminated 
00002908  4E4F                    3447          TRAP        #15                 ;string without CR, LF
0000290A                          3448          
0000290A  6000 00D8               3449          BRA         Get_Effective_Address_Exit  ;return
0000290E                          3450  
0000290E                          3451                 
0000290E                          3452  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
0000290E                          3453  
0000290E  43F9 00002E03           3454          LEA         lprn,A1             ;output 'D' for data register
00002914  103C 000E               3455          MOVE.B      #14,D0              ;set for task to display null terminated 
00002918  4E4F                    3456          TRAP        #15                 ;string without CR, LF
0000291A                          3457  
0000291A  43F9 00002DFB           3458          LEA         letterA,A1          ;output 'A' for address register
00002920  103C 000E               3459          MOVE.B      #14,D0              ;set for task to display null terminated 
00002924  4E4F                    3460          TRAP        #15                 ;string without CR, LF
00002926                          3461          
00002926  4281                    3462          CLR.L       D1
00002928  1205                    3463          MOVE.B      D5,D1               ;move register number for display into D1
0000292A  103C 0003               3464          MOVE.B      #3,D0               ;set for task to display null terminated 
0000292E  4E4F                    3465          TRAP        #15                 ;string without CR, LF
00002930                          3466  
00002930  43F9 00002E05           3467          LEA         rprn,A1             ;output 'D' for data register
00002936  103C 000E               3468          MOVE.B      #14,D0              ;set for task to display null terminated 
0000293A  4E4F                    3469          TRAP        #15                 ;string without CR, LF
0000293C                          3470          
0000293C  43F9 00002DFF           3471          LEA         plus,A1             ;output 'D' for data register
00002942  103C 000E               3472          MOVE.B      #14,D0              ;set for task to display null terminated 
00002946  4E4F                    3473          TRAP        #15                 ;string without CR, LF
00002948                          3474          
00002948  6000 009A               3475          BRA         Get_Effective_Address_Exit  ;return
0000294C                          3476  
0000294C                          3477  Addr_Reg_Indirect_Dec                   ;4 = ?(An) - Address Register Indirect with Predecrement (100)
0000294C                          3478  
0000294C  43F9 00002E01           3479          LEA         minus,A1            ;output '-' for Predecrement
00002952  103C 000E               3480          MOVE.B      #14,D0              ;set for task to display null terminated 
00002956  4E4F                    3481          TRAP        #15                 ;string without CR, LF
00002958                          3482  
00002958  43F9 00002E03           3483          LEA         lprn,A1             ;output 'D' for data register
0000295E  103C 000E               3484          MOVE.B      #14,D0              ;set for task to display null terminated 
00002962  4E4F                    3485          TRAP        #15                 ;string without CR, LF
00002964                          3486  
00002964  43F9 00002DFB           3487          LEA         letterA,A1          ;output 'A' for address register
0000296A  103C 000E               3488          MOVE.B      #14,D0              ;set for task to display null terminated 
0000296E  4E4F                    3489          TRAP        #15                 ;string without CR, LF
00002970                          3490          
00002970  4281                    3491          CLR.L       D1
00002972  1205                    3492          MOVE.B      D5,D1               ;move register number for display into D1
00002974  103C 0003               3493          MOVE.B      #3,D0               ;set for task to display null terminated 
00002978  4E4F                    3494          TRAP        #15                 ;string without CR, LF
0000297A                          3495  
0000297A  43F9 00002E05           3496          LEA         rprn,A1             ;output 'D' for data register
00002980  103C 000E               3497          MOVE.B      #14,D0              ;set for task to display null terminated 
00002984  4E4F                    3498          TRAP        #15                 ;string without CR, LF
00002986                          3499          
00002986  6000 005C               3500          BRA         Get_Effective_Address_Exit  ;return
0000298A                          3501          
0000298A                          3502                         
0000298A                          3503  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
0000298A                          3504          
0000298A                          3505          
0000298A  548B                    3506          ADDA.L      #word,A3            ;move past instruction
0000298C                          3507          
0000298C                          3508          ;print word (A3)
0000298C  48E7 1200               3509          MOVEM.L D6/D3,-(SP)
00002990  1C3C 0001               3510          MOVE.B #1,D6                    ;put size of word in D6
00002994  3613                    3511          MOVE.W (A3),D3                  ;move data at (A3) to D3
00002996  6100 00D8               3512          BSR outputHex
0000299A  4CDF 0048               3513          MOVEM.L (SP)+,D6/D3
0000299E                          3514          
0000299E  5487                    3515          ADDI.L      #word,D7 
000029A0  6000 0042               3516          BRA         Get_Effective_Address_Exit  ;return
000029A4                          3517                         
000029A4                          3518  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
000029A4                          3519          
000029A4                          3520          ;LEA         xxxL,A1             ;output 'D' for data register
000029A4                          3521          ;MOVE.B      #14,D0              ;set for task to display null terminated 
000029A4                          3522          ;TRAP        #15                 ;string without CR, LF
000029A4                          3523  
000029A4  548B                    3524          ADDA.L      #word,A3
000029A6                          3525          
000029A6                          3526          ;print long (A3)
000029A6  48E7 1200               3527          MOVEM.L D6/D3,-(SP)
000029AA  1C3C 0002               3528          MOVE.B #2,D6                    ;put size of word in D6
000029AE  2613                    3529          MOVE.L (A3),D3                  ;move data at (A3) to D3
000029B0  6100 00BE               3530          BSR outputHex
000029B4  4CDF 0048               3531          MOVEM.L (SP)+,D6/D3
000029B8                          3532  
000029B8                          3533          
000029B8  5887                    3534          ADDI.L      #long,D7
000029BA  6000 0028               3535          BRA         Get_Effective_Address_Exit  ;return
000029BE                          3536                         
000029BE                          3537  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
000029BE                          3538  
000029BE                          3539  *        LEA         iData,A1            ;output 'D' for data register
000029BE                          3540  *        MOVE.B      #14,D0              ;set for task to display null terminated 
000029BE                          3541  *        TRAP        #15                 ;string without CR, LF
000029BE                          3542          
000029BE  4CDF 0040               3543          MOVEM.L (SP)+,D6                 ;restore D6 data
000029C2  48E7 0200               3544          MOVEM.L D6,-(SP)                 ;save D6 data again to balance stack
000029C6                          3545  
000029C6                          3546          ;print '#'
000029C6  48E7 4000               3547          MOVEM.L D1,-(SP)                ;save D1 to the stack
000029CA  123C 0023               3548          MOVE.B #'#',D1                  ;put ascii value of char in D1
000029CE  103C 0006               3549          MOVE.B #6,D0                    ;move task 6 into D0
000029D2  4E4F                    3550          TRAP #15                        ;print char
000029D4  4CDF 0002               3551          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000029D8                          3552          
000029D8  0C06 0001               3553          CMPI.B #1,D6
000029DC  6FAC                    3554          BLE Addr_Abs_Short
000029DE  6EC4                    3555          BGT Addr_Abs_Long
000029E0                          3556          
000029E0  6000 0002               3557          BRA         Get_Effective_Address_Exit  ;return
000029E4                          3558  
000029E4                          3559  invalidEA:
000029E4                          3560  
000029E4                          3561          ;do something
000029E4                          3562   
000029E4                          3563  Get_Effective_Address_Exit:     
000029E4                          3564  
000029E4  4CDF 0040               3565          MOVEM.L (SP)+,D6                 ;restore D6 data
000029E8  4E75                    3566          RTS                             ;return
000029EA                          3567  
000029EA                          3568  ***assume size in D6. 00 = byte, 01 = word, 10 = long
000029EA                          3569  printSize:
000029EA  48E7 C000               3570          MOVEM.L D0/D1,-(SP)
000029EE                          3571          
000029EE                          3572          ;print '.'
000029EE  48E7 4000               3573          MOVEM.L D1,-(SP)                ;save D1 to the stack
000029F2  123C 002E               3574          MOVE.B #'.',D1                  ;put ascii value of char in D1
000029F6  103C 0006               3575          MOVE.B #6,D0                    ;move task 6 into D0
000029FA  4E4F                    3576          TRAP #15                        ;print char
000029FC  4CDF 0002               3577          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002A00                          3578          
00002A00  0C06 0001               3579          CMPI.B #1,D6
00002A04  6D00 0022               3580          BLT printByteSize
00002A08  6700 0032               3581          BEQ printWordSize
00002A0C  6E00 0042               3582          BGT printLongSize
00002A10                          3583  printSizeDone:
00002A10                          3584          ;print ' '
00002A10  48E7 4000               3585          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002A14  123C 0020               3586          MOVE.B #' ',D1                  ;put ascii value of char in D1
00002A18  103C 0006               3587          MOVE.B #6,D0                    ;move task 6 into D0
00002A1C  4E4F                    3588          TRAP #15                        ;print char
00002A1E  4CDF 0002               3589          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002A22                          3590          
00002A22  4CDF 0003               3591          MOVEM.L (SP)+,D0/D1
00002A26  4E75                    3592          RTS
00002A28                          3593          
00002A28                          3594  printByteSize:
00002A28                          3595          ;print 'B'
00002A28  48E7 4000               3596          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002A2C  123C 0042               3597          MOVE.B #'B',D1                  ;put ascii value of char in D1
00002A30  103C 0006               3598          MOVE.B #6,D0                    ;move task 6 into D0
00002A34  4E4F                    3599          TRAP #15                        ;print char
00002A36  4CDF 0002               3600          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002A3A  60D4                    3601          BRA printSizeDone
00002A3C                          3602          
00002A3C                          3603  printWordSize:
00002A3C                          3604          ;print 'W'
00002A3C  48E7 4000               3605          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002A40  123C 0057               3606          MOVE.B #'W',D1                  ;put ascii value of char in D1
00002A44  103C 0006               3607          MOVE.B #6,D0                    ;move task 6 into D0
00002A48  4E4F                    3608          TRAP #15                        ;print char
00002A4A  4CDF 0002               3609          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002A4E  60C0                    3610          BRA printSizeDone
00002A50                          3611  
00002A50                          3612  printLongSize:
00002A50                          3613          ;print 'L'
00002A50  48E7 4000               3614          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002A54  123C 004C               3615          MOVE.B #'L',D1                  ;put ascii value of char in D1
00002A58  103C 0006               3616          MOVE.B #6,D0                    ;move task 6 into D0
00002A5C  4E4F                    3617          TRAP #15                        ;print char
00002A5E  4CDF 0002               3618          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002A62  60AC                    3619          BRA printSizeDone       
00002A64                          3620          
00002A64                          3621  
00002A64                          3622  ***assume hex to print is in D3***
00002A64                          3623  ***assume size in D6. 00 = byte, 01 = word, 10 = long
00002A64                          3624  
00002A64= 00000000 00000000 ...   3625  hexoutputbuffer DC.L 0,0,0
00002A70                          3626  
00002A70                          3627  outputHex:
00002A70  48E7 B248               3628          MOVEM.L D0/D2/D3/D6/A1/A4,-(SP)
00002A74  49F8 2A64               3629          LEA hexoutputbuffer,A4
00002A78  0C06 0001               3630          CMPI.B #1,D6
00002A7C  6D00 006A               3631          BLT hexByte
00002A80  6700 004C               3632          BEQ hexWord
00002A84  6E00 0016               3633          BGT hexLong
00002A88                          3634  outputHexDone:
00002A88  18BC 0000               3635          MOVE.B #0,(A4)
00002A8C                          3636          
00002A8C                          3637          ;output string of hex
00002A8C  103C 000E               3638          MOVE.B #14,D0
00002A90  43F8 2A64               3639          LEA hexoutputbuffer,A1
00002A94  4E4F                    3640          TRAP #15
00002A96  4CDF 124D               3641          MOVEM.L (SP)+ ,D0/D2/D3/D6/A1/A4
00002A9A  4E75                    3642          RTS
00002A9C                          3643          
00002A9C                          3644  hexLong:
00002A9C  E99B                    3645          ROL.L #4,D3
00002A9E  6100 0056               3646          BSR convertHexToASCII
00002AA2  E99B                    3647          ROL.L #4,D3
00002AA4  6100 0050               3648          BSR convertHexToASCII
00002AA8  E99B                    3649          ROL.L #4,D3
00002AAA  6100 004A               3650          BSR convertHexToASCII
00002AAE  E99B                    3651          ROL.L #4,D3
00002AB0  6100 0044               3652          BSR convertHexToASCII
00002AB4  E99B                    3653          ROL.L #4,D3
00002AB6  6100 003E               3654          BSR convertHexToASCII
00002ABA  E99B                    3655          ROL.L #4,D3
00002ABC  6100 0038               3656          BSR convertHexToASCII
00002AC0  E99B                    3657          ROL.L #4,D3
00002AC2  6100 0032               3658          BSR convertHexToASCII
00002AC6  E99B                    3659          ROL.L #4,D3
00002AC8  6100 002C               3660          BSR convertHexToASCII
00002ACC                          3661          
00002ACC  60BA                    3662          BRA outputHexDone
00002ACE                          3663          
00002ACE                          3664  hexWord:
00002ACE  E95B                    3665          ROL.W #4,D3
00002AD0  6100 0024               3666          BSR convertHexToASCII
00002AD4  E95B                    3667          ROL.W #4,D3
00002AD6  6100 001E               3668          BSR convertHexToASCII
00002ADA  E95B                    3669          ROL.W #4,D3
00002ADC  6100 0018               3670          BSR convertHexToASCII
00002AE0  E95B                    3671          ROL.W #4,D3
00002AE2  6100 0012               3672          BSR convertHexToASCII
00002AE6                          3673  
00002AE6  60A0                    3674          BRA outputHexDone
00002AE8                          3675          
00002AE8                          3676  hexByte:
00002AE8  E91B                    3677          ROL.B #4,D3
00002AEA  6100 000A               3678          BSR convertHexToASCII
00002AEE  E91B                    3679          ROL.B #4,D3
00002AF0  6100 0004               3680          BSR convertHexToASCII
00002AF4                          3681          
00002AF4  6092                    3682          BRA outputHexDone
00002AF6                          3683          
00002AF6                          3684  convertHexToASCII:
00002AF6  1403                    3685          MOVE.B D3,D2
00002AF8  0202 000F               3686          ANDI.B #%00001111,D2            ;mask out all but hex at least significant nyb
00002AFC  0C02 0009               3687          CMPI.B #9,D2
00002B00  6F00 0006               3688          BLE Number
00002B04  6000 000A               3689          BRA Letter       
00002B08                          3690  
00002B08                          3691  Number:
00002B08  0602 0030               3692          ADDI.B #'0',D2
00002B0C  18C2                    3693          MOVE.B D2,(A4)+
00002B0E  4E75                    3694          RTS
00002B10                          3695          
00002B10                          3696  Letter:
00002B10  0402 000A               3697          SUBI.B #$A,D2
00002B14  0602 0041               3698          ADDI.B #'A',D2
00002B18  18C2                    3699          MOVE.B D2,(A4)+
00002B1A  4E75                    3700          RTS
00002B1C                          3701  
00002B1C                          3702  
00002B1C                          3703  
00002B1C                          3704  switchModeAndReg:
00002B1C                          3705  ***
00002B1C                          3706  * Assumed in D2
00002B1C                          3707  *
00002B1C                          3708  * Assumed that they are in least significant byte:
00002B1C                          3709  *
00002B1C                          3710  *            _this_
00002B1C                          3711  *           /      \
00002B1C                          3712  *  ........ ........
00002B1C                          3713  *  \                /
00002B1C                          3714  *   -----word-------
00002B1C                          3715  *
00002B1C                          3716  *  and that in that byte they are ordered:
00002B1C                          3717  *
00002B1C                          3718  *       ........   
00002B1C                          3719  *       \/\_/\_/
00002B1C                          3720  *      /  /    \
00002B1C                          3721  *    /   /      \
00002B1C                          3722  * dont  one    other
00002B1C                          3723  * care
00002B1C                          3724  *
00002B1C                          3725  * after they will be
00002B1C                          3726  *
00002B1C                          3727  *       ........   
00002B1C                          3728  *       \/\_/\_/
00002B1C                          3729  *      /  /    \
00002B1C                          3730  *    /   /      \
00002B1C                          3731  * dont other    one
00002B1C                          3732  * care
00002B1C                          3733  *** 
00002B1C  0202 003F               3734          AndI.B #%00111111,D2            ;remove unwanted bits from D2
00002B20  0283 00000000           3735          ANDI.L #0,D3                    ;clear D3
00002B26  1602                    3736          MOVE.B D2,D3                    ;copy to D3
00002B28  E70B                    3737          LSL.B  #3,D3 
00002B2A  E60A                    3738          LSR.B  #3,D2
00002B2C  D403                    3739          ADD.B  D3,D2
00002B2E  4E75                    3740          RTS
00002B30                          3741  
00002B30                          3742          
00002B30                          3743  *==============================================================================
00002B30                          3744  *                            variables and constants
00002B30                          3745  *==============================================================================
00002B30                          3746  
00002B30                          3747  
00002B30                          3748  ***initial user prompt stuff        
00002B30= 45 6E 74 65 72 20 ...   3749  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE, "Q" or "q" to quit: $',0
00002B75= 45 6E 74 65 72 20 ...   3750  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE, "Q" or "q" to quit: $',0
00002BB8                          3751  
00002BB8= 20 41 64 64 72 65 ...   3752  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
00002BFD= 20 41 20 43 68 61 ...   3753  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
00002C45                          3754  
00002C45= 20 59 6F 75 20 6D ...   3755  even_msg        DC.B    ' You must enter an even address!',0
00002C66= 20 54 6F 20 61 64 ...   3756  to_from_err     DC.B    ' To address must cannot come before the from address!',0
00002C9C                          3757  
00002C9C= 20                      3758  spc             DC.B    ' '
00002C9D= 01                      3759  spc_len         DC.B    spc_len-spc
00002C9E                          3760  ***
00002C9E                          3761  
00002C9E                          3762  
00002C9E                          3763  
00002C9E                          3764  ***list of OP codes
00002C9E                          3765  
00002C9E  =00000040               3766  moveaInstruction EQU %0000000001000000
00002C9E  =0000B000               3767  eorInstruction   EQU %1011000000000000
00002C9E  =0000B000               3768  cmpInstruction   EQU %1011000000000000
00002C9E  =00008000               3769  orInstruction    EQU %1000000000000000
00002C9E  =00000880               3770  bclrdataInstruction EQU %0000100010000000
00002C9E  =00000180               3771  bclrInstruction  EQU %0000000110000000
00002C9E  =000041C0               3772  leaInstruction   EQU %0100000111000000
00002C9E  =000081C0               3773  divsInstruction  EQU %1000000111000000
00002C9E  =0000C1C0               3774  mulsInstruction  EQU %1100000111000000
00002C9E  =0000E6C0               3775  rsrlweaInstruction  EQU %1110011011000000
00002C9E  =0000E018               3776  rsrlregInstruction  EQU %1110000000011000
00002C9E  =0000E0C0               3777  asrlweaInstruction  EQU %1110000011000000
00002C9E  =0000E000               3778  asrlregInstruction  EQU %1110000000000000
00002C9E  =0000E2C0               3779  lsrlweaInstruction  EQU %1110001011000000
00002C9E  =0000E008               3780  lsrlregInstruction  EQU %1110000000001000
00002C9E  =00005100               3781  subqInstruction  EQU %0101000100000000
00002C9E  =00009000               3782  subInstruction   EQU %1001000000000000
00002C9E  =0000D000               3783  addaInstruction  EQU %1101000000000000
00002C9E  =0000D000               3784  addInstruction   EQU %1101000000000000
00002C9E  =00004880               3785  movemInstruction EQU %0100100010000000
00002C9E  =00000600               3786  addiInstruction  EQU %0000011000000000
00002C9E  =00000000               3787  oriInstruction   EQU 0
00002C9E  =00000C00               3788  cmpiInstruction  EQU %0000110000000000
00002C9E  =00004E80               3789  jsrInstruction   EQU %0100111010000000
00002C9E  =00004E75               3790  rtsInstruction   EQU %0100111001110101
00002C9E  =00004E71               3791  NoOpInstruction  EQU %0100111001110001
00002C9E  =00000000               3792  moveInstruction  EQU 0
00002C9E  =00006000               3793  bccInstruction   EQU %0110000000000000
00002C9E  =00004400               3794  negInstruction   EQU %0100010000000000
00002C9E  =00000000               3795  dataInstruction  EQU 0
00002C9E                          3796  
00002C9E                          3797  ***
00002C9E                          3798  
00002C9E                          3799  ***list of OP masks
00002C9E                          3800  
00002C9E  =0000C1C0               3801  moveaMask EQU %1100000111000000
00002C9E  =0000F000               3802  eorMask   EQU %1111000000000000
00002C9E  =0000F000               3803  cmpMask   EQU %1111000000000000
00002C9E  =0000F000               3804  orMask    EQU %1111000000000000
00002C9E  =0000FFC0               3805  bclrdataMask EQU %1111111111000000
00002C9E  =0000F1C0               3806  bclrMask  EQU %1111000111000000
00002C9E  =0000F1C0               3807  leaMask   EQU %1111000111000000
00002C9E  =0000F1C0               3808  divsMask  EQU %1111000111000000
00002C9E  =0000F1C0               3809  mulsMask  EQU %1111000111000000
00002C9E  =0000FEC0               3810  rsrlweaMask  EQU %1111111011000000
00002C9E  =0000F018               3811  rsrlregMask  EQU %1111000000011000
00002C9E  =0000FEC0               3812  asrlweaMask  EQU %1111111011000000
00002C9E  =0000F018               3813  asrlregMask  EQU %1111000000011000
00002C9E  =0000FEC0               3814  lsrlweaMask  EQU %1111111011000000
00002C9E  =0000F018               3815  lsrlregMask  EQU %1111000000011000
00002C9E  =0000F100               3816  subqMask  EQU %1111000100000000
00002C9E  =0000F000               3817  subMask   EQU %1111000000000000
00002C9E  =0000F000               3818  addaMask  EQU %1111000000000000
00002C9E  =0000F000               3819  addMask   EQU %1111000000000000
00002C9E  =0000FB80               3820  movemMask EQU %1111101110000000
00002C9E  =0000FF00               3821  addiMask  EQU %1111111100000000
00002C9E  =0000FF00               3822  oriMask   EQU %1111111100000000
00002C9E  =0000FF00               3823  cmpiMask  EQU %1111111100000000
00002C9E  =0000FFC0               3824  jsrMask   EQU %1111111111000000
00002C9E  =0000FFFF               3825  rtsMask   EQU $FFFF
00002C9E  =0000FFFF               3826  NoOpMask  EQU $FFFF
00002C9E  =0000C000               3827  moveMask  EQU $C000
00002C9E  =0000F000               3828  bccMask   EQU $F000
00002C9E  =0000FF00               3829  negMask   EQU $FF00
00002C9E  =00000000               3830  dataMask  EQU 0
00002C9E                          3831  ***
00002C9E                          3832  
00002C9E                          3833  ***Bcc Codes***
00002C9E  =00000004               3834  CC EQU $04
00002C9E  =00000005               3835  CS EQU $05
00002C9E  =00000007               3836  EQ EQU $07
00002C9E  =0000000C               3837  GE EQU $0C
00002C9E  =0000000E               3838  GT EQU $0E
00002C9E  =00000002               3839  HI EQU $02
00002C9E  =0000000F               3840  LE EQU $0F
00002C9E  =00000003               3841  LS EQU $03
00002C9E  =0000000D               3842  LT EQU $0D
00002C9E  =0000000B               3843  MI EQU $0B
00002C9E  =00000006               3844  NE EQU $06
00002C9E  =0000000A               3845  PL EQU $0A
00002C9E  =00000008               3846  VC EQU $08
00002C9E  =00000009               3847  VS EQU $09
00002C9E  =00000000               3848  RA EQU $00 ;not really a Condition Code
00002C9E  =00000001               3849  SR EQU $01 ;not really a Condition Code
00002C9E                          3850  
00002C9E= 43 43 20 00             3851  CCm DC.B 'CC ',0
00002CA2= 43 53 20 00             3852  CSm DC.B 'CS ',0
00002CA6= 45 51 20 00             3853  EQm DC.B 'EQ ',0
00002CAA= 47 45 20 00             3854  GEm DC.B 'GE ',0
00002CAE= 47 54 20 00             3855  GTm DC.B 'GT ',0
00002CB2= 48 49 20 00             3856  HIm DC.B 'HI ',0
00002CB6= 4C 45 20 00             3857  LEm DC.B 'LE ',0
00002CBA= 4C 53 20 00             3858  LSm DC.B 'LS ',0
00002CBE= 4C 54 20 00             3859  LTm DC.B 'LT ',0
00002CC2= 4D 49 20 00             3860  MIm DC.B 'MI ',0
00002CC6= 4E 45 20 00             3861  NEm DC.B 'NE ',0
00002CCA= 50 4C 20 00             3862  PLm DC.B 'PL ',0
00002CCE= 56 43 20 00             3863  VCm DC.B 'VC ',0
00002CD2= 56 53 20 00             3864  VSm DC.B 'VS ',0
00002CD6= 52 41 20 00             3865  RAm DC.B 'RA ',0
00002CDA= 53 52 20 00             3866  SRm DC.B 'SR ',0
00002CDE                          3867  
00002CDE= 01 04 05 07 0C 0E ...   3868  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
00002CEE= 00002CDA 00002C9E ...   3869  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
00002D2E                          3870  ***
00002D2E                          3871  
00002D2E= 45 6E 74 65 72 20 ...   3872  startLocationPrompt DC.B    'Enter start location',0
00002D43= 45 6E 74 65 72 20 ...   3873  endLocationPrompt   DC.B    'Enter end location',0
00002D56                          3874  
00002D56= 0D 0A 00                3875  clearLine  DC.B $0D,$0A,0
00002D59                          3876  
00002D59= 45 4F 52 00             3877  eorMessage      DC.B 'EOR',0
00002D5D= 43 4D 50 00             3878  cmpMessage      DC.B 'CMP',0
00002D61= 4F 52 00                3879  orMessage       DC.B 'OR',0
00002D64= 42 43 4C 52 20 00       3880  bclrMessage     DC.B 'BCLR ',0
00002D6A= 4C 45 41 20 00          3881  leaMessage      DC.B 'LEA ',0
00002D6F= 44 49 56 53 00          3882  divsMessage     DC.B 'DIVS',0
00002D74= 4D 55 4C 53 00          3883  mulsMessage     DC.B 'MULS',0
00002D79= 52 4F 4C 00             3884  rslMessage      DC.B 'ROL',0
00002D7D= 52 4F 52 00             3885  rsrMessage      DC.B 'ROR',0
00002D81= 41 53 4C 00             3886  aslMessage      DC.B 'ASL',0
00002D85= 41 53 52 00             3887  asrMessage      DC.B 'ASR',0
00002D89= 4C 53 4C 00             3888  lslMessage      DC.B 'LSL',0
00002D8D= 4C 53 52 00             3889  lsrMessage      DC.B 'LSR',0
00002D91= 53 55 42 51 00          3890  subqMessage     DC.B 'SUBQ',0
00002D96= 53 55 42 00             3891  subMessage      DC.B 'SUB',0 
00002D9A= 41 44 44 41 00          3892  addaMessage     DC.B 'ADDA',0
00002D9F= 41 44 44 00             3893  addMessage      DC.B 'ADD',0
00002DA3= 4D 4F 56 45 4D 00       3894  movemMessage    DC.B 'MOVEM',0
00002DA9= 41 44 44 49 00          3895  addiMessage     DC.B 'ADDI',0
00002DAE= 4F 52 49 00             3896  oriMessage      DC.B 'ORI',0
00002DB2= 43 4D 50 49 00          3897  cmpiMessage     DC.B 'CMPI',0
00002DB7= 4A 53 52 20 00          3898  jsrMessage      DC.B 'JSR ',0
00002DBC= 52 54 53 20 00          3899  rtsMessage      DC.B 'RTS ',0
00002DC1= 4E 4F 50 20 00          3900  nopMessage      DC.B 'NOP ',0 
00002DC6= 4D 4F 56 45 00          3901  moveMessage     DC.B 'MOVE',0
00002DCB= 42 00                   3902  bccMessage      DC.B 'B',0
00002DCD= 4E 45 47 00             3903  negMessage      DC.B 'NEG',0
00002DD1= 44 41 54 41 20 00       3904  dataMessage     DC.B 'DATA ',0
00002DD7= 4D 4F 56 45 41 00       3905  moveaMessage    DC.B 'MOVEA',0
00002DDD                          3906  
00002DDD= 28 78 78 78 29 2E ...   3907  xxxW            DC.B '(xxx).W: ',0
00002DE7= 28 78 78 78 29 2E ...   3908  xxxL            DC.B '(xxx).L: ',0
00002DF1= 23 28 64 61 74 61 ...   3909  iData           DC.B '#(data): ',0
00002DFB                          3910  
00002DFB= 41 00                   3911  letterA         DC.B 'A', 0
00002DFD= 44 00                   3912  letterD         DC.B 'D', 0
00002DFF                          3913  
00002DFF= 2B 00                   3914  plus            DC.B '+', 0
00002E01= 2D 00                   3915  minus           DC.B '-', 0
00002E03= 28 00                   3916  lPrn            DC.B '(', 0
00002E05= 29 00                   3917  rPrn            DC.B ')', 0
00002E07                          3918  
00002E07                          3919  
00002E07= 50 72 65 73 73 20 ...   3920  nextAddrPrompt  DC.B 'Press "Q" or "q" to quit or any other key to enter a new starting address: ',0
00002E53= 50 72 65 73 73 20 ...   3921  continuePrompt  DC.B 'Press "S" or "s" to stop or any other key to display the next page: ',0
00002E98= 50 72 6F 67 72 61 ...   3922  thankyoumessage DC.B 'Program Complete. Thank You!',0
00002EB5                          3923  
00002EB6= 00000000                3924  startLocation       DC.L    0
00002EBA= 00000000                3925  endLocation         DC.L    0
00002EBE                          3926  
00002EBE                          3927  
00002EBE                          3928     
00002EBE                          3929      END    START                        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 1D26
ADDA                1C60
ADDABODY            1CA8
ADDAINSTRUCTION     D000
ADDAMASK            F000
ADDAMESSAGE         2D9A
ADDDEST             1DFA
ADDDESTEA           1D1A
ADDDESTEAMASKS      1D20
ADDI                217E
ADDIBODY            21AA
ADDIDONE            21FC
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         2DA9
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          2D9F
ADDPOSTREGDONE      205A
ADDPREREGDONE       20D6
ADDRESS_DONE        2722
ADDRESS_EXIT        271C
ADDR_ABS_LONG       29A4
ADDR_ABS_SHORT      298A
ADDR_IMMEDIATE_DATA  29BE
ADDR_REG_DIRECT     28C2
ADDR_REG_INDIRECT   28DC
ADDR_REG_INDIRECT_DEC  294C
ADDR_REG_INDIRECT_INC  290E
ADDSOURCE           1D9C
ASLEA               1878
ASLMESSAGE          2D81
ASLREG              18BE
ASREA               1868
ASRLREG             1888
ASRLREGINSTRUCTION  E000
ASRLREGMASK         F018
ASRLWEA             1828
ASRLWEACHECKDIRECTION  1854
ASRLWEAINSTRUCTION  E0C0
ASRLWEAMASK         FEC0
ASRMESSAGE          2D85
ASRREG              18AE
BCC                 2576
BCCBYTE             25CC
BCCDONE             25FC
BCCINSTRUCTION      6000
BCCLIST             2CDE
BCCLONG             25F4
BCCMASK             F000
BCCMESSAGE          2DCB
BCCWORD             25EA
BCLR                154C
BCLRBODY            1578
BCLRDATA            14B2
BCLRDATABODY        14DE
BCLRDATAINSTRUCTION  880
BCLRDATAMASK        FFC0
BCLRINSTRUCTION     180
BCLRMASK            F1C0
BCLRMESSAGE         2D64
BEGIN               0
BEGIN_ADDRESS       268E
BYTE                1
CC                  4
CCM                 2C9E
CHECKCC             2590
CHECKCONTINUE       11AC
CHECKMOVEDEST       2402
CHECKNEXTADDR       11E6
CHECKOPCODE         1076
CHECKPOSTREGADD     2054
CHECKPREREGADD      20D0
CK_ADDR_DONE        282E
CK_ADDR_RANGE       2806
CK_ADDR_RANGE_ERROR  281E
CK_BOUNDRY          274A
CK_BOUNDRY_ERROR    276C
CK_SIZE_ERROR       2780
CLEARLINE           2D56
CMP                 12D2
CMPBODY             1312
CMPI                22AC
CMPIBODY            22D4
CMPIDONE            232A
CMPIEA              229E
CMPIEAMASKS         22A5
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         2DB2
CMPINSTRUCTION      B000
CMPMASK             F000
CMPMESSAGE          2D5D
CONDITIONCODEMESSAGE  2CEE
CONTINUEPROMPT      2E53
CONVERTHEXTOASCII   2AF6
CS                  5
CSM                 2CA2
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         2DD1
DATA_REG_DIRECT     28A8
DIVS                165E
DIVSBODY            168A
DIVSINSTRUCTION     81C0
DIVSMASK            F1C0
DIVSMESSAGE         2D6F
ELPROMPT            2B75
END                 FFFFFE
ENDLOCATION         2EBA
ENDLOCATIONPROMPT   2D43
END_ADDRESS         26DA
ENTER_ADDR_EDIT_ALL  2724
ENTER_ADDR_EDIT_ALL_EXIT  2748
ENTER_ADDR_EDIT_TO  2830
ENTER_ADDR_EDIT_TO_ERROR  283A
ENTER_ADDR_EDIT_TO_RETURN  2838
EOR                 1230
EORBODY             1274
EOREA               1222
EOREAMASKS          1229
EORINSTRUCTION      B000
EORMASK             F000
EORMESSAGE          2D59
EQ                  7
EQM                 2CA6
EVEN_MSG            2C45
FALSEPOSITIVE       1096
FARLABEL            FFE
FIN                 267E
FOUNDCC             25A2
GE                  C
GEM                 2CAA
GET_EFFECTIVE_ADDRESS  284C
GET_EFFECTIVE_ADDRESS_EXIT  29E4
GET_EFFECTIVE_ADDRESS_OTHER  288C
GT                  E
GTM                 2CAE
HANDLEBYTEDATA      2644
HEXBYTE             2AE8
HEXLONG             2A9C
HEXOUTPUTBUFFER     2A64
HEXWORD             2ACE
HEX_RANGE_ERROR     27EE
HI                  2
HIM                 2CB2
IDATA               2DF1
INSTLABELLIST       1134
INSTLABELLIST2      113C
INSTLABELLIST3      1170
INSTMASKLIST        10F8
INSTMASKLIST2       10FC
INSTMASKLIST3       1116
INSTOPLIST          10BC
INSTOPLIST2         10C0
INSTOPLIST3         10DA
INVALIDEA           29E4
INVALIDMSG          2BB8
INVCHARMSG          2BFD
JSR                 2342
JSRBODY             236A
JSRDONE             238A
JSREA               233A
JSREAMASKS          233E
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          2DB7
LCASEHEX            27D0
LE                  F
LEA                 15DA
LEABODY             1602
LEAEA               15D2
LEAEAMASKS          15D6
LEAINSTRUCTION      41C0
LEAMASK             F1C0
LEAMESSAGE          2D6A
LEM                 2CB6
LETTER              2B10
LETTERA             2DFB
LETTERD             2DFD
LONG                4
LPRN                2E03
LS                  3
LSLEA               1926
LSLMESSAGE          2D89
LSLREG              19A2
LSM                 2CBA
LSREA               1916
LSRLCHECKI          1A0E
LSRLCHECKIR         19F8
LSRLCHECKIRRETURN   1A0C
LSRLCHECKR          1A42
LSRLEA              18CE
LSRLEAMASKS         18D4
LSRLREG             196C
LSRLREGBODY         19B2
LSRLREGINSTRUCTION  E008
LSRLREGMASK         F018
LSRLWEA             18DA
LSRLWEABODY         1936
LSRLWEACHECKDIRECTION  1902
LSRLWEAINSTRUCTION  E2C0
LSRLWEAMASK         FEC0
LSRMESSAGE          2D8D
LSRREG              1992
LT                  D
LTM                 2CBE
MAIN_LOOP           1018
MATCH               109C
MI                  B
MIM                 2CC2
MINUS               2E01
MOVE                23DA
MOVEA               24D8
MOVEABODY           2500
MOVEADESTEA         24D4
MOVEADESTEAMASKS    24D6
MOVEAINSTRUCTION    40
MOVEAMASK           C1C0
MOVEAMESSAGE        2DD7
MOVEBODY            2430
MOVEDESTEA          23CC
MOVEDESTEAMASKS     23D3
MOVEINSTRUCTION     0
MOVEM               1E6C
MOVEMASK            C000
MOVEMESSAGE         2DC6
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     1E62
MOVEMMEMTOREGEAMASKS  1E67
MOVEMMESSAGE        2DA3
MOVEMPOST           1F2A
MOVEMPOSTREGLIST    1FB6
MOVEMPRE            1ECE
MOVEMPREREGLIST     1FD6
MOVEMREGLISTBUFFER  1F86
MOVEMREGTOMEMEA     1E58
MOVEMREGTOMEMEAMASKS  1E5D
MOVESIZE            249E
MOVESIZEBYTE        24C2
MOVESIZEDONE        24BC
MOVESIZELONG        24CE
MOVESIZEWORD        24C8
MOVESOURCEEA        23BA
MOVESOURCEEAMASKS   23C3
MULS                16FA
MULSBODY            1722
MULSEA              16EA
MULSEAMASKS         16F2
MULSINSTRUCTION     C1C0
MULSMASK            F1C0
MULSMESSAGE         2D74
NE                  6
NEG                 2102
NEGBODY             212A
NEGDONE             215C
NEGEA               20F2
NEGEAMASKS          20FA
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          2DCD
NEGSIZE             216C
NEM                 2CC6
NEXTADDRPROMPT      2E07
NEXTHEX             2796
NEXTHEXDONE         27E8
NEXTHEXRETURN       2804
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 239A
NOPMESSAGE          2DC1
NUMBER              2B08
OR                  1380
ORDEST              1454
ORI                 220C
ORIBODY             2238
ORIDONE             228E
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          2DAE
ORINSTRUCTION       8000
ORMASK              F000
ORMESSAGE           2D61
ORSOURCE            13F6
ORSOURCEEA          1370
ORSOURCEEAMASKS     1378
OUTPUTHEX           2A70
OUTPUTHEXDONE       2A88
OUTPUTPOSTINCREMENT  2074
OUTPUTPREINCREMENT  1FD6
PARSEHEXSTRING      2794
PL                  A
PLM                 2CCA
PLUS                2DFF
POSTADDBACKSLASH    206E
POSTREGADD          205C
POSTREGADDDONE      2066
PREADDBACKSLASH     20EA
PREREGADD           20D8
PREREGADDDONE       20E2
PRGORG              1000
PRINTBYTESIZE       2A28
PRINTLONGSIZE       2A50
PRINTSIZE           29EA
PRINTSIZEDONE       2A10
PRINTWORDSIZE       2A3C
PROCESS_OP_CODES    284A
PROCESS_OP_CODES_EXIT  284A
PROMPT_USER         1004
RA                  0
RAM                 2CD6
RPRN                2E05
RSLEA               17D2
RSLMESSAGE          2D79
RSLREG              1818
RSREA               17C2
RSRLREG             17E2
RSRLREGINSTRUCTION  E018
RSRLREGMASK         F018
RSRLWEA             1782
RSRLWEACHECKDIRECTION  17AE
RSRLWEAINSTRUCTION  E6C0
RSRLWEAMASK         FEC0
RSRMESSAGE          2D7D
RSRREG              1808
RTS                 23AA
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          2DBC
SCREENLOOP          1014
SIGNEXTENDBYTE      25DE
SLPROMPT            2B30
SPC                 2C9C
SPC_LEN             2C9D
SR                  1
SRM                 2CDA
STACK               5000
START               1000
STARTLOCATION       2EB6
STARTLOCATIONPROMPT  2D2E
SUB                 1B2A
SUBDEST             1C02
SUBINSTRUCTION      9000
SUBMASK             F000
SUBMESSAGE          2D96
SUBQ                1A6C
SUBQBODY            1AA4
SUBQEA              1A5C
SUBQEAMASKS         1A64
SUBQINSTRUCTION     5100
SUBQMASK            F100
SUBQMESSAGE         2D91
SUBSOURCE           1BA4
SWITCHMODEANDREG    2B1C
THANKYOUMESSAGE     2E98
TOEIGHT             1B26
TO_FROM_ERR         2C66
UCASEHEX            27B8
UNKNOWNOPCODE       2616
VALIDADDA           1C7E
VALIDADDDESTEA      1D76
VALIDADDIMODES      2180
VALIDADDSOURCEEA    1D4C
VALIDASRL           182A
VALIDBCLRDATAMODES  14B4
VALIDBCLRMODES      154E
VALIDCMPEA          12E8
VALIDCMPIMODES      22AE
VALIDDIVSMODES      1660
VALIDEOREA          124E
VALIDJSRMODES       2344
VALIDLEAMODES       15DC
VALIDLSRL           18DC
VALIDMEMTOREG       1EA8
VALIDMOVEAMODES     24DA
VALIDMOVEDESTMODES  2404
VALIDMOVESOURCEMODES  23DC
VALIDMULSMODES      16FC
VALIDNEGMODES       2104
VALIDORDESTEA       13CC
VALIDORIMODES       220E
VALIDORSOURCEEA     13A6
VALIDREGTOMEM       1E82
VALIDRSRL           1784
VALIDSUBDESTEA      1B7A
VALIDSUBQ           1A7E
VALIDSUBSOURCEEA    1B50
VC                  8
VCM                 2CCE
VS                  9
VSM                 2CD2
WORD                2
XXXL                2DE7
XXXW                2DDD
ZEROTOEIGHT         1B1C
ZEROTOEIGHTRETURN   1B24

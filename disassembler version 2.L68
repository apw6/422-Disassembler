00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/16/2014 3:20:16 AM

00000000                             1  
00000000                             2  *#################################################################################################
00000000                             3  * Title      : 
00000000                             4  * Written by : Andrew Watson
00000000                             5  *            : Elaine Keller
00000000                             6  *            : Robert Anderson
00000000                             7  * Date       : 11/14/2014
00000000                             8  * Description: 
00000000                             9  *#################################################################################################
00000000                            10  
00000000                            11  **************************************************************************************************
00000000                            12  *  Assumptions: Can not tell data from an unidentified instruction that is an actual 
00000000                            13  *               instruction therefore causing errors. It may not actually be a bug because 
00000000                            14  *               data is data to the machine, and if you modify the instructions in memory for a 
00000000                            15  *               program by moivng data, you can modify the instuctions executed.
00000000                            16  **************************************************************************************************
00000000                            17  
00000000                            18  **************************************************************************************************
00000000                            19  *                                    Variable/Data Definitions
00000000                            20  **************************************************************************************************
00000000                            21  
00000000  =00005000                 22  stack   EQU   $00005000
00000000  =00000000                 23  begin   EQU   $00000000
00000000  =00FFFFFE                 24  end     EQU   $00FFFFFE
00000000  =00000001                 25  byte    EQU   1
00000000  =00000002                 26  word    EQU   2
00000000  =00000004                 27  long    EQU   4
00000000  =00001000                 28  prgorg  EQU   $1000
00000000                            29  
00000FFE                            30          ORG         $00000FFE
00000FFE                            31  FarLabel:
00001000                            32          ORG         prgorg
00001000                            33  start:
00001000  4FF8 5000                 34          LEA         stack, SP           ;initialize stack
00001004                            35  
00001000                            36          ORG         prgorg
00001000                            37  
00001000                            38  **************************************************************************************************
00001000                            39  *                                   Begin processing active code
00001000                            40  **************************************************************************************************
00001000                            41  
00001000                            42      
00001000                            43  start:
00001000                            44  
00001000  4FF8 5000                 45          LEA         stack, SP           ;Initialize stack
00001004                            46          
00001004                            47  prompt_user:
00001004                            48  
00001004  6100 1688                 49          BSR         begin_address
00001008  B67C FFFF                 50          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000100C  6700 1670                 51          BEQ         fin                 ;Yes, then exit
00001010                            52          
00001010  6000 0002                 53          BRA         screenLoop
00001014                            54                          
00001014                            55  **************************************************************************************************
00001014                            56  *                                  Begin processing OP Codes
00001014                            57  **************************************************************************************************
00001014                            58  
00001014                            59  
00001014                            60  screenLoop:
00001014                            61  
00001014  143C 001E                 62          MOVE.B      #30,D2
00001018                            63   
00001018                            64  main_Loop:
00001018                            65  
00001018  B9CB                      66          CMPA.L      A3,A4               ;check end of prog
0000101A  6F00 01CA                 67          BLE         checkNextAddr
0000101E  0C02 0000                 68          CMPI.B      #0,D2
00001022  6700 0188                 69          BEQ         checkContinue
00001026  5302                      70          SUBQ.B      #1,D2
00001028  48A7 2000                 71          MOVEM.W     D2,-(SP)            ;save D2 for next iteration
0000102C                            72          
0000102C                            73          ;print memory location
0000102C  48E7 1200                 74          MOVEM.L     D3/D6,-(SP)
00001030  7C02                      75          MOVEQ.L     #2,D6               ;set as long hex string
00001032  260B                      76          MOVE.L      A3,D3               ;put hex in D3
00001034  6100 1A22                 77          BSR         outputHex
00001038  4CDF 0048                 78          MOVEM.L     (SP)+,D3/D6
0000103C                            79          
0000103C                            80          ;print ' '
0000103C  48E7 4000                 81          MOVEM.L     D1,-(SP)            ;save D1 to the stack
00001040  123C 0020                 82          MOVE.B      #' ',D1             ;put ascii value of char in D1
00001044  103C 0006                 83          MOVE.B      #6,D0               ;move task 6 into D0
00001048  4E4F                      84          TRAP        #15                 ;prin char
0000104A  4CDF 0002                 85          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
0000104E                            86                  
0000104E                            87          ;handle an odd memory access(instructions will never be misaligned)
0000104E  240B                      88          MOVE.L      A3,D2               ;copy address to D2
00001050  0202 0001                 89          ANDI.B      #%00000001,D2       ;mask everything except the least significant bit
00001054  0C02 0001                 90          CMPI.B      #1,D2               ;compare the least sig bit of the address to one
00001058  6700 15EA                 91          BEQ         handlebytedata      ;the least sig bit will only be one if the insrtuction
0000105C                            92                                          ;is odd(misaligned) and therefore not an instruction
0000105C  7600                      93          MOVEQ.L     #0,D3
0000105E                            94          
0000105E  3213                      95          MOVE.W      (A3),D1             ;copy word from other prog to analyze as instructioninstruction
00001060                            96          
00001060                            97          ***things to save A3,A4,D1(?)***
00001060  48E7 0018                 98          MOVEM.L     A3-A4,-(SP)
00001064  6100 0010                 99          BSR         checkOPcode
00001068  4CDF 1800                100          MOVEM.L     (SP)+,A3-A4
0000106C  D7C7                     101          ADDA.L      D7,A3               ;look past data that was part of the instruction
0000106E                           102          
0000106E  548B                     103          ADDQ.L      #word,A3
00001070  4C9F 0004                104          MOVEM.W     (SP)+,D2            ;restore D2 for next iteration
00001074  60A2                     105          BRA         main_Loop 
00001076                           106  
00001076                           107  *=================================================================================================
00001076                           108  *                                  Search for a valid OP Code
00001076                           109  *=================================================================================================
00001076                           110          
00001076                           111  checkOPcode:
00001076                           112  
00001076                           113  
00001076  7E00                     114          MOVEQ.L     #0,D7
00001078                           115          
00001078  41F9 000010BC            116          LEA         instOPList,A0       ;get instruction signitrue list in A0
0000107E  D1C3                     117          ADDA.L      D3,A0               ;get correct sig         
00001080                           118          
00001080  43F9 000010F8            119          LEA         instMaskList,A1     ;get instruction mask in A1
00001086  D3C3                     120          ADDA.L      D3,A1               ;get correct mast
00001088                           121          
00001088  3401                     122          MOVE.W      D1,D2               ;move instruction into D2 for manipulaiton
0000108A                           123          
0000108A  C451                     124          AND.W       (A1),D2             ;mask instruction
0000108C                           125          
0000108C                           126          
0000108C                           127          
0000108C                           128          
0000108C  B450                     129          CMP.W       (A0),D2             ;compare to sig
0000108E  6700 000C                130          BEQ         match               ;if sig matches branch
00001092  5483                     131          ADDQ.L      #word,D3            ;add to D3 to check for next instruction
00001094  60E0                     132          BRA         checkOPcode
00001096                           133          
00001096                           134  falsePositive:
00001096                           135          
00001096  103C 00FF                136          MOVE.B      #-1,D0
0000109A  4E75                     137          RTS
0000109C                           138  
0000109C                           139  *-------------------------------------------------------------------------------------------------
0000109C                           140  *                      Load instructions from list and jump to that op code
0000109C                           141  *-------------------------------------------------------------------------------------------------
0000109C                           142  
0000109C                           143  match:
0000109C                           144          
0000109C  43F9 00001134            145          LEA         instLabelList,A1    ;get instruction code label
000010A2  D3C3                     146          ADDA.L      D3,A1               ;get correct label
000010A4  D3C3                     147          ADDA.L      D3,A1
000010A6  5483                     148          ADDQ.L      #word,D3            ;add to D3 incase false positive
000010A8  2251                     149          MOVEA.L     (A1),A1
000010AA  48E7 1000                150          MOVEM.L     D3,-(SP)            ;save D3
000010AE  4E91                     151          JSR         (A1)
000010B0  4CDF 0008                152          MOVEM.L     (SP)+,D3            ;restore D3
000010B4  B03C 00FF                153          CMP.B       #-1,D0
000010B8  67BC                     154          BEQ         checkOPcode
000010BA  4E75                     155          RTS
000010BC                           156  
000010BC                           157  *.................................................................................................
000010BC                           158  *                          List Variables for OP Code instructions
000010BC                           159  *.................................................................................................
000010BC                           160  
000010BC= 0040 B000                161  instOPList  DC.W moveaInstruction,eorInstruction
000010C0= B000 8000 0880 0...      162  instOPList2 DC.W cmpInstruction,orInstruction,bclrdataInstruction,bclrInstruction,leaInstruction,divsInstruction,mulsInstruction,rsrlweaInstruction,rsrlregInstruction,asrlweaInstruction,asrlregInstruction,lsrlweaInstruction,lsrlregInstruction
000010DA= 5100 9000 D000 D...      163  instOPList3 DC.W subqInstruction,subInstruction,addaInstruction,addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruct
000010F8                           164      
000010F8= C1C0 F000                165  instMaskList  DC.W moveaMask,eorMask
000010FC= F000 F000 FFC0 F...      166  instMaskList2 DC.W cmpMask,orMask,bclrdataMask,bclrMask,leaMask,divsMask,mulsMask,rsrlweaMask,rsrlregMask,asrlweaMask,asrlregMask,lsrlweaMask,lsrlregMask
00001116= F100 F000 F000 F...      167  instMaskList3 DC.W subqMask,subMask,addaMask,addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
00001134= 000024D8 00001230        168  instLabelList  DC.L MOVEA,EOR
0000113C= 000012D2 00001380 ...    169  instLabelList2 DC.L CMP,OR,BCLRDATA,BCLR,LEA,DIVS,MULS,RSRLWEA,RSRLREG,ASRLWEA,ASRLREG,LSRLWEA,LSRLREG
00001170= 00001A6C 00001B2A ...    170  instLabelList3 DC.L SUBQ,SUB,ADDA,ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
000011AC                           171  
000011AC                           172  
000011AC                           173  *=================================================================================================
000011AC                           174  *    Check for the user wanting to continue / stop displaying another page of the output
000011AC                           175  *=================================================================================================
000011AC                           176  
000011AC                           177  checkContinue:
000011AC                           178          
000011AC  48A7 6040                179          MOVEM.W     D1/D2/A1,-(SP)      ;save reg that are modified just in case
000011B0                           180          
000011B0  43F9 00002E3B            181          LEA         continuePrompt,A1   ;move string
000011B6  103C 000E                182          MOVE.B      #14,D0              ;set for task to display null terminated 
000011BA                           183                                          ;string without CR, LF
000011BA  4E4F                     184          TRAP        #15
000011BC                           185          
000011BC                           186          
000011BC  103C 0005                187          MOVE.B      #5,D0               ;set for task to read single char into D1
000011C0  4E4F                     188          TRAP        #15
000011C2                           189          
000011C2  43F9 00002D3E            190          LEA         clearLine,A1        ;move string for a CR and LF
000011C8  103C 000E                191          MOVE.B      #14,D0              ;set for task to display null terminated 
000011CC                           192                                          ;string without CR, LF
000011CC  4E4F                     193          TRAP        #15
000011CE                           194          
000011CE                           195          ;if either case of 'S' is entered, stop displaying the output
000011CE  0C01 0073                196          CMPI.B      #'s',D1             ;has the user selected 'S' to stop
000011D2  6700 0012                197          BEQ         checkNextAddr       ;yes, check if user wants to stop, or display more lines
000011D6  0C01 0053                198          CMPI.B      #'S',D1
000011DA  6700 000A                199          BEQ         checkNextAddr
000011DE                           200          
000011DE  4C9F 0206                201          MOVEM.W     (SP)+,D1/D2/A1
000011E2  6000 FE30                202          BRA         screenLoop
000011E6                           203  
000011E6                           204  *-------------------------------------------------------------------------------------------------
000011E6                           205  *            Check for the user wants to enter another address to check, or quit
000011E6                           206  *-------------------------------------------------------------------------------------------------
000011E6                           207  
000011E6                           208  checkNextAddr:
000011E6                           209  
000011E6  43F9 00002DEF            210          LEA         nextAddrPrompt,A1   ;move string
000011EC  103C 000E                211          MOVE.B      #14,D0              ;set for task to display null terminated 
000011F0                           212                                          ;string without CR, LF
000011F0  4E4F                     213          TRAP        #15
000011F2                           214          
000011F2                           215          
000011F2  103C 0005                216          MOVE.B      #5,D0               ;set for task to read single char into D1
000011F6  4E4F                     217          TRAP        #15
000011F8                           218          
000011F8  43F9 00002D3E            219          LEA         clearLine,A1        ;move string for a CR and LF
000011FE  103C 000E                220          MOVE.B      #14,D0              ;set for task to display null terminated 
00001202                           221                                          ;string without CR, LF
00001202  4E4F                     222          TRAP        #15
00001204                           223          
00001204                           224          ;if either case of 'Q' is entered, quit the program
00001204  0C01 0071                225          CMPI.B      #'q',D1             ;has the user selected 'Q' to quit
00001208  6700 1474                226          BEQ         fin                 ;yes, check if user wants to quit, or check new address
0000120C  0C01 0051                227          CMPI.B      #'Q',D1
00001210  6700 146C                228          BEQ         fin
00001214                           229          
00001214                           230          ;Clear screen for new address
00001214  323C FF00                231          MOVE.W      #$FF00, D1          ;Clear screen value
00001218  103C 000B                232          MOVE.B      #11,D0              ;set for task to clear screen
0000121C  4E4F                     233          TRAP        #15
0000121E                           234          
0000121E  6000 FDE4                235          BRA         prompt_user
00001222                           236          
00001222                           237  **************************************************************************************************
00001222                           238  *                                       Tests for OP Code EOR     
00001222                           239  **************************************************************************************************
00001222                           240           
00001222= 00 10 18 20 38 39 00     241  eorEA      Dc.B %000000,%010000,%011000,%100000,%111000,%111001,0
00001229= 38 38 38 38 3F 3F 00     242  eorEAmasks DC.B %111000,%111000,%111000,%111000,%111111,%111111,0
00001230                           243  
00001230                           244  EOR:
00001230                           245          
00001230  7000                     246          MOVEQ.L     #0, D0              ;clear D0
00001232                           247          
00001232                           248          ;Figure out if EA is source or destination
00001232  3401                     249          MOVE.W      D1,D2               ;copy inst to D2
00001234  EC4A                     250          LSR.W       #6,D2               ;shift opmode to least sig bit of least sig byte
00001236  0202 0007                251          ANDI.B      #%00000111,D2       ;mask out rest of byte
0000123A  0C02 0003                252          CMPI.B      #3,D2               ;compare to 3
0000123E  6F00 FE56                253          BLE         falsePositive       ;3 or less is not valid
00001242                           254          
00001242  0C02 0007                255          CMPI.B      #%111,D2            ;compare to 7
00001246  6700 FE4E                256          BEQ         falsePositive       ;thats not valid
0000124A  6000 0002                257          BRA         validEorEA          ;all thats left is valid EA size 
0000124E                           258          
0000124E                           259  validEorEA:
0000124E                           260          
0000124E  43F8 1229                261          LEA         eorEAmasks,A1       ;load the list of masks
00001252  D3C0                     262          ADDA.L      D0,A1               ;displace to a specific mask
00001254  1A11                     263          MOVE.B      (A1),D5             ;move the mask to D5
00001256                           264          
00001256  0C05 0000                265          CMPI.B      #0,D5               ;check if the mask is 0
0000125A  6700 FE3A                266          BEQ         falsePositive       ;branch if it is
0000125E                           267          
0000125E  1401                     268          MOVE.B      D1,D2               ;copy instruction to D2
00001260  C405                     269          AND.B       D5,D2               ;mask D2
00001262                           270          
00001262  43F8 1222                271          LEA         eorEA,A1            ;load the list of valid modes
00001266  D3C0                     272          ADDA.L      D0,A1               ;displace to a specific mode
00001268  1811                     273          MOVE.B      (A1),D4             ;move mode to D4
0000126A  B404                     274          CMP.B       D4,D2               ;compare mode to masked value
0000126C  6700 0006                275          BEQ         eorBody             ;if its match, its a valid mode and we can procede
00001270                           276          
00001270  5280                     277          ADDQ.L      #1,D0               ;add one to displacement
00001272  60DA                     278          BRA         validEorEA          ;check for next mode
00001274                           279                  
00001274                           280  
00001274                           281  eorBody
00001274                           282  
00001274  43F9 00002D41            283          LEA         eorMessage,A1       ;move string for MOVE
0000127A  103C 000E                284          MOVE.B      #14,D0              ;set for task to display null terminated 
0000127E                           285                                          ;string with CR, LF
0000127E  4E4F                     286          TRAP        #15
00001280  6100 0EEA                287          BSR         negSize
00001284                           288          
00001284                           289          ;Do Dn
00001284  3401                     290          MOVE.W      D1,D2
00001286  E04A                     291          LSR.W       #8,D2               ;move reg into first byte
00001288  E20A                     292          LSR.B       #1,D2               ;line it up to least sig bit
0000128A  C43C 0007                293          AND.B       #%00000111,D2       ;force mode to Dn
0000128E  1A02                     294          MOVE.B      D2,D5
00001290  48E7 4000                295          MOVEM.L     D1,-(SP)
00001294  6100 159E                296          BSR         Get_Effective_Address
00001298  4CDF 0002                297          MOVEM.L     (SP)+,D1
0000129C                           298          
0000129C                           299          
0000129C                           300          ;print ','
0000129C  48E7 4000                301          MOVEM.L     D1,-(SP)            ;save D1 to the stack
000012A0  123C 002C                302          MOVE.B      #',',D1             ;put ascii value of char in D1
000012A4  103C 0006                303          MOVE.B      #6,D0               ;move task 6 into D0
000012A8  4E4F                     304          TRAP        #15                 ;prin char
000012AA  4CDF 0002                305          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
000012AE                           306          
000012AE                           307          ;Then do EA
000012AE  3401                     308          MOVE.W      D1,D2               ;check mode
000012B0  C43C 003F                309          AND.B       #%00111111,D2
000012B4  1A02                     310          MOVE.B      D2,D5
000012B6  48E7 4000                311          MOVEM.L     D1,-(SP)
000012BA  6100 1578                312          BSR         Get_Effective_Address
000012BE  4CDF 0002                313          MOVEM.L     (SP)+,D1
000012C2                           314          
000012C2                           315          
000012C2  43F9 00002D3E            316          LEA         clearLine,A1        ;move string for a CR and LF
000012C8  103C 000E                317          MOVE.B      #14,D0              ;set for task to display null terminated 
000012CC                           318                                          ;string without CR, LF
000012CC  4E4F                     319          TRAP        #15
000012CE                           320  
000012CE  7000                     321          MOVEQ.L     #0,D0
000012D0  4E75                     322          RTS
000012D2                           323  
000012D2                           324  **************************************************************************************************
000012D2                           325  *                                       Tests for OP Code CMP     
000012D2                           326  **************************************************************************************************
000012D2                           327  
000012D2                           328  CMP:
000012D2                           329          
000012D2  7000                     330          MOVEQ.L     #0, D0              ;clear D0
000012D4                           331          
000012D4                           332          ;Figure out if EA is source or destination
000012D4  3401                     333          MOVE.W      D1,D2               ;copy inst to D2
000012D6  EC4A                     334          LSR.W       #6,D2               ;shift opmode to least sig bit of least sig byte
000012D8  0202 0007                335          ANDI.B      #%00000111,D2       ;mask out rest of byte
000012DC  0C02 0002                336          CMPI.B      #2,D2               ;compare to 2
000012E0  6F00 0006                337          BLE         validCmpEA          ;2 or less is EA 
000012E4                           338          
000012E4  6000 FDB0                339          BRA         falsePositive       ;thats not valid
000012E8                           340          
000012E8                           341  validCmpEA:
000012E8                           342          
000012E8  43F9 000023C3            343          LEA         moveSourceEAmasks,A1 ;load the list of masks
000012EE  D3C0                     344          ADDA.L      D0,A1               ;displace to a specific mask
000012F0  1A11                     345          MOVE.B      (A1),D5             ;move the mask to D5
000012F2                           346          
000012F2  0C05 0000                347          CMPI.B      #0,D5               ;check if the mask is 0
000012F6  6700 FD9E                348          BEQ         falsePositive       ;branch if it is
000012FA                           349          
000012FA  1401                     350          MOVE.B      D1,D2               ;copy instruction to D2
000012FC  C405                     351          AND.B       D5,D2               ;mask D2
000012FE                           352          
000012FE  43F9 000023BA            353          LEA         moveSourceEA,A1     ;load the list of valid modes
00001304  D3C0                     354          ADDA.L      D0,A1               ;displace to a specific mode
00001306  1811                     355          MOVE.B      (A1),D4             ;move mode to D4
00001308  B404                     356          CMP.B       D4,D2               ;compare mode to masked value
0000130A  6700 0006                357          BEQ         cmpBody             ;if its match, its a valid mode and we can procede
0000130E                           358          
0000130E  5280                     359          ADDQ.L      #1,D0               ;add one to displacement
00001310  60D6                     360          BRA         validCmpEA          ;check for next mode
00001312                           361          
00001312                           362          
00001312                           363          
00001312                           364  cmpBody
00001312                           365  
00001312  43F9 00002D45            366          LEA         cmpMessage,A1       ;move string for MOVE
00001318  103C 000E                367          MOVE.B      #14,D0              ;set for task to display null terminated 
0000131C                           368                                          ;string with CR, LF
0000131C  4E4F                     369          TRAP        #15
0000131E                           370          
0000131E  6100 0E4C                371          BSR         negSize
00001322                           372          
00001322                           373          ;do EA
00001322  3401                     374          MOVE.W      D1,D2               ;check mode
00001324  C43C 003F                375          AND.B       #%00111111,D2
00001328  1A02                     376          MOVE.B      D2,D5
0000132A  48E7 4000                377          MOVEM.L     D1,-(SP)
0000132E  6100 1504                378          BSR         Get_Effective_Address
00001332  4CDF 0002                379          MOVEM.L     (SP)+,D1
00001336                           380          
00001336                           381          ;print ','
00001336  48E7 4000                382          MOVEM.L     D1,-(SP)            ;save D1 to the stack
0000133A  123C 002C                383          MOVE.B      #',',D1             ;put ascii value of char in D1
0000133E  103C 0006                384          MOVE.B      #6,D0               ;move task 6 into D0
00001342  4E4F                     385          TRAP        #15                 ;prin char
00001344  4CDF 0002                386          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
00001348                           387          
00001348                           388          ;Then do Dn
00001348                           389          
00001348  3401                     390          MOVE.W      D1,D2
0000134A  E04A                     391          LSR.W       #8,D2               ;move reg into first byte
0000134C  E20A                     392          LSR.B       #1,D2               ;line it up to least sig bit
0000134E  C43C 0007                393          AND.B       #%00000111,D2       ;force mode to Dn
00001352  1A02                     394          MOVE.B      D2,D5
00001354  48E7 4000                395          MOVEM.L     D1,-(SP)
00001358  6100 14DA                396          BSR         Get_Effective_Address
0000135C  4CDF 0002                397          MOVEM.L     (SP)+,D1
00001360                           398          
00001360  43F9 00002D3E            399          LEA         clearLine,A1        ;move string for a CR and LF
00001366  103C 000E                400          MOVE.B      #14,D0              ;set for task to display null terminated 
0000136A                           401                                          ;string without CR, LF
0000136A  4E4F                     402          TRAP        #15
0000136C                           403  
0000136C  7000                     404          MOVEQ.L     #0,D0
0000136E  4E75                     405          RTS
00001370                           406  
00001370                           407  **************************************************************************************************
00001370                           408  *                                       Tests for OP Code OR     
00001370                           409  **************************************************************************************************
00001370                           410  
00001370= 00 10 18 20 38 39 ...    411  orSourceEA      Dc.B %000000,%010000,%011000,%100000,%111000,%111001,%111100,0
00001378= 38 38 38 38 3F 3F ...    412  orSourceEAmasks DC.B %111000,%111000,%111000,%111000,%111111,%111111,%111111,0
00001380                           413  
00001380                           414  OR:
00001380                           415          
00001380  7000                     416          MOVEQ.L     #0, D0              ;clear D0
00001382                           417          
00001382                           418          ;Figure out if EA is source or destination
00001382  3401                     419          MOVE.W      D1,D2               ;copy inst to D2
00001384  EC4A                     420          LSR.W       #6,D2               ;shift opmode to least sig bit of least sig byte
00001386  0202 0007                421          ANDI.B      #%00000111,D2       ;mask out rest of byte
0000138A  0C02 0002                422          CMPI.B      #2,D2               ;compare to 2
0000138E  6F00 0016                423          BLE         validOrSourceEA     ;2 or less is EA is source
00001392                           424          
00001392  0C02 0007                425          CMPI.B      #%111,D2            ;compare to 7
00001396  6700 FCFE                426          BEQ         falsePositive       ;thats not valid
0000139A  0C02 0003                427          CMPI.B      #%11,D2             ;compare to 3
0000139E  6700 FCF6                428          BEQ         falsePositive       ;also not valid
000013A2  6000 0028                429          BRA         validOrDestEA       ;all thats left is valid EA as Dest 
000013A6                           430          
000013A6                           431  validORSourceEA:
000013A6                           432          
000013A6  43F8 1378                433          LEA         orSourceEAmasks,A1  ;load the list of masks
000013AA  D3C0                     434          ADDA.L      D0,A1               ;displace to a specific mask
000013AC  1A11                     435          MOVE.B      (A1),D5             ;move the mask to D5
000013AE                           436          
000013AE  0C05 0000                437          CMPI.B      #0,D5               ;check if the mask is 0
000013B2  6700 FCE2                438          BEQ         falsePositive       ;branch if it is
000013B6                           439          
000013B6  1401                     440          MOVE.B      D1,D2               ;copy instruction to D2
000013B8  C405                     441          AND.B       D5,D2               ;mask D2
000013BA                           442          
000013BA  43F8 1370                443          LEA         orSourceEA,A1       ;load the list of valid modes
000013BE  D3C0                     444          ADDA.L      D0,A1               ;displace to a specific mode
000013C0  1811                     445          MOVE.B      (A1),D4             ;move mode to D4
000013C2  B404                     446          CMP.B       D4,D2               ;compare mode to masked value
000013C4  6700 0030                447          BEQ         orSource            ;if its match, its a valid mode and we can procede
000013C8                           448          
000013C8  5280                     449          ADDQ.L      #1,D0               ;add one to displacement
000013CA  60DA                     450          BRA         validOrSourceEA     ;check for next mode
000013CC                           451          
000013CC                           452  validOrDestEA:
000013CC                           453          
000013CC  43F9 00001D20            454          LEA         addDestEAmasks,A1   ;load the list of masks
000013D2  D3C0                     455          ADDA.L      D0,A1               ;displace to a specific mask
000013D4  1A11                     456          MOVE.B      (A1),D5             ;move the mask to D5
000013D6                           457          
000013D6  0C05 0000                458          CMPI.B      #0,D5               ;check if the mask is 0
000013DA  6700 FCBA                459          BEQ         falsePositive       ;branch if it is
000013DE                           460          
000013DE  3401                     461          MOVE.W      D1,D2               ;copy instruction to D2
000013E0  C405                     462          AND.B       D5,D2               ;mask D2
000013E2                           463          
000013E2  43F9 00001D1A            464          LEA         addDestEA,A1        ;load the list of valid modes
000013E8  D3C0                     465          ADDA.L      D0,A1               ;displace to a specific mode
000013EA  1811                     466          MOVE.B      (A1),D4             ;move mode to D4
000013EC  B404                     467          CMP.B       D4,D2               ;compare mode to masked value
000013EE  6700 0064                468          BEQ         orDest              ;if its match, its a valid mode and we can procede
000013F2                           469          
000013F2  5280                     470          ADDQ.L      #1,D0               ;add one to displacement
000013F4  60D6                     471          BRA         validOrDestEA       ;check for next mode
000013F6                           472          
000013F6                           473  orSource
000013F6                           474  
000013F6  43F9 00002D49            475          LEA         orMessage,A1        ;move string for MOVE
000013FC  103C 000E                476          MOVE.B      #14,D0              ;set for task to display null terminated 
00001400                           477                                          ;string with CR, LF
00001400  4E4F                     478          TRAP        #15
00001402                           479              
00001402  6100 0D68                480          BSR         negSize
00001406                           481          
00001406                           482          ;do EA
00001406  3401                     483          MOVE.W      D1,D2               ;check mode
00001408  C43C 003F                484          AND.B       #%00111111,D2
0000140C  1A02                     485          MOVE.B      D2,D5
0000140E  48E7 4000                486          MOVEM.L     D1,-(SP)
00001412  6100 1420                487          BSR         Get_Effective_Address
00001416  4CDF 0002                488          MOVEM.L     (SP)+,D1
0000141A                           489          
0000141A                           490          ;print ','
0000141A  48E7 4000                491          MOVEM.L     D1,-(SP)            ;save D1 to the stack
0000141E  123C 002C                492          MOVE.B      #',',D1             ;put ascii value of char in D1
00001422  103C 0006                493          MOVE.B      #6,D0               ;move task 6 into D0
00001426  4E4F                     494          TRAP        #15                 ;prin char
00001428  4CDF 0002                495          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
0000142C                           496          
0000142C                           497          ;Then do Dn
0000142C  3401                     498          MOVE.W      D1,D2
0000142E  E04A                     499          LSR.W       #8,D2               ;move reg into first byte
00001430  E20A                     500          LSR.B       #1,D2               ;line it up to least sig bit
00001432  C43C 0007                501          AND.B       #%00000111,D2       ;force mode to Dn
00001436  1A02                     502          MOVE.B      D2,D5
00001438  48E7 4000                503          MOVEM.L     D1,-(SP)
0000143C  6100 13F6                504          BSR         Get_Effective_Address
00001440  4CDF 0002                505          MOVEM.L     (SP)+,D1
00001444                           506          
00001444  43F9 00002D3E            507          LEA         clearLine,A1        ;move string for a CR and LF
0000144A  103C 000E                508          MOVE.B      #14,D0              ;set for task to display null terminated 
0000144E                           509                                          ;string without CR, LF
0000144E  4E4F                     510          TRAP        #15
00001450                           511  
00001450  7000                     512          MOVEQ.L     #0,D0
00001452  4E75                     513          RTS
00001454                           514  
00001454                           515  orDest
00001454                           516  
00001454  43F9 00002D49            517          LEA         orMessage,A1        ;move string for MOVE
0000145A  103C 000E                518          MOVE.B      #14,D0              ;set for task to display null terminated 
0000145E                           519                                          ;string with CR, LF
0000145E  4E4F                     520          TRAP        #15
00001460                           521          
00001460  6100 0D0A                522          BSR         negSize
00001464                           523          
00001464                           524          ;Do Dn
00001464  3401                     525          MOVE.W      D1,D2
00001466  E04A                     526          LSR.W       #8,D2               ;move reg into first byte
00001468  E20A                     527          LSR.B       #1,D2               ;line it up to least sig bit
0000146A  C43C 0007                528          AND.B       #%00000111,D2       ;force mode to Dn
0000146E  1A02                     529          MOVE.B      D2,D5
00001470  48E7 4000                530          MOVEM.L     D1,-(SP)
00001474  6100 13BE                531          BSR         Get_Effective_Address
00001478  4CDF 0002                532          MOVEM.L     (SP)+,D1
0000147C                           533          
0000147C                           534          
0000147C                           535          ;print ','
0000147C  48E7 4000                536          MOVEM.L     D1,-(SP)            ;save D1 to the stack
00001480  123C 002C                537          MOVE.B      #',',D1             ;put ascii value of char in D1
00001484  103C 0006                538          MOVE.B      #6,D0               ;move task 6 into D0
00001488  4E4F                     539          TRAP        #15                 ;prin char
0000148A  4CDF 0002                540          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
0000148E                           541          
0000148E                           542          ;Then do EA
0000148E                           543          
0000148E  3401                     544          MOVE.W      D1,D2               ;check mode
00001490  C43C 003F                545          AND.B       #%00111111,D2
00001494  1A02                     546          MOVE.B      D2,D5
00001496  48E7 4000                547          MOVEM.L     D1,-(SP)
0000149A  6100 1398                548          BSR         Get_Effective_Address
0000149E  4CDF 0002                549          MOVEM.L     (SP)+,D1
000014A2                           550          
000014A2                           551          
000014A2  43F9 00002D3E            552          LEA         clearLine,A1        ;move string for a CR and LF
000014A8  103C 000E                553          MOVE.B      #14,D0              ;set for task to display null terminated 
000014AC                           554                                          ;string without CR, LF
000014AC  4E4F                     555          TRAP        #15
000014AE                           556  
000014AE  7000                     557          MOVEQ.L     #0,D0
000014B0  4E75                     558          RTS
000014B2                           559  
000014B2                           560  **************************************************************************************************
000014B2                           561  *                                       Tests for OP Code BCLRDATA     
000014B2                           562  **************************************************************************************************
000014B2                           563  
000014B2                           564  BCLRDATA:
000014B2                           565  
000014B2  7000                     566          MOVEQ.L     #0, D0              ;clear D0
000014B4                           567          
000014B4                           568  validBCLRdataModes:
000014B4                           569          
000014B4  43F9 000016F2            570          LEA         mulsEAmasks,A1      ;load the list of masks
000014BA  D3C0                     571          ADDA.L      D0,A1               ;displace to a specific mask
000014BC  1A11                     572          MOVE.B      (A1),D5             ;move the mask to D5
000014BE                           573          
000014BE  0C05 0000                574          CMPI.B      #0,D5               ;check if the mask is 0
000014C2  6700 FBD2                575          BEQ         falsePositive       ;branch if it is
000014C6                           576          
000014C6  1401                     577          MOVE.B      D1,D2               ;copy instruction to D2
000014C8  C405                     578          AND.B       D5,D2               ;mask D2
000014CA                           579          
000014CA  43F9 000016EA            580          LEA         mulsEA,A1           ;load the list of valid modes
000014D0  D3C0                     581          ADDA.L      D0,A1               ;displace to a specific mode
000014D2  1811                     582          MOVE.B      (A1),D4             ;move mode to D4
000014D4  B404                     583          CMP.B       D4,D2               ;compare mode to masked value
000014D6  6700 0006                584          BEQ         bclrdataBody        ;if its match, its a valid mode and we can procede
000014DA                           585          
000014DA  5280                     586          ADDQ.L      #1,D0               ;add one to displacement
000014DC  60D6                     587          BRA         validBCLRdataModes  ;check for next mode
000014DE                           588          
000014DE                           589  bclrdataBody:
000014DE                           590  
000014DE  43F9 00002D4C            591          LEA         bclrMessage,A1      ;move string for MOVE
000014E4  103C 000E                592          MOVE.B      #14,D0              ;set for task to display null terminated 
000014E8                           593                                          ;string without CR, LF
000014E8  4E4F                     594          TRAP        #15
000014EA                           595      
000014EA  48E7 C010                596          MOVEM.L     D0/D1/A3,-(SP)      ;save D1 and A3
000014EE  5487                     597          ADDQ.L      #word,D7            ;signal there is a word following this instruction
000014F0                           598          
000014F0                           599          ;print '#'
000014F0  48E7 4000                600          MOVEM.L     D1,-(SP)            ;save D1 to the stack
000014F4  123C 0023                601          MOVE.B      #'#',D1             ;put ascii value of char in D1
000014F8  103C 0006                602          MOVE.B      #6,D0               ;move task 6 into D0
000014FC  4E4F                     603          TRAP        #15                 ;prin char
000014FE  4CDF 0002                604          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
00001502                           605          
00001502                           606          ;get following word
00001502  548B                     607          ADDQ.L      #word,A3
00001504  3213                     608          MOVE.W      (A3),D1             ;move word at (A3)
00001506  0281 0000FFFF            609          ANDI.L      #$0000FFFF,D1       ;clear unimportant bit of D1
0000150C                           610          
0000150C                           611          ;print number
0000150C  103C 0003                612          MOVE.B      #3,D0
00001510  4E4F                     613          TRAP        #15
00001512                           614          
00001512  4CDF 0803                615          MOVEM.L     (SP)+,D0/D1/A3      ;restore D1 and A3
00001516                           616  
00001516                           617  
00001516                           618  
00001516                           619          ;print ','
00001516  48E7 4000                620          MOVEM.L     D1,-(SP)            ;save D1 to the stack
0000151A  123C 002C                621          MOVE.B      #',',D1             ;put ascii value of char in D1
0000151E  103C 0006                622          MOVE.B      #6,D0               ;move task 6 into D0
00001522  4E4F                     623          TRAP        #15                 ;prin char
00001524  4CDF 0002                624          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
00001528                           625          
00001528                           626          ;do dest EA
00001528  3401                     627          MOVE.W      D1,D2               ;check mode
0000152A  C43C 003F                628          AND.B       #%00111111,D2
0000152E  1A02                     629          MOVE.B      D2,D5
00001530  48E7 4000                630          MOVEM.L     D1,-(SP)
00001534  6100 12FE                631          BSR         Get_Effective_Address
00001538  4CDF 0002                632          MOVEM.L     (SP)+,D1
0000153C                           633          
0000153C  43F9 00002D3E            634          LEA         clearLine,A1        ;move string for a CR and LF
00001542  103C 000E                635          MOVE.B      #14,D0              ;set for task to display null terminated 
00001546                           636                                          ;string without CR, LF
00001546  4E4F                     637          TRAP        #15
00001548                           638  
00001548  7000                     639          MOVEQ.L     #0,D0
0000154A  4E75                     640          RTS
0000154C                           641  
0000154C                           642  **************************************************************************************************
0000154C                           643  *                                       Tests for OP Code BCLR     
0000154C                           644  **************************************************************************************************
0000154C                           645           
0000154C                           646  BCLR:
0000154C                           647  
0000154C  7000                     648          MOVEQ.L     #0, D0              ;clear D0
0000154E                           649          
0000154E                           650  validBCLRModes:
0000154E                           651          
0000154E  43F9 000016F2            652          LEA         mulsEAmasks,A1      ;load the list of masks
00001554  D3C0                     653          ADDA.L      D0,A1               ;displace to a specific mask
00001556  1A11                     654          MOVE.B      (A1),D5             ;move the mask to D5
00001558                           655          
00001558  0C05 0000                656          CMPI.B      #0,D5               ;check if the mask is 0
0000155C  6700 FB38                657          BEQ         falsePositive       ;branch if it is
00001560                           658          
00001560  1401                     659          MOVE.B      D1,D2               ;copy instruction to D2
00001562  C405                     660          AND.B       D5,D2               ;mask D2
00001564                           661          
00001564  43F9 000016EA            662          LEA         mulsEA,A1           ;load the list of valid modes
0000156A  D3C0                     663          ADDA.L      D0,A1               ;displace to a specific mode
0000156C  1811                     664          MOVE.B      (A1),D4             ;move mode to D4
0000156E  B404                     665          CMP.B       D4,D2               ;compare mode to masked value
00001570  6700 0006                666          BEQ         bclrBody            ;if its match, its a valid mode and we can procede
00001574                           667          
00001574  5280                     668          ADDQ.L      #1,D0               ;add one to displacement
00001576  60D6                     669          BRA         validBCLRModes      ;check for next mode
00001578                           670          
00001578                           671  bclrBody:
00001578                           672  
00001578  43F9 00002D4C            673          LEA         bclrMessage,A1      ;move string for MOVE
0000157E  103C 000E                674          MOVE.B      #14,D0              ;set for task to display null terminated 
00001582                           675                                          ;string without CR, LF
00001582  4E4F                     676          TRAP        #15
00001584                           677  
00001584                           678          ;do source EA
00001584  3401                     679          MOVE.W      D1,D2               ;check mode
00001586  C43C 003F                680          AND.B       #%00111111,D2
0000158A  1A02                     681          MOVE.B      D2,D5
0000158C  48E7 4000                682          MOVEM.L     D1,-(SP)
00001590  6100 12A2                683          BSR         Get_Effective_Address
00001594  4CDF 0002                684          MOVEM.L     (SP)+,D1
00001598                           685  
00001598                           686          ;print ','
00001598  48E7 4000                687          MOVEM.L     D1,-(SP)            ;save D1 to the stack
0000159C  123C 002C                688          MOVE.B      #',',D1             ;put ascii value of char in D1
000015A0  103C 0006                689          MOVE.B      #6,D0               ;move task 6 into D0
000015A4  4E4F                     690          TRAP        #15                 ;prin char
000015A6  4CDF 0002                691          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
000015AA                           692          
000015AA                           693          ;do dest data reg
000015AA  3401                     694          MOVE.W      D1,D2               ;check mode
000015AC  E04A                     695          LSR.W       #8,D2               ;shift reg over
000015AE  E20A                     696          LSR.B       #1,D2
000015B0  C43C 0007                697          AND.B       #%00000111,D2       ;force recognition as a Dn
000015B4  1A02                     698          MOVE.B      D2,D5
000015B6  48E7 4000                699          MOVEM.L     D1,-(SP)
000015BA  6100 1278                700          BSR         Get_Effective_Address
000015BE  4CDF 0002                701          MOVEM.L     (SP)+,D1
000015C2                           702          
000015C2  43F9 00002D3E            703          LEA         clearLine,A1        ;move string for a CR and LF
000015C8  103C 000E                704          MOVE.B      #14,D0              ;set for task to display null terminated 
000015CC                           705                                          ;string without CR, LF
000015CC  4E4F                     706          TRAP        #15
000015CE                           707  
000015CE  7000                     708          MOVEQ.L     #0,D0
000015D0  4E75                     709          RTS
000015D2                           710  
000015D2                           711  **************************************************************************************************
000015D2                           712  *                                       Tests for OP Code LEA     
000015D2                           713  **************************************************************************************************
000015D2                           714           
000015D2                           715  
000015D2= 10 38 39 00              716  leaEA        DC.B %010000,%111000,%111001,0
000015D6= 38 3F 3F 00              717  leaEAmasks   DC.B %111000,%111111,%111111,0
000015DA                           718          
000015DA                           719  LEA:
000015DA                           720  
000015DA  7000                     721          MOVEQ.L     #0, D0              ;clear D0
000015DC                           722          
000015DC                           723  validLeaModes:
000015DC                           724          
000015DC  43F8 15D6                725          LEA         leaEAmasks,A1       ;load the list of masks
000015E0  D3C0                     726          ADDA.L      D0,A1               ;displace to a specific mask
000015E2  1A11                     727          MOVE.B      (A1),D5             ;move the mask to D5
000015E4                           728          
000015E4  0C05 0000                729          CMPI.B      #0,D5               ;check if the mask is 0
000015E8  6700 FAAC                730          BEQ         falsePositive       ;branch if it is
000015EC                           731          
000015EC  1401                     732          MOVE.B      D1,D2               ;copy instruction to D2
000015EE  C405                     733          AND.B       D5,D2               ;mask D2
000015F0                           734          
000015F0  43F8 15D2                735          LEA         leaEA,A1            ;load the list of valid modes
000015F4  D3C0                     736          ADDA.L      D0,A1               ;displace to a specific mode
000015F6  1811                     737          MOVE.B      (A1),D4             ;move mode to D4
000015F8  B404                     738          CMP.B       D4,D2               ;compare mode to masked value
000015FA  6700 0006                739          BEQ         leaBody             ;if its match, its a valid mode and we can procede
000015FE                           740          
000015FE  5280                     741          ADDQ.L      #1,D0               ;add one to displacement
00001600  60DA                     742          BRA         validLeaModes       ;check for next mode
00001602                           743          
00001602                           744  leaBody:
00001602                           745  
00001602  43F9 00002D52            746          LEA         leaMessage,A1       ;move string for MOVE
00001608  103C 000E                747          MOVE.B      #14,D0              ;set for task to display null terminated 
0000160C                           748                                          ;string without CR, LF
0000160C  4E4F                     749          TRAP        #15
0000160E                           750  
0000160E                           751          ;do source EA
0000160E  3401                     752          MOVE.W      D1,D2               ;check mode
00001610  C43C 003F                753          AND.B       #%00111111,D2
00001614  1A02                     754          MOVE.B      D2,D5
00001616  48E7 4000                755          MOVEM.L     D1,-(SP)
0000161A  6100 1218                756          BSR         Get_Effective_Address
0000161E  4CDF 0002                757          MOVEM.L     (SP)+,D1
00001622                           758  
00001622                           759          ;print ','
00001622  48E7 4000                760          MOVEM.L     D1,-(SP)            ;save D1 to the stack
00001626  123C 002C                761          MOVE.B      #',',D1             ;put ascii value of char in D1
0000162A  103C 0006                762          MOVE.B      #6,D0               ;move task 6 into D0
0000162E  4E4F                     763          TRAP        #15                 ;prin char
00001630  4CDF 0002                764          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
00001634                           765          
00001634                           766          ;do dest addr reg
00001634  3401                     767          MOVE.W      D1,D2               ;check mode
00001636  E04A                     768          LSR.W       #8,D2               ;shift reg over
00001638  E20A                     769          LSR.B       #1,D2
0000163A  C43C 0007                770          AND.B       #%00000111,D2       ;force recognition as a An
0000163E  5002                     771          ADDQ.B      #%1000,D2
00001640  1A02                     772          MOVE.B      D2,D5
00001642  48E7 4000                773          MOVEM.L     D1,-(SP)
00001646  6100 11EC                774          BSR         Get_Effective_Address
0000164A  4CDF 0002                775          MOVEM.L     (SP)+,D1
0000164E                           776          
0000164E  43F9 00002D3E            777          LEA         clearLine,A1        ;move string for a CR and LF
00001654  103C 000E                778          MOVE.B      #14,D0              ;set for task to display null terminated 
00001658                           779                                          ;string without CR, LF
00001658  4E4F                     780          TRAP        #15
0000165A                           781  
0000165A  7000                     782          MOVEQ.L     #0,D0
0000165C  4E75                     783          RTS
0000165E                           784  
0000165E                           785  **************************************************************************************************
0000165E                           786  *                                       Tests for OP Code DIVS     
0000165E                           787  **************************************************************************************************
0000165E                           788  
0000165E                           789  
0000165E                           790  DIVS:
0000165E                           791  
0000165E  7000                     792          MOVEQ.L     #0, D0              ;clear D0
00001660                           793          
00001660                           794  validDivsModes:
00001660                           795          
00001660  43F9 000016F2            796          LEA         mulsEAmasks,A1      ;load the list of masks
00001666  D3C0                     797          ADDA.L      D0,A1               ;displace to a specific mask
00001668  1A11                     798          MOVE.B      (A1),D5             ;move the mask to D5
0000166A                           799          
0000166A  0C05 0000                800          CMPI.B      #0,D5               ;check if the mask is 0
0000166E  6700 FA26                801          BEQ         falsePositive       ;branch if it is
00001672                           802          
00001672  1401                     803          MOVE.B      D1,D2               ;copy instruction to D2
00001674  C405                     804          AND.B       D5,D2               ;mask D2
00001676                           805          
00001676  43F9 000016EA            806          LEA         mulsEA,A1           ;load the list of valid modes
0000167C  D3C0                     807          ADDA.L      D0,A1               ;displace to a specific mode
0000167E  1811                     808          MOVE.B      (A1),D4             ;move mode to D4
00001680  B404                     809          CMP.B       D4,D2               ;compare mode to masked value
00001682  6700 0006                810          BEQ         divsBody            ;if its match, its a valid mode and we can procede
00001686                           811          
00001686  5280                     812          ADDQ.L      #1,D0               ;add one to displacement
00001688  60D6                     813          BRA         validDivsModes      ;check for next mode
0000168A                           814          
0000168A                           815  divsBody:
0000168A                           816  
0000168A  43F9 00002D57            817          LEA         divsMessage,A1      ;move string for MOVE
00001690  103C 000E                818          MOVE.B      #14,D0              ;set for task to display null terminated 
00001694                           819                                          ;string without CR, LF
00001694  4E4F                     820          TRAP        #15
00001696                           821          
00001696                           822          ;set size to word
00001696  7C01                     823          MOVEQ.L     #1,D6
00001698  6100 1338                824          BSR         printSize
0000169C                           825          
0000169C                           826          ;do source EA
0000169C  3401                     827          MOVE.W      D1,D2               ;check mode
0000169E  C43C 003F                828          AND.B       #%00111111,D2
000016A2  1A02                     829          MOVE.B      D2,D5
000016A4  48E7 4000                830          MOVEM.L     D1,-(SP)
000016A8  6100 118A                831          BSR         Get_Effective_Address
000016AC  4CDF 0002                832          MOVEM.L     (SP)+,D1
000016B0                           833  
000016B0                           834          ;print ','
000016B0  48E7 4000                835          MOVEM.L     D1,-(SP)            ;save D1 to the stack
000016B4  123C 002C                836          MOVE.B      #',',D1             ;put ascii value of char in D1
000016B8  103C 0006                837          MOVE.B      #6,D0               ;move task 6 into D0
000016BC  4E4F                     838          TRAP        #15                 ;prin char
000016BE  4CDF 0002                839          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
000016C2                           840          
000016C2                           841          ;do dest data reg
000016C2  3401                     842          MOVE.W      D1,D2               ;check mode
000016C4  E04A                     843          LSR.W       #8,D2               ;shift reg over
000016C6  E20A                     844          LSR.B       #1,D2
000016C8  C43C 0007                845          AND.B       #%00000111,D2       ;force recognition as a Dn
000016CC  1A02                     846          MOVE.B      D2,D5
000016CE  48E7 4000                847          MOVEM.L     D1,-(SP)
000016D2  6100 1160                848          BSR         Get_Effective_Address
000016D6  4CDF 0002                849          MOVEM.L     (SP)+,D1
000016DA                           850          
000016DA  43F9 00002D3E            851          LEA         clearLine,A1        ;move string for a CR and LF
000016E0  103C 000E                852          MOVE.B      #14,D0              ;set for task to display null terminated 
000016E4                           853                                          ;string without CR, LF
000016E4  4E4F                     854          TRAP        #15
000016E6                           855  
000016E6  7000                     856          MOVEQ.L     #0,D0
000016E8  4E75                     857          RTS
000016EA                           858  
000016EA                           859  **************************************************************************************************
000016EA                           860  *                                       Tests for OP Code MULS     
000016EA                           861  **************************************************************************************************
000016EA                           862  
000016EA= 00 10 18 20 38 39 ...    863  mulsEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,%111100,0
000016F2= 38 38 38 38 3F 3F ...    864  mulsEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,%111111,0
000016FA                           865          
000016FA                           866  MULS:
000016FA                           867  
000016FA  7000                     868          MOVEQ.L     #0, D0              ;clear D0
000016FC                           869          
000016FC                           870  validMulsModes:
000016FC                           871          
000016FC  43F8 16F2                872          LEA         mulsEAmasks,A1      ;load the list of masks
00001700  D3C0                     873          ADDA.L      D0,A1               ;displace to a specific mask
00001702  1A11                     874          MOVE.B      (A1),D5             ;move the mask to D5
00001704                           875          
00001704  0C05 0000                876          CMPI.B      #0,D5               ;check if the mask is 0
00001708  6700 F98C                877          BEQ         falsePositive       ;branch if it is
0000170C                           878          
0000170C  1401                     879          MOVE.B      D1,D2               ;copy instruction to D2
0000170E  C405                     880          AND.B       D5,D2               ;mask D2
00001710                           881          
00001710  43F8 16EA                882          LEA         mulsEA,A1           ;load the list of valid modes
00001714  D3C0                     883          ADDA.L      D0,A1               ;displace to a specific mode
00001716  1811                     884          MOVE.B      (A1),D4             ;move mode to D4
00001718  B404                     885          CMP.B       D4,D2               ;compare mode to masked value
0000171A  6700 0006                886          BEQ         mulsBody            ;if its match, its a valid mode and we can procede
0000171E                           887          
0000171E  5280                     888          ADDQ.L      #1,D0               ;add one to displacement
00001720  60DA                     889          BRA         validMulsModes      ;check for next mode
00001722                           890          
00001722                           891  mulsBody:
00001722                           892  
00001722  43F9 00002D5C            893          LEA         mulsMessage,A1      ;move string for MOVE
00001728  103C 000E                894          MOVE.B      #14,D0              ;set for task to display null terminated 
0000172C                           895                                          ;string without CR, LF
0000172C  4E4F                     896          TRAP        #15
0000172E                           897          
0000172E                           898          ;set size to word
0000172E  7C01                     899          MOVEQ.L     #1,D6
00001730  6100 12A0                900          BSR         printSize
00001734                           901  
00001734                           902          ;do source EA
00001734  3401                     903          MOVE.W      D1,D2               ;check mode
00001736  C43C 003F                904          AND.B       #%00111111,D2
0000173A  1A02                     905          MOVE.B      D2,D5
0000173C  48E7 4000                906          MOVEM.L     D1,-(SP)
00001740  6100 10F2                907          BSR         Get_Effective_Address
00001744  4CDF 0002                908          MOVEM.L     (SP)+,D1
00001748                           909  
00001748                           910          ;print ','
00001748  48E7 4000                911          MOVEM.L     D1,-(SP)            ;save D1 to the stack
0000174C  123C 002C                912          MOVE.B      #',',D1             ;put ascii value of char in D1
00001750  103C 0006                913          MOVE.B      #6,D0               ;move task 6 into D0
00001754  4E4F                     914          TRAP        #15                 ;prin char
00001756  4CDF 0002                915          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
0000175A                           916          
0000175A                           917          ;do dest data reg
0000175A  3401                     918          MOVE.W      D1,D2               ;check mode
0000175C  E04A                     919          LSR.W       #8,D2               ;shift reg over
0000175E  E20A                     920          LSR.B       #1,D2
00001760  C43C 0007                921          AND.B       #%00000111,D2       ;force recognition as a Dn
00001764  1A02                     922          MOVE.B      D2,D5
00001766  48E7 4000                923          MOVEM.L     D1,-(SP)
0000176A  6100 10C8                924          BSR         Get_Effective_Address
0000176E  4CDF 0002                925          MOVEM.L     (SP)+,D1
00001772                           926          
00001772  43F9 00002D3E            927          LEA         clearLine,A1        ;move string for a CR and LF
00001778  103C 000E                928          MOVE.B      #14,D0              ;set for task to display null terminated 
0000177C                           929                                          ;string without CR, LF
0000177C  4E4F                     930          TRAP        #15
0000177E                           931  
0000177E  7000                     932          MOVEQ.L     #0,D0
00001780  4E75                     933          RTS
00001782                           934  
00001782                           935  **************************************************************************************************
00001782                           936  *                                       Tests for OP Code RSRLW     
00001782                           937  **************************************************************************************************
00001782                           938  
00001782                           939  RSRLWEA:
00001782                           940          
00001782  7000                     941          MOVEQ.L #0, D0                  ;clear D0
00001784                           942          
00001784                           943  validRSRL:
00001784                           944          
00001784  43F9 000018D4            945          LEA lsrlEAmasks,A1              ;load the list of masks
0000178A  D3C0                     946          ADDA.L D0,A1                    ;displace to a specific mask
0000178C  1A11                     947          MOVE.B (A1),D5                  ;move the mask to D5
0000178E                           948          
0000178E  0C05 0000                949          CMPI.B #0,D5                    ;check if the mask is 0
00001792  6700 F902                950          BEQ falsePositive               ;branch if it is
00001796                           951          
00001796  1401                     952          MOVE.B D1,D2                    ;copy instruction to D2
00001798  C405                     953          AND.B D5,D2                     ;mask D2
0000179A                           954          
0000179A  43F9 000018CE            955          LEA lsrlEA,A1                   ;load the list of valid modes
000017A0  D3C0                     956          ADDA.L D0,A1                    ;displace to a specific mode
000017A2  1811                     957          MOVE.B (A1),D4                  ;move mode to D4
000017A4  B404                     958          CMP.B D4,D2                     ;compare mode to masked value
000017A6  6700 0006                959          BEQ  rsrlweaCheckDirection      ;if its match, its a valid mode and we can procede
000017AA                           960          
000017AA  5280                     961          ADDQ.L #1,D0                    ;add one to displacement
000017AC  60D6                     962          BRA validRSRL                   ;check for next mode
000017AE                           963  
000017AE                           964  rsrlweaCheckDirection:
000017AE                           965          ;Figure out which direction we are going
000017AE  3401                     966          MOVE.W D1,D2                    ;copy inst to D2
000017B0  E04A                     967          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
000017B2  0202 0001                968          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
000017B6  0C02 0000                969          CMPI.B #0,D2                    ;compare bit to zero
000017BA  6700 0006                970          BEQ RSREA                       ;if zero, right
000017BE  6000 0012                971          BRA RSLEA                       ;else, its left
000017C2                           972  
000017C2                           973  RSREA:
000017C2                           974  
000017C2  43F9 00002D65            975          LEA     rsrMessage,A1           ;move string for MOVE
000017C8  103C 000E                976          MOVE.B  #14,D0                  ;set for task to display null terminated 
000017CC                           977                                ;string with CR, LF
000017CC  4E4F                     978          TRAP    #15
000017CE  6000 0166                979          BRA lsrlweaBody
000017D2                           980          
000017D2                           981  RSLEA:
000017D2                           982          
000017D2  43F9 00002D61            983          LEA     rslMessage,A1           ;move string for MOVE
000017D8  103C 000E                984          MOVE.B  #14,D0                  ;set for task to display null terminated 
000017DC                           985                                ;string with CR, LF
000017DC  4E4F                     986          TRAP    #15
000017DE  6000 0156                987          BRA lsrlweaBody        
000017E2                           988          
000017E2                           989  
000017E2                           990  
000017E2                           991  RSRLREG:
000017E2                           992          
000017E2                           993  
000017E2                           994          
000017E2  7000                     995          MOVEQ.L #0, D0                  ;clear D0
000017E4                           996          
000017E4                           997          ;check valid size field
000017E4  3401                     998          MOVE.W D1,D2                    ;copy inst to D2
000017E6  EC4A                     999          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
000017E8  0202 0003               1000          ANDI.B #%00000011,D2            ;mask out rest of byte
000017EC  0C02 0003               1001          CMPI.B #%11,D2                  ;compare to 3
000017F0  6700 F8A4               1002          BEQ falsePositive               ;invalid size
000017F4                          1003  
000017F4                          1004          
000017F4                          1005          ;Figure out which direction we are going
000017F4  3401                    1006          MOVE.W D1,D2                    ;copy inst to D2
000017F6  E04A                    1007          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
000017F8  0202 0001               1008          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
000017FC  0C02 0000               1009          CMPI.B #0,D2                    ;compare bit to zero
00001800  6700 0006               1010          BEQ RSRreg                      ;if zero, right
00001804  6000 0012               1011          BRA RSLreg                      ;else, its left        
00001808                          1012          
00001808                          1013  RSRreg:
00001808                          1014  
00001808  43F9 00002D65           1015          LEA     rsrMessage,A1           ;move string for MOVE
0000180E  103C 000E               1016          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001812                          1017                                ;string with CR, LF
00001812  4E4F                    1018          TRAP    #15
00001814  6000 019C               1019          BRA LSRLregBody
00001818                          1020          
00001818                          1021  RSLreg:
00001818                          1022          
00001818  43F9 00002D61           1023          LEA     rslMessage,A1           ;move string for MOVE
0000181E  103C 000E               1024          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001822                          1025                                ;string with CR, LF
00001822  4E4F                    1026          TRAP    #15
00001824  6000 018C               1027          BRA LSRLregBody
00001828                          1028  
00001828                          1029  
00001828                          1030  **************************************************************************************************
00001828                          1031  *                                       Tests for OP Code ASRLW     
00001828                          1032  **************************************************************************************************
00001828                          1033  
00001828                          1034  ASRLWEA:
00001828                          1035          
00001828                          1036  
00001828                          1037          
00001828  7000                    1038          MOVEQ.L #0, D0                  ;clear D0
0000182A                          1039          
0000182A                          1040  validASRL:
0000182A                          1041          
0000182A  43F9 000018D4           1042          LEA lsrlEAmasks,A1              ;load the list of masks
00001830  D3C0                    1043          ADDA.L D0,A1                    ;displace to a specific mask
00001832  1A11                    1044          MOVE.B (A1),D5                  ;move the mask to D5
00001834                          1045          
00001834  0C05 0000               1046          CMPI.B #0,D5                    ;check if the mask is 0
00001838  6700 F85C               1047          BEQ falsePositive               ;branch if it is
0000183C                          1048          
0000183C  1401                    1049          MOVE.B D1,D2                    ;copy instruction to D2
0000183E  C405                    1050          AND.B D5,D2                     ;mask D2
00001840                          1051          
00001840  43F9 000018CE           1052          LEA lsrlEA,A1                   ;load the list of valid modes
00001846  D3C0                    1053          ADDA.L D0,A1                    ;displace to a specific mode
00001848  1811                    1054          MOVE.B (A1),D4                  ;move mode to D4
0000184A  B404                    1055          CMP.B D4,D2                     ;compare mode to masked value
0000184C  6700 0006               1056          BEQ  asrlweaCheckDirection      ;if its match, its a valid mode and we can procede
00001850                          1057          
00001850  5280                    1058          ADDQ.L #1,D0                    ;add one to displacement
00001852  60D6                    1059          BRA validASRL                   ;check for next mode
00001854                          1060  
00001854                          1061  asrlweaCheckDirection:
00001854                          1062          ;Figure out which direction we are going
00001854  3401                    1063          MOVE.W D1,D2                    ;copy inst to D2
00001856  E04A                    1064          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
00001858  0202 0001               1065          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
0000185C  0C02 0000               1066          CMPI.B #0,D2                    ;compare bit to zero
00001860  6700 0006               1067          BEQ ASREA                       ;if zero, right
00001864  6000 0012               1068          BRA ASLEA                       ;else, its left
00001868                          1069  
00001868                          1070  ASREA:
00001868                          1071  
00001868  43F9 00002D6D           1072          LEA     asrMessage,A1           ;move string for MOVE
0000186E  103C 000E               1073          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001872                          1074                                ;string with CR, LF
00001872  4E4F                    1075          TRAP    #15
00001874  6000 00C0               1076          BRA lsrlweaBody
00001878                          1077          
00001878                          1078  ASLEA:
00001878                          1079          
00001878  43F9 00002D69           1080          LEA     aslMessage,A1           ;move string for MOVE
0000187E  103C 000E               1081          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001882                          1082                                ;string with CR, LF
00001882  4E4F                    1083          TRAP    #15
00001884  6000 00B0               1084          BRA lsrlweaBody        
00001888                          1085          
00001888                          1086  
00001888                          1087  
00001888                          1088  ASRLREG:
00001888                          1089          
00001888                          1090  
00001888                          1091          
00001888  7000                    1092          MOVEQ.L #0, D0                  ;clear D0
0000188A                          1093          
0000188A                          1094          ;check valid size field
0000188A  3401                    1095          MOVE.W D1,D2                    ;copy inst to D2
0000188C  EC4A                    1096          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
0000188E  0202 0003               1097          ANDI.B #%00000011,D2            ;mask out rest of byte
00001892  0C02 0003               1098          CMPI.B #%11,D2                  ;compare to 3
00001896  6700 F7FE               1099          BEQ falsePositive               ;invalid size
0000189A                          1100  
0000189A                          1101          
0000189A                          1102          ;Figure out which direction we are going
0000189A  3401                    1103          MOVE.W D1,D2                    ;copy inst to D2
0000189C  E04A                    1104          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
0000189E  0202 0001               1105          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
000018A2  0C02 0000               1106          CMPI.B #0,D2                    ;compare bit to zero
000018A6  6700 0006               1107          BEQ ASRreg                      ;if zero, right
000018AA  6000 0012               1108          BRA ASLreg                      ;else, its left        
000018AE                          1109          
000018AE                          1110  ASRreg:
000018AE                          1111  
000018AE  43F9 00002D6D           1112          LEA     asrMessage,A1           ;move string for MOVE
000018B4  103C 000E               1113          MOVE.B  #14,D0                  ;set for task to display null terminated 
000018B8                          1114                                ;string with CR, LF
000018B8  4E4F                    1115          TRAP    #15
000018BA  6000 00F6               1116          BRA LSRLregBody
000018BE                          1117          
000018BE                          1118  ASLreg:
000018BE                          1119          
000018BE  43F9 00002D69           1120          LEA     aslMessage,A1           ;move string for MOVE
000018C4  103C 000E               1121          MOVE.B  #14,D0                  ;set for task to display null terminated 
000018C8                          1122                                ;string with CR, LF
000018C8  4E4F                    1123          TRAP    #15
000018CA  6000 00E6               1124          BRA LSRLregBody
000018CE                          1125  
000018CE                          1126  
000018CE                          1127  **************************************************************************************************
000018CE                          1128  *                                       Tests for OP Code LSRL     
000018CE                          1129  **************************************************************************************************
000018CE                          1130  
000018CE= 10 18 20 38 39 00       1131  lsrlEA        DC.B %010000,%011000,%100000,%111000,%111001,0
000018D4= 38 38 38 3F 3F 00       1132  lsrlEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0       
000018DA                          1133  
000018DA                          1134  LSRLWEA:
000018DA                          1135          
000018DA                          1136  
000018DA                          1137          
000018DA  7000                    1138          MOVEQ.L #0, D0                  ;clear D0
000018DC                          1139          
000018DC                          1140  validLSRL:
000018DC                          1141          
000018DC  43F8 18D4               1142          LEA lsrlEAmasks,A1              ;load the list of masks
000018E0  D3C0                    1143          ADDA.L D0,A1                    ;displace to a specific mask
000018E2  1A11                    1144          MOVE.B (A1),D5                  ;move the mask to D5
000018E4                          1145          
000018E4  0C05 0000               1146          CMPI.B #0,D5                    ;check if the mask is 0
000018E8  6700 F7AC               1147          BEQ falsePositive               ;branch if it is
000018EC                          1148          
000018EC  1401                    1149          MOVE.B D1,D2                    ;copy instruction to D2
000018EE  C405                    1150          AND.B D5,D2                     ;mask D2
000018F0                          1151          
000018F0  43F8 18CE               1152          LEA lsrlEA,A1                   ;load the list of valid modes
000018F4  D3C0                    1153          ADDA.L D0,A1                    ;displace to a specific mode
000018F6  1811                    1154          MOVE.B (A1),D4                  ;move mode to D4
000018F8  B404                    1155          CMP.B D4,D2                     ;compare mode to masked value
000018FA  6700 0006               1156          BEQ  lsrlweaCheckDirection      ;if its match, its a valid mode and we can procede
000018FE                          1157          
000018FE  5280                    1158          ADDQ.L #1,D0                    ;add one to displacement
00001900  60DA                    1159          BRA validLSRL                   ;check for next mode
00001902                          1160  
00001902                          1161  lsrlweaCheckDirection:
00001902                          1162          ;Figure out which direction we are going
00001902  3401                    1163          MOVE.W D1,D2                    ;copy inst to D2
00001904  E04A                    1164          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
00001906  0202 0001               1165          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
0000190A  0C02 0000               1166          CMPI.B #0,D2                    ;compare bit to zero
0000190E  6700 0006               1167          BEQ LSREA                       ;if zero, right
00001912  6000 0012               1168          BRA LSLEA                       ;else, its left
00001916                          1169  
00001916                          1170  LSREA:
00001916                          1171  
00001916  43F9 00002D75           1172          LEA     lsrMessage,A1           ;move string for MOVE
0000191C  103C 000E               1173          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001920                          1174                                ;string with CR, LF
00001920  4E4F                    1175          TRAP    #15
00001922  6000 0012               1176          BRA lsrlweaBody
00001926                          1177          
00001926                          1178  LSLEA:
00001926                          1179          
00001926  43F9 00002D71           1180          LEA     lslMessage,A1           ;move string for MOVE
0000192C  103C 000E               1181          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001930                          1182                                ;string with CR, LF
00001930  4E4F                    1183          TRAP    #15
00001932  6000 0002               1184          BRA lsrlweaBody        
00001936                          1185          
00001936                          1186  lsrlweaBody:
00001936                          1187          
00001936                          1188          ;print ' '
00001936  48E7 4000               1189          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000193A  123C 0020               1190          MOVE.B #' ',D1                  ;put ascii value of char in D1
0000193E  103C 0006               1191          MOVE.B #6,D0                    ;move task 6 into D0
00001942  4E4F                    1192          TRAP #15                        ;print char
00001944  4CDF 0002               1193          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001948                          1194          
00001948  3401                    1195          MOVE.W  D1,D2                   ;check mode
0000194A  C43C 003F               1196          AND.B   #%00111111,D2
0000194E  1A02                    1197          MOVE.B  D2,D5
00001950  48E7 4000               1198          MOVEM.L D1,-(SP)
00001954  6100 0EDE               1199          BSR     Get_Effective_Address
00001958  4CDF 0002               1200          MOVEM.L (SP)+,D1
0000195C                          1201          
0000195C                          1202          
0000195C  43F9 00002D3E           1203          LEA     clearLine,A1            ;move string for a CR and LF
00001962  103C 000E               1204          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001966                          1205                                ;string without CR, LF
00001966  4E4F                    1206          TRAP    #15
00001968                          1207  
00001968  7000                    1208          MOVEQ.L #0,D0
0000196A  4E75                    1209          RTS
0000196C                          1210  
0000196C                          1211  
0000196C                          1212  LSRLREG:
0000196C                          1213          
0000196C                          1214  
0000196C                          1215          
0000196C  7000                    1216          MOVEQ.L #0, D0                  ;clear D0
0000196E                          1217          
0000196E                          1218          ;check valid size field
0000196E  3401                    1219          MOVE.W D1,D2                    ;copy inst to D2
00001970  EC4A                    1220          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
00001972  0202 0003               1221          ANDI.B #%00000011,D2            ;mask out rest of byte
00001976  0C02 0003               1222          CMPI.B #%11,D2                  ;compare to 3
0000197A  6700 F71A               1223          BEQ falsePositive               ;invalid size
0000197E                          1224  
0000197E                          1225          
0000197E                          1226          ;Figure out which direction we are going
0000197E  3401                    1227          MOVE.W D1,D2                    ;copy inst to D2
00001980  E04A                    1228          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
00001982  0202 0001               1229          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
00001986  0C02 0000               1230          CMPI.B #0,D2                    ;compare bit to zero
0000198A  6700 0006               1231          BEQ LSRreg                      ;if zero, right
0000198E  6000 0012               1232          BRA LSLreg                      ;else, its left        
00001992                          1233          
00001992                          1234  LSRreg:
00001992                          1235  
00001992  43F9 00002D75           1236          LEA     lsrMessage,A1           ;move string for MOVE
00001998  103C 000E               1237          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000199C                          1238                                ;string with CR, LF
0000199C  4E4F                    1239          TRAP    #15
0000199E  6000 0012               1240          BRA LSRLregBody
000019A2                          1241          
000019A2                          1242  LSLreg:
000019A2                          1243          
000019A2  43F9 00002D71           1244          LEA     lslMessage,A1           ;move string for MOVE
000019A8  103C 000E               1245          MOVE.B  #14,D0                  ;set for task to display null terminated 
000019AC                          1246                                ;string with CR, LF
000019AC  4E4F                    1247          TRAP    #15
000019AE  6000 0002               1248          BRA LSRLregBody
000019B2                          1249          
000019B2                          1250  LSRLregBody:
000019B2                          1251          
000019B2  6100 07B8               1252          BSR negSize        
000019B6                          1253              
000019B6                          1254          ;check i/r
000019B6  48E7 4000               1255          MOVEM.L D1,-(SP)
000019BA  6100 003C               1256          BSR LSRLcheckIR
000019BE  4CDF 0002               1257          MOVEM.L (SP)+,D1
000019C2                          1258          
000019C2                          1259          ;print ','
000019C2  48E7 4000               1260          MOVEM.L D1,-(SP)                ;save D1 to the stack
000019C6  123C 002C               1261          MOVE.B #',',D1                  ;put ascii value of char in D1
000019CA  103C 0006               1262          MOVE.B #6,D0                    ;move task 6 into D0
000019CE  4E4F                    1263          TRAP #15                        ;prin char
000019D0  4CDF 0002               1264          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000019D4                          1265          
000019D4  3401                    1266          MOVE.W  D1,D2                   ;check mode
000019D6  C43C 0007               1267          AND.B   #%00000111,D2
000019DA  1A02                    1268          MOVE.B  D2,D5
000019DC  48E7 4000               1269          MOVEM.L D1,-(SP)
000019E0  6100 0E52               1270          BSR     Get_Effective_Address
000019E4  4CDF 0002               1271          MOVEM.L (SP)+,D1
000019E8                          1272          
000019E8                          1273          
000019E8  43F9 00002D3E           1274          LEA     clearLine,A1            ;move string for a CR and LF
000019EE  103C 000E               1275          MOVE.B  #14,D0                  ;set for task to display null terminated 
000019F2                          1276                                ;string without CR, LF
000019F2  4E4F                    1277          TRAP    #15
000019F4                          1278  
000019F4  7000                    1279          MOVEQ.L #0,D0
000019F6  4E75                    1280          RTS
000019F8                          1281  
000019F8                          1282  LSRLcheckIR:
000019F8                          1283  
000019F8  1401                    1284          MOVE.B D1,D2                    ;move inst to D2
000019FA  EA0A                    1285          LSR.B  #5,D2
000019FC  C43C 0001               1286          AND.B  #%00000001,D2
00001A00  0C02 0000               1287          CMPI.B #0,D2
00001A04  6700 0008               1288          BEQ  LSRLcheckI
00001A08  6000 0038               1289          BRA  LSRLcheckR
00001A0C                          1290  LSRLcheckIRreturn:
00001A0C  4E75                    1291          RTS
00001A0E                          1292          
00001A0E                          1293  LSRLcheckI:
00001A0E                          1294          ;print '#'
00001A0E  48E7 4000               1295          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001A12  123C 0023               1296          MOVE.B #'#',D1                  ;put ascii value of '#' in D1
00001A16  103C 0006               1297          MOVE.B #6,D0                    ;move task 6 into D0
00001A1A  4E4F                    1298          TRAP #15                        ;prin char
00001A1C  4CDF 0002               1299          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001A20                          1300          
00001A20                          1301          
00001A20                          1302          ;print number
00001A20  48E7 4000               1303          MOVEM.L D1,-(SP)
00001A24  3401                    1304          MOVE.W D1,D2                    ;copy inst to d2
00001A26  E04A                    1305          LSR.W #8,D2                     ;shift data section
00001A28  E20A                    1306          LSR.B #1,D2
00001A2A  C43C 0007               1307          AND.B #%00000111,D2             ;mask out rest of data
00001A2E  6100 00EC               1308          BSR ZeroToEight                 ;handle zero
00001A32  7200                    1309          MOVEQ.L #0,D1                   ;clear D1
00001A34  1202                    1310          MOVE.B D2,D1                    ;move number to display into D1
00001A36  103C 0003               1311          MOVE.B #3,D0                    ;move task 3 to D0
00001A3A  4E4F                    1312          TRAP #15
00001A3C  4CDF 0002               1313          MOVEM.L (SP)+,D1
00001A40  60CA                    1314          BRA LSRLcheckIRreturn
00001A42                          1315          
00001A42                          1316  LSRLcheckR:
00001A42  3401                    1317          MOVE.W D1,D2                    ;copy inst to d2
00001A44  E04A                    1318          LSR.W #8,D2                     ;shift data section
00001A46  E20A                    1319          LSR.B #1,D2
00001A48  C43C 0007               1320          AND.B #%00000111,D2             ;mask out rest of data
00001A4C  1A02                    1321          MOVE.B D2,D5                    ;force Dn
00001A4E  48E7 4000               1322          MOVEM.L D1,-(SP)
00001A52  6100 0DE0               1323          BSR     Get_Effective_Address
00001A56  4CDF 0002               1324          MOVEM.L (SP)+,D1
00001A5A  60B0                    1325          BRA LSRLcheckIRreturn
00001A5C                          1326  
00001A5C                          1327  
00001A5C                          1328  **************************************************************************************************
00001A5C                          1329  *                                       Tests for OP Code SUBQ     
00001A5C                          1330  **************************************************************************************************
00001A5C                          1331          
00001A5C= 00 08 10 18 20 38 ...   1332  subqEA        DC.B %000000,%001000,%010000,%011000,%100000,%111000,%111001,0
00001A64= 38 38 38 38 38 3F ...   1333  subqEAmasks   DC.B %111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001A6C                          1334  
00001A6C                          1335  SUBQ:
00001A6C                          1336          
00001A6C                          1337  
00001A6C                          1338          
00001A6C  7000                    1339          MOVEQ.L #0, D0                  ;clear D0
00001A6E                          1340          
00001A6E                          1341          ;check valid size field
00001A6E  3401                    1342          MOVE.W D1,D2                    ;copy inst to D2
00001A70  EC4A                    1343          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
00001A72  0202 0003               1344          ANDI.B #%00000011,D2            ;mask out rest of byte
00001A76  0C02 0003               1345          CMPI.B #%11,D2                  ;compare to 3
00001A7A  6700 F61A               1346          BEQ falsePositive               ;invalid size
00001A7E                          1347          
00001A7E                          1348  validSubq:
00001A7E                          1349          
00001A7E  43F8 1A64               1350          LEA subqEAmasks,A1              ;load the list of masks
00001A82  D3C0                    1351          ADDA.L D0,A1                    ;displace to a specific mask
00001A84  1A11                    1352          MOVE.B (A1),D5                  ;move the mask to D5
00001A86                          1353          
00001A86  0C05 0000               1354          CMPI.B #0,D5                    ;check if the mask is 0
00001A8A  6700 F60A               1355          BEQ falsePositive               ;branch if it is
00001A8E                          1356          
00001A8E  1401                    1357          MOVE.B D1,D2                    ;copy instruction to D2
00001A90  C405                    1358          AND.B D5,D2                     ;mask D2
00001A92                          1359          
00001A92  43F8 1A5C               1360          LEA subqEA,A1                   ;load the list of valid modes
00001A96  D3C0                    1361          ADDA.L D0,A1                    ;displace to a specific mode
00001A98  1811                    1362          MOVE.B (A1),D4                  ;move mode to D4
00001A9A  B404                    1363          CMP.B D4,D2                     ;compare mode to masked value
00001A9C  6700 0006               1364          BEQ  subqBody                   ;if its match, its a valid mode and we can procede
00001AA0                          1365          
00001AA0  5280                    1366          ADDQ.L #1,D0                    ;add one to displacement
00001AA2  60DA                    1367          BRA validSubq                   ;check for next mode
00001AA4                          1368          
00001AA4                          1369          
00001AA4                          1370  subqBody
00001AA4                          1371  
00001AA4  43F9 00002D79           1372          LEA     subqMessage,A1          ;move string for MOVE
00001AAA  103C 000E               1373          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001AAE                          1374                                ;string with CR, LF
00001AAE  4E4F                    1375          TRAP    #15
00001AB0                          1376          
00001AB0  6100 06BA               1377          BSR negSize
00001AB4                          1378          
00001AB4                          1379          ;immediate data
00001AB4                          1380          
00001AB4                          1381          ;print '#'
00001AB4  48E7 4000               1382          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001AB8  123C 0023               1383          MOVE.B #'#',D1                  ;put ascii value of '#' in D1
00001ABC  103C 0006               1384          MOVE.B #6,D0                    ;move task 6 into D0
00001AC0  4E4F                    1385          TRAP #15                        ;prin char
00001AC2  4CDF 0002               1386          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001AC6                          1387          
00001AC6                          1388          ;print number
00001AC6  48E7 4000               1389          MOVEM.L D1,-(SP)
00001ACA  3401                    1390          MOVE.W D1,D2                    ;copy inst to d2
00001ACC  E04A                    1391          LSR.W #8,D2                     ;shift data section
00001ACE  E20A                    1392          LSR.B #1,D2
00001AD0  C43C 0007               1393          AND.B #%00000111,D2             ;mask out rest of data
00001AD4  6100 0046               1394          BSR ZeroToEight                 ;handle zero
00001AD8  7200                    1395          MOVEQ.L #0,D1                   ;clear D1
00001ADA  1202                    1396          MOVE.B D2,D1                    ;move number to display into D1
00001ADC  103C 0003               1397          MOVE.B #3,D0                    ;move task 3 to D0
00001AE0  4E4F                    1398          TRAP #15
00001AE2  4CDF 0002               1399          MOVEM.L (SP)+,D1
00001AE6                          1400          
00001AE6                          1401          ;print ','
00001AE6  48E7 4000               1402          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001AEA  123C 002C               1403          MOVE.B #',',D1                  ;put ascii value of char in D1
00001AEE  103C 0006               1404          MOVE.B #6,D0                    ;move task 6 into D0
00001AF2  4E4F                    1405          TRAP #15                        ;prin char
00001AF4  4CDF 0002               1406          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001AF8                          1407          
00001AF8                          1408          ;Then do EA
00001AF8                          1409          
00001AF8  3401                    1410          MOVE.W  D1,D2                   ;check mode
00001AFA  C43C 003F               1411          AND.B   #%00111111,D2
00001AFE  1A02                    1412          MOVE.B  D2,D5
00001B00  48E7 4000               1413          MOVEM.L D1,-(SP)
00001B04  6100 0D2E               1414          BSR     Get_Effective_Address
00001B08  4CDF 0002               1415          MOVEM.L (SP)+,D1
00001B0C                          1416          
00001B0C  43F9 00002D3E           1417          LEA     clearLine,A1            ;move string for a CR and LF
00001B12  103C 000E               1418          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001B16                          1419                                ;string without CR, LF
00001B16  4E4F                    1420          TRAP    #15
00001B18                          1421  
00001B18  7000                    1422          MOVEQ.L #0,D0
00001B1A  4E75                    1423          RTS
00001B1C                          1424          
00001B1C                          1425  ZeroToEight:
00001B1C                          1426          
00001B1C  0C02 0000               1427          CMPI.B #0,D2
00001B20  6700 0004               1428          BEQ toEight
00001B24                          1429  ZeroToEightReturn:
00001B24                          1430          
00001B24  4E75                    1431          RTS
00001B26                          1432  toEight:
00001B26                          1433          
00001B26  5002                    1434          ADDQ.B #8,D2
00001B28  60FA                    1435          BRA ZeroToEightReturn
00001B2A                          1436  
00001B2A                          1437      
00001B2A                          1438  SUB:
00001B2A                          1439          
00001B2A                          1440  
00001B2A                          1441          
00001B2A  7000                    1442          MOVEQ.L #0, D0                  ;clear D0
00001B2C                          1443          
00001B2C                          1444          ;Figure out if EA is source or destination
00001B2C  3401                    1445          MOVE.W D1,D2                    ;copy inst to D2
00001B2E  EC4A                    1446          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001B30  0202 0007               1447          ANDI.B #%00000111,D2            ;mask out rest of byte
00001B34  0C02 0002               1448          CMPI.B #2,D2                    ;compare to 2
00001B38  6F00 0016               1449          BLE validSubSourceEA            ;2 or less is EA is source
00001B3C                          1450          
00001B3C  0C02 0007               1451          CMPI.B #%111,D2                 ;compare to 7
00001B40  6700 F554               1452          BEQ falsePositive               ;thats not valid
00001B44  0C02 0003               1453          CMPI.B #%11,D2                  ;compare to 3
00001B48  6700 F54C               1454          BEQ falsePositive               ;also not valid
00001B4C  6000 002C               1455          BRA validSubDestEA              ;all thats left is valid EA as Dest 
00001B50                          1456          
00001B50                          1457  validSubSourceEA:
00001B50                          1458          
00001B50  43F9 000023C3           1459          LEA moveSourceEAmasks,A1        ;load the list of masks
00001B56  D3C0                    1460          ADDA.L D0,A1                    ;displace to a specific mask
00001B58  1A11                    1461          MOVE.B (A1),D5                  ;move the mask to D5
00001B5A                          1462          
00001B5A  0C05 0000               1463          CMPI.B #0,D5                    ;check if the mask is 0
00001B5E  6700 F536               1464          BEQ falsePositive               ;branch if it is
00001B62                          1465          
00001B62  1401                    1466          MOVE.B D1,D2                    ;copy instruction to D2
00001B64  C405                    1467          AND.B D5,D2                     ;mask D2
00001B66                          1468          
00001B66  43F9 000023BA           1469          LEA moveSourceEA,A1             ;load the list of valid modes
00001B6C  D3C0                    1470          ADDA.L D0,A1                    ;displace to a specific mode
00001B6E  1811                    1471          MOVE.B (A1),D4                  ;move mode to D4
00001B70  B404                    1472          CMP.B D4,D2                     ;compare mode to masked value
00001B72  6700 0030               1473          BEQ  subSource                  ;if its match, its a valid mode and we can procede
00001B76                          1474          
00001B76  5280                    1475          ADDQ.L #1,D0                    ;add one to displacement
00001B78  60D6                    1476          BRA validSubSourceEA            ;check for next mode
00001B7A                          1477          
00001B7A                          1478          
00001B7A                          1479  validSubDestEA:
00001B7A                          1480          
00001B7A  43F9 00001D20           1481          LEA addDestEAmasks,A1           ;load the list of masks
00001B80  D3C0                    1482          ADDA.L D0,A1                    ;displace to a specific mask
00001B82  1A11                    1483          MOVE.B (A1),D5                  ;move the mask to D5
00001B84                          1484          
00001B84  0C05 0000               1485          CMPI.B #0,D5                    ;check if the mask is 0
00001B88  6700 F50C               1486          BEQ falsePositive               ;branch if it is
00001B8C                          1487          
00001B8C  3401                    1488          MOVE.W D1,D2                    ;copy instruction to D2
00001B8E  C405                    1489          AND.B D5,D2                     ;mask D2
00001B90                          1490          
00001B90  43F9 00001D1A           1491          LEA addDestEA,A1                ;load the list of valid modes
00001B96  D3C0                    1492          ADDA.L D0,A1                    ;displace to a specific mode
00001B98  1811                    1493          MOVE.B (A1),D4                  ;move mode to D4
00001B9A  B404                    1494          CMP.B D4,D2                     ;compare mode to masked value
00001B9C  6700 0064               1495          BEQ subDest                     ;if its match, its a valid mode and we can procede
00001BA0                          1496          
00001BA0  5280                    1497          ADDQ.L #1,D0                    ;add one to displacement
00001BA2  60D6                    1498          BRA validSubDestEA              ;check for next mode
00001BA4                          1499          
00001BA4                          1500  subSource
00001BA4                          1501  
00001BA4  43F9 00002D7E           1502          LEA     subMessage,A1           ;move string for MOVE
00001BAA  103C 000E               1503          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001BAE                          1504                                ;string with CR, LF
00001BAE  4E4F                    1505          TRAP    #15
00001BB0                          1506          
00001BB0  6100 05BA               1507          BSR negSize
00001BB4                          1508          
00001BB4                          1509          ;do EA
00001BB4                          1510          
00001BB4  3401                    1511          MOVE.W  D1,D2                   ;check mode
00001BB6  C43C 003F               1512          AND.B   #%00111111,D2
00001BBA  1A02                    1513          MOVE.B  D2,D5
00001BBC  48E7 4000               1514          MOVEM.L D1,-(SP)
00001BC0  6100 0C72               1515          BSR     Get_Effective_Address
00001BC4  4CDF 0002               1516          MOVEM.L (SP)+,D1
00001BC8                          1517          
00001BC8                          1518          ;print ','
00001BC8  48E7 4000               1519          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001BCC  123C 002C               1520          MOVE.B #',',D1                  ;put ascii value of char in D1
00001BD0  103C 0006               1521          MOVE.B #6,D0                    ;move task 6 into D0
00001BD4  4E4F                    1522          TRAP #15                        ;prin char
00001BD6  4CDF 0002               1523          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001BDA                          1524          
00001BDA                          1525          ;Then do Dn
00001BDA                          1526          
00001BDA  3401                    1527          MOVE.W  D1,D2
00001BDC  E04A                    1528          LSR.W   #8,D2                   ;move reg into first byte
00001BDE  E20A                    1529          LSR.B   #1,D2                   ;line it up to least sig bit
00001BE0  C43C 0007               1530          AND.B   #%00000111,D2           ;force mode to Dn
00001BE4  1A02                    1531          MOVE.B  D2,D5
00001BE6  48E7 4000               1532          MOVEM.L D1,-(SP)
00001BEA  6100 0C48               1533          BSR     Get_Effective_Address
00001BEE  4CDF 0002               1534          MOVEM.L (SP)+,D1
00001BF2                          1535          
00001BF2  43F9 00002D3E           1536          LEA     clearLine,A1            ;move string for a CR and LF
00001BF8  103C 000E               1537          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001BFC                          1538          ;string without CR, LF
00001BFC  4E4F                    1539          TRAP    #15
00001BFE                          1540  
00001BFE  7000                    1541          MOVEQ.L #0,D0
00001C00  4E75                    1542          RTS
00001C02                          1543  
00001C02                          1544  subDest
00001C02                          1545  
00001C02  43F9 00002D7E           1546          LEA     subMessage,A1           ;move string for MOVE
00001C08  103C 000E               1547          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001C0C                          1548                                          ;string with CR, LF
00001C0C  4E4F                    1549          TRAP    #15
00001C0E                          1550          
00001C0E  6100 055C               1551          BSR negSize
00001C12                          1552          
00001C12                          1553          ;Do Dn
00001C12                          1554          
00001C12  3401                    1555          MOVE.W  D1,D2
00001C14  E04A                    1556          LSR.W   #8,D2                   ;move reg into first byte
00001C16  E20A                    1557          LSR.B   #1,D2                   ;line it up to least sig bit
00001C18  C43C 0007               1558          AND.B   #%00000111,D2           ;force mode to Dn
00001C1C  1A02                    1559          MOVE.B  D2,D5
00001C1E  48E7 4000               1560          MOVEM.L D1,-(SP)
00001C22  6100 0C10               1561          BSR     Get_Effective_Address
00001C26  4CDF 0002               1562          MOVEM.L (SP)+,D1
00001C2A                          1563          
00001C2A                          1564          
00001C2A                          1565          ;print ','
00001C2A  48E7 4000               1566          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001C2E  123C 002C               1567          MOVE.B #',',D1                  ;put ascii value of char in D1
00001C32  103C 0006               1568          MOVE.B #6,D0                    ;move task 6 into D0
00001C36  4E4F                    1569          TRAP #15                        ;prin char
00001C38  4CDF 0002               1570          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001C3C                          1571          
00001C3C                          1572          ;Then do EA
00001C3C                          1573          
00001C3C  3401                    1574          MOVE.W  D1,D2                   ;check mode
00001C3E  C43C 003F               1575          AND.B   #%00111111,D2
00001C42  1A02                    1576          MOVE.B  D2,D5
00001C44  48E7 4000               1577          MOVEM.L D1,-(SP)
00001C48  6100 0BEA               1578          BSR     Get_Effective_Address
00001C4C  4CDF 0002               1579          MOVEM.L (SP)+,D1
00001C50                          1580          
00001C50                          1581          
00001C50  43F9 00002D3E           1582          LEA     clearLine,A1            ;move string for a CR and LF
00001C56  103C 000E               1583          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001C5A                          1584          ;string without CR, LF
00001C5A  4E4F                    1585          TRAP    #15
00001C5C                          1586  
00001C5C  7000                    1587          MOVEQ.L #0,D0
00001C5E  4E75                    1588          RTS
00001C60                          1589  
00001C60                          1590  
00001C60                          1591  ADDA:
00001C60                          1592          
00001C60                          1593  
00001C60                          1594          
00001C60  7000                    1595          MOVEQ.L #0, D0                  ;clear D0
00001C62                          1596          
00001C62                          1597          ;check opmode field
00001C62  3401                    1598          MOVE.W D1,D2                    ;copy inst to D2
00001C64  EC4A                    1599          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001C66  0202 0007               1600          ANDI.B #%00000111,D2            ;mask out rest of byte
00001C6A  0C02 0007               1601          CMPI.B #%111,D2                 ;compare to 7
00001C6E  6700 000E               1602          BEQ validAdda                   ;thats valid
00001C72  0C02 0003               1603          CMPI.B #%11,D2                  ;compare to 3
00001C76  6700 0006               1604          BEQ validAdda                   ;also valid
00001C7A  6000 F41A               1605          BRA falsePositive               ;all thats left is invalid 
00001C7E                          1606          
00001C7E                          1607  validAdda:
00001C7E                          1608          
00001C7E  43F9 000023C3           1609          LEA moveSourceEAmasks,A1        ;load the list of masks
00001C84  D3C0                    1610          ADDA.L D0,A1                    ;displace to a specific mask
00001C86  1A11                    1611          MOVE.B (A1),D5                  ;move the mask to D5
00001C88                          1612          
00001C88  0C05 0000               1613          CMPI.B #0,D5                    ;check if the mask is 0
00001C8C  6700 F408               1614          BEQ falsePositive               ;branch if it is
00001C90                          1615          
00001C90  1401                    1616          MOVE.B D1,D2                    ;copy instruction to D2
00001C92  C405                    1617          AND.B D5,D2                     ;mask D2
00001C94                          1618          
00001C94  43F9 000023BA           1619          LEA moveSourceEA,A1             ;load the list of valid modes
00001C9A  D3C0                    1620          ADDA.L D0,A1                    ;displace to a specific mode
00001C9C  1811                    1621          MOVE.B (A1),D4                  ;move mode to D4
00001C9E  B404                    1622          CMP.B D4,D2                     ;compare mode to masked value
00001CA0  6700 0006               1623          BEQ  addaBody                   ;if its match, its a valid mode and we can procede
00001CA4                          1624          
00001CA4  5280                    1625          ADDQ.L #1,D0                    ;add one to displacement
00001CA6  60D6                    1626          BRA validAdda                   ;check for next mode
00001CA8                          1627          
00001CA8                          1628          
00001CA8                          1629  addaBody
00001CA8                          1630  
00001CA8  43F9 00002D82           1631          LEA     addaMessage,A1          ;move string for MOVE
00001CAE  103C 000E               1632          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001CB2                          1633          ;string with CR, LF
00001CB2  4E4F                    1634          TRAP    #15
00001CB4                          1635          
00001CB4                          1636          ;size
00001CB4  48E7 4000               1637          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001CB8                          1638          ;make it look like NEG's size
00001CB8  E449                    1639          LSR.W #2,D1                     ;shift opmode bits over to use them as size
00001CBA  C23C 007F               1640          AND.B #%01111111,D1             ;clear bit next to size
00001CBE  0641 0040               1641          ADDI.W #%01000000,D1            ;add 1 to size to make it look like a word or long
00001CC2  6100 04A8               1642          BSR negSize
00001CC6  4CDF 0002               1643          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001CCA                          1644          
00001CCA                          1645          ;do EA
00001CCA                          1646          
00001CCA  3401                    1647          MOVE.W  D1,D2                   ;check mode
00001CCC  C43C 003F               1648          AND.B   #%00111111,D2
00001CD0  1A02                    1649          MOVE.B  D2,D5
00001CD2  48E7 4000               1650          MOVEM.L D1,-(SP)
00001CD6  6100 0B5C               1651          BSR     Get_Effective_Address
00001CDA  4CDF 0002               1652          MOVEM.L (SP)+,D1
00001CDE                          1653          
00001CDE                          1654          ;print ','
00001CDE  48E7 4000               1655          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001CE2  123C 002C               1656          MOVE.B #',',D1                  ;put ascii value of char in D1
00001CE6  103C 0006               1657          MOVE.B #6,D0                    ;move task 6 into D0
00001CEA  4E4F                    1658          TRAP #15                        ;prin char
00001CEC  4CDF 0002               1659          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001CF0                          1660          
00001CF0                          1661          ;Then do Dn
00001CF0                          1662          
00001CF0  3401                    1663          MOVE.W  D1,D2
00001CF2  E04A                    1664          LSR.W   #8,D2                   ;move reg into first byte
00001CF4  E20A                    1665          LSR.B   #1,D2                   ;line it up to least sig bit
00001CF6  C43C 0007               1666          AND.B   #%00000111,D2           ;force mode to An
00001CFA  5002                    1667          ADDI.B  #%00001000,D2 
00001CFC  1A02                    1668          MOVE.B  D2,D5
00001CFE  48E7 4000               1669          MOVEM.L D1,-(SP)
00001D02  6100 0B30               1670          BSR     Get_Effective_Address
00001D06  4CDF 0002               1671          MOVEM.L (SP)+,D1
00001D0A                          1672          
00001D0A  43F9 00002D3E           1673          LEA     clearLine,A1            ;move string for a CR and LF
00001D10  103C 000E               1674          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001D14                          1675          ;string without CR, LF
00001D14  4E4F                    1676          TRAP    #15
00001D16                          1677  
00001D16  7000                    1678          MOVEQ.L #0,D0
00001D18  4E75                    1679          RTS
00001D1A                          1680  
00001D1A                          1681  
00001D1A                          1682      
00001D1A= 10 18 20 38 39 00       1683  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
00001D20= 38 38 38 3F 3F 00       1684  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
00001D26                          1685  
00001D26                          1686  ADD:
00001D26                          1687          
00001D26                          1688  
00001D26                          1689          
00001D26  7000                    1690          MOVEQ.L #0, D0                  ;clear D0
00001D28                          1691          
00001D28                          1692          ;Figure out if EA is source or destination
00001D28  3401                    1693          MOVE.W D1,D2                    ;copy inst to D2
00001D2A  EC4A                    1694          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001D2C  0202 0007               1695          ANDI.B #%00000111,D2            ;mask out rest of byte
00001D30  0C02 0002               1696          CMPI.B #2,D2                    ;compare to 2
00001D34  6F00 0016               1697          BLE validAddSourceEA            ;2 or less is EA is source
00001D38                          1698          
00001D38  0C02 0007               1699          CMPI.B #%111,D2                 ;compare to 7
00001D3C  6700 F358               1700          BEQ falsePositive               ;thats not valid
00001D40  0C02 0003               1701          CMPI.B #%11,D2                  ;compare to 3
00001D44  6700 F350               1702          BEQ falsePositive               ;also not valid
00001D48  6000 002C               1703          BRA validAddDestEA              ;all thats left is valid EA as Dest 
00001D4C                          1704          
00001D4C                          1705  validAddSourceEA:
00001D4C                          1706          
00001D4C  43F9 000023C3           1707          LEA moveSourceEAmasks,A1        ;load the list of masks
00001D52  D3C0                    1708          ADDA.L D0,A1                    ;displace to a specific mask
00001D54  1A11                    1709          MOVE.B (A1),D5                  ;move the mask to D5
00001D56                          1710          
00001D56  0C05 0000               1711          CMPI.B #0,D5                    ;check if the mask is 0
00001D5A  6700 F33A               1712          BEQ falsePositive               ;branch if it is
00001D5E                          1713          
00001D5E  1401                    1714          MOVE.B D1,D2                    ;copy instruction to D2
00001D60  C405                    1715          AND.B D5,D2                     ;mask D2
00001D62                          1716          
00001D62  43F9 000023BA           1717          LEA moveSourceEA,A1             ;load the list of valid modes
00001D68  D3C0                    1718          ADDA.L D0,A1                    ;displace to a specific mode
00001D6A  1811                    1719          MOVE.B (A1),D4                  ;move mode to D4
00001D6C  B404                    1720          CMP.B D4,D2                     ;compare mode to masked value
00001D6E  6700 002C               1721          BEQ  addSource                  ;if its match, its a valid mode and we can procede
00001D72                          1722          
00001D72  5280                    1723          ADDQ.L #1,D0                    ;add one to displacement
00001D74  60D6                    1724          BRA validAddSourceEA            ;check for next mode
00001D76                          1725          
00001D76                          1726          
00001D76                          1727  validAddDestEA:
00001D76                          1728          
00001D76  43F8 1D20               1729          LEA addDestEAmasks,A1           ;load the list of masks
00001D7A  D3C0                    1730          ADDA.L D0,A1                    ;displace to a specific mask
00001D7C  1A11                    1731          MOVE.B (A1),D5                  ;move the mask to D5
00001D7E                          1732          
00001D7E  0C05 0000               1733          CMPI.B #0,D5                    ;check if the mask is 0
00001D82  6700 F312               1734          BEQ falsePositive               ;branch if it is
00001D86                          1735          
00001D86  3401                    1736          MOVE.W D1,D2                    ;copy instruction to D2
00001D88  C405                    1737          AND.B D5,D2                     ;mask D2
00001D8A                          1738          
00001D8A  43F8 1D1A               1739          LEA addDestEA,A1                ;load the list of valid modes
00001D8E  D3C0                    1740          ADDA.L D0,A1                    ;displace to a specific mode
00001D90  1811                    1741          MOVE.B (A1),D4                  ;move mode to D4
00001D92  B404                    1742          CMP.B D4,D2                     ;compare mode to masked value
00001D94  6700 0064               1743          BEQ addDest                     ;if its match, its a valid mode and we can procede
00001D98                          1744          
00001D98  5280                    1745          ADDQ.L #1,D0                    ;add one to displacement
00001D9A  60DA                    1746          BRA validAddDestEA              ;check for next mode
00001D9C                          1747          
00001D9C                          1748  addSource
00001D9C                          1749  
00001D9C  43F9 00002D87           1750          LEA     addMessage,A1           ;move string for MOVE
00001DA2  103C 000E               1751          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001DA6                          1752          ;string with CR, LF
00001DA6  4E4F                    1753          TRAP    #15
00001DA8                          1754          
00001DA8  6100 03C2               1755          BSR negSize
00001DAC                          1756          
00001DAC                          1757          ;do EA
00001DAC                          1758          
00001DAC  3401                    1759          MOVE.W  D1,D2                   ;check mode
00001DAE  C43C 003F               1760          AND.B   #%00111111,D2
00001DB2  1A02                    1761          MOVE.B  D2,D5
00001DB4  48E7 4000               1762          MOVEM.L D1,-(SP)
00001DB8  6100 0A7A               1763          BSR     Get_Effective_Address
00001DBC  4CDF 0002               1764          MOVEM.L (SP)+,D1
00001DC0                          1765          
00001DC0                          1766          ;print ','
00001DC0  48E7 4000               1767          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001DC4  123C 002C               1768          MOVE.B #',',D1                  ;put ascii value of char in D1
00001DC8  103C 0006               1769          MOVE.B #6,D0                    ;move task 6 into D0
00001DCC  4E4F                    1770          TRAP #15                        ;prin char
00001DCE  4CDF 0002               1771          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001DD2                          1772          
00001DD2                          1773          ;Then do Dn
00001DD2                          1774          
00001DD2  3401                    1775          MOVE.W  D1,D2
00001DD4  E04A                    1776          LSR.W   #8,D2                   ;move reg into first byte
00001DD6  E20A                    1777          LSR.B   #1,D2                   ;line it up to least sig bit
00001DD8  C43C 0007               1778          AND.B   #%00000111,D2           ;force mode to Dn
00001DDC  1A02                    1779          MOVE.B  D2,D5
00001DDE  48E7 4000               1780          MOVEM.L D1,-(SP)
00001DE2  6100 0A50               1781          BSR     Get_Effective_Address
00001DE6  4CDF 0002               1782          MOVEM.L (SP)+,D1
00001DEA                          1783          
00001DEA  43F9 00002D3E           1784          LEA     clearLine,A1            ;move string for a CR and LF
00001DF0  103C 000E               1785          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001DF4                          1786                                ;string without CR, LF
00001DF4  4E4F                    1787          TRAP    #15
00001DF6                          1788  
00001DF6  7000                    1789          MOVEQ.L #0,D0
00001DF8  4E75                    1790          RTS
00001DFA                          1791  
00001DFA                          1792  addDest
00001DFA                          1793  
00001DFA  43F9 00002D87           1794          LEA     addMessage,A1           ;move string for MOVE
00001E00  103C 000E               1795          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001E04                          1796                                          ;string with CR, LF
00001E04  4E4F                    1797          TRAP    #15
00001E06                          1798          
00001E06  6100 0364               1799          BSR negSize
00001E0A                          1800          
00001E0A                          1801          ;Do Dn
00001E0A                          1802          
00001E0A  3401                    1803          MOVE.W  D1,D2
00001E0C  E04A                    1804          LSR.W   #8,D2                   ;move reg into first byte
00001E0E  E20A                    1805          LSR.B   #1,D2                   ;line it up to least sig bit
00001E10  C43C 0007               1806          AND.B   #%00000111,D2           ;force mode to Dn
00001E14  1A02                    1807          MOVE.B  D2,D5
00001E16  48E7 4000               1808          MOVEM.L D1,-(SP)
00001E1A  6100 0A18               1809          BSR     Get_Effective_Address
00001E1E  4CDF 0002               1810          MOVEM.L (SP)+,D1
00001E22                          1811          
00001E22                          1812          
00001E22                          1813          ;print ','
00001E22  48E7 4000               1814          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001E26  123C 002C               1815          MOVE.B #',',D1                  ;put ascii value of char in D1
00001E2A  103C 0006               1816          MOVE.B #6,D0                    ;move task 6 into D0
00001E2E  4E4F                    1817          TRAP #15                        ;prin char
00001E30  4CDF 0002               1818          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001E34                          1819          
00001E34                          1820          ;Then do EA
00001E34                          1821          
00001E34  3401                    1822          MOVE.W  D1,D2                   ;check mode
00001E36  C43C 003F               1823          AND.B   #%00111111,D2
00001E3A  1A02                    1824          MOVE.B  D2,D5
00001E3C  48E7 4000               1825          MOVEM.L D1,-(SP)
00001E40  6100 09F2               1826          BSR     Get_Effective_Address
00001E44  4CDF 0002               1827          MOVEM.L (SP)+,D1
00001E48                          1828          
00001E48                          1829          
00001E48  43F9 00002D3E           1830          LEA     clearLine,A1            ;move string for a CR and LF
00001E4E  103C 000E               1831          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001E52                          1832                                          ;string without CR, LF
00001E52  4E4F                    1833          TRAP    #15
00001E54                          1834  
00001E54  7000                    1835          MOVEQ.L #0,D0
00001E56  4E75                    1836          RTS
00001E58                          1837  
00001E58                          1838  
00001E58= 10 20 38 39 00          1839  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
00001E5D= 38 38 3F 3F 00          1840  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
00001E62                          1841  
00001E62= 10 18 38 39 00          1842  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
00001E67= 38 38 3F 3F 00          1843  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
00001E6C                          1844  
00001E6C                          1845  MOVEM:
00001E6C                          1846          
00001E6C                          1847  
00001E6C                          1848          
00001E6C  7000                    1849          MOVEQ.L #0, D0                  ;clear D0
00001E6E                          1850          
00001E6E                          1851          ;Figure out which direction we are going
00001E6E  3401                    1852          MOVE.W D1,D2                    ;copy inst to D2
00001E70  E64A                    1853          LSR.W #3,D2                     ;shift direction bit into most sig bit of first byte
00001E72  0202 0080               1854          ANDI.B #%10000000,D2            ;mask out everything but direction bit in first byte
00001E76  0C02 0000               1855          CMPI.B #0,D2                    ;compare bit to zero
00001E7A  6700 0006               1856          BEQ validRegToMem               ;if zero, reg to mem
00001E7E  6000 0028               1857          BRA validMemToReg               ;else, its mem to reg
00001E82                          1858          
00001E82                          1859  validRegToMem:
00001E82                          1860          
00001E82  43F8 1E5D               1861          LEA movemRegToMemEAmasks,A1     ;load the list of masks
00001E86  D3C0                    1862          ADDA.L D0,A1                    ;displace to a specific mask
00001E88  1A11                    1863          MOVE.B (A1),D5                  ;move the mask to D5
00001E8A                          1864          
00001E8A  0C05 0000               1865          CMPI.B #0,D5                    ;check if the mask is 0
00001E8E  6700 F206               1866          BEQ falsePositive               ;branch if it is
00001E92                          1867          
00001E92  1401                    1868          MOVE.B D1,D2                    ;copy instruction to D2
00001E94  C405                    1869          AND.B D5,D2                     ;mask D2
00001E96                          1870          
00001E96  43F8 1E58               1871          LEA movemRegToMemEA,A1          ;load the list of valid modes
00001E9A  D3C0                    1872          ADDA.L D0,A1                    ;displace to a specific mode
00001E9C  1811                    1873          MOVE.B (A1),D4                  ;move mode to D4
00001E9E  B404                    1874          CMP.B D4,D2                     ;compare mode to masked value
00001EA0  6700 002C               1875          BEQ  movemPre                   ;if its match, its a valid mode and we can procede
00001EA4                          1876          
00001EA4  5280                    1877          ADDQ.L #1,D0                    ;add one to displacement
00001EA6  60DA                    1878          BRA validRegToMem               ;check for next mode
00001EA8                          1879          
00001EA8                          1880          
00001EA8                          1881  validMemToReg:
00001EA8                          1882          
00001EA8  43F8 1E67               1883          LEA movemMemToRegEAmasks,A1     ;load the list of masks
00001EAC  D3C0                    1884          ADDA.L D0,A1                    ;displace to a specific mask
00001EAE  1A11                    1885          MOVE.B (A1),D5                  ;move the mask to D5
00001EB0                          1886          
00001EB0  0C05 0000               1887          CMPI.B #0,D5                    ;check if the mask is 0
00001EB4  6700 F1E0               1888          BEQ falsePositive               ;branch if it is
00001EB8                          1889          
00001EB8  3401                    1890          MOVE.W D1,D2                    ;copy instruction to D2
00001EBA  C405                    1891          AND.B D5,D2                     ;mask D2
00001EBC                          1892          
00001EBC  43F8 1E62               1893          LEA movemMemToRegEA,A1          ;load the list of valid modes
00001EC0  D3C0                    1894          ADDA.L D0,A1                    ;displace to a specific mode
00001EC2  1811                    1895          MOVE.B (A1),D4                  ;move mode to D4
00001EC4  B404                    1896          CMP.B D4,D2                     ;compare mode to masked value
00001EC6  6700 0062               1897          BEQ movemPost                   ;if its match, its a valid mode and we can procede
00001ECA                          1898          
00001ECA  5280                    1899          ADDQ.L #1,D0                    ;add one to displacement
00001ECC  60DA                    1900          BRA validMemToReg               ;check for next mode
00001ECE                          1901  
00001ECE                          1902  movemPre:
00001ECE                          1903  
00001ECE  43F9 00002D8B           1904          LEA     movemMessage,A1         ;move string for MOVE
00001ED4  103C 000E               1905          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001ED8                          1906                                          ;string with CR, LF
00001ED8  4E4F                    1907          TRAP    #15
00001EDA                          1908          
00001EDA                          1909          ;size
00001EDA  48E7 4000               1910          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001EDE                          1911          ;make it look like NEG's size
00001EDE  C23C 007F               1912          AND.B #%01111111,D1             ;clear bit next to size
00001EE2  0641 0040               1913          ADDI.W #%01000000,D1            ;add 1 to size to make it look like a word or long
00001EE6  6100 0284               1914          BSR negSize
00001EEA  4CDF 0002               1915          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001EEE                          1916          
00001EEE                          1917          
00001EEE                          1918          ;show list
00001EEE                          1919          
00001EEE  6100 00E6               1920          BSR outputPreIncrement     
00001EF2                          1921          
00001EF2  5487                    1922          ADDQ.L #word,D7                 ;read past the register list mask(word) following
00001EF4                          1923                                          ;the instruction
00001EF4                          1924          
00001EF4                          1925          ;print ','
00001EF4  48E7 4000               1926          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001EF8  123C 002C               1927          MOVE.B #',',D1                  ;put ascii value of char in D1
00001EFC  103C 0006               1928          MOVE.B #6,D0                    ;move task 6 into D0
00001F00  4E4F                    1929          TRAP #15                        ;prin char
00001F02  4CDF 0002               1930          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001F06                          1931          
00001F06  3401                    1932          MOVE.W  D1,D2                   ;check mode
00001F08  C43C 003F               1933          AND.B   #%00111111,D2
00001F0C  1A02                    1934          MOVE.B  D2,D5
00001F0E  48E7 4000               1935          MOVEM.L D1,-(SP)
00001F12  6100 0920               1936          BSR     Get_Effective_Address
00001F16  4CDF 0002               1937          MOVEM.L (SP)+,D1
00001F1A                          1938          
00001F1A                          1939          
00001F1A  43F9 00002D3E           1940          LEA     clearLine,A1            ;move string for a CR and LF
00001F20  103C 000E               1941          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001F24                          1942                                          ;string without CR, LF
00001F24  4E4F                    1943          TRAP    #15
00001F26                          1944  
00001F26  7000                    1945          MOVEQ.L #0,D0
00001F28  4E75                    1946          RTS
00001F2A                          1947          
00001F2A                          1948  movemPost:
00001F2A                          1949  
00001F2A  43F9 00002D8B           1950          LEA     movemMessage,A1         ;move string for MOVE
00001F30  103C 000E               1951          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001F34                          1952                                          ;string with CR, LF
00001F34  4E4F                    1953          TRAP    #15
00001F36                          1954          
00001F36                          1955          ;size
00001F36  48E7 4000               1956          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001F3A                          1957          ;make it look like NEG's size
00001F3A  C23C 007F               1958          AND.B #%01111111,D1             ;clear bit next to size
00001F3E  0641 0040               1959          ADDI.W #%01000000,D1            ;add 1 to size to make it look like a word or long
00001F42  6100 0228               1960          BSR negSize
00001F46  4CDF 0002               1961          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001F4A                          1962  
00001F4A  3401                    1963          MOVE.W  D1,D2                   ;check mode
00001F4C  C43C 003F               1964          AND.B   #%00111111,D2
00001F50  1A02                    1965          MOVE.B  D2,D5
00001F52  48E7 4000               1966          MOVEM.L D1,-(SP)
00001F56  6100 08DC               1967          BSR     Get_Effective_Address
00001F5A  4CDF 0002               1968          MOVEM.L (SP)+,D1
00001F5E                          1969          
00001F5E                          1970          
00001F5E                          1971          ;print ','
00001F5E  48E7 4000               1972          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001F62  123C 002C               1973          MOVE.B #',',D1                  ;put ascii value of char in D1
00001F66  103C 0006               1974          MOVE.B #6,D0                    ;move task 6 into D0
00001F6A  4E4F                    1975          TRAP #15                        ;prin char
00001F6C  4CDF 0002               1976          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001F70                          1977          
00001F70                          1978  
00001F70                          1979          
00001F70                          1980          ;show list
00001F70  6100 0102               1981          BSR outputPostIncrement        
00001F74                          1982          
00001F74  5487                    1983          ADDQ.L #word,D7                 ;read past the register list mask(word) following
00001F76                          1984                                          ;the instruction
00001F76                          1985          
00001F76  43F9 00002D3E           1986          LEA     clearLine,A1            ;move string for a CR and LF
00001F7C  103C 000E               1987          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001F80                          1988                                          ;string without CR, LF
00001F80  4E4F                    1989          TRAP    #15
00001F82                          1990  
00001F82  7000                    1991          MOVEQ.L #0,D0
00001F84  4E75                    1992          RTS
00001F86                          1993  
00001F86= 00000000 00000000 ...   1994  movemRegListBuffer DC.L 0,0,0,0,0,0,0,0,0,0,0,0 
00001FB6                          1995                                          ;max of 16 regs @ 2 bytes each, 
00001FB6                          1996                                          ;15 possible '/' @ a byte
00001FB6                          1997                                          ;byte for null terminator
00001FB6                          1998                                          ; 48 bytes = 12 longs 
00001FB6                          1999                              
00001FB6= 41 37 41 36 41 35 ...   2000  movemPostRegList DC.B 'A7','A6','A5','A4','A3','A2','A1','A0','D7','D6','D5','D4','D3','D2','D1','D0'
00001FD6                          2001  movemPreRegList ;should be location after PostList
00001FD6                          2002          
00001FD6                          2003  outputPreincrement:
00001FD6  548B                    2004             ADDQ.L #word,A3
00001FD8  3413                    2005          MOVE.W (A3),D2
00001FDA  7600                    2006          MOVEQ.L #0,D3
00001FDC  47F8 1F86               2007          LEA movemRegListBuffer,A3
00001FE0  49F8 1FD6               2008          LEA movemPreRegList,A4        
00001FE4  558C                    2009          SUBQ.L #word,A4
00001FE6                          2010          
00001FE6  6100 00E8               2011          BSR checkPreRegAdd              ;1
00001FEA                          2012          
00001FEA  558C                    2013          SUBQ.L #word,A4
00001FEC                          2014          
00001FEC  6100 00E2               2015          BSR checkPreRegAdd              ;2
00001FF0  558C                    2016          SUBQ.L #word,A4
00001FF2  6100 00DC               2017          BSR checkPreRegAdd              ;3
00001FF6  558C                    2018          SUBQ.L #word,A4
00001FF8  6100 00D6               2019          BSR checkPreRegAdd              ;4
00001FFC  558C                    2020          SUBQ.L #word,A4
00001FFE  6100 00D0               2021          BSR checkPreRegAdd              ;5
00002002  558C                    2022          SUBQ.L #word,A4
00002004  6100 00CA               2023          BSR checkPreRegAdd              ;6
00002008  558C                    2024          SUBQ.L #word,A4
0000200A  6100 00C4               2025          BSR checkPreRegAdd              ;7
0000200E  558C                    2026          SUBQ.L #word,A4
00002010  6100 00BE               2027          BSR checkPreRegAdd              ;8
00002014  558C                    2028          SUBQ.L #word,A4
00002016  6100 00B8               2029          BSR checkPreRegAdd              ;9
0000201A  558C                    2030          SUBQ.L #word,A4
0000201C  6100 00B2               2031          BSR checkPreRegAdd              ;10
00002020  558C                    2032          SUBQ.L #word,A4
00002022  6100 00AC               2033          BSR checkPreRegAdd              ;11
00002026  558C                    2034          SUBQ.L #word,A4
00002028  6100 00A6               2035          BSR checkPreRegAdd              ;12
0000202C  558C                    2036          SUBQ.L #word,A4
0000202E  6100 00A0               2037          BSR checkPreRegAdd              ;13
00002032  558C                    2038          SUBQ.L #word,A4
00002034  6100 009A               2039          BSR checkPreRegAdd              ;14
00002038  558C                    2040          SUBQ.L #word,A4
0000203A  6100 0094               2041          BSR checkPreRegAdd              ;15
0000203E  558C                    2042          SUBQ.L #word,A4
00002040  6100 008E               2043          BSR checkPreRegAdd              ;16
00002044                          2044          
00002044  16BC 0000               2045          MOVE.B #0,(A3)
00002048  43F8 1F86               2046          LEA     movemRegListBuffer,A1   ;move string for MOVE
0000204C  103C 000E               2047          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002050                          2048                                          ;string without CR, LF
00002050  4E4F                    2049          TRAP    #15 
00002052                          2050          
00002052  4E75                    2051          RTS
00002054                          2052          
00002054                          2053  checkPostRegAdd:
00002054  E342                    2054          ASL.W #1,D2
00002056  6500 0004               2055          BCS PostRegAdd
0000205A                          2056  addPostRegDone:
0000205A  4E75                    2057          RTS
0000205C                          2058          
0000205C                          2059  PostRegAdd:
0000205C  4BF8 1F86               2060          LEA movemRegListBuffer,A5
00002060  BBCB                    2061          CMP.L A3,A5
00002062  6600 000A               2062          BNE postAddBackslash
00002066                          2063  PostRegAddDone:
00002066  16DC                    2064          MOVE.B (A4)+,(A3)+
00002068  16D4                    2065          MOVE.B (A4),(A3)+
0000206A  538C                    2066          SUBQ.L #byte,A4
0000206C  60EC                    2067          BRA addPostRegDone
0000206E                          2068          
0000206E                          2069  postAddBackslash:
0000206E  16FC 002F               2070          MOVE.B #'/',(A3)+
00002072  60F2                    2071          BRA PostRegAddDone
00002074                          2072          
00002074                          2073  
00002074                          2074  outputPostincrement:
00002074  548B                    2075          ADDQ.L #word,A3
00002076  3413                    2076          MOVE.W (A3),D2
00002078  7600                    2077          MOVEQ.L #0,D3
0000207A  47F8 1F86               2078          LEA movemRegListBuffer,A3
0000207E  49F8 1FB6               2079          LEA movemPostRegList,A4
00002082                          2080          
00002082  61D0                    2081          BSR checkPostRegAdd             ;1
00002084  548C                    2082          ADDQ.L #word,A4
00002086  61CC                    2083          BSR checkPostRegAdd             ;2
00002088  548C                    2084          ADDQ.L #word,A4
0000208A  61C8                    2085          BSR checkPostRegAdd             ;3
0000208C  548C                    2086          ADDQ.L #word,A4
0000208E  61C4                    2087          BSR checkPostRegAdd             ;4
00002090  548C                    2088          ADDQ.L #word,A4
00002092  61C0                    2089          BSR checkPostRegAdd             ;5
00002094  548C                    2090          ADDQ.L #word,A4
00002096  61BC                    2091          BSR checkPostRegAdd             ;6
00002098  548C                    2092          ADDQ.L #word,A4
0000209A  61B8                    2093          BSR checkPostRegAdd             ;7
0000209C  548C                    2094          ADDQ.L #word,A4
0000209E  61B4                    2095          BSR checkPostRegAdd             ;8
000020A0  548C                    2096          ADDQ.L #word,A4
000020A2  61B0                    2097          BSR checkPostRegAdd             ;9
000020A4  548C                    2098          ADDQ.L #word,A4
000020A6  61AC                    2099          BSR checkPostRegAdd             ;10
000020A8  548C                    2100          ADDQ.L #word,A4
000020AA  61A8                    2101          BSR checkPostRegAdd             ;11
000020AC  548C                    2102          ADDQ.L #word,A4
000020AE  61A4                    2103          BSR checkPostRegAdd             ;12
000020B0  548C                    2104          ADDQ.L #word,A4
000020B2  61A0                    2105          BSR checkPostRegAdd             ;13
000020B4  548C                    2106          ADDQ.L #word,A4
000020B6  619C                    2107          BSR checkPostRegAdd             ;14
000020B8  548C                    2108          ADDQ.L #word,A4
000020BA  6198                    2109          BSR checkPostRegAdd             ;15
000020BC  548C                    2110          ADDQ.L #word,A4
000020BE  6194                    2111          BSR checkPostRegAdd             ;16
000020C0                          2112          
000020C0  16BC 0000               2113          MOVE.B #0,(A3)
000020C4  43F8 1F86               2114          LEA     movemRegListBuffer,A1   ;move string for MOVE
000020C8  103C 000E               2115          MOVE.B  #14,D0                  ;set for task to display null terminated 
000020CC                          2116                               ;string without CR, LF
000020CC  4E4F                    2117          TRAP    #15 
000020CE                          2118          
000020CE  4E75                    2119          RTS
000020D0                          2120          
000020D0                          2121  checkPreRegAdd:
000020D0  E342                    2122          ASL.W #1,D2
000020D2  6500 0004               2123          BCS PreRegAdd
000020D6                          2124  addPreRegDone:
000020D6  4E75                    2125          RTS
000020D8                          2126          
000020D8                          2127  PreRegAdd:
000020D8  4BF8 1F86               2128          LEA movemRegListBuffer,A5
000020DC  BBCB                    2129          CMP.L A3,A5
000020DE  6600 000A               2130          BNE preAddBackslash
000020E2                          2131  PreRegAddDone:
000020E2  16DC                    2132          MOVE.B (A4)+,(A3)+
000020E4  16D4                    2133          MOVE.B (A4),(A3)+
000020E6  538C                    2134          SUBQ.L #byte,A4
000020E8  60EC                    2135          BRA addPreRegDone
000020EA                          2136          
000020EA                          2137  preAddBackslash:
000020EA  16FC 002F               2138          MOVE.B #'/',(A3)+
000020EE  6000 FF76               2139          BRA PostRegAddDone
000020F2                          2140  
000020F2                          2141      
000020F2= 00 10 18 20 28 38 ...   2142  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
000020FA= 38 38 38 38 38 3F ...   2143  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
00002102                          2144     
00002102                          2145  NEG:            
00002102                          2146       
00002102  7000                    2147          MOVEQ.L #0, D0                  ;clear D0
00002104                          2148          
00002104                          2149  validNegModes:
00002104                          2150          
00002104  43F8 20FA               2151          LEA NegEAmasks,A1               ;load the list of masks
00002108  D3C0                    2152          ADDA.L D0,A1                    ;displace to a specific mask
0000210A  1A11                    2153          MOVE.B (A1),D5                  ;move the mask to D5
0000210C                          2154          
0000210C  0C05 0000               2155          CMPI.B #0,D5                    ;check if the mask is 0
00002110  6700 EF84               2156          BEQ falsePositive               ;branch if it is
00002114                          2157          
00002114  1401                    2158          MOVE.B D1,D2                    ;copy instruction to D2
00002116  C405                    2159          AND.B D5,D2                     ;mask D2
00002118  43F8 20F2               2160          LEA NegEA,A1                    ;load the list of valid modes
0000211C  D3C0                    2161          ADDA.L D0,A1                    ;displace to a specific mode
0000211E  1811                    2162          MOVE.B (A1),D4                  ;move mode to D4
00002120  B404                    2163          CMP.B D4,D2                     ;compare mode to masked value
00002122  6700 0006               2164          BEQ NegBody                     ;if its match, its a valid mode and we can procede
00002126                          2165          
00002126  5280                    2166          ADDQ.L #1,D0                    ;add one to displacement
00002128  60DA                    2167          BRA validNegModes               ;check for next mode
0000212A                          2168          
0000212A                          2169  NegBody:
0000212A                          2170  
0000212A                          2171  
0000212A  3401                    2172          MOVE.W  D1,D2                   ;copy inst to D2
0000212C  C47C 0600               2173          AND.W  #%0011000000000,D2       ;mask word for size
00002130  0C42 0000               2174          CMPI.W #0,D2                    ;0 is the only non valid size
00002134  6700 EF60               2175          BEQ falsePositive               ; zero is not valid
00002138                          2176  
00002138  43F9 00002DB5           2177          LEA     negMessage,A1           ;move string for NEG info
0000213E  103C 000E               2178          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002142                          2179                                ;string without CR, LF
00002142  4E4F                    2180          TRAP    #15
00002144                          2181          
00002144  6100 0026               2182          BSR NegSize
00002148                          2183          
00002148  3401                    2184          MOVE.W D1,D2
0000214A  C47C 003F               2185          AND #%000000000111111,D2
0000214E  1A02                    2186          MOVE.B D2,D5
00002150                          2187          
00002150  48E7 4000               2188          MOVEM.L D1,-(SP)
00002154  6100 06DE               2189          BSR     Get_Effective_Address
00002158  4CDF 0002               2190          MOVEM.L (SP)+,D1
0000215C                          2191          
0000215C                          2192                
0000215C                          2193          
0000215C                          2194  NEGdone:
0000215C                          2195  
0000215C  43F9 00002D3E           2196          LEA     clearLine,A1            ;move string for a CR and LF
00002162  103C 000E               2197          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002166                          2198                                          ;string without CR, LF
00002166  4E4F                    2199          TRAP    #15
00002168  7000                    2200          MOVEQ.L #0,D0
0000216A  4E75                    2201          RTS
0000216C                          2202          
0000216C                          2203  NegSize:
0000216C  3401                    2204          MOVE.W  D1,D2                   ;copy inst to D2
0000216E  EC4A                    2205          LSR.W #6,D2                     ;shift size over to first byte
00002170  C4BC 00000003           2206          AND.L  #%11,D2                  ;mask word for size
00002176  2C02                    2207          MOVE.L D2,D6                    ;size does not need to be translated,
00002178                          2208                                          ;so moved directly to D6
00002178                          2209          
00002178  6100 0858               2210          BSR printSize
0000217C                          2211          
0000217C  4E75                    2212          RTS
0000217E                          2213          
0000217E                          2214          
0000217E                          2215   ADDI:            
0000217E                          2216       
0000217E  7000                    2217          MOVEQ.L #0, D0                  ;clear D0
00002180                          2218          
00002180                          2219  validAddiModes:
00002180                          2220          
00002180                          2221          
00002180  43F9 000022A5           2222          LEA cmpiEAmasks,A1              ;load the list of masks
00002186  D3C0                    2223          ADDA.L D0,A1                    ;displace to a specific mask
00002188  1A11                    2224          MOVE.B (A1),D5                  ;move the mask to D5
0000218A                          2225          
0000218A  0C05 0000               2226          CMPI.B #0,D5                    ;check if the mask is 0
0000218E  6700 EF06               2227          BEQ falsePositive               ;branch if it is
00002192                          2228          
00002192  1401                    2229          MOVE.B D1,D2                    ;copy instruction to D2
00002194  C405                    2230          AND.B D5,D2                     ;mask D2
00002196  43F9 0000229E           2231          LEA cmpiEA,A1                   ;load the list of valid modes
0000219C  D3C0                    2232          ADDA.L D0,A1                    ;displace to a specific mode
0000219E  1811                    2233          MOVE.B (A1),D4                  ;move mode to D4
000021A0  B404                    2234          CMP.B D4,D2                     ;compare mode to masked value
000021A2  6700 0006               2235          BEQ addiBody                    ;if its match, its a valid mode and we can procede
000021A6                          2236          
000021A6  5280                    2237          ADDQ.L #1,D0                    ;add one to displacement
000021A8  60D6                    2238          BRA validAddiModes              ;check for next mode
000021AA                          2239          
000021AA                          2240  addiBody:
000021AA                          2241  
000021AA                          2242  
000021AA  3401                    2243          MOVE.W  D1,D2                   ;copy inst to D2
000021AC  C47C 00C0               2244          AND.W  #%0000000011000000,D2    ;mask word for size
000021B0  0C42 00C0               2245          CMPI.W #%0000000011000000,D2    ;11 is the only non valid size
000021B4  6700 EEE0               2246          BEQ falsePositive
000021B8                          2247  
000021B8  43F9 00002D91           2248          LEA     addiMessage,A1          ;move string for NEG info
000021BE  103C 000E               2249          MOVE.B  #14,D0                  ;set for task to display null terminated 
000021C2                          2250                                ;string without CR, LF
000021C2  4E4F                    2251          TRAP    #15
000021C4                          2252          
000021C4  61A6                    2253          BSR NegSize
000021C6                          2254          
000021C6                          2255          ;go to Effective_Address for immediate data
000021C6  743C                    2256          MOVE.L #%00111100,D2
000021C8  2A02                    2257          MOVE.L D2,D5
000021CA  48E7 4000               2258          MOVEM.L D1,-(SP)
000021CE  6100 0664               2259          BSR     Get_Effective_Address
000021D2  4CDF 0002               2260          MOVEM.L (SP)+,D1
000021D6                          2261          
000021D6                          2262          ;print ','
000021D6  48E7 4000               2263          MOVEM.L D1,-(SP)                ;save D1 to the stack
000021DA  123C 002C               2264          MOVE.B #',',D1                  ;put ascii value of char in D1
000021DE  103C 0006               2265          MOVE.B #6,D0                    ;move task 6 into D0
000021E2  4E4F                    2266          TRAP #15                        ;prin char
000021E4  4CDF 0002               2267          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000021E8                          2268          
000021E8  3401                    2269          MOVE.W D1,D2                    ;copy inst to D2
000021EA  C47C 003F               2270          AND #%000000000111111,D2        ;and out everything but modes and regs
000021EE  1A02                    2271          MOVE.B D2,D5                    ; copy to D5 for following BSR
000021F0                          2272          
000021F0  48E7 4000               2273          MOVEM.L D1,-(SP)
000021F4  6100 063E               2274          BSR     Get_Effective_Address
000021F8  4CDF 0002               2275          MOVEM.L (SP)+,D1
000021FC                          2276          
000021FC                          2277                
000021FC                          2278          
000021FC                          2279  addidone:
000021FC                          2280  
000021FC  43F9 00002D3E           2281          LEA     clearLine,A1            ;move string for a CR and LF
00002202  103C 000E               2282          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002206                          2283                                          ;string without CR, LF
00002206  4E4F                    2284          TRAP    #15
00002208  7000                    2285          MOVEQ.L #0,D0
0000220A  4E75                    2286          RTS
0000220C                          2287    
0000220C                          2288  ORI:            
0000220C                          2289       
0000220C  7000                    2290          MOVEQ.L #0, D0                  ;clear D0
0000220E                          2291          
0000220E                          2292  validOriModes:
0000220E                          2293          
0000220E                          2294          
0000220E  43F9 000022A5           2295          LEA cmpiEAmasks,A1              ;load the list of masks
00002214  D3C0                    2296          ADDA.L D0,A1                    ;displace to a specific mask
00002216  1A11                    2297          MOVE.B (A1),D5                  ;move the mask to D5
00002218                          2298          
00002218  0C05 0000               2299          CMPI.B #0,D5                    ;check if the mask is 0
0000221C  6700 EE78               2300          BEQ falsePositive               ;branch if it is
00002220                          2301          
00002220  1401                    2302          MOVE.B D1,D2                    ;copy instruction to D2
00002222  C405                    2303          AND.B D5,D2                     ;mask D2
00002224  43F9 0000229E           2304          LEA cmpiEA,A1                   ;load the list of valid modes
0000222A  D3C0                    2305          ADDA.L D0,A1                    ;displace to a specific mode
0000222C  1811                    2306          MOVE.B (A1),D4                  ;move mode to D4
0000222E  B404                    2307          CMP.B D4,D2                     ;compare mode to masked value
00002230  6700 0006               2308          BEQ oriBody                     ;if its match, its a valid mode and we can procede
00002234                          2309          
00002234  5280                    2310          ADDQ.L #1,D0                    ;add one to displacement
00002236  60D6                    2311          BRA validOriModes               ;check for next mode
00002238                          2312          
00002238                          2313  oriBody:
00002238                          2314  
00002238                          2315  
00002238  3401                    2316          MOVE.W  D1,D2                   ;copy inst to D2
0000223A  C47C 00C0               2317          AND.W  #%0000000011000000,D2    ;mask word for size
0000223E  0C42 00C0               2318          CMPI.W #%0000000011000000,D2    ;11 is the only non valid size
00002242  6700 EE52               2319          BEQ falsePositive
00002246                          2320  
00002246  43F9 00002D96           2321          LEA     oriMessage,A1           ;move string for NEG info
0000224C  103C 000E               2322          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002250                          2323                                ;string without CR, LF
00002250  4E4F                    2324          TRAP    #15
00002252                          2325          
00002252  6100 FF18               2326          BSR negSize
00002256                          2327          
00002256                          2328          ;go to Effective_Address for immediate data
00002256  143C 003C               2329          MOVE.B #%00111100,D2
0000225A  1A02                    2330          MOVE.B D2,D5
0000225C  48E7 4000               2331          MOVEM.L D1,-(SP)
00002260  6100 05D2               2332          BSR     Get_Effective_Address
00002264  4CDF 0002               2333          MOVEM.L (SP)+,D1
00002268                          2334          
00002268                          2335          ;print ','
00002268  48E7 4000               2336          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000226C  123C 002C               2337          MOVE.B #',',D1                  ;put ascii value of char in D1
00002270  103C 0006               2338          MOVE.B #6,D0                    ;move task 6 into D0
00002274  4E4F                    2339          TRAP #15                        ;print char
00002276  4CDF 0002               2340          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000227A                          2341          
0000227A  3401                    2342          MOVE.W D1,D2                    ;copy inst to D2
0000227C  C47C 003F               2343          AND #%000000000111111,D2        ;and out everything but modes and regs
00002280  1A02                    2344          MOVE.B D2,D5                    ; copy to D5 for following BSR
00002282                          2345          
00002282  48E7 4000               2346          MOVEM.L D1,-(SP)
00002286  6100 05AC               2347          BSR     Get_Effective_Address
0000228A  4CDF 0002               2348          MOVEM.L (SP)+,D1
0000228E                          2349          
0000228E                          2350                
0000228E                          2351          
0000228E                          2352  oridone:
0000228E                          2353  
0000228E  43F9 00002D3E           2354          LEA     clearLine,A1            ;move string for a CR and LF
00002294  103C 000E               2355          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002298                          2356                                          ;string without CR, LF
00002298  4E4F                    2357          TRAP    #15
0000229A  7000                    2358          MOVEQ.L #0,D0
0000229C  4E75                    2359          RTS
0000229E                          2360  
0000229E                          2361          
0000229E                          2362          
0000229E= 20 18 00 10 38 39 00    2363  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
000022A5= 38 38 38 38 3F 3F 00    2364  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
000022AC                          2365     
000022AC                          2366  CMPI:            
000022AC                          2367       
000022AC  7000                    2368          MOVEQ.L #0, D0                  ;clear D0
000022AE                          2369          
000022AE                          2370  validCmpiModes:
000022AE                          2371          
000022AE                          2372          
000022AE  43F8 22A5               2373          LEA cmpiEAmasks,A1              ;load the list of masks
000022B2  D3C0                    2374          ADDA.L D0,A1                    ;displace to a specific mask
000022B4  1A11                    2375          MOVE.B (A1),D5                  ;move the mask to D5
000022B6                          2376          
000022B6  0C05 0000               2377          CMPI.B #0,D5                    ;check if the mask is 0
000022BA  6700 EDDA               2378          BEQ falsePositive               ;branch if it is
000022BE                          2379          
000022BE  1401                    2380          MOVE.B D1,D2                    ;copy instruction to D2
000022C0  C405                    2381          AND.B D5,D2                     ;mask D2
000022C2  43F8 229E               2382          LEA cmpiEA,A1                   ;load the list of valid modes
000022C6  D3C0                    2383          ADDA.L D0,A1                    ;displace to a specific mode
000022C8  1811                    2384          MOVE.B (A1),D4                  ;move mode to D4
000022CA  B404                    2385          CMP.B D4,D2                     ;compare mode to masked value
000022CC  6700 0006               2386          BEQ CMPIBody                    ;if its match, its a valid mode and we can procede
000022D0                          2387          
000022D0  5280                    2388          ADDQ.L #1,D0                    ;add one to displacement
000022D2  60DA                    2389          BRA validCmpiModes              ;check for next mode
000022D4                          2390          
000022D4                          2391  CMPIBody:
000022D4                          2392  
000022D4                          2393  
000022D4  3401                    2394          MOVE.W  D1,D2                   ;copy inst to D2
000022D6  C47C 00C0               2395          AND.W  #%0000000011000000,D2    ;mask word for size
000022DA  0C42 00C0               2396          CMPI.W #%0000000011000000,D2    ;11 is the only non valid size
000022DE  6700 EDB6               2397          BEQ falsePositive
000022E2                          2398  
000022E2  43F9 00002D9A           2399          LEA     cmpiMessage,A1          ;move string for NEG info
000022E8  103C 000E               2400          MOVE.B  #14,D0                  ;set for task to display null terminated 
000022EC                          2401                                ;string without CR, LF
000022EC  4E4F                    2402          TRAP    #15
000022EE                          2403          
000022EE  6100 FE7C               2404          BSR negSize
000022F2                          2405          
000022F2                          2406          ;go to Effective_Address for immediate data
000022F2  143C 003C               2407          MOVE.B #%00111100,D2
000022F6  1A02                    2408          MOVE.B D2,D5
000022F8  48E7 4000               2409          MOVEM.L D1,-(SP)
000022FC  6100 0536               2410          BSR     Get_Effective_Address
00002300  4CDF 0002               2411          MOVEM.L (SP)+,D1
00002304                          2412          
00002304                          2413          ;print ','
00002304  48E7 4000               2414          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002308  123C 002C               2415          MOVE.B #',',D1                  ;put ascii value of char in D1
0000230C  103C 0006               2416          MOVE.B #6,D0                    ;move task 6 into D0
00002310  4E4F                    2417          TRAP #15                        ;prin char
00002312  4CDF 0002               2418          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002316                          2419          
00002316  3401                    2420          MOVE.W D1,D2                    ;copy inst to D2
00002318  C47C 003F               2421          AND #%000000000111111,D2        ;and out everything but modes and regs
0000231C  1A02                    2422          MOVE.B D2,D5                    ; copy to D5 for following BSR
0000231E                          2423          
0000231E  48E7 4000               2424          MOVEM.L D1,-(SP)
00002322  6100 0510               2425          BSR     Get_Effective_Address
00002326  4CDF 0002               2426          MOVEM.L (SP)+,D1
0000232A                          2427          
0000232A                          2428                
0000232A                          2429          
0000232A                          2430  CMPidone:
0000232A                          2431  
0000232A  43F9 00002D3E           2432          LEA     clearLine,A1            ;move string for a CR and LF
00002330  103C 000E               2433          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002334                          2434                                ;string without CR, LF
00002334  4E4F                    2435          TRAP    #15
00002336  7000                    2436          MOVEQ.L #0,D0
00002338  4E75                    2437          RTS
0000233A                          2438  
0000233A                          2439          
0000233A= 10 38 39 00             2440  JsrEA        DC.B %010000, %111000, %111001,0
0000233E= 38 3F 3F 00             2441  JsrEAmasks   DC.B %111000, %111111, %111111,0
00002342                          2442     
00002342                          2443  JSR:            
00002342                          2444       
00002342  7000                    2445          MOVEQ.L #0, D0                  ;clear D0
00002344                          2446          
00002344                          2447  validJsrModes:
00002344                          2448          
00002344  43F8 233E               2449          LEA JsrEAmasks,A1               ;load the list of masks
00002348  D3C0                    2450          ADDA.L D0,A1                    ;displace to a specific mask
0000234A  1A11                    2451          MOVE.B (A1),D5                  ;move the mask to D5
0000234C                          2452          
0000234C  0C05 0000               2453          CMPI.B #0,D5                    ;check if the mask is 0
00002350  6700 ED44               2454          BEQ falsePositive               ;branch if it is
00002354                          2455          
00002354  1401                    2456          MOVE.B D1,D2                    ;copy instruction to D2
00002356  C405                    2457          AND.B D5,D2                     ;mask D2
00002358  43F8 233A               2458          LEA JsrEA,A1                    ;load the list of valid modes
0000235C  D3C0                    2459          ADDA.L D0,A1                    ;displace to a specific mode
0000235E  1811                    2460          MOVE.B (A1),D4                  ;move mode to D4
00002360  B404                    2461          CMP.B D4,D2                     ;compare mode to masked value
00002362  6700 0006               2462          BEQ JsrBody                     ;if its match, its a valid mode and we can procede
00002366                          2463          
00002366  5280                    2464          ADDQ.L #1,D0                    ;add one to displacement
00002368  60DA                    2465          BRA validJsrModes               ;check for next mode
0000236A                          2466          
0000236A                          2467  JsrBody:
0000236A                          2468  
0000236A                          2469  
0000236A  43F9 00002D9F           2470          LEA     jsrMessage,A1           ;move string for NEG info
00002370  103C 000E               2471          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002374                          2472                                ;string without CR, LF
00002374  4E4F                    2473          TRAP    #15
00002376                          2474          
00002376  3401                    2475          MOVE.W D1,D2                    ;copy inst to D2
00002378  C47C 003F               2476          AND #%000000000111111,D2        ;and out everything but modes and regs
0000237C  1A02                    2477          MOVE.B D2,D5                    ; copy to D5 for following BSR
0000237E                          2478          
0000237E  48E7 4000               2479          MOVEM.L D1,-(SP)
00002382  6100 04B0               2480          BSR     Get_Effective_Address
00002386  4CDF 0002               2481          MOVEM.L (SP)+,D1
0000238A                          2482          
0000238A                          2483                
0000238A                          2484          
0000238A                          2485  Jsrdone:
0000238A                          2486  
0000238A  43F9 00002D3E           2487          LEA     clearLine,A1            ;move string for a CR and LF
00002390  103C 000E               2488          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002394                          2489                                ;string without CR, LF
00002394  4E4F                    2490          TRAP    #15
00002396  7000                    2491          MOVEQ.L #0,D0
00002398  4E75                    2492          RTS
0000239A                          2493  
0000239A                          2494  
0000239A                          2495          
0000239A                          2496  NOP:
0000239A                          2497  
0000239A  43F9 00002DA9           2498          LEA     nopMessage,A1           ;move string for NOP info
000023A0  103C 000D               2499          MOVE.B  #13,D0                  ;set for task to display null terminated 
000023A4                          2500                                          ;string with CR, LF
000023A4  4E4F                    2501          TRAP    #15
000023A6                          2502          
000023A6  7000                    2503          MOVEQ.L #0,D0
000023A8  4E75                    2504          RTS
000023AA                          2505          
000023AA                          2506  RTS:
000023AA                          2507          
000023AA  43F9 00002DA4           2508          LEA     rtsMessage,A1           ;move string for rts info
000023B0  103C 000D               2509          MOVE.B  #13,D0                  ;set for task to display null terminated 
000023B4                          2510                                          ;string with CR, LF
000023B4  4E4F                    2511          TRAP    #15  
000023B6                          2512     
000023B6  7000                    2513          MOVEQ.L #0,D0
000023B8  4E75                    2514          RTS   
000023BA                          2515  
000023BA= 3C 08 00 10 18 20 ...   2516  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
000023C3= 3F 38 38 38 38 38 ...   2517  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
000023CC                          2518  
000023CC= 00 10 18 20 38 39 00    2519  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
000023D3= 38 38 38 38 3F 3F 00    2520  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
000023DA                          2521  
000023DA                          2522  MOVE:
000023DA                          2523          
000023DA                          2524  
000023DA                          2525          
000023DA  7000                    2526          MOVEQ.L #0, D0                  ;clear D0
000023DC                          2527          
000023DC                          2528  validMoveSourceModes:
000023DC                          2529          
000023DC  43F8 23C3               2530          LEA moveSourceEAmasks,A1        ;load the list of masks
000023E0  D3C0                    2531          ADDA.L D0,A1                    ;displace to a specific mask
000023E2  1A11                    2532          MOVE.B (A1),D5                  ;move the mask to D5
000023E4                          2533          
000023E4  0C05 0000               2534          CMPI.B #0,D5                    ;check if the mask is 0
000023E8  6700 ECAC               2535          BEQ falsePositive               ;branch if it is
000023EC                          2536          
000023EC  1401                    2537          MOVE.B D1,D2                    ;copy instruction to D2
000023EE  C405                    2538          AND.B D5,D2                     ;mask D2
000023F0                          2539          
000023F0  43F8 23BA               2540          LEA moveSourceEA,A1             ;load the list of valid modes
000023F4  D3C0                    2541          ADDA.L D0,A1                    ;displace to a specific mode
000023F6  1811                    2542          MOVE.B (A1),D4                  ;move mode to D4
000023F8  B404                    2543          CMP.B D4,D2                     ;compare mode to masked value
000023FA  6700 0006               2544          BEQ  checkMoveDest              ;if its match, its a valid mode and we can procede
000023FE                          2545          
000023FE  5280                    2546          ADDQ.L #1,D0                    ;add one to displacement
00002400  60DA                    2547          BRA validMoveSourceModes        ;check for next mode
00002402                          2548          
00002402                          2549  checkMoveDest:
00002402  7000                    2550          MOVEQ.L #0, D0                  ;clear D0
00002404                          2551          
00002404                          2552  validMoveDestModes:
00002404                          2553          
00002404  43F8 23D3               2554          LEA moveDestEAmasks,A1          ;load the list of masks
00002408  D3C0                    2555          ADDA.L D0,A1                    ;displace to a specific mask
0000240A  1A11                    2556          MOVE.B (A1),D5                  ;move the mask to D5
0000240C                          2557          
0000240C  0C05 0000               2558          CMPI.B #0,D5                    ;check if the mask is 0
00002410  6700 EC84               2559          BEQ falsePositive               ;branch if it is
00002414                          2560          
00002414  3401                    2561          MOVE.W D1,D2                    ;copy instruction to D2
00002416  EC4A                    2562          LSR.W #6,D2                     ;move mode
00002418  6100 06EA               2563          BSR switchModeAndReg            ;switch register and mode
0000241C  C405                    2564          AND.B D5,D2                     ;mask D2
0000241E                          2565          
0000241E  43F8 23CC               2566          LEA moveDestEA,A1               ;load the list of valid modes
00002422  D3C0                    2567          ADDA.L D0,A1                    ;displace to a specific mode
00002424  1811                    2568          MOVE.B (A1),D4                  ;move mode to D4
00002426  B404                    2569          CMP.B D4,D2                     ;compare mode to masked value
00002428  6700 0006               2570          BEQ moveBody                    ;if its match, its a valid mode and we can procede
0000242C                          2571          
0000242C  5280                    2572          ADDQ.L #1,D0                    ;add one to displacement
0000242E  60D4                    2573          BRA validMoveDestModes          ;check for next mode
00002430                          2574          
00002430                          2575  moveBody
00002430  3401                    2576          MOVE.W  D1,D2                   ;copy inst to D2
00002432  C47C 3000               2577          AND.W  #%0011000000000000,D2    ;mask word for size
00002436  0C42 0000               2578          CMPI.W #0,D2                    ;0 is the only non valid size
0000243A  6700 EC5A               2579          BEQ falsePositive               ; if zero, this is not move
0000243E                          2580  
0000243E  43F9 00002DAE           2581          LEA     moveMessage,A1          ;move string for MOVE
00002444  103C 000E               2582          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002448                          2583                                ;string with CR, LF
00002448  4E4F                    2584          TRAP    #15
0000244A                          2585          
0000244A  6100 0052               2586          BSR moveSize
0000244E                          2587          
0000244E  3401                    2588          MOVE.W  D1,D2                   ;check source mode
00002450  C43C 003F               2589          AND.B   #%00111111,D2
00002454  1A02                    2590          MOVE.B  D2,D5
00002456  48E7 4000               2591          MOVEM.L D1,-(SP)
0000245A  6100 03D8               2592          BSR     Get_Effective_Address
0000245E  4CDF 0002               2593          MOVEM.L (SP)+,D1
00002462                          2594          
00002462                          2595          ;print ','
00002462  48E7 4000               2596          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002466  123C 002C               2597          MOVE.B #',',D1                  ;put ascii value of char in D1
0000246A  103C 0006               2598          MOVE.B #6,D0                    ;move task 6 into D0
0000246E  4E4F                    2599          TRAP #15                        ;prin char
00002470  4CDF 0002               2600          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002474                          2601          
00002474  3401                    2602          MOVE.W  D1,D2                   ;check dest mode
00002476  EC4A                    2603          LSR.W   #6,D2
00002478  6100 068A               2604          BSR  switchModeAndReg
0000247C  C43C 003F               2605          AND.B   #%00111111,D2
00002480  1A02                    2606          MOVE.B  D2,D5
00002482  48E7 4000               2607          MOVEM.L D1,-(SP)
00002486  6100 03AC               2608          BSR     Get_Effective_Address
0000248A  4CDF 0002               2609          MOVEM.L (SP)+,D1
0000248E                          2610          
0000248E                          2611          
0000248E                          2612          
0000248E  43F9 00002D3E           2613          LEA     clearLine,A1            ;move string for a CR and LF
00002494  103C 000E               2614          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002498                          2615                                ;string without CR, LF
00002498  4E4F                    2616          TRAP    #15
0000249A                          2617  
0000249A  7000                    2618          MOVEQ.L #0,D0
0000249C  4E75                    2619          RTS
0000249E                          2620          
0000249E                          2621  moveSize:
0000249E  3401                    2622          MOVE.W  D1,D2                   ;copy inst to D2
000024A0  E04A                    2623          LSR.W   #8,D2                   ;shift size
000024A2  E80A                    2624          LSR.B   #4,D2
000024A4  C4BC 00000003           2625          AND.L  #%11,D2                  ;mask for size
000024AA  7C00                    2626          MOVEQ.L #0,D6                   ;clear D6
000024AC  0C42 0002               2627          CMPI.W #2,D2                    ;compare and then branch depending on size
000024B0  6700 001C               2628          BEQ moveSizeLong
000024B4  6E00 0012               2629          BGT moveSizeWord
000024B8  6D00 0008               2630          BLT moveSizeByte
000024BC                          2631  moveSizeDone:        
000024BC  6100 0514               2632          BSR printSize
000024C0  4E75                    2633          RTS
000024C2                          2634          
000024C2                          2635  moveSizeByte:
000024C2  1C3C 0000               2636          MOVE.B #0,D6
000024C6  60F4                    2637          BRA moveSizeDone
000024C8                          2638          
000024C8                          2639  moveSizeWord:
000024C8  1C3C 0001               2640          MOVE.B #1,D6
000024CC  60EE                    2641          BRA moveSizeDone
000024CE                          2642          
000024CE                          2643  moveSizeLong:
000024CE  1C3C 0002               2644          MOVE.B #2,D6
000024D2  60E8                    2645          BRA moveSizeDone
000024D4                          2646          
000024D4= 08 00                   2647  moveADestEA        DC.B %001000,0
000024D6= 38 00                   2648  moveADestEAmasks   DC.B %111000,0
000024D8                          2649          
000024D8                          2650  MOVEA:
000024D8                          2651  
000024D8  7000                    2652          MOVEQ.L #0, D0                  ;clear D0
000024DA                          2653          
000024DA                          2654  validMoveAModes:
000024DA                          2655          
000024DA  43F8 23C3               2656          LEA moveSourceEAmasks,A1        ;load the list of masks
000024DE  D3C0                    2657          ADDA.L D0,A1                    ;displace to a specific mask
000024E0  1A11                    2658          MOVE.B (A1),D5                  ;move the mask to D5
000024E2                          2659          
000024E2  0C05 0000               2660          CMPI.B #0,D5                    ;check if the mask is 0
000024E6  6700 EBAE               2661          BEQ falsePositive               ;branch if it is
000024EA                          2662          
000024EA  1401                    2663          MOVE.B D1,D2                    ;copy instruction to D2
000024EC  C405                    2664          AND.B D5,D2                     ;mask D2
000024EE                          2665          
000024EE  43F8 23BA               2666          LEA moveSourceEA,A1             ;load the list of valid modes
000024F2  D3C0                    2667          ADDA.L D0,A1                    ;displace to a specific mode
000024F4  1811                    2668          MOVE.B (A1),D4                  ;move mode to D4
000024F6  B404                    2669          CMP.B D4,D2                     ;compare mode to masked value
000024F8  6700 0006               2670          BEQ  moveABody                  ;if its match, its a valid mode and we can procede
000024FC                          2671          
000024FC  5280                    2672          ADDQ.L #1,D0                    ;add one to displacement
000024FE  60DA                    2673          BRA validMoveAModes             ;check for next mode
00002500                          2674          
00002500                          2675  moveABody:
00002500  3401                    2676          MOVE.W  D1,D2                   ;copy inst to D2
00002502  C47C 3000               2677          AND.W  #%0011000000000000,D2    ;mask word for size
00002506  0C42 0000               2678          CMPI.W #0,D2                    ;0 is the non valid size
0000250A  6700 EB8A               2679          BEQ falsePositive               ; if zero, this is not move
0000250E  0C42 1000               2680          CMPI.W #%0001000000000000,D2
00002512  6700 EB82               2681          BEQ falsePositive               ; if byte, this is not movea
00002516                          2682  
00002516                          2683  
00002516  43F9 00002DBF           2684          LEA     moveAMessage,A1         ;move string for MOVE
0000251C  103C 000E               2685          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002520                          2686                                ;string without CR, LF
00002520  4E4F                    2687          TRAP    #15
00002522                          2688  
00002522  6100 FF7A               2689          BSR moveSize
00002526                          2690          
00002526                          2691          ;Do EA
00002526                          2692          
00002526  3401                    2693          MOVE.W  D1,D2                   ;check mode
00002528  C43C 003F               2694          AND.B   #%00111111,D2
0000252C  1A02                    2695          MOVE.B  D2,D5
0000252E  48E7 4000               2696          MOVEM.L D1,-(SP)
00002532  6100 0300               2697          BSR     Get_Effective_Address
00002536  4CDF 0002               2698          MOVEM.L (SP)+,D1
0000253A                          2699          
0000253A                          2700          
0000253A                          2701          ;print ','
0000253A  48E7 4000               2702          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000253E  123C 002C               2703          MOVE.B #',',D1                  ;put ascii value of char in D1
00002542  103C 0006               2704          MOVE.B #6,D0                    ;move task 6 into D0
00002546  4E4F                    2705          TRAP #15                        ;prin char
00002548  4CDF 0002               2706          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000254C                          2707          
0000254C                          2708          
0000254C                          2709          ;Then do An
0000254C                          2710          
0000254C  3401                    2711          MOVE.W  D1,D2
0000254E  E04A                    2712          LSR.W   #8,D2                   ;move reg into first byte
00002550  E20A                    2713          LSR.B   #1,D2                   ;line it up to least sig bit
00002552  C43C 0007               2714          AND.B   #%00000111,D2           ;force mode to An
00002556  5002                    2715          ADDQ.B  #8,D2
00002558  1A02                    2716          MOVE.B  D2,D5
0000255A  48E7 4000               2717          MOVEM.L D1,-(SP)
0000255E  6100 02D4               2718          BSR     Get_Effective_Address
00002562  4CDF 0002               2719          MOVEM.L (SP)+,D1
00002566                          2720          
00002566  43F9 00002D3E           2721          LEA     clearLine,A1            ;move string for a CR and LF
0000256C  103C 000E               2722          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002570                          2723                                ;string without CR, LF
00002570  4E4F                    2724          TRAP    #15
00002572                          2725  
00002572  7000                    2726          MOVEQ.L #0,D0
00002574  4E75                    2727          RTS
00002576                          2728  
00002576                          2729             
00002576                          2730  Bcc:
00002576                          2731          
00002576  48E7 4000               2732          MOVEM.L D1,-(SP)
0000257A  43F9 00002DB3           2733          LEA     bccMessage,A1           ;move string for BRA info
00002580  103C 000E               2734          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002584                          2735                                ;string without CR, LF
00002584  4E4F                    2736          TRAP    #15
00002586                          2737          
00002586  7000                    2738          MOVEQ.L #0,D0                   ;clear D0
00002588  3401                    2739          MOVE.W  D1,D2                   ;move instruction into D2 for manipulaiton
0000258A  E04A                    2740          LSR.W   #8,D2
0000258C  C47C 000F               2741          AND.W   #$0F,D2                 ;mask instruction
00002590                          2742          
00002590                          2743  checkCC:        
00002590  41F9 00002CC6           2744          LEA     bccList,A0              ;get condition code signature list in A0
00002596  D1C0                    2745          ADDA.L  D0,A0                   ;get correct sig         
00002598  B410                    2746          CMP.B   (A0),D2                 ;compare to sig
0000259A  6700 0006               2747          BEQ     foundCC                 ;if sig matches branch
0000259E  5200                    2748          ADDQ.B  #byte,D0
000025A0  60EE                    2749          BRA     checkCC
000025A2                          2750  foundCC:
000025A2  43F9 00002CD6           2751          LEA     conditionCodeMessage,A1 ;get condition code message in A1
000025A8  C0FC 0004               2752          MULU.W  #long,D0                ;adjust size of D0 for a long
000025AC  D3C0                    2753          ADDA.L  D0,A1                   ;get correct message location
000025AE  2251                    2754          MOVEA.L (A1),A1                 ;get correct message
000025B0                          2755          
000025B0  103C 000E               2756          MOVE.B  #14,D0                  ;set for task to display null terminated 
000025B4                          2757                                ;string without CR, LF
000025B4  4E4F                    2758          TRAP    #15
000025B6                          2759  
000025B6                          2760          
000025B6                          2761          
000025B6  548B                    2762          ADDQ.L  #word,A3                ;move past instruction in case long displacement
000025B8  C27C 00FF               2763          AND.W   #$00FF,D1               ;check for word sized displacement
000025BC                          2764          
000025BC  B23C 0000               2765          CMP.B   #$0,D1
000025C0  6700 0028               2766          BEQ     BccWord
000025C4                          2767          
000025C4  B23C 00FF               2768          CMP.B   #$FF,D1 check for long sized displacement
000025C8  6700 002A               2769          BEQ     BccLong
000025CC                          2770          
000025CC                          2771  BccByte:
000025CC                          2772          
000025CC  1201                    2773          MOVE.B D1,D1                    ;lazy check if negative
000025CE                          2774          
000025CE  6B00 000E               2775          BMI signExtendByte
000025D2                          2776          
000025D2  C2BC 000000FF           2777          AND.L #$000000FF,D1             ;mask out rest of reg just in case
000025D8                          2778          
000025D8  7E00                    2779          MOVEQ.L #0,D7                   ;pass back no extra data followed
000025DA  6000 0020               2780          BRA     BccDone
000025DE                          2781          
000025DE                          2782  signExtendByte:        
000025DE                          2783          
000025DE  82BC FFFFFF00           2784          OR.L #$FFFFFF00,D1              ;extend to long by set all bits not part of the
000025E4                          2785                             ;least significant byte
000025E4                          2786          
000025E4  7E00                    2787          MOVEQ.L #0,D7                   ;pass back no extra data followed
000025E6  6000 0014               2788          BRA     BccDone
000025EA                          2789  
000025EA                          2790  BccWord:
000025EA  3253                    2791          MOVEA.W  (A3),A1                ;sign extend word
000025EC  2209                    2792          MOVE.L   A1,D1
000025EE  7E02                    2793          MOVEQ.L #word,D7                ;pass back an extra word followed
000025F0  6000 000A               2794          BRA     BccDone
000025F4                          2795  BccLong:
000025F4  2213                    2796          MOVE.L  (A3),D1 
000025F6  7E04                    2797          MOVEQ.L #long,D7                ;pass back an extra long followed
000025F8  6000 0002               2798          BRA     BccDone
000025FC                          2799  BccDone:
000025FC                          2800  
000025FC  303C 0003               2801          MOVE.W  #3,D0                   ;put task #15 in D0
00002600  4E4F                    2802          TRAP    #15
00002602                          2803          
00002602  43F9 00002D3E           2804          LEA     clearLine,A1            ;move string for a CR and LF
00002608  103C 000E               2805          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000260C                          2806                                ;string without CR, LF
0000260C  4E4F                    2807          TRAP    #15
0000260E                          2808          
0000260E  4CDF 0002               2809          MOVEM.L (SP)+,D1
00002612  7000                    2810          MOVEQ.L #0,D0
00002614  4E75                    2811          RTS
00002616                          2812          
00002616                          2813          
00002616                          2814  unknownOpCode:
00002616  43F9 00002DB9           2815          LEA     dataMessage,A1          ;move string for data info
0000261C  103C 000E               2816          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002620                          2817                                ;string without CR, LF
00002620  4E4F                    2818          TRAP    #15
00002622                          2819          
00002622                          2820          ;print word in D1
00002622  48E7 1200               2821          MOVEM.L D6/D3,-(SP)
00002626  1C3C 0001               2822          MOVE.B #1,D6                    ;put size of word in D6
0000262A  2601                    2823          MOVE.L D1,D3                    ;move data at D1 to D3
0000262C  6100 042A               2824          BSR outputHex
00002630  4CDF 0048               2825          MOVEM.L (SP)+,D6/D3
00002634                          2826          
00002634  43F9 00002D3E           2827          LEA     clearLine,A1            ;move string for a CR and LF
0000263A  103C 000E               2828          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000263E                          2829                                ;string without CR, LF
0000263E  4E4F                    2830          TRAP    #15
00002640                          2831          
00002640  7000                    2832          MOVEQ.L #0,D0
00002642  4E75                    2833          RTS
00002644                          2834          
00002644                          2835  handlebytedata:
00002644                          2836  
00002644  43F9 00002DB9           2837          LEA     dataMessage,A1          ;move string for data info
0000264A  103C 000E               2838          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000264E                          2839                                ;string without CR, LF
0000264E  4E4F                    2840          TRAP    #15
00002650                          2841          
00002650  1213                    2842          MOVE.B (A3),D1                  ;copy word from other prog to analyze as instruction
00002652                          2843          
00002652  E049                    2844          LSR.W   #8,D1                   ;shift the word read into D1 by a byte
00002654                          2845          
00002654  48E7 1200               2846          MOVEM.L D6/D3,-(SP)
00002658  1C3C 0000               2847          MOVE.B #0,D6                    ;put size of byte in D6
0000265C  1601                    2848          MOVE.B D1,D3                    ;move data at D1 to D3
0000265E  6100 03F8               2849          BSR outputHex
00002662  4CDF 0048               2850          MOVEM.L (SP)+,D6/D3
00002666                          2851          
00002666  43F9 00002D3E           2852          LEA     clearLine,A1            ;move string for a CR and LF
0000266C  103C 000E               2853          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002670                          2854                                ;string without CR, LF
00002670  4E4F                    2855          TRAP    #15
00002672                          2856          
00002672  4C9F 0004               2857          MOVEM.W (SP)+,D2                ;restore D2 for next iteration in main loop
00002676  7000                    2858          MOVEQ.L #0,D0
00002678                          2859          
00002678  528B                    2860          ADDQ.L  #byte,A3
0000267A  6000 E99C               2861          BRA main_Loop
0000267E                          2862  
0000267E                          2863          
0000267E                          2864          
0000267E                          2865  fin:
0000267E  43F9 00002E80           2866          LEA     thankyouMessage,A1      ;move string for MOVE
00002684  103C 000E               2867          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002688                          2868                                ;string without CR, LF
00002688  4E4F                    2869          TRAP    #15
0000268A                          2870          
0000268A                          2871          
0000268A  FFFF FFFF               2872          simhalt
0000268E                          2873          
0000268E                          2874  
0000268E                          2875  *******************************************************************************
0000268E                          2876  *                            SUB ROUTINES
0000268E                          2877  *******************************************************************************
0000268E                          2878  
0000268E                          2879  *******************************************************************************
0000268E                          2880  *                          IO ROLE ROUTINES
0000268E                          2881  *******************************************************************************
0000268E                          2882  
0000268E                          2883  *==========================================================================
0000268E                          2884  *                   Enter / Validate beginning address 
0000268E                          2885  *==========================================================================
0000268E                          2886   
0000268E                          2887  begin_address:
0000268E                          2888  
0000268E                          2889         
0000268E  43F9 00002B18           2890          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00002694  2239 00002B18           2891          MOVE.L      slPrompt,D1         ;Load display length to D1
0000269A  700E                    2892          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
0000269C  4E4F                    2893          TRAP        #15                 ;Perform task 14 (display)
0000269E                          2894          
0000269E  43F9 00002E9E           2895          LEA         startLocation,A1    ;Load address to store user input
000026A4  103C 0002               2896          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
000026A8  4E4F                    2897          TRAP        #15                 ;Perform task 2 (input)
000026AA                          2898          
000026AA                          2899          ;CMP.B       #27,(A1)            ;Check for ESC entered
000026AA                          2900          ;BEQ         address_Exit        ;Exit condition
000026AA                          2901                  
000026AA  0C11 0071               2902          CMP.B       #113,(A1)            ;Check for 'q' entered
000026AE  6700 006C               2903          BEQ         address_Exit
000026B2                          2904          
000026B2                          2905          
000026B2  0C11 0051               2906          CMP.B       #81,(A1)            ;Check for 'Q' entered
000026B6  6700 0064               2907          BEQ         address_Exit 
000026BA                          2908          
000026BA  6100 0068               2909          BSR         enter_addr_edit_all
000026BE  B67C FFFF               2910          CMP.W       #-1,D3              ;Did the edit pass?
000026C2  67CA                    2911          BEQ         begin_address       ;No, loop and ask for correct input
000026C4                          2912          
000026C4  2643                    2913          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
000026C6                          2914          
000026C6  43F9 00002C84           2915          LEA         spc,A1              ;Load address for starting loaction prompt
000026CC  1239 00002C85           2916          MOVE.B      spc_len,D1          ;Load empty line length
000026D2  7000                    2917          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
000026D4  4E4F                    2918          TRAP        #15                 ;Perform task 14 (display)
000026D6  6000 0002               2919          BRA         end_address
000026DA                          2920  
000026DA                          2921  *===========================================================================
000026DA                          2922  *                   Enter / Validate ending address 
000026DA                          2923  *===========================================================================
000026DA                          2924  
000026DA                          2925  end_address:
000026DA                          2926          
000026DA  43F9 00002B5D           2927          LEA         elPrompt,A1         ;Load address for ending loaction prompt
000026E0                          2928          ;MOVE.L     elPrompt,D1         ;Load display length to D1
000026E0  7250                    2929          MOVE.L      #80,D1              ;did not like previous command, do not know why, it should have worked
000026E2  700E                    2930          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
000026E4  4E4F                    2931          TRAP        #15                 ;Perform task 14 (display)
000026E6                          2932          
000026E6  43F9 00002EA2           2933          LEA         endLocation,A1      ;Load address to store user input
000026EC  103C 0002               2934          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
000026F0  4E4F                    2935          TRAP        #15                 ;Perform task 2 (input)
000026F2                          2936          
000026F2                          2937          ;CMP.B       #27,(A1)            ;Check for ESC entered
000026F2                          2938          ;BEQ         address_Exit        ;Exit condition 
000026F2                          2939                  
000026F2  0C11 0071               2940          CMP.B       #113,(A1)            ;Check for 'q' entered
000026F6  6700 0024               2941          BEQ         address_Exit
000026FA                          2942                 
000026FA  0C11 0051               2943          CMP.B       #81,(A1)            ;Check for 'Q' entered
000026FE  6700 001C               2944          BEQ         address_Exit 
00002702                          2945          
00002702                          2946          
00002702  6100 0020               2947          BSR         enter_addr_edit_all
00002706  B67C FFFF               2948          CMP.W       #-1,D3              ;Did the edit pass?
0000270A  67CE                    2949          BEQ         end_address         ;No, loop and ask for correct input
0000270C                          2950          
0000270C  6100 010A               2951          BSR         enter_addr_edit_to  ;Test for to address less than from address
00002710  B67C FFFF               2952          CMP.W       #-1,D3              ;Did the edit pass?
00002714  67C4                    2953          BEQ         end_address         ;No, loop and ask for correct input
00002716                          2954  
00002716                          2955  
00002716  2843                    2956          MOVEA.L     D3,A4               ;Ending address gets stored in A4
00002718  6000 0008               2957          BRA         address_done
0000271C                          2958  
0000271C                          2959  address_Exit:
0000271C                          2960  
0000271C  76FF                    2961          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000271E  6000 0002               2962          BRA         address_done
00002722                          2963          
00002722                          2964  address_done:
00002722                          2965  
00002722  4E75                    2966          RTS    
00002724                          2967  
00002724                          2968  *==============================================================================
00002724                          2969  * enter_addr_edit_all - Enter address edit check to edit all errors  
00002724                          2970  *                       using multiple different error checking routines.
00002724                          2971  *
00002724                          2972  * Parameters -
00002724                          2973  *   Input   A1      The data that needs checked.
00002724                          2974  *   Input   D1      The number of characters input     
00002724                          2975  *   Output  D3      Returns '-1' when there is an error.
00002724                          2976  *==============================================================================
00002724                          2977  
00002724                          2978  enter_addr_edit_all
00002724                          2979  
00002724                          2980  *------------------------------------------------------------------------------
00002724                          2981  * Test for odd number of characters entered, not allowed
00002724                          2982  *------------------------------------------------------------------------------
00002724                          2983         
00002724  6100 0024               2984          BSR         ck_boundry          ;check if the input is on a odd / even boundry
00002728  B67C FFFF               2985          CMP.W       #-1,D3              ;Is the address odd?
0000272C  6700 001A               2986          BEQ         enter_addr_edit_all_exit     ;No, return
00002730                          2987  
00002730                          2988  *------------------------------------------------------------------------------
00002730                          2989  * Ttest for character entered all being valid address characters
00002730                          2990  * Note: lower case a-f, gets converted to upper case A-F in D3
00002730                          2991  *------------------------------------------------------------------------------
00002730                          2992          
00002730  6100 004E               2993          BSR         parseHexString      ;check if the input contains valid Hex characters
00002734  B67C FFFF               2994          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
00002738  6700 000E               2995          BEQ         enter_addr_edit_all_exit     ;No, return
0000273C                          2996  
0000273C                          2997  *------------------------------------------------------------------------------
0000273C                          2998  * Verify that the address entered is witin the range defined in the Equate
0000273C                          2999  *------------------------------------------------------------------------------        
0000273C                          3000          
0000273C  6100 00B0               3001          BSR         ck_addr_range       ;is address entered witin the range 
00002740                          3002                                          ;   as defined in the Equate? 
00002740  B67C FFFF               3003          CMP.W       #-1,D3              ;is the address  valid?
00002744  6700 0002               3004          BEQ         enter_addr_edit_all_exit     ;No, return
00002748                          3005  
00002748                          3006  enter_addr_edit_all_exit:
00002748                          3007  
00002748  4E75                    3008          RTS                             ;return
0000274A                          3009  
0000274A                          3010  *==============================================================================
0000274A                          3011  * ck_boundry - Check the size of the data characters input and determine
0000274A                          3012  *              if an odd number of characters was entered
0000274A                          3013  *
0000274A                          3014  * Parameters -
0000274A                          3015  *   Input   A1      The data that needs checked for odd length.
0000274A                          3016  *   Input   D1      The number of characters input     
0000274A                          3017  *   Output  D3      Returns '-1' when there is an odd length.
0000274A                          3018  *==============================================================================
0000274A                          3019  
0000274A                          3020  ck_boundry:
0000274A                          3021  
0000274A  4243                    3022          CLR.W       D3                  ;Clear the return
0000274C                          3023  
0000274C  B23C 0000               3024          CMP.B       #0,D1               ;Check for nothing entered
00002750  6700 001A               3025          BEQ         ck_size_error       ;Number of characters entered must be 
00002754                          3026                                          ;greater than 0  
00002754                          3027          
00002754                          3028          
00002754                          3029          * The program will branch to ck_size_error if D1 is greater than #8        
00002754  B23C 0008               3030          CMP.B       #8,D1               ;Check for more than 8 characters entered
00002758  6E00 0012               3031          BGT         ck_size_error       ;Number of characters entered must be less
0000275C                          3032                                          ;than 9
0000275C                          3033          
0000275C                          3034    
0000275C  4E75                    3035          RTS                             ;return
0000275E                          3036  
0000275E                          3037  *------------------------------------------------------------------------------
0000275E                          3038  * ck_boundry_error - An odd number of characters was entered
0000275E                          3039  *                  - Load error message and display it
0000275E                          3040  *                  - Return error condition
0000275E                          3041  *------------------------------------------------------------------------------
0000275E                          3042          
0000275E                          3043  ck_boundry_error:
0000275E                          3044  
0000275E  43F9 00002C2D           3045          LEA         even_msg,A1         ;Load odd error message into A1
00002764                          3046                  
00002764  700D                    3047          MOVE.L      #13,D0              ;Display null-terminated string at (A1), 
00002766                          3048                                          ;with CR, LF. 
00002766  4E4F                    3049          TRAP #15                        ;Display the error message
00002768  76FF                    3050          MOVE.L #-1,D3                   ;Load -1 into return parameter
0000276A  4E75                    3051          RTS                             ;Return
0000276C                          3052          
0000276C                          3053  *------------------------------------------------------------------------------
0000276C                          3054  * ck_size_error -   The number of characters entered must be more than zero
0000276C                          3055  *                  - Load error message and display it
0000276C                          3056  *                  - Return error condition
0000276C                          3057  *------------------------------------------------------------------------------
0000276C                          3058          
0000276C                          3059  ck_size_error:
0000276C                          3060  
0000276C  43F9 00002BA0           3061          LEA         invalidMsg,A1       ;Load invalid range message into A1
00002772  2239 00002BA0           3062          MOVE.L      invalidMsg,D1       ;Load error length to D1
00002778                          3063          
00002778  7000                    3064          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
0000277A                          3065                                          ; n is D1.W with CR, LF. 
0000277A  4E4F                    3066          TRAP        #15                 ;Display the error message
0000277C  76FF                    3067          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000277E  4E75                    3068          RTS                             ;Return        
00002780                          3069  
00002780                          3070  *==============================================================================
00002780                          3071  * parseHexString - Converts user input string into a valid memory address
00002780                          3072  *                - Stores parsed address data into D3
00002780                          3073  *                - Stores good/bad (1/0) data in D4 
00002780                          3074  *
00002780                          3075  * Hex values are stored as bytes in D2, the ASCII chart shows their value
00002780                          3076  *   The ASCII chart values we care about are in the ranges of: 
00002780                          3077  *                            Hex            Decimal
00002780                          3078  *       No Value           NULL = 0         0
00002780                          3079  *       Numeric Values:     0-9 = 30-39     48-57
00002780                          3080  *       Upper Case letters: A-F = 41-46     65-70
00002780                          3081  *       Lower Case letterc: a-f = 61-66     97-102
00002780                          3082  
00002780                          3083  * Parameters -
00002780                          3084  *   Input   A1      The data that needs checked for valid input.
00002780                          3085  *   Output  D3      The return value, '-1' for error
00002780                          3086  *==============================================================================
00002780                          3087  
00002780                          3088  parseHexString:
00002780                          3089  
00002780                          3090  * setup any initializing item that do not get looped through
00002780  4243                    3091          CLR.W       D3                  ;Clear the return
00002782                          3092  
00002782                          3093          
00002782                          3094  *------------------------------------------------------------------------------
00002782                          3095  * NextHex - Loop through all bytes and vaildate the input
00002782                          3096  * Parameters -
00002782                          3097  *   Input   A1      The data that needs checked for valid input.
00002782                          3098  *   Output  D3      The return value, '-1' for error
00002782                          3099  *------------------------------------------------------------------------------
00002782                          3100          
00002782                          3101  NextHex:
00002782                          3102  
00002782  1419                    3103          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00002784  B43C 0000               3104          CMP.B       #0,D2               ;Check character for null 
00002788  6700 0062               3105          BEQ         NextHexReturn       ;Character is null (end of input)
0000278C                          3106          
0000278C                          3107  *................................................................................
0000278C                          3108  *  Check decimal values 0-9 by testing hexadecimal values 30-39
0000278C                          3109  *................................................................................
0000278C                          3110                  
0000278C                          3111          * The program will branch to hex_range_error if D2 is less than #30
0000278C  B43C 0030               3112          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
00002790  6D00 0048               3113          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00002794                          3114                                          ;processing
00002794                          3115          
00002794                          3116          * The program will branch to UcaseHex if D2 is greater than #39
00002794  B43C 0039               3117          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
00002798  6E00 000A               3118          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
0000279C                          3119          
0000279C                          3120          *a valid number was found within this range
0000279C  0402 0030               3121          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
000027A0  6000 0032               3122          BRA         NextHexDone         ;Done parsing this byte
000027A4                          3123  
000027A4                          3124  
000027A4                          3125  *..............................................................................
000027A4                          3126  *  Check upper case values A-F by testing hexadecimal values 41-46
000027A4                          3127  *..............................................................................
000027A4                          3128  
000027A4                          3129  UcaseHex:
000027A4                          3130  
000027A4                          3131          * The program will branch to hex_range_error if D2 is less than #41
000027A4  B43C 0041               3132          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
000027A8  6D00 0030               3133          BLT         hex_range_error     ;Branch to handle range error hexidecimal
000027AC                          3134                                          ;processing
000027AC                          3135          
000027AC  B43C 0046               3136          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
000027B0  6E00 000A               3137          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
000027B4                          3138                                          ;processing
000027B4                          3139          
000027B4                          3140          *a valid number was found within this range
000027B4  0402 0037               3141          SUBI.B      #55,D2              ;Change uppercase character to actual value
000027B8  6000 001A               3142          BRA         NextHexDone         ;Done parsing this byte
000027BC                          3143  
000027BC                          3144  
000027BC                          3145  *..............................................................................
000027BC                          3146  *  Check lower case values a-f by testing hexadecimal values 61-66
000027BC                          3147  *..............................................................................
000027BC                          3148  
000027BC                          3149  LcaseHex
000027BC                          3150          
000027BC                          3151          * The program will branch to hex_range_error if D2 is less than #61
000027BC  B43C 0061               3152          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
000027C0  6D00 0018               3153          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
000027C4                          3154                                          ;processing
000027C4                          3155  
000027C4  B43C 0066               3156          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
000027C8  6E00 0010               3157          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
000027CC                          3158                                          ;processing
000027CC                          3159  
000027CC                          3160          *a valid number was found within this range
000027CC  0402 0057               3161          SUBI.B      #87,D2              ;Change lowercase character to actual value
000027D0  6000 0002               3162          BRA         NextHexDone         ;Done parsing this byte
000027D4                          3163  
000027D4                          3164  NextHexDone:
000027D4                          3165  
000027D4  E983                    3166          ASL.L       #4,D3               ; Make rooom for new byte in the return register
000027D6  D602                    3167          ADD.B       D2,D3               ; Move the new byte into the return register
000027D8  60A8                    3168          BRA         NextHex             ; We're ready to parse the next byte
000027DA                          3169          
000027DA                          3170  *-------------------------------------------------------------------------------------
000027DA                          3171  * hex_range_error -  A character entered was within the valid range for a hex address
000027DA                          3172  *                 -  Load error message and display it
000027DA                          3173  *                 -  Return error condition
000027DA                          3174  *-------------------------------------------------------------------------------------
000027DA                          3175          
000027DA                          3176  hex_range_error:
000027DA                          3177  
000027DA  43F9 00002BE5           3178          LEA         invCharMsg,A1       ;Load invalid range message into A1
000027E0  700D                    3179          MOVE.L      #13,D0               ;Display string at (A1), 
000027E2                          3180                                          ;with CR, LF. 
000027E2  4E4F                    3181          TRAP        #15                 ;Display the error message
000027E4  363C FFFF               3182          MOVE.W      #-1,D3              ;Load -1 into return parameter
000027E8  6000 0002               3183          BRA         NextHexReturn
000027EC                          3184          
000027EC                          3185  NextHexReturn:
000027EC                          3186          
000027EC  4E75                    3187          RTS                             ;Return      
000027EE                          3188  
000027EE                          3189  
000027EE                          3190  *===============================================================================
000027EE                          3191  * ck_addr_range - check the address input is within a valid memory address range
000027EE                          3192  *                - Parsed address data into D3
000027EE                          3193  *
000027EE                          3194  * Parameters -
000027EE                          3195  *   Input   A1      The data that needs checked for valid address.
000027EE                          3196  *   Output  D3      The return value, '-1' for error
000027EE                          3197  *===============================================================================
000027EE                          3198  
000027EE                          3199  
000027EE                          3200  ck_addr_range:   
000027EE                          3201  
000027EE                          3202  *------------------------------------------------------------------------------
000027EE                          3203  * Verify that the address entered is witin the 
000027EE                          3204  * beginning range ('begin') as defined in the Equate
000027EE                          3205  *------------------------------------------------------------------------------   
000027EE                          3206              
000027EE  7C00                    3207          MOVE.L      #begin,D6           * Load minimum starting address
000027F0  B686                    3208          CMP.L       D6,D3               * Is input at or above minimum?
000027F2  6D00 0012               3209          BLT         ck_addr_range_error 
000027F6                          3210          
000027F6                          3211  *------------------------------------------------------------------------------
000027F6                          3212  * Verify that the address entered is witin the 
000027F6                          3213  * ending range ('end') as defined in the Equate
000027F6                          3214  *------------------------------------------------------------------------------
000027F6                          3215          
000027F6  2C3C 00FFFFFE           3216          MOVE.L      #end,D6             * Load maximum starting address
000027FC  B686                    3217          CMP.L       D6,D3               * Is input at or below maximum?
000027FE  6E00 0006               3218          BGT         ck_addr_range_error 
00002802  6000 0012               3219          BRA         ck_addr_done        ;done checking
00002806                          3220          
00002806                          3221  *..............................................................................
00002806                          3222  * ck_addr_range_error -  A address entered is not within the 
00002806                          3223  *                        valid range for a hex address
00002806                          3224  *..............................................................................
00002806                          3225          
00002806                          3226  ck_addr_range_error
00002806                          3227  
00002806  43F9 00002BA0           3228          LEA         invalidMsg,A1       ;Load invalid range message into A1
0000280C                          3229          
0000280C  700D                    3230          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
0000280E                          3231                                          ;with CR, LF. 
0000280E  4E4F                    3232          TRAP        #15                 ;Display the error message
00002810  76FF                    3233          MOVE.L      #-1,D3              ;Load -1 into return parameter
00002812  6000 0002               3234          BRA         ck_addr_done 
00002816                          3235  
00002816                          3236  ck_addr_done:
00002816                          3237  
00002816  4E75                    3238          RTS                             ;Return
00002818                          3239          
00002818                          3240  *------------------------------------------------------------------------------
00002818                          3241  * enter_addr_edit_to -  Test for to date coming before a from date
00002818                          3242  *                    - Return error condition
00002818                          3243  *------------------------------------------------------------------------------
00002818                          3244  
00002818                          3245  enter_addr_edit_to
00002818                          3246  
00002818                          3247          ;MOVE.L      (A3),D6             * Load starting address
00002818                          3248          
00002818  2C43                    3249          MOVEA.L     D3,A6               ;Ending address gets stored in A6 for compare
0000281A  BDCB                    3250          CMPA.L      A3,A6               * Is input at or above minimum?
0000281C  6D00 0004               3251          BLT         enter_addr_edit_to_error 
00002820                          3252          
00002820                          3253  
00002820                          3254  enter_addr_edit_to_return
00002820                          3255  
00002820  4E75                    3256          RTS
00002822                          3257          
00002822                          3258  *------------------------------------------------------------------------------
00002822                          3259  * enter_addr_edit_to_error - To address can not be before from address
00002822                          3260  *                          - Load error message and display it
00002822                          3261  *                          - Return error condition
00002822                          3262  *------------------------------------------------------------------------------
00002822                          3263          
00002822                          3264  enter_addr_edit_to_error:
00002822                          3265  
00002822  43F9 00002C4E           3266          LEA         to_from_err,A1      ;Load to address error message into A1
00002828  7250                    3267          MOVE.L      #80,D1              ;Load to address error length to D1
0000282A                          3268          
0000282A  7000                    3269          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
0000282C                          3270                                          ; n is D1.W with CR, LF. 
0000282C  4E4F                    3271          TRAP #15                        ;Display the error message
0000282E  76FF                    3272          MOVE.L #-1,D3                   ;Load -1 into return parameter
00002830  4E75                    3273          RTS                             ;Return
00002832                          3274          
00002832                          3275   
00002832                          3276  *******************************************************************************
00002832                          3277  *                          OP CODE ROLE ROUTINES
00002832                          3278  *******************************************************************************
00002832                          3279  
00002832                          3280  process_op_codes:
00002832                          3281  
00002832                          3282  
00002832                          3283  
00002832                          3284  process_op_codes_exit:
00002832                          3285  
00002832  4E75                    3286          RTS
00002834                          3287  
00002834                          3288  
00002834                          3289  *******************************************************************************
00002834                          3290  *                    Effective Addressing ROLE ROUTINES
00002834                          3291  *******************************************************************************
00002834                          3292  
00002834                          3293  Get_Effective_Address:
00002834                          3294  
00002834  48E7 0200               3295          MOVEM.L D6,-(SP)                ;save D6 data
00002838  1C05                    3296          MOVE.B      D5,D6
0000283A  E60E                    3297          LSR.B       #3,D6               ;mode
0000283C  CA3C 0007               3298          And.B       #%00000111,D5       ;register
00002840                          3299          
00002840  BC3C 0000               3300          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
00002844  6700 004A               3301          BEQ         Data_Reg_Direct
00002848                          3302          
00002848  BC3C 0001               3303          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
0000284C  6700 005C               3304          BEQ         Addr_Reg_Direct
00002850                          3305          
00002850  BC3C 0002               3306          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
00002854  6700 006E               3307          BEQ         Addr_Reg_Indirect
00002858                          3308          
00002858  BC3C 0003               3309          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
0000285C  6700 0098               3310          BEQ         Addr_Reg_Indirect_Inc
00002860                          3311          
00002860  BC3C 0004               3312          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
00002864  6700 00CE               3313          BEQ         Addr_Reg_Indirect_Dec
00002868                          3314          
00002868  BC3C 0007               3315          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
0000286C  6700 0006               3316          BEQ         Get_Effective_Address_Other
00002870                          3317          
00002870  6000 015A               3318          BRA         invalidEA
00002874                          3319          
00002874                          3320  Get_Effective_Address_Other:        
00002874                          3321          
00002874  BA3C 0000               3322          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00002878  6700 00F8               3323          BEQ Addr_Abs_Short
0000287C                          3324          
0000287C  BA3C 0001               3325          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
00002880  6700 010A               3326          BEQ Addr_Abs_Long
00002884                          3327          
00002884  BA3C 0004               3328          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
00002888  6700 011C               3329          BEQ Addr_Immediate_Data
0000288C                          3330          
0000288C  6000 013E               3331          BRA         invalidEA
00002890                          3332          
00002890                          3333  Data_Reg_Direct:                        ;case 0(0000)
00002890                          3334  
00002890  43F9 00002DE5           3335          LEA         letterD,A1          ;output 'D' for data register
00002896  103C 000E               3336          MOVE.B      #14,D0              ;set for task to display null terminated 
0000289A  4E4F                    3337          TRAP        #15                 ;string without CR, LF
0000289C                          3338                          
0000289C  4281                    3339          CLR.L       D1
0000289E  1205                    3340          MOVE.B      D5,D1               ;move register number for display into D1
000028A0  103C 0003               3341          MOVE.B      #3,D0               ;set for task to display null terminated 
000028A4  4E4F                    3342          TRAP        #15                 ;string without CR, LF
000028A6                          3343                 
000028A6  6000 0124               3344          BRA         Get_Effective_Address_Exit  ;return
000028AA                          3345          
000028AA                          3346          
000028AA                          3347  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
000028AA                          3348        
000028AA  43F9 00002DE3           3349          LEA         letterA,A1          ;output 'A' for address register
000028B0  103C 000E               3350          MOVE.B      #14,D0              ;set for task to display null terminated 
000028B4  4E4F                    3351          TRAP        #15                 ;string without CR, LF
000028B6                          3352          
000028B6  4281                    3353          CLR.L       D1
000028B8  1205                    3354          MOVE.B      D5,D1               ;move register number for display into D1
000028BA  103C 0003               3355          MOVE.B      #3,D0               ;set for task to display null terminated 
000028BE  4E4F                    3356          TRAP        #15                 ;string without CR, LF
000028C0                          3357          
000028C0  6000 010A               3358          BRA         Get_Effective_Address_Exit  ;return
000028C4                          3359  
000028C4                          3360  
000028C4                          3361  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
000028C4                          3362          
000028C4  43F9 00002DEB           3363          LEA         lprn,A1             ;output 'D' for data register
000028CA  103C 000E               3364          MOVE.B      #14,D0              ;set for task to display null terminated 
000028CE  4E4F                    3365          TRAP        #15                 ;string without CR, LF
000028D0                          3366  
000028D0  43F9 00002DE3           3367          LEA         letterA,A1          ;output 'A' for address register
000028D6  103C 000E               3368          MOVE.B      #14,D0              ;set for task to display null terminated 
000028DA  4E4F                    3369          TRAP        #15                 ;string without CR, LF
000028DC                          3370          
000028DC  4281                    3371          CLR.L       D1
000028DE  1205                    3372          MOVE.B      D5,D1               ;move register number for display into D1
000028E0  103C 0003               3373          MOVE.B      #3,D0               ;set for task to display null terminated 
000028E4  4E4F                    3374          TRAP        #15                 ;string without CR, LF
000028E6                          3375  
000028E6  43F9 00002DED           3376          LEA         rprn,A1             ;output 'D' for data register
000028EC  103C 000E               3377          MOVE.B      #14,D0              ;set for task to display null terminated 
000028F0  4E4F                    3378          TRAP        #15                 ;string without CR, LF
000028F2                          3379          
000028F2  6000 00D8               3380          BRA         Get_Effective_Address_Exit  ;return
000028F6                          3381  
000028F6                          3382                 
000028F6                          3383  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
000028F6                          3384  
000028F6  43F9 00002DEB           3385          LEA         lprn,A1             ;output 'D' for data register
000028FC  103C 000E               3386          MOVE.B      #14,D0              ;set for task to display null terminated 
00002900  4E4F                    3387          TRAP        #15                 ;string without CR, LF
00002902                          3388  
00002902  43F9 00002DE3           3389          LEA         letterA,A1          ;output 'A' for address register
00002908  103C 000E               3390          MOVE.B      #14,D0              ;set for task to display null terminated 
0000290C  4E4F                    3391          TRAP        #15                 ;string without CR, LF
0000290E                          3392          
0000290E  4281                    3393          CLR.L       D1
00002910  1205                    3394          MOVE.B      D5,D1               ;move register number for display into D1
00002912  103C 0003               3395          MOVE.B      #3,D0               ;set for task to display null terminated 
00002916  4E4F                    3396          TRAP        #15                 ;string without CR, LF
00002918                          3397  
00002918  43F9 00002DED           3398          LEA         rprn,A1             ;output 'D' for data register
0000291E  103C 000E               3399          MOVE.B      #14,D0              ;set for task to display null terminated 
00002922  4E4F                    3400          TRAP        #15                 ;string without CR, LF
00002924                          3401          
00002924  43F9 00002DE7           3402          LEA         plus,A1             ;output 'D' for data register
0000292A  103C 000E               3403          MOVE.B      #14,D0              ;set for task to display null terminated 
0000292E  4E4F                    3404          TRAP        #15                 ;string without CR, LF
00002930                          3405          
00002930  6000 009A               3406          BRA         Get_Effective_Address_Exit  ;return
00002934                          3407  
00002934                          3408  Addr_Reg_Indirect_Dec                   ;4 = ?(An) - Address Register Indirect with Predecrement (100)
00002934                          3409  
00002934  43F9 00002DE9           3410          LEA         minus,A1            ;output '-' for Predecrement
0000293A  103C 000E               3411          MOVE.B      #14,D0              ;set for task to display null terminated 
0000293E  4E4F                    3412          TRAP        #15                 ;string without CR, LF
00002940                          3413  
00002940  43F9 00002DEB           3414          LEA         lprn,A1             ;output 'D' for data register
00002946  103C 000E               3415          MOVE.B      #14,D0              ;set for task to display null terminated 
0000294A  4E4F                    3416          TRAP        #15                 ;string without CR, LF
0000294C                          3417  
0000294C  43F9 00002DE3           3418          LEA         letterA,A1          ;output 'A' for address register
00002952  103C 000E               3419          MOVE.B      #14,D0              ;set for task to display null terminated 
00002956  4E4F                    3420          TRAP        #15                 ;string without CR, LF
00002958                          3421          
00002958  4281                    3422          CLR.L       D1
0000295A  1205                    3423          MOVE.B      D5,D1               ;move register number for display into D1
0000295C  103C 0003               3424          MOVE.B      #3,D0               ;set for task to display null terminated 
00002960  4E4F                    3425          TRAP        #15                 ;string without CR, LF
00002962                          3426  
00002962  43F9 00002DED           3427          LEA         rprn,A1             ;output 'D' for data register
00002968  103C 000E               3428          MOVE.B      #14,D0              ;set for task to display null terminated 
0000296C  4E4F                    3429          TRAP        #15                 ;string without CR, LF
0000296E                          3430          
0000296E  6000 005C               3431          BRA         Get_Effective_Address_Exit  ;return
00002972                          3432          
00002972                          3433                         
00002972                          3434  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00002972                          3435          
00002972                          3436          
00002972  548B                    3437          ADDA.L      #word,A3            ;move past instruction
00002974                          3438          
00002974                          3439          ;print word (A3)
00002974  48E7 1200               3440          MOVEM.L     D6/D3,-(SP)
00002978  1C3C 0001               3441          MOVE.B      #1,D6               ;put size of word in D6
0000297C  3613                    3442          MOVE.W      (A3),D3             ;move data at (A3) to D3
0000297E  6100 00D8               3443          BSR         outputHex
00002982  4CDF 0048               3444          MOVEM.L     (SP)+,D6/D3
00002986                          3445          
00002986  5487                    3446          ADDI.L      #word,D7 
00002988  6000 0042               3447          BRA         Get_Effective_Address_Exit  ;return
0000298C                          3448                         
0000298C                          3449  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
0000298C                          3450          
0000298C  548B                    3451          ADDA.L      #word,A3
0000298E                          3452          
0000298E                          3453          ;print long (A3)
0000298E  48E7 1200               3454          MOVEM.L     D6/D3,-(SP)
00002992  1C3C 0002               3455          MOVE.B      #2,D6               ;put size of word in D6
00002996  2613                    3456          MOVE.L      (A3),D3             ;move data at (A3) to D3
00002998  6100 00BE               3457          BSR         outputHex
0000299C  4CDF 0048               3458          MOVEM.L     (SP)+,D6/D3
000029A0                          3459  
000029A0                          3460          
000029A0  5887                    3461          ADDI.L      #long,D7
000029A2  6000 0028               3462          BRA         Get_Effective_Address_Exit  ;return
000029A6                          3463                         
000029A6                          3464  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
000029A6                          3465          
000029A6  4CDF 0040               3466          MOVEM.L     (SP)+,D6            ;restore D6 data
000029AA  48E7 0200               3467          MOVEM.L     D6,-(SP)            ;save D6 data again to balance stack
000029AE                          3468  
000029AE                          3469          ;print '#'
000029AE  48E7 4000               3470          MOVEM.L     D1,-(SP)            ;save D1 to the stack
000029B2  123C 0023               3471          MOVE.B      #'#',D1             ;put ascii value of char in D1
000029B6  103C 0006               3472          MOVE.B      #6,D0               ;move task 6 into D0
000029BA  4E4F                    3473          TRAP        #15                 ;print char
000029BC  4CDF 0002               3474          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
000029C0                          3475          
000029C0  0C06 0001               3476          CMPI.B      #1,D6
000029C4  6FAC                    3477          BLE         Addr_Abs_Short
000029C6  6EC4                    3478          BGT         Addr_Abs_Long
000029C8                          3479          
000029C8  6000 0002               3480          BRA         Get_Effective_Address_Exit  ;return
000029CC                          3481  
000029CC                          3482  invalidEA:
000029CC                          3483  
000029CC                          3484          ;do something
000029CC                          3485   
000029CC                          3486  Get_Effective_Address_Exit:     
000029CC                          3487  
000029CC  4CDF 0040               3488          MOVEM.L     (SP)+,D6            ;restore D6 data
000029D0  4E75                    3489          RTS                             ;return
000029D2                          3490  
000029D2                          3491  ***assume size in D6. 00 = byte, 01 = word, 10 = long
000029D2                          3492  printSize:
000029D2  48E7 C000               3493          MOVEM.L     D0/D1,-(SP)
000029D6                          3494          
000029D6                          3495          ;print '.'
000029D6  48E7 4000               3496          MOVEM.L     D1,-(SP)            ;save D1 to the stack
000029DA  123C 002E               3497          MOVE.B      #'.',D1             ;put ascii value of char in D1
000029DE  103C 0006               3498          MOVE.B      #6,D0               ;move task 6 into D0
000029E2  4E4F                    3499          TRAP        #15                 ;print char
000029E4  4CDF 0002               3500          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
000029E8                          3501          
000029E8  0C06 0001               3502          CMPI.B      #1,D6
000029EC  6D00 0022               3503          BLT         printByteSize
000029F0  6700 0032               3504          BEQ         printWordSize
000029F4  6E00 0042               3505          BGT         printLongSize
000029F8                          3506          
000029F8                          3507  printSizeDone:
000029F8                          3508  
000029F8                          3509          ;print ' '
000029F8  48E7 4000               3510          MOVEM.L     D1,-(SP)            ;save D1 to the stack
000029FC  123C 0020               3511          MOVE.B      #' ',D1             ;put ascii value of char in D1
00002A00  103C 0006               3512          MOVE.B      #6,D0               ;move task 6 into D0
00002A04  4E4F                    3513          TRAP        #15                 ;print char
00002A06  4CDF 0002               3514          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
00002A0A                          3515          
00002A0A  4CDF 0003               3516          MOVEM.L     (SP)+,D0/D1
00002A0E  4E75                    3517          RTS
00002A10                          3518          
00002A10                          3519  printByteSize:
00002A10                          3520          ;print 'B'
00002A10  48E7 4000               3521          MOVEM.L     D1,-(SP)            ;save D1 to the stack
00002A14  123C 0042               3522          MOVE.B      #'B',D1             ;put ascii value of char in D1
00002A18  103C 0006               3523          MOVE.B      #6,D0               ;move task 6 into D0
00002A1C  4E4F                    3524          TRAP        #15                 ;print char
00002A1E  4CDF 0002               3525          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
00002A22  60D4                    3526          BRA         printSizeDone
00002A24                          3527          
00002A24                          3528  printWordSize:
00002A24                          3529          ;print 'W'
00002A24  48E7 4000               3530          MOVEM.L     D1,-(SP)            ;save D1 to the stack
00002A28  123C 0057               3531          MOVE.B      #'W',D1             ;put ascii value of char in D1
00002A2C  103C 0006               3532          MOVE.B      #6,D0               ;move task 6 into D0
00002A30  4E4F                    3533          TRAP        #15                 ;print char
00002A32  4CDF 0002               3534          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
00002A36  60C0                    3535          BRA         printSizeDone
00002A38                          3536  
00002A38                          3537  printLongSize:
00002A38                          3538          ;print 'L'
00002A38  48E7 4000               3539          MOVEM.L     D1,-(SP)            ;save D1 to the stack
00002A3C  123C 004C               3540          MOVE.B      #'L',D1             ;put ascii value of char in D1
00002A40  103C 0006               3541          MOVE.B      #6,D0               ;move task 6 into D0
00002A44  4E4F                    3542          TRAP        #15                 ;print char
00002A46  4CDF 0002               3543          MOVEM.L     (SP)+,D1            ;pull D1 off the stack
00002A4A  60AC                    3544          BRA         printSizeDone       
00002A4C                          3545          
00002A4C                          3546  
00002A4C                          3547  ***assume hex to print is in D3***
00002A4C                          3548  ***assume size in D6. 00 = byte, 01 = word, 10 = long
00002A4C                          3549  
00002A4C= 00000000 00000000 ...   3550  hexoutputbuffer DC.L 0,0,0
00002A58                          3551  
00002A58                          3552  outputHex:
00002A58  48E7 B248               3553          MOVEM.L     D0/D2/D3/D6/A1/A4,-(SP)
00002A5C  49F8 2A4C               3554          LEA         hexoutputbuffer,A4
00002A60  0C06 0001               3555          CMPI.B      #1,D6
00002A64  6D00 006A               3556          BLT         hexByte
00002A68  6700 004C               3557          BEQ         hexWord
00002A6C  6E00 0016               3558          BGT         hexLong
00002A70                          3559          
00002A70                          3560  outputHexDone:
00002A70                          3561  
00002A70  18BC 0000               3562          MOVE.B      #0,(A4)
00002A74                          3563          
00002A74                          3564          ;output string of hex
00002A74  103C 000E               3565          MOVE.B      #14,D0
00002A78  43F8 2A4C               3566          LEA         hexoutputbuffer,A1
00002A7C  4E4F                    3567          TRAP        #15
00002A7E  4CDF 124D               3568          MOVEM.L     (SP)+ ,D0/D2/D3/D6/A1/A4
00002A82  4E75                    3569          RTS
00002A84                          3570          
00002A84                          3571  hexLong:
00002A84                          3572  
00002A84  E99B                    3573          ROL.L       #4,D3
00002A86  6100 0056               3574          BSR         convertHexToASCII
00002A8A  E99B                    3575          ROL.L       #4,D3
00002A8C  6100 0050               3576          BSR         convertHexToASCII
00002A90  E99B                    3577          ROL.L       #4,D3
00002A92  6100 004A               3578          BSR         convertHexToASCII
00002A96  E99B                    3579          ROL.L       #4,D3
00002A98  6100 0044               3580          BSR         convertHexToASCII
00002A9C  E99B                    3581          ROL.L       #4,D3
00002A9E  6100 003E               3582          BSR         convertHexToASCII
00002AA2  E99B                    3583          ROL.L       #4,D3
00002AA4  6100 0038               3584          BSR         convertHexToASCII
00002AA8  E99B                    3585          ROL.L       #4,D3
00002AAA  6100 0032               3586          BSR         convertHexToASCII
00002AAE  E99B                    3587          ROL.L       #4,D3
00002AB0  6100 002C               3588          BSR         convertHexToASCII
00002AB4                          3589          
00002AB4  60BA                    3590          BRA         outputHexDone
00002AB6                          3591          
00002AB6                          3592  hexWord:
00002AB6                          3593  
00002AB6  E95B                    3594          ROL.W       #4,D3
00002AB8  6100 0024               3595          BSR         convertHexToASCII
00002ABC  E95B                    3596          ROL.W       #4,D3
00002ABE  6100 001E               3597          BSR         convertHexToASCII
00002AC2  E95B                    3598          ROL.W       #4,D3
00002AC4  6100 0018               3599          BSR         convertHexToASCII
00002AC8  E95B                    3600          ROL.W       #4,D3
00002ACA  6100 0012               3601          BSR         convertHexToASCII
00002ACE                          3602  
00002ACE  60A0                    3603          BRA         outputHexDone
00002AD0                          3604          
00002AD0                          3605  hexByte:
00002AD0                          3606  
00002AD0  E91B                    3607          ROL.B       #4,D3
00002AD2  6100 000A               3608          BSR         convertHexToASCII
00002AD6  E91B                    3609          ROL.B       #4,D3
00002AD8  6100 0004               3610          BSR         convertHexToASCII
00002ADC                          3611          
00002ADC  6092                    3612          BRA         outputHexDone
00002ADE                          3613          
00002ADE                          3614  convertHexToASCII:
00002ADE                          3615  
00002ADE  1403                    3616          MOVE.B      D3,D2
00002AE0  0202 000F               3617          ANDI.B      #%00001111,D2            ;mask out all but hex at least significant nyb
00002AE4  0C02 0009               3618          CMPI.B      #9,D2
00002AE8  6F00 0006               3619          BLE         Number
00002AEC  6000 000A               3620          BRA         Letter       
00002AF0                          3621  
00002AF0                          3622  Number:
00002AF0                          3623  
00002AF0  0602 0030               3624          ADDI.B      #'0',D2
00002AF4  18C2                    3625          MOVE.B      D2,(A4)+
00002AF6  4E75                    3626          RTS
00002AF8                          3627          
00002AF8                          3628  Letter:
00002AF8                          3629  
00002AF8  0402 000A               3630          SUBI.B      #$A,D2
00002AFC  0602 0041               3631          ADDI.B      #'A',D2
00002B00  18C2                    3632          MOVE.B      D2,(A4)+
00002B02  4E75                    3633          RTS
00002B04                          3634  
00002B04                          3635  
00002B04                          3636  switchModeAndReg:
00002B04                          3637  ***
00002B04                          3638  * Assumed in D2
00002B04                          3639  *
00002B04                          3640  * Assumed that they are in least significant byte:
00002B04                          3641  *
00002B04                          3642  *            _this_
00002B04                          3643  *           /      \
00002B04                          3644  *  ........ ........
00002B04                          3645  *  \                /
00002B04                          3646  *   -----word-------
00002B04                          3647  *
00002B04                          3648  *  and that in that byte they are ordered:
00002B04                          3649  *
00002B04                          3650  *       ........   
00002B04                          3651  *       \/\_/\_/
00002B04                          3652  *      /  /    \
00002B04                          3653  *    /   /      \
00002B04                          3654  * dont  one    other
00002B04                          3655  * care
00002B04                          3656  *
00002B04                          3657  * after they will be
00002B04                          3658  *
00002B04                          3659  *       ........   
00002B04                          3660  *       \/\_/\_/
00002B04                          3661  *      /  /    \
00002B04                          3662  *    /   /      \
00002B04                          3663  * dont other    one
00002B04                          3664  * care
00002B04                          3665  *** 
00002B04  0202 003F               3666          AndI.B      #%00111111,D2       ;remove unwanted bits from D2
00002B08  0283 00000000           3667          ANDI.L      #0,D3               ;clear D3
00002B0E  1602                    3668          MOVE.B      D2,D3               ;copy to D3
00002B10  E70B                    3669          LSL.B       #3,D3 
00002B12  E60A                    3670          LSR.B       #3,D2
00002B14  D403                    3671          ADD.B       D3,D2
00002B16  4E75                    3672          RTS
00002B18                          3673  
00002B18                          3674          
00002B18                          3675  *==============================================================================
00002B18                          3676  *                            variables and constants
00002B18                          3677  *==============================================================================
00002B18                          3678      
00002B18= 45 6E 74 65 72 20 ...   3679  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE, "Q" or "q" to quit: $',0
00002B5D= 45 6E 74 65 72 20 ...   3680  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE, "Q" or "q" to quit: $',0
00002BA0                          3681  
00002BA0= 20 41 64 64 72 65 ...   3682  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
00002BE5= 20 41 20 43 68 61 ...   3683  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
00002C2D                          3684  
00002C2D= 20 59 6F 75 20 6D ...   3685  even_msg        DC.B    ' You must enter an even address!',0
00002C4E= 20 54 6F 20 61 64 ...   3686  to_from_err     DC.B    ' To address must cannot come before the from address!',0
00002C84                          3687  
00002C84= 20                      3688  spc             DC.B    ' '
00002C85= 01                      3689  spc_len         DC.B    spc_len-spc
00002C86                          3690  
00002C86                          3691  
00002C86                          3692  ***list of OP codes
00002C86                          3693  
00002C86  =00000040               3694  moveaInstruction EQU %0000000001000000
00002C86  =0000B000               3695  eorInstruction   EQU %1011000000000000
00002C86  =0000B000               3696  cmpInstruction   EQU %1011000000000000
00002C86  =00008000               3697  orInstruction    EQU %1000000000000000
00002C86  =00000880               3698  bclrdataInstruction EQU %0000100010000000
00002C86  =00000180               3699  bclrInstruction  EQU %0000000110000000
00002C86  =000041C0               3700  leaInstruction   EQU %0100000111000000
00002C86  =000081C0               3701  divsInstruction  EQU %1000000111000000
00002C86  =0000C1C0               3702  mulsInstruction  EQU %1100000111000000
00002C86  =0000E6C0               3703  rsrlweaInstruction  EQU %1110011011000000
00002C86  =0000E018               3704  rsrlregInstruction  EQU %1110000000011000
00002C86  =0000E0C0               3705  asrlweaInstruction  EQU %1110000011000000
00002C86  =0000E000               3706  asrlregInstruction  EQU %1110000000000000
00002C86  =0000E2C0               3707  lsrlweaInstruction  EQU %1110001011000000
00002C86  =0000E008               3708  lsrlregInstruction  EQU %1110000000001000
00002C86  =00005100               3709  subqInstruction  EQU %0101000100000000
00002C86  =00009000               3710  subInstruction   EQU %1001000000000000
00002C86  =0000D000               3711  addaInstruction  EQU %1101000000000000
00002C86  =0000D000               3712  addInstruction   EQU %1101000000000000
00002C86  =00004880               3713  movemInstruction EQU %0100100010000000
00002C86  =00000600               3714  addiInstruction  EQU %0000011000000000
00002C86  =00000000               3715  oriInstruction   EQU 0
00002C86  =00000C00               3716  cmpiInstruction  EQU %0000110000000000
00002C86  =00004E80               3717  jsrInstruction   EQU %0100111010000000
00002C86  =00004E75               3718  rtsInstruction   EQU %0100111001110101
00002C86  =00004E71               3719  NoOpInstruction  EQU %0100111001110001
00002C86  =00000000               3720  moveInstruction  EQU 0
00002C86  =00006000               3721  bccInstruction   EQU %0110000000000000
00002C86  =00004400               3722  negInstruction   EQU %0100010000000000
00002C86  =00000000               3723  dataInstruction  EQU 0
00002C86                          3724  
00002C86                          3725  ***
00002C86                          3726  
00002C86                          3727  ***list of OP masks
00002C86                          3728  
00002C86  =0000C1C0               3729  moveaMask EQU %1100000111000000
00002C86  =0000F000               3730  eorMask   EQU %1111000000000000
00002C86  =0000F000               3731  cmpMask   EQU %1111000000000000
00002C86  =0000F000               3732  orMask    EQU %1111000000000000
00002C86  =0000FFC0               3733  bclrdataMask EQU %1111111111000000
00002C86  =0000F1C0               3734  bclrMask  EQU %1111000111000000
00002C86  =0000F1C0               3735  leaMask   EQU %1111000111000000
00002C86  =0000F1C0               3736  divsMask  EQU %1111000111000000
00002C86  =0000F1C0               3737  mulsMask  EQU %1111000111000000
00002C86  =0000FEC0               3738  rsrlweaMask  EQU %1111111011000000
00002C86  =0000F018               3739  rsrlregMask  EQU %1111000000011000
00002C86  =0000FEC0               3740  asrlweaMask  EQU %1111111011000000
00002C86  =0000F018               3741  asrlregMask  EQU %1111000000011000
00002C86  =0000FEC0               3742  lsrlweaMask  EQU %1111111011000000
00002C86  =0000F018               3743  lsrlregMask  EQU %1111000000011000
00002C86  =0000F100               3744  subqMask  EQU %1111000100000000
00002C86  =0000F000               3745  subMask   EQU %1111000000000000
00002C86  =0000F000               3746  addaMask  EQU %1111000000000000
00002C86  =0000F000               3747  addMask   EQU %1111000000000000
00002C86  =0000FB80               3748  movemMask EQU %1111101110000000
00002C86  =0000FF00               3749  addiMask  EQU %1111111100000000
00002C86  =0000FF00               3750  oriMask   EQU %1111111100000000
00002C86  =0000FF00               3751  cmpiMask  EQU %1111111100000000
00002C86  =0000FFC0               3752  jsrMask   EQU %1111111111000000
00002C86  =0000FFFF               3753  rtsMask   EQU $FFFF
00002C86  =0000FFFF               3754  NoOpMask  EQU $FFFF
00002C86  =0000C000               3755  moveMask  EQU $C000
00002C86  =0000F000               3756  bccMask   EQU $F000
00002C86  =0000FF00               3757  negMask   EQU $FF00
00002C86  =00000000               3758  dataMask  EQU 0
00002C86                          3759  ***
00002C86                          3760  
00002C86                          3761  ***Bcc Codes***
00002C86  =00000004               3762  CC EQU $04
00002C86  =00000005               3763  CS EQU $05
00002C86  =00000007               3764  EQ EQU $07
00002C86  =0000000C               3765  GE EQU $0C
00002C86  =0000000E               3766  GT EQU $0E
00002C86  =00000002               3767  HI EQU $02
00002C86  =0000000F               3768  LE EQU $0F
00002C86  =00000003               3769  LS EQU $03
00002C86  =0000000D               3770  LT EQU $0D
00002C86  =0000000B               3771  MI EQU $0B
00002C86  =00000006               3772  NE EQU $06
00002C86  =0000000A               3773  PL EQU $0A
00002C86  =00000008               3774  VC EQU $08
00002C86  =00000009               3775  VS EQU $09
00002C86  =00000000               3776  RA EQU $00 ;not really a Condition Code
00002C86  =00000001               3777  SR EQU $01 ;not really a Condition Code
00002C86                          3778  
00002C86= 43 43 20 00             3779  CCm DC.B 'CC ',0
00002C8A= 43 53 20 00             3780  CSm DC.B 'CS ',0
00002C8E= 45 51 20 00             3781  EQm DC.B 'EQ ',0
00002C92= 47 45 20 00             3782  GEm DC.B 'GE ',0
00002C96= 47 54 20 00             3783  GTm DC.B 'GT ',0
00002C9A= 48 49 20 00             3784  HIm DC.B 'HI ',0
00002C9E= 4C 45 20 00             3785  LEm DC.B 'LE ',0
00002CA2= 4C 53 20 00             3786  LSm DC.B 'LS ',0
00002CA6= 4C 54 20 00             3787  LTm DC.B 'LT ',0
00002CAA= 4D 49 20 00             3788  MIm DC.B 'MI ',0
00002CAE= 4E 45 20 00             3789  NEm DC.B 'NE ',0
00002CB2= 50 4C 20 00             3790  PLm DC.B 'PL ',0
00002CB6= 56 43 20 00             3791  VCm DC.B 'VC ',0
00002CBA= 56 53 20 00             3792  VSm DC.B 'VS ',0
00002CBE= 52 41 20 00             3793  RAm DC.B 'RA ',0
00002CC2= 53 52 20 00             3794  SRm DC.B 'SR ',0
00002CC6                          3795  
00002CC6= 01 04 05 07 0C 0E ...   3796  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
00002CD6= 00002CC2 00002C86 ...   3797  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
00002D16                          3798  ***
00002D16                          3799  
00002D16= 45 6E 74 65 72 20 ...   3800  startLocationPrompt DC.B    'Enter start location',0
00002D2B= 45 6E 74 65 72 20 ...   3801  endLocationPrompt   DC.B    'Enter end location',0
00002D3E                          3802  
00002D3E= 0D 0A 00                3803  clearLine  DC.B $0D,$0A,0
00002D41                          3804  
00002D41= 45 4F 52 00             3805  eorMessage      DC.B 'EOR',0
00002D45= 43 4D 50 00             3806  cmpMessage      DC.B 'CMP',0
00002D49= 4F 52 00                3807  orMessage       DC.B 'OR',0
00002D4C= 42 43 4C 52 20 00       3808  bclrMessage     DC.B 'BCLR ',0
00002D52= 4C 45 41 20 00          3809  leaMessage      DC.B 'LEA ',0
00002D57= 44 49 56 53 00          3810  divsMessage     DC.B 'DIVS',0
00002D5C= 4D 55 4C 53 00          3811  mulsMessage     DC.B 'MULS',0
00002D61= 52 4F 4C 00             3812  rslMessage      DC.B 'ROL',0
00002D65= 52 4F 52 00             3813  rsrMessage      DC.B 'ROR',0
00002D69= 41 53 4C 00             3814  aslMessage      DC.B 'ASL',0
00002D6D= 41 53 52 00             3815  asrMessage      DC.B 'ASR',0
00002D71= 4C 53 4C 00             3816  lslMessage      DC.B 'LSL',0
00002D75= 4C 53 52 00             3817  lsrMessage      DC.B 'LSR',0
00002D79= 53 55 42 51 00          3818  subqMessage     DC.B 'SUBQ',0
00002D7E= 53 55 42 00             3819  subMessage      DC.B 'SUB',0 
00002D82= 41 44 44 41 00          3820  addaMessage     DC.B 'ADDA',0
00002D87= 41 44 44 00             3821  addMessage      DC.B 'ADD',0
00002D8B= 4D 4F 56 45 4D 00       3822  movemMessage    DC.B 'MOVEM',0
00002D91= 41 44 44 49 00          3823  addiMessage     DC.B 'ADDI',0
00002D96= 4F 52 49 00             3824  oriMessage      DC.B 'ORI',0
00002D9A= 43 4D 50 49 00          3825  cmpiMessage     DC.B 'CMPI',0
00002D9F= 4A 53 52 20 00          3826  jsrMessage      DC.B 'JSR ',0
00002DA4= 52 54 53 20 00          3827  rtsMessage      DC.B 'RTS ',0
00002DA9= 4E 4F 50 20 00          3828  nopMessage      DC.B 'NOP ',0 
00002DAE= 4D 4F 56 45 00          3829  moveMessage     DC.B 'MOVE',0
00002DB3= 42 00                   3830  bccMessage      DC.B 'B',0
00002DB5= 4E 45 47 00             3831  negMessage      DC.B 'NEG',0
00002DB9= 44 41 54 41 20 00       3832  dataMessage     DC.B 'DATA ',0
00002DBF= 4D 4F 56 45 41 00       3833  moveaMessage    DC.B 'MOVEA',0
00002DC5                          3834  
00002DC5= 28 78 78 78 29 2E ...   3835  xxxW            DC.B '(xxx).W: ',0
00002DCF= 28 78 78 78 29 2E ...   3836  xxxL            DC.B '(xxx).L: ',0
00002DD9= 23 28 64 61 74 61 ...   3837  iData           DC.B '#(data): ',0
00002DE3                          3838  
00002DE3= 41 00                   3839  letterA         DC.B 'A', 0
00002DE5= 44 00                   3840  letterD         DC.B 'D', 0
00002DE7                          3841  
00002DE7= 2B 00                   3842  plus            DC.B '+', 0
00002DE9= 2D 00                   3843  minus           DC.B '-', 0
00002DEB= 28 00                   3844  lPrn            DC.B '(', 0
00002DED= 29 00                   3845  rPrn            DC.B ')', 0
00002DEF                          3846  
00002DEF                          3847  
00002DEF= 50 72 65 73 73 20 ...   3848  nextAddrPrompt  DC.B 'Press "Q" or "q" to quit or any other key to enter a new starting address: ',0
00002E3B= 50 72 65 73 73 20 ...   3849  continuePrompt  DC.B 'Press "S" or "s" to stop or any other key to display the next page: ',0
00002E80= 50 72 6F 67 72 61 ...   3850  thankyoumessage DC.B 'Program Complete. Thank You!',0
00002E9D                          3851  
00002E9E= 00000000                3852  startLocation       DC.L    0
00002EA2= 00000000                3853  endLocation         DC.L    0
00002EA6                          3854  
00002EA6                          3855  
00002EA6                          3856     
00002EA6                          3857      END    START                        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 1D26
ADDA                1C60
ADDABODY            1CA8
ADDAINSTRUCTION     D000
ADDAMASK            F000
ADDAMESSAGE         2D82
ADDDEST             1DFA
ADDDESTEA           1D1A
ADDDESTEAMASKS      1D20
ADDI                217E
ADDIBODY            21AA
ADDIDONE            21FC
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         2D91
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          2D87
ADDPOSTREGDONE      205A
ADDPREREGDONE       20D6
ADDRESS_DONE        2722
ADDRESS_EXIT        271C
ADDR_ABS_LONG       298C
ADDR_ABS_SHORT      2972
ADDR_IMMEDIATE_DATA  29A6
ADDR_REG_DIRECT     28AA
ADDR_REG_INDIRECT   28C4
ADDR_REG_INDIRECT_DEC  2934
ADDR_REG_INDIRECT_INC  28F6
ADDSOURCE           1D9C
ASLEA               1878
ASLMESSAGE          2D69
ASLREG              18BE
ASREA               1868
ASRLREG             1888
ASRLREGINSTRUCTION  E000
ASRLREGMASK         F018
ASRLWEA             1828
ASRLWEACHECKDIRECTION  1854
ASRLWEAINSTRUCTION  E0C0
ASRLWEAMASK         FEC0
ASRMESSAGE          2D6D
ASRREG              18AE
BCC                 2576
BCCBYTE             25CC
BCCDONE             25FC
BCCINSTRUCTION      6000
BCCLIST             2CC6
BCCLONG             25F4
BCCMASK             F000
BCCMESSAGE          2DB3
BCCWORD             25EA
BCLR                154C
BCLRBODY            1578
BCLRDATA            14B2
BCLRDATABODY        14DE
BCLRDATAINSTRUCTION  880
BCLRDATAMASK        FFC0
BCLRINSTRUCTION     180
BCLRMASK            F1C0
BCLRMESSAGE         2D4C
BEGIN               0
BEGIN_ADDRESS       268E
BYTE                1
CC                  4
CCM                 2C86
CHECKCC             2590
CHECKCONTINUE       11AC
CHECKMOVEDEST       2402
CHECKNEXTADDR       11E6
CHECKOPCODE         1076
CHECKPOSTREGADD     2054
CHECKPREREGADD      20D0
CK_ADDR_DONE        2816
CK_ADDR_RANGE       27EE
CK_ADDR_RANGE_ERROR  2806
CK_BOUNDRY          274A
CK_BOUNDRY_ERROR    275E
CK_SIZE_ERROR       276C
CLEARLINE           2D3E
CMP                 12D2
CMPBODY             1312
CMPI                22AC
CMPIBODY            22D4
CMPIDONE            232A
CMPIEA              229E
CMPIEAMASKS         22A5
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         2D9A
CMPINSTRUCTION      B000
CMPMASK             F000
CMPMESSAGE          2D45
CONDITIONCODEMESSAGE  2CD6
CONTINUEPROMPT      2E3B
CONVERTHEXTOASCII   2ADE
CS                  5
CSM                 2C8A
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         2DB9
DATA_REG_DIRECT     2890
DIVS                165E
DIVSBODY            168A
DIVSINSTRUCTION     81C0
DIVSMASK            F1C0
DIVSMESSAGE         2D57
ELPROMPT            2B5D
END                 FFFFFE
ENDLOCATION         2EA2
ENDLOCATIONPROMPT   2D2B
END_ADDRESS         26DA
ENTER_ADDR_EDIT_ALL  2724
ENTER_ADDR_EDIT_ALL_EXIT  2748
ENTER_ADDR_EDIT_TO  2818
ENTER_ADDR_EDIT_TO_ERROR  2822
ENTER_ADDR_EDIT_TO_RETURN  2820
EOR                 1230
EORBODY             1274
EOREA               1222
EOREAMASKS          1229
EORINSTRUCTION      B000
EORMASK             F000
EORMESSAGE          2D41
EQ                  7
EQM                 2C8E
EVEN_MSG            2C2D
FALSEPOSITIVE       1096
FARLABEL            FFE
FIN                 267E
FOUNDCC             25A2
GE                  C
GEM                 2C92
GET_EFFECTIVE_ADDRESS  2834
GET_EFFECTIVE_ADDRESS_EXIT  29CC
GET_EFFECTIVE_ADDRESS_OTHER  2874
GT                  E
GTM                 2C96
HANDLEBYTEDATA      2644
HEXBYTE             2AD0
HEXLONG             2A84
HEXOUTPUTBUFFER     2A4C
HEXWORD             2AB6
HEX_RANGE_ERROR     27DA
HI                  2
HIM                 2C9A
IDATA               2DD9
INSTLABELLIST       1134
INSTLABELLIST2      113C
INSTLABELLIST3      1170
INSTMASKLIST        10F8
INSTMASKLIST2       10FC
INSTMASKLIST3       1116
INSTOPLIST          10BC
INSTOPLIST2         10C0
INSTOPLIST3         10DA
INVALIDEA           29CC
INVALIDMSG          2BA0
INVCHARMSG          2BE5
JSR                 2342
JSRBODY             236A
JSRDONE             238A
JSREA               233A
JSREAMASKS          233E
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          2D9F
LCASEHEX            27BC
LE                  F
LEA                 15DA
LEABODY             1602
LEAEA               15D2
LEAEAMASKS          15D6
LEAINSTRUCTION      41C0
LEAMASK             F1C0
LEAMESSAGE          2D52
LEM                 2C9E
LETTER              2AF8
LETTERA             2DE3
LETTERD             2DE5
LONG                4
LPRN                2DEB
LS                  3
LSLEA               1926
LSLMESSAGE          2D71
LSLREG              19A2
LSM                 2CA2
LSREA               1916
LSRLCHECKI          1A0E
LSRLCHECKIR         19F8
LSRLCHECKIRRETURN   1A0C
LSRLCHECKR          1A42
LSRLEA              18CE
LSRLEAMASKS         18D4
LSRLREG             196C
LSRLREGBODY         19B2
LSRLREGINSTRUCTION  E008
LSRLREGMASK         F018
LSRLWEA             18DA
LSRLWEABODY         1936
LSRLWEACHECKDIRECTION  1902
LSRLWEAINSTRUCTION  E2C0
LSRLWEAMASK         FEC0
LSRMESSAGE          2D75
LSRREG              1992
LT                  D
LTM                 2CA6
MAIN_LOOP           1018
MATCH               109C
MI                  B
MIM                 2CAA
MINUS               2DE9
MOVE                23DA
MOVEA               24D8
MOVEABODY           2500
MOVEADESTEA         24D4
MOVEADESTEAMASKS    24D6
MOVEAINSTRUCTION    40
MOVEAMASK           C1C0
MOVEAMESSAGE        2DBF
MOVEBODY            2430
MOVEDESTEA          23CC
MOVEDESTEAMASKS     23D3
MOVEINSTRUCTION     0
MOVEM               1E6C
MOVEMASK            C000
MOVEMESSAGE         2DAE
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     1E62
MOVEMMEMTOREGEAMASKS  1E67
MOVEMMESSAGE        2D8B
MOVEMPOST           1F2A
MOVEMPOSTREGLIST    1FB6
MOVEMPRE            1ECE
MOVEMPREREGLIST     1FD6
MOVEMREGLISTBUFFER  1F86
MOVEMREGTOMEMEA     1E58
MOVEMREGTOMEMEAMASKS  1E5D
MOVESIZE            249E
MOVESIZEBYTE        24C2
MOVESIZEDONE        24BC
MOVESIZELONG        24CE
MOVESIZEWORD        24C8
MOVESOURCEEA        23BA
MOVESOURCEEAMASKS   23C3
MULS                16FA
MULSBODY            1722
MULSEA              16EA
MULSEAMASKS         16F2
MULSINSTRUCTION     C1C0
MULSMASK            F1C0
MULSMESSAGE         2D5C
NE                  6
NEG                 2102
NEGBODY             212A
NEGDONE             215C
NEGEA               20F2
NEGEAMASKS          20FA
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          2DB5
NEGSIZE             216C
NEM                 2CAE
NEXTADDRPROMPT      2DEF
NEXTHEX             2782
NEXTHEXDONE         27D4
NEXTHEXRETURN       27EC
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 239A
NOPMESSAGE          2DA9
NUMBER              2AF0
OR                  1380
ORDEST              1454
ORI                 220C
ORIBODY             2238
ORIDONE             228E
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          2D96
ORINSTRUCTION       8000
ORMASK              F000
ORMESSAGE           2D49
ORSOURCE            13F6
ORSOURCEEA          1370
ORSOURCEEAMASKS     1378
OUTPUTHEX           2A58
OUTPUTHEXDONE       2A70
OUTPUTPOSTINCREMENT  2074
OUTPUTPREINCREMENT  1FD6
PARSEHEXSTRING      2780
PL                  A
PLM                 2CB2
PLUS                2DE7
POSTADDBACKSLASH    206E
POSTREGADD          205C
POSTREGADDDONE      2066
PREADDBACKSLASH     20EA
PREREGADD           20D8
PREREGADDDONE       20E2
PRGORG              1000
PRINTBYTESIZE       2A10
PRINTLONGSIZE       2A38
PRINTSIZE           29D2
PRINTSIZEDONE       29F8
PRINTWORDSIZE       2A24
PROCESS_OP_CODES    2832
PROCESS_OP_CODES_EXIT  2832
PROMPT_USER         1004
RA                  0
RAM                 2CBE
RPRN                2DED
RSLEA               17D2
RSLMESSAGE          2D61
RSLREG              1818
RSREA               17C2
RSRLREG             17E2
RSRLREGINSTRUCTION  E018
RSRLREGMASK         F018
RSRLWEA             1782
RSRLWEACHECKDIRECTION  17AE
RSRLWEAINSTRUCTION  E6C0
RSRLWEAMASK         FEC0
RSRMESSAGE          2D65
RSRREG              1808
RTS                 23AA
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          2DA4
SCREENLOOP          1014
SIGNEXTENDBYTE      25DE
SLPROMPT            2B18
SPC                 2C84
SPC_LEN             2C85
SR                  1
SRM                 2CC2
STACK               5000
START               1000
STARTLOCATION       2E9E
STARTLOCATIONPROMPT  2D16
SUB                 1B2A
SUBDEST             1C02
SUBINSTRUCTION      9000
SUBMASK             F000
SUBMESSAGE          2D7E
SUBQ                1A6C
SUBQBODY            1AA4
SUBQEA              1A5C
SUBQEAMASKS         1A64
SUBQINSTRUCTION     5100
SUBQMASK            F100
SUBQMESSAGE         2D79
SUBSOURCE           1BA4
SWITCHMODEANDREG    2B04
THANKYOUMESSAGE     2E80
TOEIGHT             1B26
TO_FROM_ERR         2C4E
UCASEHEX            27A4
UNKNOWNOPCODE       2616
VALIDADDA           1C7E
VALIDADDDESTEA      1D76
VALIDADDIMODES      2180
VALIDADDSOURCEEA    1D4C
VALIDASRL           182A
VALIDBCLRDATAMODES  14B4
VALIDBCLRMODES      154E
VALIDCMPEA          12E8
VALIDCMPIMODES      22AE
VALIDDIVSMODES      1660
VALIDEOREA          124E
VALIDJSRMODES       2344
VALIDLEAMODES       15DC
VALIDLSRL           18DC
VALIDMEMTOREG       1EA8
VALIDMOVEAMODES     24DA
VALIDMOVEDESTMODES  2404
VALIDMOVESOURCEMODES  23DC
VALIDMULSMODES      16FC
VALIDNEGMODES       2104
VALIDORDESTEA       13CC
VALIDORIMODES       220E
VALIDORSOURCEEA     13A6
VALIDREGTOMEM       1E82
VALIDRSRL           1784
VALIDSUBDESTEA      1B7A
VALIDSUBQ           1A7E
VALIDSUBSOURCEEA    1B50
VC                  8
VCM                 2CB6
VS                  9
VSM                 2CBA
WORD                2
XXXL                2DCF
XXXW                2DC5
ZEROTOEIGHT         1B1C
ZEROTOEIGHTRETURN   1B24

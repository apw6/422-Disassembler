00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.01
Created On: 12/13/2014 7:09:07 PM

00000000                             1  
00000000                             2  *##########################################################################
00000000                             3  * Title      : 
00000000                             4  * Written by : Andrew Watson
00000000                             5  *            : Elaine Keller
00000000                             6  *            : Robert Anderson
00000000                             7  * Date       : 11/14/2014
00000000                             8  * Description: 
00000000                             9  *##########################################################################
00000000                            10  
00000000                            11  ***Possible Bug***
00000000                            12  *can not tell data from an
00000000                            13  *unidentified instruction that is an actual
00000000                            14  *instruction therefore causing errors.
00000000                            15  *may not actually be a bug because data
00000000                            16  *is data to the machine, and if you modify
00000000                            17  *the instructions in memory for a program
00000000                            18  *by moivng data, you can modify the instuctions
00000000                            19  *executed.
00000000                            20  
00000000                            21  
00000000                            22  ***************************************************************************
00000000                            23  *                   Variable/Data Definitions
00000000                            24  ***************************************************************************
00000000                            25  
00000000  =00005000                 26  stack   EQU   $00005000
00000000  =00000000                 27  begin   EQU   $00000000
00000000  =00FFFFFE                 28  end     EQU   $00FFFFFE
00000000  =00000001                 29  byte    EQU   1
00000000  =00000002                 30  word    EQU   2
00000000  =00000004                 31  long    EQU   4
00000000  =00001000                 32  prgorg  EQU   $1000
00000000                            33  
00000FFE                            34      ORG $00000FFE
00000FFE                            35  FarLabel:
00001000                            36      ORG    prgorg
00001000                            37  start:
00001000  4FF8 5000                 38          LEA stack, SP                   ;initialize stack
00001004                            39  
00001000                            40      ORG    prgorg
00001000                            41  
00001000                            42  ******************************************************************************
00001000                            43  *                   Begin processing active code
00001000                            44  ******************************************************************************
00001000                            45      
00001000                            46  start:
00001000                            47  
00001000  4FF8 5000                 48          LEA         stack, SP           ;Initialize stack
00001004                            49          
00001004                            50  *.............................................................................
00001004                            51  * Debug Mode - Comment out when done
00001004                            52  *        MOVE.L      #snippet,A3
00001004                            53  *        MOVE.L      #snippetEnd,A4
00001004                            54  
00001004                            55  *        MOVE.L      #begin,A3
00001004                            56  *        MOVE.L      #end,A4
00001004                            57  
00001004                            58  *        MOVE.L      #$00004000,A3
00001004                            59  *        MOVE.L      #$00005000,A4
00001004                            60  
00001004                            61  *        BRA         screenLoop
00001004                            62  * Debug Mode - Comment out when done
00001004                            63  *.............................................................................        
00001004                            64          
00001004                            65  prompt_user:
00001004                            66  
00001004  6100 168A                 67          BSR         begin_address
00001008  B67C FFFF                 68          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000100C  6700 1672                 69          BEQ         fin                 ;Yes, then exit
00001010                            70          
00001010  6000 0004                 71          BRA         screenLoop
00001014                            72          ;BSR         process_op_codes
00001014  60EE                      73          BRA         prompt_user
00001016                            74                  
00001016                            75  ******************************************************************************
00001016                            76  *                   Begin processing OP Codes
00001016                            77  ******************************************************************************
00001016                            78  
00001016                            79  screenLoop:
00001016                            80  
00001016  143C 001E                 81          MOVE.B #30,D2
0000101A                            82   
0000101A                            83  main_Loop:
0000101A                            84  
0000101A  B9CB                      85          CMPA.L A3,A4                    ;check end of prog
0000101C  6F00 1662                 86          BLE fin
00001020                            87          
00001020  0C02 0000                 88          CMPI.B #0,D2
00001024  6700 0188                 89          BEQ checkContinue
00001028  5302                      90          SUBQ.B #1,D2
0000102A  48A7 2000                 91          MOVEM.W D2,-(SP)                ;save D2 for next iteration
0000102E                            92          
0000102E                            93          ;print memory location
0000102E  48E7 1200                 94          MOVEM.L D3/D6,-(SP)
00001032  7C02                      95          MOVEQ.L #2,D6                   ;set as long hex string
00001034  260B                      96          MOVE.L  A3,D3                   ;put hex in D3
00001036  6100 1A16                 97          BSR outputHex
0000103A  4CDF 0048                 98          MOVEM.L (SP)+,D3/D6
0000103E                            99          
0000103E                           100          ;print ' '
0000103E  48E7 4000                101          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001042  123C 0020                102          MOVE.B #' ',D1                  ;put ascii value of char in D1
00001046  103C 0006                103          MOVE.B #6,D0                    ;move task 6 into D0
0000104A  4E4F                     104          TRAP #15                        ;prin char
0000104C  4CDF 0002                105          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001050                           106          
00001050                           107          
00001050                           108          
00001050                           109          ;handle an odd memory access(instructions will never be misaligned)
00001050  240B                     110          MOVE.L A3,D2                    ; copy address to D2
00001052  0202 0001                111          ANDI.B #%00000001,D2            ;mask everything except the least significant bit
00001056  0C02 0001                112          CMPI.B #1,D2                    ;compare the least sig bit of the address to one
0000105A  6700 15EA                113          BEQ handlebytedata              ;the least sig bit will only be one if the insrtuction
0000105E                           114                             ;is odd(misaligned) and therefore not an instruction
0000105E                           115          
0000105E  7600                     116          MOVEQ.L #0,D3
00001060                           117          
00001060  3213                     118          MOVE.W (A3),D1                  ;copy word from other prog to analyze as instructioninstruction
00001062                           119          
00001062                           120          ***things to save A3,A4,D1(?)***
00001062  48E7 0018                121          MOVEM.L A3-A4,-(SP)
00001066  6100 0010                122          BSR checkOPcode
0000106A  4CDF 1800                123          MOVEM.L (SP)+,A3-A4
0000106E  D7C7                     124          ADDA.L  D7,A3                   ;look past data that was part of the instruction
00001070                           125          
00001070  548B                     126          ADDQ.L  #word,A3
00001072  4C9F 0004                127          MOVEM.W (SP)+,D2                ;restore D2 for next iteration
00001076  60A2                     128          BRA     main_Loop 
00001078                           129          
00001078                           130  checkOPcode:
00001078                           131  
00001078                           132  
00001078  7E00                     133          MOVEQ.L #0,D7
0000107A                           134          
0000107A  41F9 000010BE            135          LEA     instOPList,A0           ;get instruction signitrue list in A0
00001080  D1C3                     136          ADDA.L  D3,A0                   ;get correct sig         
00001082                           137          
00001082  43F9 000010FA            138          LEA     instMaskList,A1         ;get instruction mask in A1
00001088  D3C3                     139          ADDA.L  D3,A1                   ;get correct mast
0000108A                           140          
0000108A  3401                     141          MOVE.W  D1,D2                   ;move instruction into D2 for manipulaiton
0000108C                           142          
0000108C  C451                     143          AND.W   (A1),D2                 ;mask instruction
0000108E                           144          
0000108E                           145          
0000108E                           146          
0000108E                           147          
0000108E  B450                     148          CMP.W   (A0),D2                 ;compare to sig
00001090  6700 000C                149          BEQ     match                   ;if sig matches branch
00001094  5483                     150          ADDQ.L  #word,D3                ;add to D3 to check for next instruction
00001096  60E0                     151          BRA checkOPcode
00001098                           152          
00001098                           153  falsePositive:
00001098                           154          
00001098  103C 00FF                155          MOVE.B #-1,D0
0000109C  4E75                     156          RTS
0000109E                           157  
0000109E                           158  match:
0000109E                           159          
0000109E  43F9 00001136            160          LEA     instLabelList,A1        ;get instruction code label
000010A4  D3C3                     161          ADDA.L  D3,A1                   ;get correct label
000010A6  D3C3                     162          ADDA.L  D3,A1
000010A8  5483                     163          ADDQ.L  #word,D3                ;add to D3 incase false positive
000010AA  2251                     164          MOVEA.L (A1),A1
000010AC  48E7 1000                165          MOVEM.L D3,-(SP)                ; save D3
000010B0  4E91                     166          JSR     (A1)
000010B2  4CDF 0008                167          MOVEM.L (SP)+,D3                ;restore D3
000010B6  B03C 00FF                168          CMP.B   #-1,D0
000010BA  67BC                     169          BEQ     checkOPcode
000010BC  4E75                     170          RTS
000010BE                           171          
000010BE                           172  
000010BE= 0040 B000                173  instOPList  DC.W moveaInstruction,eorInstruction
000010C2= B000 8000 0880 0...      174  instOPList2 DC.W cmpInstruction,orInstruction,bclrdataInstruction,bclrInstruction,leaInstruction,divsInstruction,mulsInstruction,rsrlweaInstruction,rsrlregInstruction,asrlweaInstruction,asrlregInstruction,lsrlweaInstruction,lsrlregInstruction
000010DC= 5100 9000 D000 D...      175  instOPList3 DC.W subqInstruction,subInstruction,addaInstruction,addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruct
000010FA                           176      
000010FA= C1C0 F000                177  instMaskList  DC.W moveaMask,eorMask
000010FE= F000 F000 FFC0 F...      178  instMaskList2 DC.W cmpMask,orMask,bclrdataMask,bclrMask,leaMask,divsMask,mulsMask,rsrlweaMask,rsrlregMask,asrlweaMask,asrlregMask,lsrlweaMask,lsrlregMask
00001118= F100 F000 F000 F...      179  instMaskList3 DC.W subqMask,subMask,addaMask,addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
00001136= 000024DA 00001232        180  instLabelList  DC.L MOVEA,EOR
0000113E= 000012D4 00001382 ...    181  instLabelList2 DC.L CMP,OR,BCLRDATA,BCLR,LEA,DIVS,MULS,RSRLWEA,RSRLREG,ASRLWEA,ASRLREG,LSRLWEA,LSRLREG
00001172= 00001A6E 00001B2C ...    182  instLabelList3 DC.L SUBQ,SUB,ADDA,ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
000011AE                           183  
000011AE                           184  checkContinue:
000011AE                           185          
000011AE  48A7 6040                186          MOVEM.W D1/D2/A1,-(SP)          ;save reg that are modified just in case
000011B2                           187          
000011B2  43F9 00002DFB            188          LEA     continuePrompt,A1       ;move string
000011B8  103C 000E                189          MOVE.B  #14,D0                  ;set for task to display null terminated 
000011BC                           190                                ;string without CR, LF
000011BC  4E4F                     191          TRAP    #15
000011BE                           192          
000011BE                           193          
000011BE  103C 0005                194          MOVE.B  #5,D0                   ;set for task to read single char into D1
000011C2  4E4F                     195          TRAP    #15
000011C4                           196          
000011C4  43F9 00002CFE            197          LEA     clearLine,A1            ;move string for a CR and LF
000011CA  103C 000E                198          MOVE.B  #14,D0                  ;set for task to display null terminated 
000011CE                           199                                ;string without CR, LF
000011CE  4E4F                     200          TRAP    #15
000011D0                           201          
000011D0                           202          ;if either case of 'Q' is entered, quit the program
000011D0  0C01 0073                203          CMPI.B #'s',D1
000011D4  6700 0012                204          BEQ checkNextAddr
000011D8  0C01 0053                205          CMPI.B #'S',D1
000011DC  6700 000A                206          BEQ checkNextAddr
000011E0                           207          
000011E0  4C9F 0206                208          MOVEM.W (SP)+,D1/D2/A1
000011E4  6000 FE30                209          BRA screenLoop
000011E8                           210  
000011E8                           211  checkNextAddr:
000011E8                           212  
000011E8  43F9 00002DAF            213          LEA     nextAddrPrompt,A1  ;move string
000011EE  103C 000E                214          MOVE.B  #14,D0        ;set for task to display null terminated 
000011F2                           215                                ;string without CR, LF
000011F2  4E4F                     216          TRAP    #15
000011F4                           217          
000011F4                           218          
000011F4  103C 0005                219          MOVE.B  #5,D0         ;set for task to read single char into D1
000011F8  4E4F                     220          TRAP    #15
000011FA                           221          
000011FA  43F9 00002CFE            222          LEA     clearLine,A1  ;move string for a CR and LF
00001200  103C 000E                223          MOVE.B  #14,D0        ;set for task to display null terminated 
00001204                           224                                ;string without CR, LF
00001204  4E4F                     225          TRAP    #15
00001206                           226          
00001206  0C01 0071                227          CMPI.B #'q',D1
0000120A  6700 1474                228          BEQ fin
0000120E  0C01 0051                229          CMPI.B #'Q',D1
00001212  6700 146C                230          BEQ fin
00001216                           231          
00001216  323C FF00                232          MOVE.W #$FF00, D1     ;Clear screen value
0000121A  103C 000B                233          MOVE.B  #11,D0        ;set for task to clear screen
0000121E  4E4F                     234          TRAP    #15
00001220                           235          
00001220  6000 FDE2                236          BRA prompt_user
00001224                           237  
00001224                           238  *.............................................................................
00001224                           239  * Debug Mode begin: Comment out when done
00001224                           240  *snippet:
00001224                           241  *         NOP
00001224                           242  *         BRA snippet
00001224                           243  *         BRA FarLabel
00001224                           244  *         BEQ snippet
00001224                           245  *         BGT NEG
00001224                           246  *         BSR snippet
00001224                           247  *         MOVEA.W #$5668,A4
00001224                           248  *         NEG.B $3242
00001224                           249  *         NEG.W D2
00001224                           250  *         MOVE.B #$85,D1
00001224                           251  *         ADDI.L #30,D5
00001224                           252  *         RTS
00001224                           253  *         JSR $54
00001224                           254  *         CMPI.W #3,D1
00001224                           255  *         ORI.L  #3,D1
00001224                           256  *         MOVEM.L A3-A4,-(SP)
00001224                           257  *         MOVEM.L (SP)+,D1-A3
00001224                           258  *         ADD.B D1,D2
00001224                           259  *         ADD.B #10,D3
00001224                           260  *         ADDA.W #23,A3
00001224                           261  *         SUB.W D3,D5
00001224                           262  *         SUBQ.B #8,D5
00001224                           263  *         SUBQ.L #1,D5
00001224                           264  *         LSR.B #3,D3
00001224                           265  *         LSL.L #3,D4
00001224                           266  *         LSL.W D1,D1
00001224                           267  *         LSR.B D3,D7
00001224                           268  *         LSR $3563
00001224                           269  *         LSL $486412
00001224                           270  *         ASR.W #3,D3
00001224                           271  *         ASL.L #3,D4
00001224                           272  *         ASL.L D1,D1
00001224                           273  *         ASR.B D3,D7
00001224                           274  *         ASR.W $3563
00001224                           275  *         ASL.W $486412
00001224                           276  *         ROR.L #3,D3
00001224                           277  *         ROL.W #3,D4
00001224                           278  *         ROL.B D1,D1
00001224                           279  *         ROR D3,D7
00001224                           280  *         ROR $3563
00001224                           281  *         ROL $486412
00001224                           282  *         MULS #$4562,D2
00001224                           283  *         DIVS #$4562,D2
00001224                           284  *         LEA leaEAmasks,A1
00001224                           285  *         BCLR D1,D4
00001224                           286  *         BCLR #20,D5
00001224                           287  *         OR.B D1,D2
00001224                           288  *         OR.B #10,D3
00001224                           289  *         CMP.W D2,D5
00001224                           290  *         CMP.L (A3),D4
00001224                           291  *         EOR.W D2,D5
00001224                           292  *         EOR.L D4,(A3)
00001224                           293  *         MOVE.W #$5435,D6
00001224                           294  *         MOVE.L #$463463,D3
00001224                           295  *snippetEnd:
00001224                           296  *         SIMHALT
00001224                           297  * Debug Mode end:   Comment out when done
00001224                           298  *.............................................................................
00001224                           299           
00001224                           300           
00001224                           301           
00001224= 00 10 18 20 38 39 00     302  eorEA      Dc.B %000000,%010000,%011000,%100000,%111000,%111001,0
0000122B= 38 38 38 38 3F 3F 00     303  eorEAmasks DC.B %111000,%111000,%111000,%111000,%111111,%111111,0
00001232                           304  
00001232                           305  
00001232                           306  
00001232                           307  EOR:
00001232                           308          
00001232                           309  
00001232                           310          
00001232  7000                     311          MOVEQ.L #0, D0                  ;clear D0
00001234                           312          
00001234                           313          ;Figure out if EA is source or destination
00001234  3401                     314          MOVE.W D1,D2                    ;copy inst to D2
00001236  EC4A                     315          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001238  0202 0007                316          ANDI.B #%00000111,D2            ;mask out rest of byte
0000123C  0C02 0003                317          CMPI.B #3,D2                    ;compare to 3
00001240  6F00 FE56                318          BLE falsePositive               ;3 or less is not valid
00001244                           319          
00001244  0C02 0007                320          CMPI.B #%111,D2                 ;compare to 7
00001248  6700 FE4E                321          BEQ falsePositive               ;thats not valid
0000124C  6000 0002                322          BRA validEorEA                  ;all thats left is valid EA size 
00001250                           323          
00001250                           324  validEorEA:
00001250                           325          
00001250  43F8 122B                326          LEA eorEAmasks,A1               ;load the list of masks
00001254  D3C0                     327          ADDA.L D0,A1                    ;displace to a specific mask
00001256  1A11                     328          MOVE.B (A1),D5                  ;move the mask to D5
00001258                           329          
00001258  0C05 0000                330          CMPI.B #0,D5                    ;check if the mask is 0
0000125C  6700 FE3A                331          BEQ falsePositive               ;branch if it is
00001260                           332          
00001260  1401                     333          MOVE.B D1,D2                    ;copy instruction to D2
00001262  C405                     334          AND.B D5,D2                     ;mask D2
00001264                           335          
00001264  43F8 1224                336          LEA eorEA,A1                    ;load the list of valid modes
00001268  D3C0                     337          ADDA.L D0,A1                    ;displace to a specific mode
0000126A  1811                     338          MOVE.B (A1),D4                  ;move mode to D4
0000126C  B404                     339          CMP.B D4,D2                     ;compare mode to masked value
0000126E  6700 0006                340          BEQ  eorBody                    ;if its match, its a valid mode and we can procede
00001272                           341          
00001272  5280                     342          ADDQ.L #1,D0                    ;add one to displacement
00001274  60DA                     343          BRA validEorEA                  ;check for next mode
00001276                           344                  
00001276                           345  
00001276                           346  eorBody
00001276                           347  
00001276  43F9 00002D01            348          LEA     eorMessage,A1           ;move string for MOVE
0000127C  103C 000E                349          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001280                           350                                ;string with CR, LF
00001280  4E4F                     351          TRAP    #15
00001282                           352          
00001282  6100 0EEA                353          BSR negSize
00001286                           354          
00001286                           355          ;Do Dn
00001286                           356          
00001286  3401                     357          MOVE.W  D1,D2
00001288  E04A                     358          LSR.W   #8,D2                   ;move reg into first byte
0000128A  E20A                     359          LSR.B   #1,D2                   ;line it up to least sig bit
0000128C  C43C 0007                360          AND.B   #%00000111,D2           ;force mode to Dn
00001290  1A02                     361          MOVE.B  D2,D5
00001292  48E7 4000                362          MOVEM.L D1,-(SP)
00001296  6100 1592                363          BSR     Get_Effective_Address
0000129A  4CDF 0002                364          MOVEM.L (SP)+,D1
0000129E                           365          
0000129E                           366          
0000129E                           367          ;print ','
0000129E  48E7 4000                368          MOVEM.L D1,-(SP)                ;save D1 to the stack
000012A2  123C 002C                369          MOVE.B #',',D1                  ;put ascii value of char in D1
000012A6  103C 0006                370          MOVE.B #6,D0                    ;move task 6 into D0
000012AA  4E4F                     371          TRAP #15                        ;prin char
000012AC  4CDF 0002                372          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000012B0                           373          
000012B0                           374          ;Then do EA
000012B0                           375          
000012B0  3401                     376          MOVE.W  D1,D2                   ;check mode
000012B2  C43C 003F                377          AND.B   #%00111111,D2
000012B6  1A02                     378          MOVE.B  D2,D5
000012B8  48E7 4000                379          MOVEM.L D1,-(SP)
000012BC  6100 156C                380          BSR     Get_Effective_Address
000012C0  4CDF 0002                381          MOVEM.L (SP)+,D1
000012C4                           382          
000012C4                           383          
000012C4  43F9 00002CFE            384          LEA     clearLine,A1            ;move string for a CR and LF
000012CA  103C 000E                385          MOVE.B  #14,D0                  ;set for task to display null terminated 
000012CE                           386                                ;string without CR, LF
000012CE  4E4F                     387          TRAP    #15
000012D0                           388  
000012D0  7000                     389          MOVEQ.L #0,D0
000012D2  4E75                     390          RTS
000012D4                           391  
000012D4                           392  
000012D4                           393  
000012D4                           394  CMP:
000012D4                           395          
000012D4                           396  
000012D4                           397          
000012D4  7000                     398          MOVEQ.L #0, D0                  ;clear D0
000012D6                           399          
000012D6                           400          ;Figure out if EA is source or destination
000012D6  3401                     401          MOVE.W D1,D2                    ;copy inst to D2
000012D8  EC4A                     402          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
000012DA  0202 0007                403          ANDI.B #%00000111,D2            ;mask out rest of byte
000012DE  0C02 0002                404          CMPI.B #2,D2                    ;compare to 2
000012E2  6F00 0006                405          BLE validCmpEA                  ;2 or less is EA 
000012E6                           406          
000012E6  6000 FDB0                407          BRA falsePositive               ;thats not valid
000012EA                           408          
000012EA                           409  validCmpEA:
000012EA                           410          
000012EA  43F9 000023C5            411          LEA moveSourceEAmasks,A1        ;load the list of masks
000012F0  D3C0                     412          ADDA.L D0,A1                    ;displace to a specific mask
000012F2  1A11                     413          MOVE.B (A1),D5                  ;move the mask to D5
000012F4                           414          
000012F4  0C05 0000                415          CMPI.B #0,D5                    ;check if the mask is 0
000012F8  6700 FD9E                416          BEQ falsePositive               ;branch if it is
000012FC                           417          
000012FC  1401                     418          MOVE.B D1,D2                    ;copy instruction to D2
000012FE  C405                     419          AND.B D5,D2                     ;mask D2
00001300                           420          
00001300  43F9 000023BC            421          LEA moveSourceEA,A1             ;load the list of valid modes
00001306  D3C0                     422          ADDA.L D0,A1                    ;displace to a specific mode
00001308  1811                     423          MOVE.B (A1),D4                  ;move mode to D4
0000130A  B404                     424          CMP.B D4,D2                     ;compare mode to masked value
0000130C  6700 0006                425          BEQ  cmpBody                    ;if its match, its a valid mode and we can procede
00001310                           426          
00001310  5280                     427          ADDQ.L #1,D0                    ;add one to displacement
00001312  60D6                     428          BRA validCmpEA                  ;check for next mode
00001314                           429          
00001314                           430          
00001314                           431          
00001314                           432  cmpBody
00001314                           433  
00001314  43F9 00002D05            434          LEA     cmpMessage,A1           ;move string for MOVE
0000131A  103C 000E                435          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000131E                           436                                ;string with CR, LF
0000131E  4E4F                     437          TRAP    #15
00001320                           438          
00001320  6100 0E4C                439          BSR negSize
00001324                           440          
00001324                           441          ;do EA
00001324                           442          
00001324  3401                     443          MOVE.W  D1,D2                   ;check mode
00001326  C43C 003F                444          AND.B   #%00111111,D2
0000132A  1A02                     445          MOVE.B  D2,D5
0000132C  48E7 4000                446          MOVEM.L D1,-(SP)
00001330  6100 14F8                447          BSR     Get_Effective_Address
00001334  4CDF 0002                448          MOVEM.L (SP)+,D1
00001338                           449          
00001338                           450          ;print ','
00001338  48E7 4000                451          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000133C  123C 002C                452          MOVE.B #',',D1                  ;put ascii value of char in D1
00001340  103C 0006                453          MOVE.B #6,D0                    ;move task 6 into D0
00001344  4E4F                     454          TRAP #15                        ;prin char
00001346  4CDF 0002                455          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000134A                           456          
0000134A                           457          ;Then do Dn
0000134A                           458          
0000134A  3401                     459          MOVE.W  D1,D2
0000134C  E04A                     460          LSR.W   #8,D2                   ;move reg into first byte
0000134E  E20A                     461          LSR.B   #1,D2                   ;line it up to least sig bit
00001350  C43C 0007                462          AND.B   #%00000111,D2           ;force mode to Dn
00001354  1A02                     463          MOVE.B  D2,D5
00001356  48E7 4000                464          MOVEM.L D1,-(SP)
0000135A  6100 14CE                465          BSR     Get_Effective_Address
0000135E  4CDF 0002                466          MOVEM.L (SP)+,D1
00001362                           467          
00001362  43F9 00002CFE            468          LEA     clearLine,A1            ;move string for a CR and LF
00001368  103C 000E                469          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000136C                           470                                ;string without CR, LF
0000136C  4E4F                     471          TRAP    #15
0000136E                           472  
0000136E  7000                     473          MOVEQ.L #0,D0
00001370  4E75                     474          RTS
00001372                           475  
00001372                           476  
00001372                           477  
00001372= 00 10 18 20 38 39 ...    478  orSourceEA      Dc.B %000000,%010000,%011000,%100000,%111000,%111001,%111100,0
0000137A= 38 38 38 38 3F 3F ...    479  orSourceEAmasks DC.B %111000,%111000,%111000,%111000,%111111,%111111,%111111,0
00001382                           480  
00001382                           481  OR:
00001382                           482          
00001382                           483  
00001382                           484          
00001382  7000                     485          MOVEQ.L #0, D0                  ;clear D0
00001384                           486          
00001384                           487          ;Figure out if EA is source or destination
00001384  3401                     488          MOVE.W D1,D2                    ;copy inst to D2
00001386  EC4A                     489          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001388  0202 0007                490          ANDI.B #%00000111,D2            ;mask out rest of byte
0000138C  0C02 0002                491          CMPI.B #2,D2                    ;compare to 2
00001390  6F00 0016                492          BLE validOrSourceEA             ;2 or less is EA is source
00001394                           493          
00001394  0C02 0007                494          CMPI.B #%111,D2                 ;compare to 7
00001398  6700 FCFE                495          BEQ falsePositive               ;thats not valid
0000139C  0C02 0003                496          CMPI.B #%11,D2                  ;compare to 3
000013A0  6700 FCF6                497          BEQ falsePositive               ;also not valid
000013A4  6000 0028                498          BRA validOrDestEA               ;all thats left is valid EA as Dest 
000013A8                           499          
000013A8                           500  validORSourceEA:
000013A8                           501          
000013A8  43F8 137A                502          LEA orSourceEAmasks,A1          ;load the list of masks
000013AC  D3C0                     503          ADDA.L D0,A1                    ;displace to a specific mask
000013AE  1A11                     504          MOVE.B (A1),D5                  ;move the mask to D5
000013B0                           505          
000013B0  0C05 0000                506          CMPI.B #0,D5                    ;check if the mask is 0
000013B4  6700 FCE2                507          BEQ falsePositive               ;branch if it is
000013B8                           508          
000013B8  1401                     509          MOVE.B D1,D2                    ;copy instruction to D2
000013BA  C405                     510          AND.B D5,D2                     ;mask D2
000013BC                           511          
000013BC  43F8 1372                512          LEA orSourceEA,A1               ;load the list of valid modes
000013C0  D3C0                     513          ADDA.L D0,A1                    ;displace to a specific mode
000013C2  1811                     514          MOVE.B (A1),D4                  ;move mode to D4
000013C4  B404                     515          CMP.B D4,D2                     ;compare mode to masked value
000013C6  6700 0030                516          BEQ  orSource                   ;if its match, its a valid mode and we can procede
000013CA                           517          
000013CA  5280                     518          ADDQ.L #1,D0                    ;add one to displacement
000013CC  60DA                     519          BRA validOrSourceEA             ;check for next mode
000013CE                           520          
000013CE                           521          
000013CE                           522  validOrDestEA:
000013CE                           523          
000013CE  43F9 00001D22            524          LEA addDestEAmasks,A1           ;load the list of masks
000013D4  D3C0                     525          ADDA.L D0,A1                    ;displace to a specific mask
000013D6  1A11                     526          MOVE.B (A1),D5                  ;move the mask to D5
000013D8                           527          
000013D8  0C05 0000                528          CMPI.B #0,D5                    ;check if the mask is 0
000013DC  6700 FCBA                529          BEQ falsePositive               ;branch if it is
000013E0                           530          
000013E0  3401                     531          MOVE.W D1,D2                    ;copy instruction to D2
000013E2  C405                     532          AND.B D5,D2                     ;mask D2
000013E4                           533          
000013E4  43F9 00001D1C            534          LEA addDestEA,A1                ;load the list of valid modes
000013EA  D3C0                     535          ADDA.L D0,A1                    ;displace to a specific mode
000013EC  1811                     536          MOVE.B (A1),D4                  ;move mode to D4
000013EE  B404                     537          CMP.B D4,D2                     ;compare mode to masked value
000013F0  6700 0064                538          BEQ orDest                      ;if its match, its a valid mode and we can procede
000013F4                           539          
000013F4  5280                     540          ADDQ.L #1,D0                    ;add one to displacement
000013F6  60D6                     541          BRA validOrDestEA               ;check for next mode
000013F8                           542          
000013F8                           543  orSource
000013F8                           544  
000013F8  43F9 00002D09            545          LEA     orMessage,A1            ;move string for MOVE
000013FE  103C 000E                546          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001402                           547                                ;string with CR, LF
00001402  4E4F                     548          TRAP    #15
00001404                           549          
00001404  6100 0D68                550          BSR negSize
00001408                           551          
00001408                           552          ;do EA
00001408                           553          
00001408  3401                     554          MOVE.W  D1,D2                   ;check mode
0000140A  C43C 003F                555          AND.B   #%00111111,D2
0000140E  1A02                     556          MOVE.B  D2,D5
00001410  48E7 4000                557          MOVEM.L D1,-(SP)
00001414  6100 1414                558          BSR     Get_Effective_Address
00001418  4CDF 0002                559          MOVEM.L (SP)+,D1
0000141C                           560          
0000141C                           561          ;print ','
0000141C  48E7 4000                562          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001420  123C 002C                563          MOVE.B #',',D1                  ;put ascii value of char in D1
00001424  103C 0006                564          MOVE.B #6,D0                    ;move task 6 into D0
00001428  4E4F                     565          TRAP #15                        ;prin char
0000142A  4CDF 0002                566          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000142E                           567          
0000142E                           568          ;Then do Dn
0000142E                           569          
0000142E  3401                     570          MOVE.W  D1,D2
00001430  E04A                     571          LSR.W   #8,D2                   ;move reg into first byte
00001432  E20A                     572          LSR.B   #1,D2                   ;line it up to least sig bit
00001434  C43C 0007                573          AND.B   #%00000111,D2           ;force mode to Dn
00001438  1A02                     574          MOVE.B  D2,D5
0000143A  48E7 4000                575          MOVEM.L D1,-(SP)
0000143E  6100 13EA                576          BSR     Get_Effective_Address
00001442  4CDF 0002                577          MOVEM.L (SP)+,D1
00001446                           578          
00001446  43F9 00002CFE            579          LEA     clearLine,A1            ;move string for a CR and LF
0000144C  103C 000E                580          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001450                           581                                ;string without CR, LF
00001450  4E4F                     582          TRAP    #15
00001452                           583  
00001452  7000                     584          MOVEQ.L #0,D0
00001454  4E75                     585          RTS
00001456                           586  
00001456                           587  orDest
00001456                           588  
00001456  43F9 00002D09            589          LEA     orMessage,A1            ;move string for MOVE
0000145C  103C 000E                590          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001460                           591                                ;string with CR, LF
00001460  4E4F                     592          TRAP    #15
00001462                           593          
00001462  6100 0D0A                594          BSR negSize
00001466                           595          
00001466                           596          ;Do Dn
00001466                           597          
00001466  3401                     598          MOVE.W  D1,D2
00001468  E04A                     599          LSR.W   #8,D2                   ;move reg into first byte
0000146A  E20A                     600          LSR.B   #1,D2                   ;line it up to least sig bit
0000146C  C43C 0007                601          AND.B   #%00000111,D2           ;force mode to Dn
00001470  1A02                     602          MOVE.B  D2,D5
00001472  48E7 4000                603          MOVEM.L D1,-(SP)
00001476  6100 13B2                604          BSR     Get_Effective_Address
0000147A  4CDF 0002                605          MOVEM.L (SP)+,D1
0000147E                           606          
0000147E                           607          
0000147E                           608          ;print ','
0000147E  48E7 4000                609          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001482  123C 002C                610          MOVE.B #',',D1                  ;put ascii value of char in D1
00001486  103C 0006                611          MOVE.B #6,D0                    ;move task 6 into D0
0000148A  4E4F                     612          TRAP #15                        ;prin char
0000148C  4CDF 0002                613          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001490                           614          
00001490                           615          ;Then do EA
00001490                           616          
00001490  3401                     617          MOVE.W  D1,D2                   ;check mode
00001492  C43C 003F                618          AND.B   #%00111111,D2
00001496  1A02                     619          MOVE.B  D2,D5
00001498  48E7 4000                620          MOVEM.L D1,-(SP)
0000149C  6100 138C                621          BSR     Get_Effective_Address
000014A0  4CDF 0002                622          MOVEM.L (SP)+,D1
000014A4                           623          
000014A4                           624          
000014A4  43F9 00002CFE            625          LEA     clearLine,A1            ;move string for a CR and LF
000014AA  103C 000E                626          MOVE.B  #14,D0                  ;set for task to display null terminated 
000014AE                           627                                ;string without CR, LF
000014AE  4E4F                     628          TRAP    #15
000014B0                           629  
000014B0  7000                     630          MOVEQ.L #0,D0
000014B2  4E75                     631          RTS
000014B4                           632  
000014B4                           633  
000014B4                           634  
000014B4                           635  
000014B4                           636  BCLRDATA:
000014B4                           637  
000014B4  7000                     638          MOVEQ.L #0, D0                  ;clear D0
000014B6                           639          
000014B6                           640  validBCLRdataModes:
000014B6                           641          
000014B6  43F9 000016F4            642          LEA mulsEAmasks,A1              ;load the list of masks
000014BC  D3C0                     643          ADDA.L D0,A1                    ;displace to a specific mask
000014BE  1A11                     644          MOVE.B (A1),D5                  ;move the mask to D5
000014C0                           645          
000014C0  0C05 0000                646          CMPI.B #0,D5                    ;check if the mask is 0
000014C4  6700 FBD2                647          BEQ falsePositive               ;branch if it is
000014C8                           648          
000014C8  1401                     649          MOVE.B D1,D2                    ;copy instruction to D2
000014CA  C405                     650          AND.B D5,D2                     ;mask D2
000014CC                           651          
000014CC  43F9 000016EC            652          LEA mulsEA,A1                   ;load the list of valid modes
000014D2  D3C0                     653          ADDA.L D0,A1                    ;displace to a specific mode
000014D4  1811                     654          MOVE.B (A1),D4                  ;move mode to D4
000014D6  B404                     655          CMP.B D4,D2                     ;compare mode to masked value
000014D8  6700 0006                656          BEQ  bclrdataBody               ;if its match, its a valid mode and we can procede
000014DC                           657          
000014DC  5280                     658          ADDQ.L #1,D0                    ;add one to displacement
000014DE  60D6                     659          BRA validBCLRdataModes          ;check for next mode
000014E0                           660          
000014E0                           661  bclrdataBody:
000014E0                           662          
000014E0                           663  
000014E0                           664  
000014E0  43F9 00002D0C            665          LEA     bclrMessage,A1          ;move string for MOVE
000014E6  103C 000E                666          MOVE.B  #14,D0                  ;set for task to display null terminated 
000014EA                           667                                ;string without CR, LF
000014EA  4E4F                     668          TRAP    #15
000014EC                           669  
000014EC  48E7 C010                670          MOVEM.L D0/D1/A3,-(SP)          ;save D1 and A3
000014F0  5487                     671          ADDQ.L #word,D7                 ;signal there is a word following this instruction
000014F2                           672          
000014F2                           673          ;print '#'
000014F2  48E7 4000                674          MOVEM.L D1,-(SP)                ;save D1 to the stack
000014F6  123C 0023                675          MOVE.B #'#',D1                  ;put ascii value of char in D1
000014FA  103C 0006                676          MOVE.B #6,D0                    ;move task 6 into D0
000014FE  4E4F                     677          TRAP #15                        ;prin char
00001500  4CDF 0002                678          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001504                           679          
00001504                           680          ;get following word
00001504  548B                     681          ADDQ.L #word,A3
00001506  3213                     682          MOVE.W (A3),D1                  ;move word at (A3)
00001508  0281 0000FFFF            683          ANDI.L #$0000FFFF,D1            ;clear unimportant bit of D1
0000150E                           684          
0000150E                           685          ;print number
0000150E  103C 0003                686          MOVE.B #3,D0
00001512  4E4F                     687          TRAP #15
00001514                           688          
00001514  4CDF 0803                689          MOVEM.L (SP)+,D0/D1/A3          ;restore D1 and A3
00001518                           690  
00001518                           691  
00001518                           692  
00001518                           693          ;print ','
00001518  48E7 4000                694          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000151C  123C 002C                695          MOVE.B #',',D1                  ;put ascii value of char in D1
00001520  103C 0006                696          MOVE.B #6,D0                    ;move task 6 into D0
00001524  4E4F                     697          TRAP #15                        ;prin char
00001526  4CDF 0002                698          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000152A                           699          
0000152A                           700          ;do dest EA
0000152A  3401                     701          MOVE.W  D1,D2                   ;check mode
0000152C  C43C 003F                702          AND.B   #%00111111,D2
00001530  1A02                     703          MOVE.B  D2,D5
00001532  48E7 4000                704          MOVEM.L D1,-(SP)
00001536  6100 12F2                705          BSR     Get_Effective_Address
0000153A  4CDF 0002                706          MOVEM.L (SP)+,D1
0000153E                           707          
0000153E  43F9 00002CFE            708          LEA     clearLine,A1            ;move string for a CR and LF
00001544  103C 000E                709          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001548                           710                                ;string without CR, LF
00001548  4E4F                     711          TRAP    #15
0000154A                           712  
0000154A  7000                     713          MOVEQ.L #0,D0
0000154C  4E75                     714          RTS
0000154E                           715  
0000154E                           716  
0000154E                           717  
0000154E                           718           
0000154E                           719  BCLR:
0000154E                           720  
0000154E  7000                     721          MOVEQ.L #0, D0                  ;clear D0
00001550                           722          
00001550                           723  validBCLRModes:
00001550                           724          
00001550  43F9 000016F4            725          LEA mulsEAmasks,A1              ;load the list of masks
00001556  D3C0                     726          ADDA.L D0,A1                    ;displace to a specific mask
00001558  1A11                     727          MOVE.B (A1),D5                  ;move the mask to D5
0000155A                           728          
0000155A  0C05 0000                729          CMPI.B #0,D5                    ;check if the mask is 0
0000155E  6700 FB38                730          BEQ falsePositive               ;branch if it is
00001562                           731          
00001562  1401                     732          MOVE.B D1,D2                    ;copy instruction to D2
00001564  C405                     733          AND.B D5,D2                     ;mask D2
00001566                           734          
00001566  43F9 000016EC            735          LEA mulsEA,A1                   ;load the list of valid modes
0000156C  D3C0                     736          ADDA.L D0,A1                    ;displace to a specific mode
0000156E  1811                     737          MOVE.B (A1),D4                  ;move mode to D4
00001570  B404                     738          CMP.B D4,D2                     ;compare mode to masked value
00001572  6700 0006                739          BEQ  bclrBody                   ;if its match, its a valid mode and we can procede
00001576                           740          
00001576  5280                     741          ADDQ.L #1,D0                    ;add one to displacement
00001578  60D6                     742          BRA validBCLRModes              ;check for next mode
0000157A                           743          
0000157A                           744  bclrBody:
0000157A                           745          
0000157A                           746  
0000157A                           747  
0000157A  43F9 00002D0C            748          LEA     bclrMessage,A1          ;move string for MOVE
00001580  103C 000E                749          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001584                           750                                ;string without CR, LF
00001584  4E4F                     751          TRAP    #15
00001586                           752  
00001586                           753          ;do source EA
00001586  3401                     754          MOVE.W  D1,D2                   ;check mode
00001588  C43C 003F                755          AND.B   #%00111111,D2
0000158C  1A02                     756          MOVE.B  D2,D5
0000158E  48E7 4000                757          MOVEM.L D1,-(SP)
00001592  6100 1296                758          BSR     Get_Effective_Address
00001596  4CDF 0002                759          MOVEM.L (SP)+,D1
0000159A                           760  
0000159A                           761          ;print ','
0000159A  48E7 4000                762          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000159E  123C 002C                763          MOVE.B #',',D1                  ;put ascii value of char in D1
000015A2  103C 0006                764          MOVE.B #6,D0                    ;move task 6 into D0
000015A6  4E4F                     765          TRAP #15                        ;prin char
000015A8  4CDF 0002                766          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000015AC                           767          
000015AC                           768          ;do dest data reg
000015AC  3401                     769          MOVE.W  D1,D2                   ;check mode
000015AE  E04A                     770          LSR.W #8,D2                     ;shift reg over
000015B0  E20A                     771          LSR.B #1,D2
000015B2  C43C 0007                772          AND.B   #%00000111,D2           ;force recognition as a Dn
000015B6  1A02                     773          MOVE.B  D2,D5
000015B8  48E7 4000                774          MOVEM.L D1,-(SP)
000015BC  6100 126C                775          BSR     Get_Effective_Address
000015C0  4CDF 0002                776          MOVEM.L (SP)+,D1
000015C4                           777          
000015C4  43F9 00002CFE            778          LEA     clearLine,A1            ;move string for a CR and LF
000015CA  103C 000E                779          MOVE.B  #14,D0                  ;set for task to display null terminated 
000015CE                           780                                ;string without CR, LF
000015CE  4E4F                     781          TRAP    #15
000015D0                           782  
000015D0  7000                     783          MOVEQ.L #0,D0
000015D2  4E75                     784          RTS
000015D4                           785  
000015D4                           786           
000015D4                           787  
000015D4= 10 38 39 00              788  leaEA        DC.B %010000,%111000,%111001,0
000015D8= 38 3F 3F 00              789  leaEAmasks   DC.B %111000,%111111,%111111,0
000015DC                           790          
000015DC                           791  LEA:
000015DC                           792  
000015DC  7000                     793          MOVEQ.L #0, D0                  ;clear D0
000015DE                           794          
000015DE                           795  validLeaModes:
000015DE                           796          
000015DE  43F8 15D8                797          LEA leaEAmasks,A1               ;load the list of masks
000015E2  D3C0                     798          ADDA.L D0,A1                    ;displace to a specific mask
000015E4  1A11                     799          MOVE.B (A1),D5                  ;move the mask to D5
000015E6                           800          
000015E6  0C05 0000                801          CMPI.B #0,D5                    ;check if the mask is 0
000015EA  6700 FAAC                802          BEQ falsePositive               ;branch if it is
000015EE                           803          
000015EE  1401                     804          MOVE.B D1,D2                    ;copy instruction to D2
000015F0  C405                     805          AND.B D5,D2                     ;mask D2
000015F2                           806          
000015F2  43F8 15D4                807          LEA leaEA,A1                    ;load the list of valid modes
000015F6  D3C0                     808          ADDA.L D0,A1                    ;displace to a specific mode
000015F8  1811                     809          MOVE.B (A1),D4                  ;move mode to D4
000015FA  B404                     810          CMP.B D4,D2                     ;compare mode to masked value
000015FC  6700 0006                811          BEQ  leaBody                    ;if its match, its a valid mode and we can procede
00001600                           812          
00001600  5280                     813          ADDQ.L #1,D0                    ;add one to displacement
00001602  60DA                     814          BRA validLeaModes               ;check for next mode
00001604                           815          
00001604                           816  leaBody:
00001604                           817          
00001604                           818  
00001604                           819  
00001604  43F9 00002D12            820          LEA     leaMessage,A1           ;move string for MOVE
0000160A  103C 000E                821          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000160E                           822                                ;string without CR, LF
0000160E  4E4F                     823          TRAP    #15
00001610                           824  
00001610                           825          ;do source EA
00001610  3401                     826          MOVE.W  D1,D2                   ;check mode
00001612  C43C 003F                827          AND.B   #%00111111,D2
00001616  1A02                     828          MOVE.B  D2,D5
00001618  48E7 4000                829          MOVEM.L D1,-(SP)
0000161C  6100 120C                830          BSR     Get_Effective_Address
00001620  4CDF 0002                831          MOVEM.L (SP)+,D1
00001624                           832  
00001624                           833          ;print ','
00001624  48E7 4000                834          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001628  123C 002C                835          MOVE.B #',',D1                  ;put ascii value of char in D1
0000162C  103C 0006                836          MOVE.B #6,D0                    ;move task 6 into D0
00001630  4E4F                     837          TRAP #15                        ;prin char
00001632  4CDF 0002                838          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001636                           839          
00001636                           840          ;do dest addr reg
00001636  3401                     841          MOVE.W  D1,D2                   ;check mode
00001638  E04A                     842          LSR.W #8,D2                     ;shift reg over
0000163A  E20A                     843          LSR.B #1,D2
0000163C  C43C 0007                844          AND.B   #%00000111,D2           ;force recognition as a An
00001640  5002                     845          ADDQ.B #%1000,D2
00001642  1A02                     846          MOVE.B  D2,D5
00001644  48E7 4000                847          MOVEM.L D1,-(SP)
00001648  6100 11E0                848          BSR     Get_Effective_Address
0000164C  4CDF 0002                849          MOVEM.L (SP)+,D1
00001650                           850          
00001650  43F9 00002CFE            851          LEA     clearLine,A1            ;move string for a CR and LF
00001656  103C 000E                852          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000165A                           853                                ;string without CR, LF
0000165A  4E4F                     854          TRAP    #15
0000165C                           855  
0000165C  7000                     856          MOVEQ.L #0,D0
0000165E  4E75                     857          RTS
00001660                           858  
00001660                           859  
00001660                           860  
00001660                           861  DIVS:
00001660                           862  
00001660  7000                     863          MOVEQ.L #0, D0                  ;clear D0
00001662                           864          
00001662                           865  validDivsModes:
00001662                           866          
00001662  43F9 000016F4            867          LEA mulsEAmasks,A1              ;load the list of masks
00001668  D3C0                     868          ADDA.L D0,A1                    ;displace to a specific mask
0000166A  1A11                     869          MOVE.B (A1),D5                  ;move the mask to D5
0000166C                           870          
0000166C  0C05 0000                871          CMPI.B #0,D5                    ;check if the mask is 0
00001670  6700 FA26                872          BEQ falsePositive               ;branch if it is
00001674                           873          
00001674  1401                     874          MOVE.B D1,D2                    ;copy instruction to D2
00001676  C405                     875          AND.B D5,D2                     ;mask D2
00001678                           876          
00001678  43F9 000016EC            877          LEA mulsEA,A1                   ;load the list of valid modes
0000167E  D3C0                     878          ADDA.L D0,A1                    ;displace to a specific mode
00001680  1811                     879          MOVE.B (A1),D4                  ;move mode to D4
00001682  B404                     880          CMP.B D4,D2                     ;compare mode to masked value
00001684  6700 0006                881          BEQ  divsBody                   ;if its match, its a valid mode and we can procede
00001688                           882          
00001688  5280                     883          ADDQ.L #1,D0                    ;add one to displacement
0000168A  60D6                     884          BRA validDivsModes              ;check for next mode
0000168C                           885          
0000168C                           886  divsBody:
0000168C                           887          
0000168C                           888  
0000168C                           889  
0000168C  43F9 00002D17            890          LEA     divsMessage,A1          ;move string for MOVE
00001692  103C 000E                891          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001696                           892                                ;string without CR, LF
00001696  4E4F                     893          TRAP    #15
00001698                           894          
00001698                           895          ;set size to word
00001698  7C01                     896          MOVEQ.L #1,D6
0000169A  6100 132C                897          BSR printSize
0000169E                           898          
0000169E                           899          ;do source EA
0000169E  3401                     900          MOVE.W  D1,D2                   ;check mode
000016A0  C43C 003F                901          AND.B   #%00111111,D2
000016A4  1A02                     902          MOVE.B  D2,D5
000016A6  48E7 4000                903          MOVEM.L D1,-(SP)
000016AA  6100 117E                904          BSR     Get_Effective_Address
000016AE  4CDF 0002                905          MOVEM.L (SP)+,D1
000016B2                           906  
000016B2                           907          ;print ','
000016B2  48E7 4000                908          MOVEM.L D1,-(SP)                ;save D1 to the stack
000016B6  123C 002C                909          MOVE.B #',',D1                  ;put ascii value of char in D1
000016BA  103C 0006                910          MOVE.B #6,D0                    ;move task 6 into D0
000016BE  4E4F                     911          TRAP #15                        ;prin char
000016C0  4CDF 0002                912          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000016C4                           913          
000016C4                           914          ;do dest data reg
000016C4  3401                     915          MOVE.W  D1,D2                   ;check mode
000016C6  E04A                     916          LSR.W #8,D2                     ;shift reg over
000016C8  E20A                     917          LSR.B #1,D2
000016CA  C43C 0007                918          AND.B   #%00000111,D2           ;force recognition as a Dn
000016CE  1A02                     919          MOVE.B  D2,D5
000016D0  48E7 4000                920          MOVEM.L D1,-(SP)
000016D4  6100 1154                921          BSR     Get_Effective_Address
000016D8  4CDF 0002                922          MOVEM.L (SP)+,D1
000016DC                           923          
000016DC  43F9 00002CFE            924          LEA     clearLine,A1            ;move string for a CR and LF
000016E2  103C 000E                925          MOVE.B  #14,D0                  ;set for task to display null terminated 
000016E6                           926                                ;string without CR, LF
000016E6  4E4F                     927          TRAP    #15
000016E8                           928  
000016E8  7000                     929          MOVEQ.L #0,D0
000016EA  4E75                     930          RTS
000016EC                           931  
000016EC                           932  
000016EC                           933  
000016EC                           934  
000016EC= 00 10 18 20 38 39 ...    935  mulsEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,%111100,0
000016F4= 38 38 38 38 3F 3F ...    936  mulsEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,%111111,0
000016FC                           937          
000016FC                           938  MULS:
000016FC                           939  
000016FC  7000                     940          MOVEQ.L #0, D0                  ;clear D0
000016FE                           941          
000016FE                           942  validMulsModes:
000016FE                           943          
000016FE  43F8 16F4                944          LEA mulsEAmasks,A1              ;load the list of masks
00001702  D3C0                     945          ADDA.L D0,A1                    ;displace to a specific mask
00001704  1A11                     946          MOVE.B (A1),D5                  ;move the mask to D5
00001706                           947          
00001706  0C05 0000                948          CMPI.B #0,D5                    ;check if the mask is 0
0000170A  6700 F98C                949          BEQ falsePositive               ;branch if it is
0000170E                           950          
0000170E  1401                     951          MOVE.B D1,D2                    ;copy instruction to D2
00001710  C405                     952          AND.B D5,D2                     ;mask D2
00001712                           953          
00001712  43F8 16EC                954          LEA mulsEA,A1                   ;load the list of valid modes
00001716  D3C0                     955          ADDA.L D0,A1                    ;displace to a specific mode
00001718  1811                     956          MOVE.B (A1),D4                  ;move mode to D4
0000171A  B404                     957          CMP.B D4,D2                     ;compare mode to masked value
0000171C  6700 0006                958          BEQ  mulsBody                   ;if its match, its a valid mode and we can procede
00001720                           959          
00001720  5280                     960          ADDQ.L #1,D0                    ;add one to displacement
00001722  60DA                     961          BRA validMulsModes              ;check for next mode
00001724                           962          
00001724                           963  mulsBody:
00001724                           964          
00001724                           965  
00001724                           966  
00001724  43F9 00002D1C            967          LEA     mulsMessage,A1          ;move string for MOVE
0000172A  103C 000E                968          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000172E                           969                                ;string without CR, LF
0000172E  4E4F                     970          TRAP    #15
00001730                           971          
00001730                           972          ;set size to word
00001730  7C01                     973          MOVEQ.L #1,D6
00001732  6100 1294                974          BSR printSize
00001736                           975  
00001736                           976          ;do source EA
00001736  3401                     977          MOVE.W  D1,D2                   ;check mode
00001738  C43C 003F                978          AND.B   #%00111111,D2
0000173C  1A02                     979          MOVE.B  D2,D5
0000173E  48E7 4000                980          MOVEM.L D1,-(SP)
00001742  6100 10E6                981          BSR     Get_Effective_Address
00001746  4CDF 0002                982          MOVEM.L (SP)+,D1
0000174A                           983  
0000174A                           984          ;print ','
0000174A  48E7 4000                985          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000174E  123C 002C                986          MOVE.B #',',D1                  ;put ascii value of char in D1
00001752  103C 0006                987          MOVE.B #6,D0                    ;move task 6 into D0
00001756  4E4F                     988          TRAP #15                        ;prin char
00001758  4CDF 0002                989          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000175C                           990          
0000175C                           991          ;do dest data reg
0000175C  3401                     992          MOVE.W  D1,D2                   ;check mode
0000175E  E04A                     993          LSR.W #8,D2                     ;shift reg over
00001760  E20A                     994          LSR.B #1,D2
00001762  C43C 0007                995          AND.B   #%00000111,D2           ;force recognition as a Dn
00001766  1A02                     996          MOVE.B  D2,D5
00001768  48E7 4000                997          MOVEM.L D1,-(SP)
0000176C  6100 10BC                998          BSR     Get_Effective_Address
00001770  4CDF 0002                999          MOVEM.L (SP)+,D1
00001774                          1000          
00001774  43F9 00002CFE           1001          LEA     clearLine,A1            ;move string for a CR and LF
0000177A  103C 000E               1002          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000177E                          1003                                ;string without CR, LF
0000177E  4E4F                    1004          TRAP    #15
00001780                          1005  
00001780  7000                    1006          MOVEQ.L #0,D0
00001782  4E75                    1007          RTS
00001784                          1008  
00001784                          1009  
00001784                          1010  
00001784                          1011  RSRLWEA:
00001784                          1012          
00001784                          1013  
00001784                          1014          
00001784  7000                    1015          MOVEQ.L #0, D0                  ;clear D0
00001786                          1016          
00001786                          1017  validRSRL:
00001786                          1018          
00001786  43F9 000018D6           1019          LEA lsrlEAmasks,A1              ;load the list of masks
0000178C  D3C0                    1020          ADDA.L D0,A1                    ;displace to a specific mask
0000178E  1A11                    1021          MOVE.B (A1),D5                  ;move the mask to D5
00001790                          1022          
00001790  0C05 0000               1023          CMPI.B #0,D5                    ;check if the mask is 0
00001794  6700 F902               1024          BEQ falsePositive               ;branch if it is
00001798                          1025          
00001798  1401                    1026          MOVE.B D1,D2                    ;copy instruction to D2
0000179A  C405                    1027          AND.B D5,D2                     ;mask D2
0000179C                          1028          
0000179C  43F9 000018D0           1029          LEA lsrlEA,A1                   ;load the list of valid modes
000017A2  D3C0                    1030          ADDA.L D0,A1                    ;displace to a specific mode
000017A4  1811                    1031          MOVE.B (A1),D4                  ;move mode to D4
000017A6  B404                    1032          CMP.B D4,D2                     ;compare mode to masked value
000017A8  6700 0006               1033          BEQ  rsrlweaCheckDirection      ;if its match, its a valid mode and we can procede
000017AC                          1034          
000017AC  5280                    1035          ADDQ.L #1,D0                    ;add one to displacement
000017AE  60D6                    1036          BRA validRSRL                   ;check for next mode
000017B0                          1037  
000017B0                          1038  rsrlweaCheckDirection:
000017B0                          1039          ;Figure out which direction we are going
000017B0  3401                    1040          MOVE.W D1,D2                    ;copy inst to D2
000017B2  E04A                    1041          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
000017B4  0202 0001               1042          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
000017B8  0C02 0000               1043          CMPI.B #0,D2                    ;compare bit to zero
000017BC  6700 0006               1044          BEQ RSREA                       ;if zero, right
000017C0  6000 0012               1045          BRA RSLEA                       ;else, its left
000017C4                          1046  
000017C4                          1047  RSREA:
000017C4                          1048  
000017C4  43F9 00002D25           1049          LEA     rsrMessage,A1           ;move string for MOVE
000017CA  103C 000E               1050          MOVE.B  #14,D0                  ;set for task to display null terminated 
000017CE                          1051                                ;string with CR, LF
000017CE  4E4F                    1052          TRAP    #15
000017D0  6000 0166               1053          BRA lsrlweaBody
000017D4                          1054          
000017D4                          1055  RSLEA:
000017D4                          1056          
000017D4  43F9 00002D21           1057          LEA     rslMessage,A1           ;move string for MOVE
000017DA  103C 000E               1058          MOVE.B  #14,D0                  ;set for task to display null terminated 
000017DE                          1059                                ;string with CR, LF
000017DE  4E4F                    1060          TRAP    #15
000017E0  6000 0156               1061          BRA lsrlweaBody        
000017E4                          1062          
000017E4                          1063  
000017E4                          1064  
000017E4                          1065  RSRLREG:
000017E4                          1066          
000017E4                          1067  
000017E4                          1068          
000017E4  7000                    1069          MOVEQ.L #0, D0                  ;clear D0
000017E6                          1070          
000017E6                          1071          ;check valid size field
000017E6  3401                    1072          MOVE.W D1,D2                    ;copy inst to D2
000017E8  EC4A                    1073          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
000017EA  0202 0003               1074          ANDI.B #%00000011,D2            ;mask out rest of byte
000017EE  0C02 0003               1075          CMPI.B #%11,D2                  ;compare to 3
000017F2  6700 F8A4               1076          BEQ falsePositive               ;invalid size
000017F6                          1077  
000017F6                          1078          
000017F6                          1079          ;Figure out which direction we are going
000017F6  3401                    1080          MOVE.W D1,D2                    ;copy inst to D2
000017F8  E04A                    1081          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
000017FA  0202 0001               1082          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
000017FE  0C02 0000               1083          CMPI.B #0,D2                    ;compare bit to zero
00001802  6700 0006               1084          BEQ RSRreg                      ;if zero, right
00001806  6000 0012               1085          BRA RSLreg                      ;else, its left        
0000180A                          1086          
0000180A                          1087  RSRreg:
0000180A                          1088  
0000180A  43F9 00002D25           1089          LEA     rsrMessage,A1           ;move string for MOVE
00001810  103C 000E               1090          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001814                          1091                                ;string with CR, LF
00001814  4E4F                    1092          TRAP    #15
00001816  6000 019C               1093          BRA LSRLregBody
0000181A                          1094          
0000181A                          1095  RSLreg:
0000181A                          1096          
0000181A  43F9 00002D21           1097          LEA     rslMessage,A1           ;move string for MOVE
00001820  103C 000E               1098          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001824                          1099                                ;string with CR, LF
00001824  4E4F                    1100          TRAP    #15
00001826  6000 018C               1101          BRA LSRLregBody
0000182A                          1102  
0000182A                          1103       
0000182A                          1104  
0000182A                          1105  ASRLWEA:
0000182A                          1106          
0000182A                          1107  
0000182A                          1108          
0000182A  7000                    1109          MOVEQ.L #0, D0                  ;clear D0
0000182C                          1110          
0000182C                          1111  validASRL:
0000182C                          1112          
0000182C  43F9 000018D6           1113          LEA lsrlEAmasks,A1              ;load the list of masks
00001832  D3C0                    1114          ADDA.L D0,A1                    ;displace to a specific mask
00001834  1A11                    1115          MOVE.B (A1),D5                  ;move the mask to D5
00001836                          1116          
00001836  0C05 0000               1117          CMPI.B #0,D5                    ;check if the mask is 0
0000183A  6700 F85C               1118          BEQ falsePositive               ;branch if it is
0000183E                          1119          
0000183E  1401                    1120          MOVE.B D1,D2                    ;copy instruction to D2
00001840  C405                    1121          AND.B D5,D2                     ;mask D2
00001842                          1122          
00001842  43F9 000018D0           1123          LEA lsrlEA,A1                   ;load the list of valid modes
00001848  D3C0                    1124          ADDA.L D0,A1                    ;displace to a specific mode
0000184A  1811                    1125          MOVE.B (A1),D4                  ;move mode to D4
0000184C  B404                    1126          CMP.B D4,D2                     ;compare mode to masked value
0000184E  6700 0006               1127          BEQ  asrlweaCheckDirection      ;if its match, its a valid mode and we can procede
00001852                          1128          
00001852  5280                    1129          ADDQ.L #1,D0                    ;add one to displacement
00001854  60D6                    1130          BRA validASRL                   ;check for next mode
00001856                          1131  
00001856                          1132  asrlweaCheckDirection:
00001856                          1133          ;Figure out which direction we are going
00001856  3401                    1134          MOVE.W D1,D2                    ;copy inst to D2
00001858  E04A                    1135          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
0000185A  0202 0001               1136          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
0000185E  0C02 0000               1137          CMPI.B #0,D2                    ;compare bit to zero
00001862  6700 0006               1138          BEQ ASREA                       ;if zero, right
00001866  6000 0012               1139          BRA ASLEA                       ;else, its left
0000186A                          1140  
0000186A                          1141  ASREA:
0000186A                          1142  
0000186A  43F9 00002D2D           1143          LEA     asrMessage,A1           ;move string for MOVE
00001870  103C 000E               1144          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001874                          1145                                ;string with CR, LF
00001874  4E4F                    1146          TRAP    #15
00001876  6000 00C0               1147          BRA lsrlweaBody
0000187A                          1148          
0000187A                          1149  ASLEA:
0000187A                          1150          
0000187A  43F9 00002D29           1151          LEA     aslMessage,A1           ;move string for MOVE
00001880  103C 000E               1152          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001884                          1153                                ;string with CR, LF
00001884  4E4F                    1154          TRAP    #15
00001886  6000 00B0               1155          BRA lsrlweaBody        
0000188A                          1156          
0000188A                          1157  
0000188A                          1158  
0000188A                          1159  ASRLREG:
0000188A                          1160          
0000188A                          1161  
0000188A                          1162          
0000188A  7000                    1163          MOVEQ.L #0, D0                  ;clear D0
0000188C                          1164          
0000188C                          1165          ;check valid size field
0000188C  3401                    1166          MOVE.W D1,D2                    ;copy inst to D2
0000188E  EC4A                    1167          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
00001890  0202 0003               1168          ANDI.B #%00000011,D2            ;mask out rest of byte
00001894  0C02 0003               1169          CMPI.B #%11,D2                  ;compare to 3
00001898  6700 F7FE               1170          BEQ falsePositive               ;invalid size
0000189C                          1171  
0000189C                          1172          
0000189C                          1173          ;Figure out which direction we are going
0000189C  3401                    1174          MOVE.W D1,D2                    ;copy inst to D2
0000189E  E04A                    1175          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
000018A0  0202 0001               1176          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
000018A4  0C02 0000               1177          CMPI.B #0,D2                    ;compare bit to zero
000018A8  6700 0006               1178          BEQ ASRreg                      ;if zero, right
000018AC  6000 0012               1179          BRA ASLreg                      ;else, its left        
000018B0                          1180          
000018B0                          1181  ASRreg:
000018B0                          1182  
000018B0  43F9 00002D2D           1183          LEA     asrMessage,A1           ;move string for MOVE
000018B6  103C 000E               1184          MOVE.B  #14,D0                  ;set for task to display null terminated 
000018BA                          1185                                ;string with CR, LF
000018BA  4E4F                    1186          TRAP    #15
000018BC  6000 00F6               1187          BRA LSRLregBody
000018C0                          1188          
000018C0                          1189  ASLreg:
000018C0                          1190          
000018C0  43F9 00002D29           1191          LEA     aslMessage,A1           ;move string for MOVE
000018C6  103C 000E               1192          MOVE.B  #14,D0                  ;set for task to display null terminated 
000018CA                          1193                                ;string with CR, LF
000018CA  4E4F                    1194          TRAP    #15
000018CC  6000 00E6               1195          BRA LSRLregBody
000018D0                          1196  
000018D0                          1197  
000018D0= 10 18 20 38 39 00       1198  lsrlEA        DC.B %010000,%011000,%100000,%111000,%111001,0
000018D6= 38 38 38 3F 3F 00       1199  lsrlEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0       
000018DC                          1200  
000018DC                          1201  LSRLWEA:
000018DC                          1202          
000018DC                          1203  
000018DC                          1204          
000018DC  7000                    1205          MOVEQ.L #0, D0                  ;clear D0
000018DE                          1206          
000018DE                          1207  validLSRL:
000018DE                          1208          
000018DE  43F8 18D6               1209          LEA lsrlEAmasks,A1              ;load the list of masks
000018E2  D3C0                    1210          ADDA.L D0,A1                    ;displace to a specific mask
000018E4  1A11                    1211          MOVE.B (A1),D5                  ;move the mask to D5
000018E6                          1212          
000018E6  0C05 0000               1213          CMPI.B #0,D5                    ;check if the mask is 0
000018EA  6700 F7AC               1214          BEQ falsePositive               ;branch if it is
000018EE                          1215          
000018EE  1401                    1216          MOVE.B D1,D2                    ;copy instruction to D2
000018F0  C405                    1217          AND.B D5,D2                     ;mask D2
000018F2                          1218          
000018F2  43F8 18D0               1219          LEA lsrlEA,A1                   ;load the list of valid modes
000018F6  D3C0                    1220          ADDA.L D0,A1                    ;displace to a specific mode
000018F8  1811                    1221          MOVE.B (A1),D4                  ;move mode to D4
000018FA  B404                    1222          CMP.B D4,D2                     ;compare mode to masked value
000018FC  6700 0006               1223          BEQ  lsrlweaCheckDirection      ;if its match, its a valid mode and we can procede
00001900                          1224          
00001900  5280                    1225          ADDQ.L #1,D0                    ;add one to displacement
00001902  60DA                    1226          BRA validLSRL                   ;check for next mode
00001904                          1227  
00001904                          1228  lsrlweaCheckDirection:
00001904                          1229          ;Figure out which direction we are going
00001904  3401                    1230          MOVE.W D1,D2                    ;copy inst to D2
00001906  E04A                    1231          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
00001908  0202 0001               1232          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
0000190C  0C02 0000               1233          CMPI.B #0,D2                    ;compare bit to zero
00001910  6700 0006               1234          BEQ LSREA                       ;if zero, right
00001914  6000 0012               1235          BRA LSLEA                       ;else, its left
00001918                          1236  
00001918                          1237  LSREA:
00001918                          1238  
00001918  43F9 00002D35           1239          LEA     lsrMessage,A1           ;move string for MOVE
0000191E  103C 000E               1240          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001922                          1241                                ;string with CR, LF
00001922  4E4F                    1242          TRAP    #15
00001924  6000 0012               1243          BRA lsrlweaBody
00001928                          1244          
00001928                          1245  LSLEA:
00001928                          1246          
00001928  43F9 00002D31           1247          LEA     lslMessage,A1           ;move string for MOVE
0000192E  103C 000E               1248          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001932                          1249                                ;string with CR, LF
00001932  4E4F                    1250          TRAP    #15
00001934  6000 0002               1251          BRA lsrlweaBody        
00001938                          1252          
00001938                          1253  lsrlweaBody:
00001938                          1254          
00001938                          1255          ;print ' '
00001938  48E7 4000               1256          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000193C  123C 0020               1257          MOVE.B #' ',D1                  ;put ascii value of char in D1
00001940  103C 0006               1258          MOVE.B #6,D0                    ;move task 6 into D0
00001944  4E4F                    1259          TRAP #15                        ;print char
00001946  4CDF 0002               1260          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000194A                          1261          
0000194A  3401                    1262          MOVE.W  D1,D2                   ;check mode
0000194C  C43C 003F               1263          AND.B   #%00111111,D2
00001950  1A02                    1264          MOVE.B  D2,D5
00001952  48E7 4000               1265          MOVEM.L D1,-(SP)
00001956  6100 0ED2               1266          BSR     Get_Effective_Address
0000195A  4CDF 0002               1267          MOVEM.L (SP)+,D1
0000195E                          1268          
0000195E                          1269          
0000195E  43F9 00002CFE           1270          LEA     clearLine,A1            ;move string for a CR and LF
00001964  103C 000E               1271          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001968                          1272                                ;string without CR, LF
00001968  4E4F                    1273          TRAP    #15
0000196A                          1274  
0000196A  7000                    1275          MOVEQ.L #0,D0
0000196C  4E75                    1276          RTS
0000196E                          1277  
0000196E                          1278  
0000196E                          1279  LSRLREG:
0000196E                          1280          
0000196E                          1281  
0000196E                          1282          
0000196E  7000                    1283          MOVEQ.L #0, D0                  ;clear D0
00001970                          1284          
00001970                          1285          ;check valid size field
00001970  3401                    1286          MOVE.W D1,D2                    ;copy inst to D2
00001972  EC4A                    1287          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
00001974  0202 0003               1288          ANDI.B #%00000011,D2            ;mask out rest of byte
00001978  0C02 0003               1289          CMPI.B #%11,D2                  ;compare to 3
0000197C  6700 F71A               1290          BEQ falsePositive               ;invalid size
00001980                          1291  
00001980                          1292          
00001980                          1293          ;Figure out which direction we are going
00001980  3401                    1294          MOVE.W D1,D2                    ;copy inst to D2
00001982  E04A                    1295          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
00001984  0202 0001               1296          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
00001988  0C02 0000               1297          CMPI.B #0,D2                    ;compare bit to zero
0000198C  6700 0006               1298          BEQ LSRreg                      ;if zero, right
00001990  6000 0012               1299          BRA LSLreg                      ;else, its left        
00001994                          1300          
00001994                          1301  LSRreg:
00001994                          1302  
00001994  43F9 00002D35           1303          LEA     lsrMessage,A1           ;move string for MOVE
0000199A  103C 000E               1304          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000199E                          1305                                ;string with CR, LF
0000199E  4E4F                    1306          TRAP    #15
000019A0  6000 0012               1307          BRA LSRLregBody
000019A4                          1308          
000019A4                          1309  LSLreg:
000019A4                          1310          
000019A4  43F9 00002D31           1311          LEA     lslMessage,A1           ;move string for MOVE
000019AA  103C 000E               1312          MOVE.B  #14,D0                  ;set for task to display null terminated 
000019AE                          1313                                ;string with CR, LF
000019AE  4E4F                    1314          TRAP    #15
000019B0  6000 0002               1315          BRA LSRLregBody
000019B4                          1316          
000019B4                          1317  LSRLregBody:
000019B4                          1318          
000019B4  6100 07B8               1319          BSR negSize        
000019B8                          1320              
000019B8                          1321          ;check i/r
000019B8  48E7 4000               1322          MOVEM.L D1,-(SP)
000019BC  6100 003C               1323          BSR LSRLcheckIR
000019C0  4CDF 0002               1324          MOVEM.L (SP)+,D1
000019C4                          1325          
000019C4                          1326          ;print ','
000019C4  48E7 4000               1327          MOVEM.L D1,-(SP)                ;save D1 to the stack
000019C8  123C 002C               1328          MOVE.B #',',D1                  ;put ascii value of char in D1
000019CC  103C 0006               1329          MOVE.B #6,D0                    ;move task 6 into D0
000019D0  4E4F                    1330          TRAP #15                        ;prin char
000019D2  4CDF 0002               1331          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000019D6                          1332          
000019D6  3401                    1333          MOVE.W  D1,D2                   ;check mode
000019D8  C43C 0007               1334          AND.B   #%00000111,D2
000019DC  1A02                    1335          MOVE.B  D2,D5
000019DE  48E7 4000               1336          MOVEM.L D1,-(SP)
000019E2  6100 0E46               1337          BSR     Get_Effective_Address
000019E6  4CDF 0002               1338          MOVEM.L (SP)+,D1
000019EA                          1339          
000019EA                          1340          
000019EA  43F9 00002CFE           1341          LEA     clearLine,A1            ;move string for a CR and LF
000019F0  103C 000E               1342          MOVE.B  #14,D0                  ;set for task to display null terminated 
000019F4                          1343                                ;string without CR, LF
000019F4  4E4F                    1344          TRAP    #15
000019F6                          1345  
000019F6  7000                    1346          MOVEQ.L #0,D0
000019F8  4E75                    1347          RTS
000019FA                          1348  
000019FA                          1349  LSRLcheckIR:
000019FA                          1350  
000019FA  1401                    1351          MOVE.B D1,D2                    ;move inst to D2
000019FC  EA0A                    1352          LSR.B  #5,D2
000019FE  C43C 0001               1353          AND.B  #%00000001,D2
00001A02  0C02 0000               1354          CMPI.B #0,D2
00001A06  6700 0008               1355          BEQ  LSRLcheckI
00001A0A  6000 0038               1356          BRA  LSRLcheckR
00001A0E                          1357  LSRLcheckIRreturn:
00001A0E  4E75                    1358          RTS
00001A10                          1359          
00001A10                          1360  LSRLcheckI:
00001A10                          1361          ;print '#'
00001A10  48E7 4000               1362          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001A14  123C 0023               1363          MOVE.B #'#',D1                  ;put ascii value of '#' in D1
00001A18  103C 0006               1364          MOVE.B #6,D0                    ;move task 6 into D0
00001A1C  4E4F                    1365          TRAP #15                        ;prin char
00001A1E  4CDF 0002               1366          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001A22                          1367          
00001A22                          1368          
00001A22                          1369          ;print number
00001A22  48E7 4000               1370          MOVEM.L D1,-(SP)
00001A26  3401                    1371          MOVE.W D1,D2                    ;copy inst to d2
00001A28  E04A                    1372          LSR.W #8,D2                     ;shift data section
00001A2A  E20A                    1373          LSR.B #1,D2
00001A2C  C43C 0007               1374          AND.B #%00000111,D2             ;mask out rest of data
00001A30  6100 00EC               1375          BSR ZeroToEight                 ;handle zero
00001A34  7200                    1376          MOVEQ.L #0,D1                   ;clear D1
00001A36  1202                    1377          MOVE.B D2,D1                    ;move number to display into D1
00001A38  103C 0003               1378          MOVE.B #3,D0                    ;move task 3 to D0
00001A3C  4E4F                    1379          TRAP #15
00001A3E  4CDF 0002               1380          MOVEM.L (SP)+,D1
00001A42  60CA                    1381          BRA LSRLcheckIRreturn
00001A44                          1382          
00001A44                          1383  LSRLcheckR:
00001A44  3401                    1384          MOVE.W D1,D2                    ;copy inst to d2
00001A46  E04A                    1385          LSR.W #8,D2                     ;shift data section
00001A48  E20A                    1386          LSR.B #1,D2
00001A4A  C43C 0007               1387          AND.B #%00000111,D2             ;mask out rest of data
00001A4E  1A02                    1388          MOVE.B D2,D5                    ;force Dn
00001A50  48E7 4000               1389          MOVEM.L D1,-(SP)
00001A54  6100 0DD4               1390          BSR     Get_Effective_Address
00001A58  4CDF 0002               1391          MOVEM.L (SP)+,D1
00001A5C  60B0                    1392          BRA LSRLcheckIRreturn
00001A5E                          1393          
00001A5E= 00 08 10 18 20 38 ...   1394  subqEA        DC.B %000000,%001000,%010000,%011000,%100000,%111000,%111001,0
00001A66= 38 38 38 38 38 3F ...   1395  subqEAmasks   DC.B %111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001A6E                          1396  
00001A6E                          1397  SUBQ:
00001A6E                          1398          
00001A6E                          1399  
00001A6E                          1400          
00001A6E  7000                    1401          MOVEQ.L #0, D0                  ;clear D0
00001A70                          1402          
00001A70                          1403          ;check valid size field
00001A70  3401                    1404          MOVE.W D1,D2                    ;copy inst to D2
00001A72  EC4A                    1405          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
00001A74  0202 0003               1406          ANDI.B #%00000011,D2            ;mask out rest of byte
00001A78  0C02 0003               1407          CMPI.B #%11,D2                  ;compare to 3
00001A7C  6700 F61A               1408          BEQ falsePositive               ;invalid size
00001A80                          1409          
00001A80                          1410  validSubq:
00001A80                          1411          
00001A80  43F8 1A66               1412          LEA subqEAmasks,A1              ;load the list of masks
00001A84  D3C0                    1413          ADDA.L D0,A1                    ;displace to a specific mask
00001A86  1A11                    1414          MOVE.B (A1),D5                  ;move the mask to D5
00001A88                          1415          
00001A88  0C05 0000               1416          CMPI.B #0,D5                    ;check if the mask is 0
00001A8C  6700 F60A               1417          BEQ falsePositive               ;branch if it is
00001A90                          1418          
00001A90  1401                    1419          MOVE.B D1,D2                    ;copy instruction to D2
00001A92  C405                    1420          AND.B D5,D2                     ;mask D2
00001A94                          1421          
00001A94  43F8 1A5E               1422          LEA subqEA,A1                   ;load the list of valid modes
00001A98  D3C0                    1423          ADDA.L D0,A1                    ;displace to a specific mode
00001A9A  1811                    1424          MOVE.B (A1),D4                  ;move mode to D4
00001A9C  B404                    1425          CMP.B D4,D2                     ;compare mode to masked value
00001A9E  6700 0006               1426          BEQ  subqBody                   ;if its match, its a valid mode and we can procede
00001AA2                          1427          
00001AA2  5280                    1428          ADDQ.L #1,D0                    ;add one to displacement
00001AA4  60DA                    1429          BRA validSubq                   ;check for next mode
00001AA6                          1430          
00001AA6                          1431          
00001AA6                          1432  subqBody
00001AA6                          1433  
00001AA6  43F9 00002D39           1434          LEA     subqMessage,A1          ;move string for MOVE
00001AAC  103C 000E               1435          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001AB0                          1436                                ;string with CR, LF
00001AB0  4E4F                    1437          TRAP    #15
00001AB2                          1438          
00001AB2  6100 06BA               1439          BSR negSize
00001AB6                          1440          
00001AB6                          1441          ;immediate data
00001AB6                          1442          
00001AB6                          1443          ;print '#'
00001AB6  48E7 4000               1444          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001ABA  123C 0023               1445          MOVE.B #'#',D1                  ;put ascii value of '#' in D1
00001ABE  103C 0006               1446          MOVE.B #6,D0                    ;move task 6 into D0
00001AC2  4E4F                    1447          TRAP #15                        ;prin char
00001AC4  4CDF 0002               1448          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001AC8                          1449          
00001AC8                          1450          ;print number
00001AC8  48E7 4000               1451          MOVEM.L D1,-(SP)
00001ACC  3401                    1452          MOVE.W D1,D2                    ;copy inst to d2
00001ACE  E04A                    1453          LSR.W #8,D2                     ;shift data section
00001AD0  E20A                    1454          LSR.B #1,D2
00001AD2  C43C 0007               1455          AND.B #%00000111,D2             ;mask out rest of data
00001AD6  6100 0046               1456          BSR ZeroToEight                 ;handle zero
00001ADA  7200                    1457          MOVEQ.L #0,D1                   ;clear D1
00001ADC  1202                    1458          MOVE.B D2,D1                    ;move number to display into D1
00001ADE  103C 0003               1459          MOVE.B #3,D0                    ;move task 3 to D0
00001AE2  4E4F                    1460          TRAP #15
00001AE4  4CDF 0002               1461          MOVEM.L (SP)+,D1
00001AE8                          1462          
00001AE8                          1463          ;print ','
00001AE8  48E7 4000               1464          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001AEC  123C 002C               1465          MOVE.B #',',D1                  ;put ascii value of char in D1
00001AF0  103C 0006               1466          MOVE.B #6,D0                    ;move task 6 into D0
00001AF4  4E4F                    1467          TRAP #15                        ;prin char
00001AF6  4CDF 0002               1468          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001AFA                          1469          
00001AFA                          1470          ;Then do EA
00001AFA                          1471          
00001AFA  3401                    1472          MOVE.W  D1,D2                   ;check mode
00001AFC  C43C 003F               1473          AND.B   #%00111111,D2
00001B00  1A02                    1474          MOVE.B  D2,D5
00001B02  48E7 4000               1475          MOVEM.L D1,-(SP)
00001B06  6100 0D22               1476          BSR     Get_Effective_Address
00001B0A  4CDF 0002               1477          MOVEM.L (SP)+,D1
00001B0E                          1478          
00001B0E  43F9 00002CFE           1479          LEA     clearLine,A1            ;move string for a CR and LF
00001B14  103C 000E               1480          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001B18                          1481                                ;string without CR, LF
00001B18  4E4F                    1482          TRAP    #15
00001B1A                          1483  
00001B1A  7000                    1484          MOVEQ.L #0,D0
00001B1C  4E75                    1485          RTS
00001B1E                          1486          
00001B1E                          1487  ZeroToEight:
00001B1E                          1488          
00001B1E  0C02 0000               1489          CMPI.B #0,D2
00001B22  6700 0004               1490          BEQ toEight
00001B26                          1491  ZeroToEightReturn:
00001B26                          1492          
00001B26  4E75                    1493          RTS
00001B28                          1494  toEight:
00001B28                          1495          
00001B28  5002                    1496          ADDQ.B #8,D2
00001B2A  60FA                    1497          BRA ZeroToEightReturn
00001B2C                          1498  
00001B2C                          1499      
00001B2C                          1500  SUB:
00001B2C                          1501          
00001B2C                          1502  
00001B2C                          1503          
00001B2C  7000                    1504          MOVEQ.L #0, D0                  ;clear D0
00001B2E                          1505          
00001B2E                          1506          ;Figure out if EA is source or destination
00001B2E  3401                    1507          MOVE.W D1,D2                    ;copy inst to D2
00001B30  EC4A                    1508          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001B32  0202 0007               1509          ANDI.B #%00000111,D2            ;mask out rest of byte
00001B36  0C02 0002               1510          CMPI.B #2,D2                    ;compare to 2
00001B3A  6F00 0016               1511          BLE validSubSourceEA            ;2 or less is EA is source
00001B3E                          1512          
00001B3E  0C02 0007               1513          CMPI.B #%111,D2                 ;compare to 7
00001B42  6700 F554               1514          BEQ falsePositive               ;thats not valid
00001B46  0C02 0003               1515          CMPI.B #%11,D2                  ;compare to 3
00001B4A  6700 F54C               1516          BEQ falsePositive               ;also not valid
00001B4E  6000 002C               1517          BRA validSubDestEA              ;all thats left is valid EA as Dest 
00001B52                          1518          
00001B52                          1519  validSubSourceEA:
00001B52                          1520          
00001B52  43F9 000023C5           1521          LEA moveSourceEAmasks,A1        ;load the list of masks
00001B58  D3C0                    1522          ADDA.L D0,A1                    ;displace to a specific mask
00001B5A  1A11                    1523          MOVE.B (A1),D5                  ;move the mask to D5
00001B5C                          1524          
00001B5C  0C05 0000               1525          CMPI.B #0,D5                    ;check if the mask is 0
00001B60  6700 F536               1526          BEQ falsePositive               ;branch if it is
00001B64                          1527          
00001B64  1401                    1528          MOVE.B D1,D2                    ;copy instruction to D2
00001B66  C405                    1529          AND.B D5,D2                     ;mask D2
00001B68                          1530          
00001B68  43F9 000023BC           1531          LEA moveSourceEA,A1             ;load the list of valid modes
00001B6E  D3C0                    1532          ADDA.L D0,A1                    ;displace to a specific mode
00001B70  1811                    1533          MOVE.B (A1),D4                  ;move mode to D4
00001B72  B404                    1534          CMP.B D4,D2                     ;compare mode to masked value
00001B74  6700 0030               1535          BEQ  subSource                  ;if its match, its a valid mode and we can procede
00001B78                          1536          
00001B78  5280                    1537          ADDQ.L #1,D0                    ;add one to displacement
00001B7A  60D6                    1538          BRA validSubSourceEA            ;check for next mode
00001B7C                          1539          
00001B7C                          1540          
00001B7C                          1541  validSubDestEA:
00001B7C                          1542          
00001B7C  43F9 00001D22           1543          LEA addDestEAmasks,A1           ;load the list of masks
00001B82  D3C0                    1544          ADDA.L D0,A1                    ;displace to a specific mask
00001B84  1A11                    1545          MOVE.B (A1),D5                  ;move the mask to D5
00001B86                          1546          
00001B86  0C05 0000               1547          CMPI.B #0,D5                    ;check if the mask is 0
00001B8A  6700 F50C               1548          BEQ falsePositive               ;branch if it is
00001B8E                          1549          
00001B8E  3401                    1550          MOVE.W D1,D2                    ;copy instruction to D2
00001B90  C405                    1551          AND.B D5,D2                     ;mask D2
00001B92                          1552          
00001B92  43F9 00001D1C           1553          LEA addDestEA,A1                ;load the list of valid modes
00001B98  D3C0                    1554          ADDA.L D0,A1                    ;displace to a specific mode
00001B9A  1811                    1555          MOVE.B (A1),D4                  ;move mode to D4
00001B9C  B404                    1556          CMP.B D4,D2                     ;compare mode to masked value
00001B9E  6700 0064               1557          BEQ subDest                     ;if its match, its a valid mode and we can procede
00001BA2                          1558          
00001BA2  5280                    1559          ADDQ.L #1,D0                    ;add one to displacement
00001BA4  60D6                    1560          BRA validSubDestEA              ;check for next mode
00001BA6                          1561          
00001BA6                          1562  subSource
00001BA6                          1563  
00001BA6  43F9 00002D3E           1564          LEA     subMessage,A1           ;move string for MOVE
00001BAC  103C 000E               1565          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001BB0                          1566                                ;string with CR, LF
00001BB0  4E4F                    1567          TRAP    #15
00001BB2                          1568          
00001BB2  6100 05BA               1569          BSR negSize
00001BB6                          1570          
00001BB6                          1571          ;do EA
00001BB6                          1572          
00001BB6  3401                    1573          MOVE.W  D1,D2                   ;check mode
00001BB8  C43C 003F               1574          AND.B   #%00111111,D2
00001BBC  1A02                    1575          MOVE.B  D2,D5
00001BBE  48E7 4000               1576          MOVEM.L D1,-(SP)
00001BC2  6100 0C66               1577          BSR     Get_Effective_Address
00001BC6  4CDF 0002               1578          MOVEM.L (SP)+,D1
00001BCA                          1579          
00001BCA                          1580          ;print ','
00001BCA  48E7 4000               1581          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001BCE  123C 002C               1582          MOVE.B #',',D1                  ;put ascii value of char in D1
00001BD2  103C 0006               1583          MOVE.B #6,D0                    ;move task 6 into D0
00001BD6  4E4F                    1584          TRAP #15                        ;prin char
00001BD8  4CDF 0002               1585          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001BDC                          1586          
00001BDC                          1587          ;Then do Dn
00001BDC                          1588          
00001BDC  3401                    1589          MOVE.W  D1,D2
00001BDE  E04A                    1590          LSR.W   #8,D2                   ;move reg into first byte
00001BE0  E20A                    1591          LSR.B   #1,D2                   ;line it up to least sig bit
00001BE2  C43C 0007               1592          AND.B   #%00000111,D2           ;force mode to Dn
00001BE6  1A02                    1593          MOVE.B  D2,D5
00001BE8  48E7 4000               1594          MOVEM.L D1,-(SP)
00001BEC  6100 0C3C               1595          BSR     Get_Effective_Address
00001BF0  4CDF 0002               1596          MOVEM.L (SP)+,D1
00001BF4                          1597          
00001BF4  43F9 00002CFE           1598          LEA     clearLine,A1            ;move string for a CR and LF
00001BFA  103C 000E               1599          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001BFE                          1600          ;string without CR, LF
00001BFE  4E4F                    1601          TRAP    #15
00001C00                          1602  
00001C00  7000                    1603          MOVEQ.L #0,D0
00001C02  4E75                    1604          RTS
00001C04                          1605  
00001C04                          1606  subDest
00001C04                          1607  
00001C04  43F9 00002D3E           1608          LEA     subMessage,A1           ;move string for MOVE
00001C0A  103C 000E               1609          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001C0E                          1610                                          ;string with CR, LF
00001C0E  4E4F                    1611          TRAP    #15
00001C10                          1612          
00001C10  6100 055C               1613          BSR negSize
00001C14                          1614          
00001C14                          1615          ;Do Dn
00001C14                          1616          
00001C14  3401                    1617          MOVE.W  D1,D2
00001C16  E04A                    1618          LSR.W   #8,D2                   ;move reg into first byte
00001C18  E20A                    1619          LSR.B   #1,D2                   ;line it up to least sig bit
00001C1A  C43C 0007               1620          AND.B   #%00000111,D2           ;force mode to Dn
00001C1E  1A02                    1621          MOVE.B  D2,D5
00001C20  48E7 4000               1622          MOVEM.L D1,-(SP)
00001C24  6100 0C04               1623          BSR     Get_Effective_Address
00001C28  4CDF 0002               1624          MOVEM.L (SP)+,D1
00001C2C                          1625          
00001C2C                          1626          
00001C2C                          1627          ;print ','
00001C2C  48E7 4000               1628          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001C30  123C 002C               1629          MOVE.B #',',D1                  ;put ascii value of char in D1
00001C34  103C 0006               1630          MOVE.B #6,D0                    ;move task 6 into D0
00001C38  4E4F                    1631          TRAP #15                        ;prin char
00001C3A  4CDF 0002               1632          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001C3E                          1633          
00001C3E                          1634          ;Then do EA
00001C3E                          1635          
00001C3E  3401                    1636          MOVE.W  D1,D2                   ;check mode
00001C40  C43C 003F               1637          AND.B   #%00111111,D2
00001C44  1A02                    1638          MOVE.B  D2,D5
00001C46  48E7 4000               1639          MOVEM.L D1,-(SP)
00001C4A  6100 0BDE               1640          BSR     Get_Effective_Address
00001C4E  4CDF 0002               1641          MOVEM.L (SP)+,D1
00001C52                          1642          
00001C52                          1643          
00001C52  43F9 00002CFE           1644          LEA     clearLine,A1            ;move string for a CR and LF
00001C58  103C 000E               1645          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001C5C                          1646          ;string without CR, LF
00001C5C  4E4F                    1647          TRAP    #15
00001C5E                          1648  
00001C5E  7000                    1649          MOVEQ.L #0,D0
00001C60  4E75                    1650          RTS
00001C62                          1651  
00001C62                          1652  
00001C62                          1653  ADDA:
00001C62                          1654          
00001C62                          1655  
00001C62                          1656          
00001C62  7000                    1657          MOVEQ.L #0, D0                  ;clear D0
00001C64                          1658          
00001C64                          1659          ;check opmode field
00001C64  3401                    1660          MOVE.W D1,D2                    ;copy inst to D2
00001C66  EC4A                    1661          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001C68  0202 0007               1662          ANDI.B #%00000111,D2            ;mask out rest of byte
00001C6C  0C02 0007               1663          CMPI.B #%111,D2                 ;compare to 7
00001C70  6700 000E               1664          BEQ validAdda                   ;thats valid
00001C74  0C02 0003               1665          CMPI.B #%11,D2                  ;compare to 3
00001C78  6700 0006               1666          BEQ validAdda                   ;also valid
00001C7C  6000 F41A               1667          BRA falsePositive               ;all thats left is invalid 
00001C80                          1668          
00001C80                          1669  validAdda:
00001C80                          1670          
00001C80  43F9 000023C5           1671          LEA moveSourceEAmasks,A1        ;load the list of masks
00001C86  D3C0                    1672          ADDA.L D0,A1                    ;displace to a specific mask
00001C88  1A11                    1673          MOVE.B (A1),D5                  ;move the mask to D5
00001C8A                          1674          
00001C8A  0C05 0000               1675          CMPI.B #0,D5                    ;check if the mask is 0
00001C8E  6700 F408               1676          BEQ falsePositive               ;branch if it is
00001C92                          1677          
00001C92  1401                    1678          MOVE.B D1,D2                    ;copy instruction to D2
00001C94  C405                    1679          AND.B D5,D2                     ;mask D2
00001C96                          1680          
00001C96  43F9 000023BC           1681          LEA moveSourceEA,A1             ;load the list of valid modes
00001C9C  D3C0                    1682          ADDA.L D0,A1                    ;displace to a specific mode
00001C9E  1811                    1683          MOVE.B (A1),D4                  ;move mode to D4
00001CA0  B404                    1684          CMP.B D4,D2                     ;compare mode to masked value
00001CA2  6700 0006               1685          BEQ  addaBody                   ;if its match, its a valid mode and we can procede
00001CA6                          1686          
00001CA6  5280                    1687          ADDQ.L #1,D0                    ;add one to displacement
00001CA8  60D6                    1688          BRA validAdda                   ;check for next mode
00001CAA                          1689          
00001CAA                          1690          
00001CAA                          1691  addaBody
00001CAA                          1692  
00001CAA  43F9 00002D42           1693          LEA     addaMessage,A1          ;move string for MOVE
00001CB0  103C 000E               1694          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001CB4                          1695          ;string with CR, LF
00001CB4  4E4F                    1696          TRAP    #15
00001CB6                          1697          
00001CB6                          1698          ;size
00001CB6  48E7 4000               1699          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001CBA                          1700          ;make it look like NEG's size
00001CBA  E449                    1701          LSR.W #2,D1                     ;shift opmode bits over to use them as size
00001CBC  C23C 007F               1702          AND.B #%01111111,D1             ;clear bit next to size
00001CC0  0641 0040               1703          ADDI.W #%01000000,D1            ;add 1 to size to make it look like a word or long
00001CC4  6100 04A8               1704          BSR negSize
00001CC8  4CDF 0002               1705          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001CCC                          1706          
00001CCC                          1707          ;do EA
00001CCC                          1708          
00001CCC  3401                    1709          MOVE.W  D1,D2                   ;check mode
00001CCE  C43C 003F               1710          AND.B   #%00111111,D2
00001CD2  1A02                    1711          MOVE.B  D2,D5
00001CD4  48E7 4000               1712          MOVEM.L D1,-(SP)
00001CD8  6100 0B50               1713          BSR     Get_Effective_Address
00001CDC  4CDF 0002               1714          MOVEM.L (SP)+,D1
00001CE0                          1715          
00001CE0                          1716          ;print ','
00001CE0  48E7 4000               1717          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001CE4  123C 002C               1718          MOVE.B #',',D1                  ;put ascii value of char in D1
00001CE8  103C 0006               1719          MOVE.B #6,D0                    ;move task 6 into D0
00001CEC  4E4F                    1720          TRAP #15                        ;prin char
00001CEE  4CDF 0002               1721          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001CF2                          1722          
00001CF2                          1723          ;Then do Dn
00001CF2                          1724          
00001CF2  3401                    1725          MOVE.W  D1,D2
00001CF4  E04A                    1726          LSR.W   #8,D2                   ;move reg into first byte
00001CF6  E20A                    1727          LSR.B   #1,D2                   ;line it up to least sig bit
00001CF8  C43C 0007               1728          AND.B   #%00000111,D2           ;force mode to An
00001CFC  5002                    1729          ADDI.B  #%00001000,D2 
00001CFE  1A02                    1730          MOVE.B  D2,D5
00001D00  48E7 4000               1731          MOVEM.L D1,-(SP)
00001D04  6100 0B24               1732          BSR     Get_Effective_Address
00001D08  4CDF 0002               1733          MOVEM.L (SP)+,D1
00001D0C                          1734          
00001D0C  43F9 00002CFE           1735          LEA     clearLine,A1            ;move string for a CR and LF
00001D12  103C 000E               1736          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001D16                          1737          ;string without CR, LF
00001D16  4E4F                    1738          TRAP    #15
00001D18                          1739  
00001D18  7000                    1740          MOVEQ.L #0,D0
00001D1A  4E75                    1741          RTS
00001D1C                          1742  
00001D1C                          1743  
00001D1C                          1744      
00001D1C= 10 18 20 38 39 00       1745  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
00001D22= 38 38 38 3F 3F 00       1746  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
00001D28                          1747  
00001D28                          1748  ADD:
00001D28                          1749          
00001D28                          1750  
00001D28                          1751          
00001D28  7000                    1752          MOVEQ.L #0, D0                  ;clear D0
00001D2A                          1753          
00001D2A                          1754          ;Figure out if EA is source or destination
00001D2A  3401                    1755          MOVE.W D1,D2                    ;copy inst to D2
00001D2C  EC4A                    1756          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001D2E  0202 0007               1757          ANDI.B #%00000111,D2            ;mask out rest of byte
00001D32  0C02 0002               1758          CMPI.B #2,D2                    ;compare to 2
00001D36  6F00 0016               1759          BLE validAddSourceEA            ;2 or less is EA is source
00001D3A                          1760          
00001D3A  0C02 0007               1761          CMPI.B #%111,D2                 ;compare to 7
00001D3E  6700 F358               1762          BEQ falsePositive               ;thats not valid
00001D42  0C02 0003               1763          CMPI.B #%11,D2                  ;compare to 3
00001D46  6700 F350               1764          BEQ falsePositive               ;also not valid
00001D4A  6000 002C               1765          BRA validAddDestEA              ;all thats left is valid EA as Dest 
00001D4E                          1766          
00001D4E                          1767  validAddSourceEA:
00001D4E                          1768          
00001D4E  43F9 000023C5           1769          LEA moveSourceEAmasks,A1        ;load the list of masks
00001D54  D3C0                    1770          ADDA.L D0,A1                    ;displace to a specific mask
00001D56  1A11                    1771          MOVE.B (A1),D5                  ;move the mask to D5
00001D58                          1772          
00001D58  0C05 0000               1773          CMPI.B #0,D5                    ;check if the mask is 0
00001D5C  6700 F33A               1774          BEQ falsePositive               ;branch if it is
00001D60                          1775          
00001D60  1401                    1776          MOVE.B D1,D2                    ;copy instruction to D2
00001D62  C405                    1777          AND.B D5,D2                     ;mask D2
00001D64                          1778          
00001D64  43F9 000023BC           1779          LEA moveSourceEA,A1             ;load the list of valid modes
00001D6A  D3C0                    1780          ADDA.L D0,A1                    ;displace to a specific mode
00001D6C  1811                    1781          MOVE.B (A1),D4                  ;move mode to D4
00001D6E  B404                    1782          CMP.B D4,D2                     ;compare mode to masked value
00001D70  6700 002C               1783          BEQ  addSource                  ;if its match, its a valid mode and we can procede
00001D74                          1784          
00001D74  5280                    1785          ADDQ.L #1,D0                    ;add one to displacement
00001D76  60D6                    1786          BRA validAddSourceEA            ;check for next mode
00001D78                          1787          
00001D78                          1788          
00001D78                          1789  validAddDestEA:
00001D78                          1790          
00001D78  43F8 1D22               1791          LEA addDestEAmasks,A1           ;load the list of masks
00001D7C  D3C0                    1792          ADDA.L D0,A1                    ;displace to a specific mask
00001D7E  1A11                    1793          MOVE.B (A1),D5                  ;move the mask to D5
00001D80                          1794          
00001D80  0C05 0000               1795          CMPI.B #0,D5                    ;check if the mask is 0
00001D84  6700 F312               1796          BEQ falsePositive               ;branch if it is
00001D88                          1797          
00001D88  3401                    1798          MOVE.W D1,D2                    ;copy instruction to D2
00001D8A  C405                    1799          AND.B D5,D2                     ;mask D2
00001D8C                          1800          
00001D8C  43F8 1D1C               1801          LEA addDestEA,A1                ;load the list of valid modes
00001D90  D3C0                    1802          ADDA.L D0,A1                    ;displace to a specific mode
00001D92  1811                    1803          MOVE.B (A1),D4                  ;move mode to D4
00001D94  B404                    1804          CMP.B D4,D2                     ;compare mode to masked value
00001D96  6700 0064               1805          BEQ addDest                     ;if its match, its a valid mode and we can procede
00001D9A                          1806          
00001D9A  5280                    1807          ADDQ.L #1,D0                    ;add one to displacement
00001D9C  60DA                    1808          BRA validAddDestEA              ;check for next mode
00001D9E                          1809          
00001D9E                          1810  addSource
00001D9E                          1811  
00001D9E  43F9 00002D47           1812          LEA     addMessage,A1           ;move string for MOVE
00001DA4  103C 000E               1813          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001DA8                          1814          ;string with CR, LF
00001DA8  4E4F                    1815          TRAP    #15
00001DAA                          1816          
00001DAA  6100 03C2               1817          BSR negSize
00001DAE                          1818          
00001DAE                          1819          ;do EA
00001DAE                          1820          
00001DAE  3401                    1821          MOVE.W  D1,D2                   ;check mode
00001DB0  C43C 003F               1822          AND.B   #%00111111,D2
00001DB4  1A02                    1823          MOVE.B  D2,D5
00001DB6  48E7 4000               1824          MOVEM.L D1,-(SP)
00001DBA  6100 0A6E               1825          BSR     Get_Effective_Address
00001DBE  4CDF 0002               1826          MOVEM.L (SP)+,D1
00001DC2                          1827          
00001DC2                          1828          ;print ','
00001DC2  48E7 4000               1829          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001DC6  123C 002C               1830          MOVE.B #',',D1                  ;put ascii value of char in D1
00001DCA  103C 0006               1831          MOVE.B #6,D0                    ;move task 6 into D0
00001DCE  4E4F                    1832          TRAP #15                        ;prin char
00001DD0  4CDF 0002               1833          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001DD4                          1834          
00001DD4                          1835          ;Then do Dn
00001DD4                          1836          
00001DD4  3401                    1837          MOVE.W  D1,D2
00001DD6  E04A                    1838          LSR.W   #8,D2                   ;move reg into first byte
00001DD8  E20A                    1839          LSR.B   #1,D2                   ;line it up to least sig bit
00001DDA  C43C 0007               1840          AND.B   #%00000111,D2           ;force mode to Dn
00001DDE  1A02                    1841          MOVE.B  D2,D5
00001DE0  48E7 4000               1842          MOVEM.L D1,-(SP)
00001DE4  6100 0A44               1843          BSR     Get_Effective_Address
00001DE8  4CDF 0002               1844          MOVEM.L (SP)+,D1
00001DEC                          1845          
00001DEC  43F9 00002CFE           1846          LEA     clearLine,A1            ;move string for a CR and LF
00001DF2  103C 000E               1847          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001DF6                          1848                                ;string without CR, LF
00001DF6  4E4F                    1849          TRAP    #15
00001DF8                          1850  
00001DF8  7000                    1851          MOVEQ.L #0,D0
00001DFA  4E75                    1852          RTS
00001DFC                          1853  
00001DFC                          1854  addDest
00001DFC                          1855  
00001DFC  43F9 00002D47           1856          LEA     addMessage,A1           ;move string for MOVE
00001E02  103C 000E               1857          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001E06                          1858                                          ;string with CR, LF
00001E06  4E4F                    1859          TRAP    #15
00001E08                          1860          
00001E08  6100 0364               1861          BSR negSize
00001E0C                          1862          
00001E0C                          1863          ;Do Dn
00001E0C                          1864          
00001E0C  3401                    1865          MOVE.W  D1,D2
00001E0E  E04A                    1866          LSR.W   #8,D2                   ;move reg into first byte
00001E10  E20A                    1867          LSR.B   #1,D2                   ;line it up to least sig bit
00001E12  C43C 0007               1868          AND.B   #%00000111,D2           ;force mode to Dn
00001E16  1A02                    1869          MOVE.B  D2,D5
00001E18  48E7 4000               1870          MOVEM.L D1,-(SP)
00001E1C  6100 0A0C               1871          BSR     Get_Effective_Address
00001E20  4CDF 0002               1872          MOVEM.L (SP)+,D1
00001E24                          1873          
00001E24                          1874          
00001E24                          1875          ;print ','
00001E24  48E7 4000               1876          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001E28  123C 002C               1877          MOVE.B #',',D1                  ;put ascii value of char in D1
00001E2C  103C 0006               1878          MOVE.B #6,D0                    ;move task 6 into D0
00001E30  4E4F                    1879          TRAP #15                        ;prin char
00001E32  4CDF 0002               1880          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001E36                          1881          
00001E36                          1882          ;Then do EA
00001E36                          1883          
00001E36  3401                    1884          MOVE.W  D1,D2                   ;check mode
00001E38  C43C 003F               1885          AND.B   #%00111111,D2
00001E3C  1A02                    1886          MOVE.B  D2,D5
00001E3E  48E7 4000               1887          MOVEM.L D1,-(SP)
00001E42  6100 09E6               1888          BSR     Get_Effective_Address
00001E46  4CDF 0002               1889          MOVEM.L (SP)+,D1
00001E4A                          1890          
00001E4A                          1891          
00001E4A  43F9 00002CFE           1892          LEA     clearLine,A1            ;move string for a CR and LF
00001E50  103C 000E               1893          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001E54                          1894                                          ;string without CR, LF
00001E54  4E4F                    1895          TRAP    #15
00001E56                          1896  
00001E56  7000                    1897          MOVEQ.L #0,D0
00001E58  4E75                    1898          RTS
00001E5A                          1899  
00001E5A                          1900  
00001E5A= 10 20 38 39 00          1901  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
00001E5F= 38 38 3F 3F 00          1902  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
00001E64                          1903  
00001E64= 10 18 38 39 00          1904  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
00001E69= 38 38 3F 3F 00          1905  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
00001E6E                          1906  
00001E6E                          1907  MOVEM:
00001E6E                          1908          
00001E6E                          1909  
00001E6E                          1910          
00001E6E  7000                    1911          MOVEQ.L #0, D0                  ;clear D0
00001E70                          1912          
00001E70                          1913          ;Figure out which direction we are going
00001E70  3401                    1914          MOVE.W D1,D2                    ;copy inst to D2
00001E72  E64A                    1915          LSR.W #3,D2                     ;shift direction bit into most sig bit of first byte
00001E74  0202 0080               1916          ANDI.B #%10000000,D2            ;mask out everything but direction bit in first byte
00001E78  0C02 0000               1917          CMPI.B #0,D2                    ;compare bit to zero
00001E7C  6700 0006               1918          BEQ validRegToMem               ;if zero, reg to mem
00001E80  6000 0028               1919          BRA validMemToReg               ;else, its mem to reg
00001E84                          1920          
00001E84                          1921  validRegToMem:
00001E84                          1922          
00001E84  43F8 1E5F               1923          LEA movemRegToMemEAmasks,A1     ;load the list of masks
00001E88  D3C0                    1924          ADDA.L D0,A1                    ;displace to a specific mask
00001E8A  1A11                    1925          MOVE.B (A1),D5                  ;move the mask to D5
00001E8C                          1926          
00001E8C  0C05 0000               1927          CMPI.B #0,D5                    ;check if the mask is 0
00001E90  6700 F206               1928          BEQ falsePositive               ;branch if it is
00001E94                          1929          
00001E94  1401                    1930          MOVE.B D1,D2                    ;copy instruction to D2
00001E96  C405                    1931          AND.B D5,D2                     ;mask D2
00001E98                          1932          
00001E98  43F8 1E5A               1933          LEA movemRegToMemEA,A1          ;load the list of valid modes
00001E9C  D3C0                    1934          ADDA.L D0,A1                    ;displace to a specific mode
00001E9E  1811                    1935          MOVE.B (A1),D4                  ;move mode to D4
00001EA0  B404                    1936          CMP.B D4,D2                     ;compare mode to masked value
00001EA2  6700 002C               1937          BEQ  movemPre                   ;if its match, its a valid mode and we can procede
00001EA6                          1938          
00001EA6  5280                    1939          ADDQ.L #1,D0                    ;add one to displacement
00001EA8  60DA                    1940          BRA validRegToMem               ;check for next mode
00001EAA                          1941          
00001EAA                          1942          
00001EAA                          1943  validMemToReg:
00001EAA                          1944          
00001EAA  43F8 1E69               1945          LEA movemMemToRegEAmasks,A1     ;load the list of masks
00001EAE  D3C0                    1946          ADDA.L D0,A1                    ;displace to a specific mask
00001EB0  1A11                    1947          MOVE.B (A1),D5                  ;move the mask to D5
00001EB2                          1948          
00001EB2  0C05 0000               1949          CMPI.B #0,D5                    ;check if the mask is 0
00001EB6  6700 F1E0               1950          BEQ falsePositive               ;branch if it is
00001EBA                          1951          
00001EBA  3401                    1952          MOVE.W D1,D2                    ;copy instruction to D2
00001EBC  C405                    1953          AND.B D5,D2                     ;mask D2
00001EBE                          1954          
00001EBE  43F8 1E64               1955          LEA movemMemToRegEA,A1          ;load the list of valid modes
00001EC2  D3C0                    1956          ADDA.L D0,A1                    ;displace to a specific mode
00001EC4  1811                    1957          MOVE.B (A1),D4                  ;move mode to D4
00001EC6  B404                    1958          CMP.B D4,D2                     ;compare mode to masked value
00001EC8  6700 0062               1959          BEQ movemPost                   ;if its match, its a valid mode and we can procede
00001ECC                          1960          
00001ECC  5280                    1961          ADDQ.L #1,D0                    ;add one to displacement
00001ECE  60DA                    1962          BRA validMemToReg               ;check for next mode
00001ED0                          1963  
00001ED0                          1964  movemPre:
00001ED0                          1965  
00001ED0  43F9 00002D4B           1966          LEA     movemMessage,A1         ;move string for MOVE
00001ED6  103C 000E               1967          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001EDA                          1968                                          ;string with CR, LF
00001EDA  4E4F                    1969          TRAP    #15
00001EDC                          1970          
00001EDC                          1971          ;size
00001EDC  48E7 4000               1972          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001EE0                          1973          ;make it look like NEG's size
00001EE0  C23C 007F               1974          AND.B #%01111111,D1             ;clear bit next to size
00001EE4  0641 0040               1975          ADDI.W #%01000000,D1            ;add 1 to size to make it look like a word or long
00001EE8  6100 0284               1976          BSR negSize
00001EEC  4CDF 0002               1977          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001EF0                          1978          
00001EF0                          1979          
00001EF0                          1980          ;show list
00001EF0                          1981          
00001EF0  6100 00E6               1982          BSR outputPreIncrement     
00001EF4                          1983          
00001EF4  5487                    1984          ADDQ.L #word,D7                 ;read past the register list mask(word) following
00001EF6                          1985                                          ;the instruction
00001EF6                          1986          
00001EF6                          1987          ;print ','
00001EF6  48E7 4000               1988          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001EFA  123C 002C               1989          MOVE.B #',',D1                  ;put ascii value of char in D1
00001EFE  103C 0006               1990          MOVE.B #6,D0                    ;move task 6 into D0
00001F02  4E4F                    1991          TRAP #15                        ;prin char
00001F04  4CDF 0002               1992          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001F08                          1993          
00001F08  3401                    1994          MOVE.W  D1,D2                   ;check mode
00001F0A  C43C 003F               1995          AND.B   #%00111111,D2
00001F0E  1A02                    1996          MOVE.B  D2,D5
00001F10  48E7 4000               1997          MOVEM.L D1,-(SP)
00001F14  6100 0914               1998          BSR     Get_Effective_Address
00001F18  4CDF 0002               1999          MOVEM.L (SP)+,D1
00001F1C                          2000          
00001F1C                          2001          
00001F1C  43F9 00002CFE           2002          LEA     clearLine,A1            ;move string for a CR and LF
00001F22  103C 000E               2003          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001F26                          2004                                          ;string without CR, LF
00001F26  4E4F                    2005          TRAP    #15
00001F28                          2006  
00001F28  7000                    2007          MOVEQ.L #0,D0
00001F2A  4E75                    2008          RTS
00001F2C                          2009          
00001F2C                          2010  movemPost:
00001F2C                          2011  
00001F2C  43F9 00002D4B           2012          LEA     movemMessage,A1         ;move string for MOVE
00001F32  103C 000E               2013          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001F36                          2014                                          ;string with CR, LF
00001F36  4E4F                    2015          TRAP    #15
00001F38                          2016          
00001F38                          2017          ;size
00001F38  48E7 4000               2018          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001F3C                          2019          ;make it look like NEG's size
00001F3C  C23C 007F               2020          AND.B #%01111111,D1             ;clear bit next to size
00001F40  0641 0040               2021          ADDI.W #%01000000,D1            ;add 1 to size to make it look like a word or long
00001F44  6100 0228               2022          BSR negSize
00001F48  4CDF 0002               2023          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001F4C                          2024  
00001F4C  3401                    2025          MOVE.W  D1,D2                   ;check mode
00001F4E  C43C 003F               2026          AND.B   #%00111111,D2
00001F52  1A02                    2027          MOVE.B  D2,D5
00001F54  48E7 4000               2028          MOVEM.L D1,-(SP)
00001F58  6100 08D0               2029          BSR     Get_Effective_Address
00001F5C  4CDF 0002               2030          MOVEM.L (SP)+,D1
00001F60                          2031          
00001F60                          2032          
00001F60                          2033          ;print ','
00001F60  48E7 4000               2034          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001F64  123C 002C               2035          MOVE.B #',',D1                  ;put ascii value of char in D1
00001F68  103C 0006               2036          MOVE.B #6,D0                    ;move task 6 into D0
00001F6C  4E4F                    2037          TRAP #15                        ;prin char
00001F6E  4CDF 0002               2038          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001F72                          2039          
00001F72                          2040  
00001F72                          2041          
00001F72                          2042          ;show list
00001F72  6100 0102               2043          BSR outputPostIncrement        
00001F76                          2044          
00001F76  5487                    2045          ADDQ.L #word,D7                 ;read past the register list mask(word) following
00001F78                          2046                                          ;the instruction
00001F78                          2047          
00001F78  43F9 00002CFE           2048          LEA     clearLine,A1            ;move string for a CR and LF
00001F7E  103C 000E               2049          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001F82                          2050                                          ;string without CR, LF
00001F82  4E4F                    2051          TRAP    #15
00001F84                          2052  
00001F84  7000                    2053          MOVEQ.L #0,D0
00001F86  4E75                    2054          RTS
00001F88                          2055  
00001F88= 00000000 00000000 ...   2056  movemRegListBuffer DC.L 0,0,0,0,0,0,0,0,0,0,0,0 
00001FB8                          2057                                          ;max of 16 regs @ 2 bytes each, 
00001FB8                          2058                                          ;15 possible '/' @ a byte
00001FB8                          2059                                          ;byte for null terminator
00001FB8                          2060                                          ; 48 bytes = 12 longs 
00001FB8                          2061                              
00001FB8= 41 37 41 36 41 35 ...   2062  movemPostRegList DC.B 'A7','A6','A5','A4','A3','A2','A1','A0','D7','D6','D5','D4','D3','D2','D1','D0'
00001FD8                          2063  movemPreRegList ;should be location after PostList
00001FD8                          2064          
00001FD8                          2065  outputPreincrement:
00001FD8  548B                    2066             ADDQ.L #word,A3
00001FDA  3413                    2067          MOVE.W (A3),D2
00001FDC  7600                    2068          MOVEQ.L #0,D3
00001FDE  47F8 1F88               2069          LEA movemRegListBuffer,A3
00001FE2  49F8 1FD8               2070          LEA movemPreRegList,A4        
00001FE6  558C                    2071          SUBQ.L #word,A4
00001FE8                          2072          
00001FE8  6100 00E8               2073          BSR checkPreRegAdd              ;1
00001FEC                          2074          
00001FEC  558C                    2075          SUBQ.L #word,A4
00001FEE                          2076          
00001FEE  6100 00E2               2077          BSR checkPreRegAdd              ;2
00001FF2  558C                    2078          SUBQ.L #word,A4
00001FF4  6100 00DC               2079          BSR checkPreRegAdd              ;3
00001FF8  558C                    2080          SUBQ.L #word,A4
00001FFA  6100 00D6               2081          BSR checkPreRegAdd              ;4
00001FFE  558C                    2082          SUBQ.L #word,A4
00002000  6100 00D0               2083          BSR checkPreRegAdd              ;5
00002004  558C                    2084          SUBQ.L #word,A4
00002006  6100 00CA               2085          BSR checkPreRegAdd              ;6
0000200A  558C                    2086          SUBQ.L #word,A4
0000200C  6100 00C4               2087          BSR checkPreRegAdd              ;7
00002010  558C                    2088          SUBQ.L #word,A4
00002012  6100 00BE               2089          BSR checkPreRegAdd              ;8
00002016  558C                    2090          SUBQ.L #word,A4
00002018  6100 00B8               2091          BSR checkPreRegAdd              ;9
0000201C  558C                    2092          SUBQ.L #word,A4
0000201E  6100 00B2               2093          BSR checkPreRegAdd              ;10
00002022  558C                    2094          SUBQ.L #word,A4
00002024  6100 00AC               2095          BSR checkPreRegAdd              ;11
00002028  558C                    2096          SUBQ.L #word,A4
0000202A  6100 00A6               2097          BSR checkPreRegAdd              ;12
0000202E  558C                    2098          SUBQ.L #word,A4
00002030  6100 00A0               2099          BSR checkPreRegAdd              ;13
00002034  558C                    2100          SUBQ.L #word,A4
00002036  6100 009A               2101          BSR checkPreRegAdd              ;14
0000203A  558C                    2102          SUBQ.L #word,A4
0000203C  6100 0094               2103          BSR checkPreRegAdd              ;15
00002040  558C                    2104          SUBQ.L #word,A4
00002042  6100 008E               2105          BSR checkPreRegAdd              ;16
00002046                          2106          
00002046  16BC 0000               2107          MOVE.B #0,(A3)
0000204A  43F8 1F88               2108          LEA     movemRegListBuffer,A1   ;move string for MOVE
0000204E  103C 000E               2109          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002052                          2110                                          ;string without CR, LF
00002052  4E4F                    2111          TRAP    #15 
00002054                          2112          
00002054  4E75                    2113          RTS
00002056                          2114          
00002056                          2115  checkPostRegAdd:
00002056  E342                    2116          ASL.W #1,D2
00002058  6500 0004               2117          BCS PostRegAdd
0000205C                          2118  addPostRegDone:
0000205C  4E75                    2119          RTS
0000205E                          2120          
0000205E                          2121  PostRegAdd:
0000205E  4BF8 1F88               2122          LEA movemRegListBuffer,A5
00002062  BBCB                    2123          CMP.L A3,A5
00002064  6600 000A               2124          BNE postAddBackslash
00002068                          2125  PostRegAddDone:
00002068  16DC                    2126          MOVE.B (A4)+,(A3)+
0000206A  16D4                    2127          MOVE.B (A4),(A3)+
0000206C  538C                    2128          SUBQ.L #byte,A4
0000206E  60EC                    2129          BRA addPostRegDone
00002070                          2130          
00002070                          2131  postAddBackslash:
00002070  16FC 002F               2132          MOVE.B #'/',(A3)+
00002074  60F2                    2133          BRA PostRegAddDone
00002076                          2134          
00002076                          2135  
00002076                          2136  outputPostincrement:
00002076  548B                    2137          ADDQ.L #word,A3
00002078  3413                    2138          MOVE.W (A3),D2
0000207A  7600                    2139          MOVEQ.L #0,D3
0000207C  47F8 1F88               2140          LEA movemRegListBuffer,A3
00002080  49F8 1FB8               2141          LEA movemPostRegList,A4
00002084                          2142          
00002084  61D0                    2143          BSR checkPostRegAdd             ;1
00002086  548C                    2144          ADDQ.L #word,A4
00002088  61CC                    2145          BSR checkPostRegAdd             ;2
0000208A  548C                    2146          ADDQ.L #word,A4
0000208C  61C8                    2147          BSR checkPostRegAdd             ;3
0000208E  548C                    2148          ADDQ.L #word,A4
00002090  61C4                    2149          BSR checkPostRegAdd             ;4
00002092  548C                    2150          ADDQ.L #word,A4
00002094  61C0                    2151          BSR checkPostRegAdd             ;5
00002096  548C                    2152          ADDQ.L #word,A4
00002098  61BC                    2153          BSR checkPostRegAdd             ;6
0000209A  548C                    2154          ADDQ.L #word,A4
0000209C  61B8                    2155          BSR checkPostRegAdd             ;7
0000209E  548C                    2156          ADDQ.L #word,A4
000020A0  61B4                    2157          BSR checkPostRegAdd             ;8
000020A2  548C                    2158          ADDQ.L #word,A4
000020A4  61B0                    2159          BSR checkPostRegAdd             ;9
000020A6  548C                    2160          ADDQ.L #word,A4
000020A8  61AC                    2161          BSR checkPostRegAdd             ;10
000020AA  548C                    2162          ADDQ.L #word,A4
000020AC  61A8                    2163          BSR checkPostRegAdd             ;11
000020AE  548C                    2164          ADDQ.L #word,A4
000020B0  61A4                    2165          BSR checkPostRegAdd             ;12
000020B2  548C                    2166          ADDQ.L #word,A4
000020B4  61A0                    2167          BSR checkPostRegAdd             ;13
000020B6  548C                    2168          ADDQ.L #word,A4
000020B8  619C                    2169          BSR checkPostRegAdd             ;14
000020BA  548C                    2170          ADDQ.L #word,A4
000020BC  6198                    2171          BSR checkPostRegAdd             ;15
000020BE  548C                    2172          ADDQ.L #word,A4
000020C0  6194                    2173          BSR checkPostRegAdd             ;16
000020C2                          2174          
000020C2  16BC 0000               2175          MOVE.B #0,(A3)
000020C6  43F8 1F88               2176          LEA     movemRegListBuffer,A1   ;move string for MOVE
000020CA  103C 000E               2177          MOVE.B  #14,D0                  ;set for task to display null terminated 
000020CE                          2178                               ;string without CR, LF
000020CE  4E4F                    2179          TRAP    #15 
000020D0                          2180          
000020D0  4E75                    2181          RTS
000020D2                          2182          
000020D2                          2183  checkPreRegAdd:
000020D2  E342                    2184          ASL.W #1,D2
000020D4  6500 0004               2185          BCS PreRegAdd
000020D8                          2186  addPreRegDone:
000020D8  4E75                    2187          RTS
000020DA                          2188          
000020DA                          2189  PreRegAdd:
000020DA  4BF8 1F88               2190          LEA movemRegListBuffer,A5
000020DE  BBCB                    2191          CMP.L A3,A5
000020E0  6600 000A               2192          BNE preAddBackslash
000020E4                          2193  PreRegAddDone:
000020E4  16DC                    2194          MOVE.B (A4)+,(A3)+
000020E6  16D4                    2195          MOVE.B (A4),(A3)+
000020E8  538C                    2196          SUBQ.L #byte,A4
000020EA  60EC                    2197          BRA addPreRegDone
000020EC                          2198          
000020EC                          2199  preAddBackslash:
000020EC  16FC 002F               2200          MOVE.B #'/',(A3)+
000020F0  6000 FF76               2201          BRA PostRegAddDone
000020F4                          2202  
000020F4                          2203      
000020F4= 00 10 18 20 28 38 ...   2204  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
000020FC= 38 38 38 38 38 3F ...   2205  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
00002104                          2206     
00002104                          2207  NEG:            
00002104                          2208       
00002104  7000                    2209          MOVEQ.L #0, D0                  ;clear D0
00002106                          2210          
00002106                          2211  validNegModes:
00002106                          2212          
00002106  43F8 20FC               2213          LEA NegEAmasks,A1               ;load the list of masks
0000210A  D3C0                    2214          ADDA.L D0,A1                    ;displace to a specific mask
0000210C  1A11                    2215          MOVE.B (A1),D5                  ;move the mask to D5
0000210E                          2216          
0000210E  0C05 0000               2217          CMPI.B #0,D5                    ;check if the mask is 0
00002112  6700 EF84               2218          BEQ falsePositive               ;branch if it is
00002116                          2219          
00002116  1401                    2220          MOVE.B D1,D2                    ;copy instruction to D2
00002118  C405                    2221          AND.B D5,D2                     ;mask D2
0000211A  43F8 20F4               2222          LEA NegEA,A1                    ;load the list of valid modes
0000211E  D3C0                    2223          ADDA.L D0,A1                    ;displace to a specific mode
00002120  1811                    2224          MOVE.B (A1),D4                  ;move mode to D4
00002122  B404                    2225          CMP.B D4,D2                     ;compare mode to masked value
00002124  6700 0006               2226          BEQ NegBody                     ;if its match, its a valid mode and we can procede
00002128                          2227          
00002128  5280                    2228          ADDQ.L #1,D0                    ;add one to displacement
0000212A  60DA                    2229          BRA validNegModes               ;check for next mode
0000212C                          2230          
0000212C                          2231  NegBody:
0000212C                          2232  
0000212C                          2233  
0000212C  3401                    2234          MOVE.W  D1,D2                   ;copy inst to D2
0000212E  C47C 0600               2235          AND.W  #%0011000000000,D2       ;mask word for size
00002132  0C42 0000               2236          CMPI.W #0,D2                    ;0 is the only non valid size
00002136  6700 EF60               2237          BEQ falsePositive               ; zero is not valid
0000213A                          2238  
0000213A  43F9 00002D75           2239          LEA     negMessage,A1           ;move string for NEG info
00002140  103C 000E               2240          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002144                          2241                                ;string without CR, LF
00002144  4E4F                    2242          TRAP    #15
00002146                          2243          
00002146  6100 0026               2244          BSR NegSize
0000214A                          2245          
0000214A  3401                    2246          MOVE.W D1,D2
0000214C  C47C 003F               2247          AND #%000000000111111,D2
00002150  1A02                    2248          MOVE.B D2,D5
00002152                          2249          
00002152  48E7 4000               2250          MOVEM.L D1,-(SP)
00002156  6100 06D2               2251          BSR     Get_Effective_Address
0000215A  4CDF 0002               2252          MOVEM.L (SP)+,D1
0000215E                          2253          
0000215E                          2254                
0000215E                          2255          
0000215E                          2256  NEGdone:
0000215E                          2257  
0000215E  43F9 00002CFE           2258          LEA     clearLine,A1            ;move string for a CR and LF
00002164  103C 000E               2259          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002168                          2260                                          ;string without CR, LF
00002168  4E4F                    2261          TRAP    #15
0000216A  7000                    2262          MOVEQ.L #0,D0
0000216C  4E75                    2263          RTS
0000216E                          2264          
0000216E                          2265  NegSize:
0000216E  3401                    2266          MOVE.W  D1,D2                   ;copy inst to D2
00002170  EC4A                    2267          LSR.W #6,D2                     ;shift size over to first byte
00002172  C4BC 00000003           2268          AND.L  #%11,D2                  ;mask word for size
00002178  2C02                    2269          MOVE.L D2,D6                    ;size does not need to be translated,
0000217A                          2270                                          ;so moved directly to D6
0000217A                          2271          
0000217A  6100 084C               2272          BSR printSize
0000217E                          2273          
0000217E  4E75                    2274          RTS
00002180                          2275          
00002180                          2276          
00002180                          2277   ADDI:            
00002180                          2278       
00002180  7000                    2279          MOVEQ.L #0, D0                  ;clear D0
00002182                          2280          
00002182                          2281  validAddiModes:
00002182                          2282          
00002182                          2283          
00002182  43F9 000022A7           2284          LEA cmpiEAmasks,A1              ;load the list of masks
00002188  D3C0                    2285          ADDA.L D0,A1                    ;displace to a specific mask
0000218A  1A11                    2286          MOVE.B (A1),D5                  ;move the mask to D5
0000218C                          2287          
0000218C  0C05 0000               2288          CMPI.B #0,D5                    ;check if the mask is 0
00002190  6700 EF06               2289          BEQ falsePositive               ;branch if it is
00002194                          2290          
00002194  1401                    2291          MOVE.B D1,D2                    ;copy instruction to D2
00002196  C405                    2292          AND.B D5,D2                     ;mask D2
00002198  43F9 000022A0           2293          LEA cmpiEA,A1                   ;load the list of valid modes
0000219E  D3C0                    2294          ADDA.L D0,A1                    ;displace to a specific mode
000021A0  1811                    2295          MOVE.B (A1),D4                  ;move mode to D4
000021A2  B404                    2296          CMP.B D4,D2                     ;compare mode to masked value
000021A4  6700 0006               2297          BEQ addiBody                    ;if its match, its a valid mode and we can procede
000021A8                          2298          
000021A8  5280                    2299          ADDQ.L #1,D0                    ;add one to displacement
000021AA  60D6                    2300          BRA validAddiModes              ;check for next mode
000021AC                          2301          
000021AC                          2302  addiBody:
000021AC                          2303  
000021AC                          2304  
000021AC  3401                    2305          MOVE.W  D1,D2                   ;copy inst to D2
000021AE  C47C 00C0               2306          AND.W  #%0000000011000000,D2    ;mask word for size
000021B2  0C42 00C0               2307          CMPI.W #%0000000011000000,D2    ;11 is the only non valid size
000021B6  6700 EEE0               2308          BEQ falsePositive
000021BA                          2309  
000021BA  43F9 00002D51           2310          LEA     addiMessage,A1          ;move string for NEG info
000021C0  103C 000E               2311          MOVE.B  #14,D0                  ;set for task to display null terminated 
000021C4                          2312                                ;string without CR, LF
000021C4  4E4F                    2313          TRAP    #15
000021C6                          2314          
000021C6  61A6                    2315          BSR NegSize
000021C8                          2316          
000021C8                          2317          ;go to Effective_Address for immediate data
000021C8  743C                    2318          MOVE.L #%00111100,D2
000021CA  2A02                    2319          MOVE.L D2,D5
000021CC  48E7 4000               2320          MOVEM.L D1,-(SP)
000021D0  6100 0658               2321          BSR     Get_Effective_Address
000021D4  4CDF 0002               2322          MOVEM.L (SP)+,D1
000021D8                          2323          
000021D8                          2324          ;print ','
000021D8  48E7 4000               2325          MOVEM.L D1,-(SP)                ;save D1 to the stack
000021DC  123C 002C               2326          MOVE.B #',',D1                  ;put ascii value of char in D1
000021E0  103C 0006               2327          MOVE.B #6,D0                    ;move task 6 into D0
000021E4  4E4F                    2328          TRAP #15                        ;prin char
000021E6  4CDF 0002               2329          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000021EA                          2330          
000021EA  3401                    2331          MOVE.W D1,D2                    ;copy inst to D2
000021EC  C47C 003F               2332          AND #%000000000111111,D2        ;and out everything but modes and regs
000021F0  1A02                    2333          MOVE.B D2,D5                    ; copy to D5 for following BSR
000021F2                          2334          
000021F2  48E7 4000               2335          MOVEM.L D1,-(SP)
000021F6  6100 0632               2336          BSR     Get_Effective_Address
000021FA  4CDF 0002               2337          MOVEM.L (SP)+,D1
000021FE                          2338          
000021FE                          2339                
000021FE                          2340          
000021FE                          2341  addidone:
000021FE                          2342  
000021FE  43F9 00002CFE           2343          LEA     clearLine,A1            ;move string for a CR and LF
00002204  103C 000E               2344          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002208                          2345                                          ;string without CR, LF
00002208  4E4F                    2346          TRAP    #15
0000220A  7000                    2347          MOVEQ.L #0,D0
0000220C  4E75                    2348          RTS
0000220E                          2349    
0000220E                          2350  ORI:            
0000220E                          2351       
0000220E  7000                    2352          MOVEQ.L #0, D0                  ;clear D0
00002210                          2353          
00002210                          2354  validOriModes:
00002210                          2355          
00002210                          2356          
00002210  43F9 000022A7           2357          LEA cmpiEAmasks,A1              ;load the list of masks
00002216  D3C0                    2358          ADDA.L D0,A1                    ;displace to a specific mask
00002218  1A11                    2359          MOVE.B (A1),D5                  ;move the mask to D5
0000221A                          2360          
0000221A  0C05 0000               2361          CMPI.B #0,D5                    ;check if the mask is 0
0000221E  6700 EE78               2362          BEQ falsePositive               ;branch if it is
00002222                          2363          
00002222  1401                    2364          MOVE.B D1,D2                    ;copy instruction to D2
00002224  C405                    2365          AND.B D5,D2                     ;mask D2
00002226  43F9 000022A0           2366          LEA cmpiEA,A1                   ;load the list of valid modes
0000222C  D3C0                    2367          ADDA.L D0,A1                    ;displace to a specific mode
0000222E  1811                    2368          MOVE.B (A1),D4                  ;move mode to D4
00002230  B404                    2369          CMP.B D4,D2                     ;compare mode to masked value
00002232  6700 0006               2370          BEQ oriBody                     ;if its match, its a valid mode and we can procede
00002236                          2371          
00002236  5280                    2372          ADDQ.L #1,D0                    ;add one to displacement
00002238  60D6                    2373          BRA validOriModes               ;check for next mode
0000223A                          2374          
0000223A                          2375  oriBody:
0000223A                          2376  
0000223A                          2377  
0000223A  3401                    2378          MOVE.W  D1,D2                   ;copy inst to D2
0000223C  C47C 00C0               2379          AND.W  #%0000000011000000,D2    ;mask word for size
00002240  0C42 00C0               2380          CMPI.W #%0000000011000000,D2    ;11 is the only non valid size
00002244  6700 EE52               2381          BEQ falsePositive
00002248                          2382  
00002248  43F9 00002D56           2383          LEA     oriMessage,A1           ;move string for NEG info
0000224E  103C 000E               2384          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002252                          2385                                ;string without CR, LF
00002252  4E4F                    2386          TRAP    #15
00002254                          2387          
00002254  6100 FF18               2388          BSR negSize
00002258                          2389          
00002258                          2390          ;go to Effective_Address for immediate data
00002258  143C 003C               2391          MOVE.B #%00111100,D2
0000225C  1A02                    2392          MOVE.B D2,D5
0000225E  48E7 4000               2393          MOVEM.L D1,-(SP)
00002262  6100 05C6               2394          BSR     Get_Effective_Address
00002266  4CDF 0002               2395          MOVEM.L (SP)+,D1
0000226A                          2396          
0000226A                          2397          ;print ','
0000226A  48E7 4000               2398          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000226E  123C 002C               2399          MOVE.B #',',D1                  ;put ascii value of char in D1
00002272  103C 0006               2400          MOVE.B #6,D0                    ;move task 6 into D0
00002276  4E4F                    2401          TRAP #15                        ;print char
00002278  4CDF 0002               2402          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000227C                          2403          
0000227C  3401                    2404          MOVE.W D1,D2                    ;copy inst to D2
0000227E  C47C 003F               2405          AND #%000000000111111,D2        ;and out everything but modes and regs
00002282  1A02                    2406          MOVE.B D2,D5                    ; copy to D5 for following BSR
00002284                          2407          
00002284  48E7 4000               2408          MOVEM.L D1,-(SP)
00002288  6100 05A0               2409          BSR     Get_Effective_Address
0000228C  4CDF 0002               2410          MOVEM.L (SP)+,D1
00002290                          2411          
00002290                          2412                
00002290                          2413          
00002290                          2414  oridone:
00002290                          2415  
00002290  43F9 00002CFE           2416          LEA     clearLine,A1            ;move string for a CR and LF
00002296  103C 000E               2417          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000229A                          2418                                          ;string without CR, LF
0000229A  4E4F                    2419          TRAP    #15
0000229C  7000                    2420          MOVEQ.L #0,D0
0000229E  4E75                    2421          RTS
000022A0                          2422  
000022A0                          2423          
000022A0                          2424          
000022A0= 20 18 00 10 38 39 00    2425  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
000022A7= 38 38 38 38 3F 3F 00    2426  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
000022AE                          2427     
000022AE                          2428  CMPI:            
000022AE                          2429       
000022AE  7000                    2430          MOVEQ.L #0, D0                  ;clear D0
000022B0                          2431          
000022B0                          2432  validCmpiModes:
000022B0                          2433          
000022B0                          2434          
000022B0  43F8 22A7               2435          LEA cmpiEAmasks,A1              ;load the list of masks
000022B4  D3C0                    2436          ADDA.L D0,A1                    ;displace to a specific mask
000022B6  1A11                    2437          MOVE.B (A1),D5                  ;move the mask to D5
000022B8                          2438          
000022B8  0C05 0000               2439          CMPI.B #0,D5                    ;check if the mask is 0
000022BC  6700 EDDA               2440          BEQ falsePositive               ;branch if it is
000022C0                          2441          
000022C0  1401                    2442          MOVE.B D1,D2                    ;copy instruction to D2
000022C2  C405                    2443          AND.B D5,D2                     ;mask D2
000022C4  43F8 22A0               2444          LEA cmpiEA,A1                   ;load the list of valid modes
000022C8  D3C0                    2445          ADDA.L D0,A1                    ;displace to a specific mode
000022CA  1811                    2446          MOVE.B (A1),D4                  ;move mode to D4
000022CC  B404                    2447          CMP.B D4,D2                     ;compare mode to masked value
000022CE  6700 0006               2448          BEQ CMPIBody                    ;if its match, its a valid mode and we can procede
000022D2                          2449          
000022D2  5280                    2450          ADDQ.L #1,D0                    ;add one to displacement
000022D4  60DA                    2451          BRA validCmpiModes              ;check for next mode
000022D6                          2452          
000022D6                          2453  CMPIBody:
000022D6                          2454  
000022D6                          2455  
000022D6  3401                    2456          MOVE.W  D1,D2                   ;copy inst to D2
000022D8  C47C 00C0               2457          AND.W  #%0000000011000000,D2    ;mask word for size
000022DC  0C42 00C0               2458          CMPI.W #%0000000011000000,D2    ;11 is the only non valid size
000022E0  6700 EDB6               2459          BEQ falsePositive
000022E4                          2460  
000022E4  43F9 00002D5A           2461          LEA     cmpiMessage,A1          ;move string for NEG info
000022EA  103C 000E               2462          MOVE.B  #14,D0                  ;set for task to display null terminated 
000022EE                          2463                                ;string without CR, LF
000022EE  4E4F                    2464          TRAP    #15
000022F0                          2465          
000022F0  6100 FE7C               2466          BSR negSize
000022F4                          2467          
000022F4                          2468          ;go to Effective_Address for immediate data
000022F4  143C 003C               2469          MOVE.B #%00111100,D2
000022F8  1A02                    2470          MOVE.B D2,D5
000022FA  48E7 4000               2471          MOVEM.L D1,-(SP)
000022FE  6100 052A               2472          BSR     Get_Effective_Address
00002302  4CDF 0002               2473          MOVEM.L (SP)+,D1
00002306                          2474          
00002306                          2475          ;print ','
00002306  48E7 4000               2476          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000230A  123C 002C               2477          MOVE.B #',',D1                  ;put ascii value of char in D1
0000230E  103C 0006               2478          MOVE.B #6,D0                    ;move task 6 into D0
00002312  4E4F                    2479          TRAP #15                        ;prin char
00002314  4CDF 0002               2480          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002318                          2481          
00002318  3401                    2482          MOVE.W D1,D2                    ;copy inst to D2
0000231A  C47C 003F               2483          AND #%000000000111111,D2        ;and out everything but modes and regs
0000231E  1A02                    2484          MOVE.B D2,D5                    ; copy to D5 for following BSR
00002320                          2485          
00002320  48E7 4000               2486          MOVEM.L D1,-(SP)
00002324  6100 0504               2487          BSR     Get_Effective_Address
00002328  4CDF 0002               2488          MOVEM.L (SP)+,D1
0000232C                          2489          
0000232C                          2490                
0000232C                          2491          
0000232C                          2492  CMPidone:
0000232C                          2493  
0000232C  43F9 00002CFE           2494          LEA     clearLine,A1            ;move string for a CR and LF
00002332  103C 000E               2495          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002336                          2496                                ;string without CR, LF
00002336  4E4F                    2497          TRAP    #15
00002338  7000                    2498          MOVEQ.L #0,D0
0000233A  4E75                    2499          RTS
0000233C                          2500  
0000233C                          2501          
0000233C= 10 38 39 00             2502  JsrEA        DC.B %010000, %111000, %111001,0
00002340= 38 3F 3F 00             2503  JsrEAmasks   DC.B %111000, %111111, %111111,0
00002344                          2504     
00002344                          2505  JSR:            
00002344                          2506       
00002344  7000                    2507          MOVEQ.L #0, D0                  ;clear D0
00002346                          2508          
00002346                          2509  validJsrModes:
00002346                          2510          
00002346  43F8 2340               2511          LEA JsrEAmasks,A1               ;load the list of masks
0000234A  D3C0                    2512          ADDA.L D0,A1                    ;displace to a specific mask
0000234C  1A11                    2513          MOVE.B (A1),D5                  ;move the mask to D5
0000234E                          2514          
0000234E  0C05 0000               2515          CMPI.B #0,D5                    ;check if the mask is 0
00002352  6700 ED44               2516          BEQ falsePositive               ;branch if it is
00002356                          2517          
00002356  1401                    2518          MOVE.B D1,D2                    ;copy instruction to D2
00002358  C405                    2519          AND.B D5,D2                     ;mask D2
0000235A  43F8 233C               2520          LEA JsrEA,A1                    ;load the list of valid modes
0000235E  D3C0                    2521          ADDA.L D0,A1                    ;displace to a specific mode
00002360  1811                    2522          MOVE.B (A1),D4                  ;move mode to D4
00002362  B404                    2523          CMP.B D4,D2                     ;compare mode to masked value
00002364  6700 0006               2524          BEQ JsrBody                     ;if its match, its a valid mode and we can procede
00002368                          2525          
00002368  5280                    2526          ADDQ.L #1,D0                    ;add one to displacement
0000236A  60DA                    2527          BRA validJsrModes               ;check for next mode
0000236C                          2528          
0000236C                          2529  JsrBody:
0000236C                          2530  
0000236C                          2531  
0000236C  43F9 00002D5F           2532          LEA     jsrMessage,A1           ;move string for NEG info
00002372  103C 000E               2533          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002376                          2534                                ;string without CR, LF
00002376  4E4F                    2535          TRAP    #15
00002378                          2536          
00002378  3401                    2537          MOVE.W D1,D2                    ;copy inst to D2
0000237A  C47C 003F               2538          AND #%000000000111111,D2        ;and out everything but modes and regs
0000237E  1A02                    2539          MOVE.B D2,D5                    ; copy to D5 for following BSR
00002380                          2540          
00002380  48E7 4000               2541          MOVEM.L D1,-(SP)
00002384  6100 04A4               2542          BSR     Get_Effective_Address
00002388  4CDF 0002               2543          MOVEM.L (SP)+,D1
0000238C                          2544          
0000238C                          2545                
0000238C                          2546          
0000238C                          2547  Jsrdone:
0000238C                          2548  
0000238C  43F9 00002CFE           2549          LEA     clearLine,A1            ;move string for a CR and LF
00002392  103C 000E               2550          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002396                          2551                                ;string without CR, LF
00002396  4E4F                    2552          TRAP    #15
00002398  7000                    2553          MOVEQ.L #0,D0
0000239A  4E75                    2554          RTS
0000239C                          2555  
0000239C                          2556  
0000239C                          2557          
0000239C                          2558  NOP:
0000239C                          2559  
0000239C  43F9 00002D69           2560          LEA     nopMessage,A1           ;move string for NOP info
000023A2  103C 000D               2561          MOVE.B  #13,D0                  ;set for task to display null terminated 
000023A6                          2562                                          ;string with CR, LF
000023A6  4E4F                    2563          TRAP    #15
000023A8                          2564          
000023A8  7000                    2565          MOVEQ.L #0,D0
000023AA  4E75                    2566          RTS
000023AC                          2567          
000023AC                          2568  RTS:
000023AC                          2569          
000023AC  43F9 00002D64           2570          LEA     rtsMessage,A1           ;move string for rts info
000023B2  103C 000D               2571          MOVE.B  #13,D0                  ;set for task to display null terminated 
000023B6                          2572                                          ;string with CR, LF
000023B6  4E4F                    2573          TRAP    #15  
000023B8                          2574     
000023B8  7000                    2575          MOVEQ.L #0,D0
000023BA  4E75                    2576          RTS   
000023BC                          2577  
000023BC= 3C 08 00 10 18 20 ...   2578  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
000023C5= 3F 38 38 38 38 38 ...   2579  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
000023CE                          2580  
000023CE= 00 10 18 20 38 39 00    2581  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
000023D5= 38 38 38 38 3F 3F 00    2582  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
000023DC                          2583  
000023DC                          2584  MOVE:
000023DC                          2585          
000023DC                          2586  
000023DC                          2587          
000023DC  7000                    2588          MOVEQ.L #0, D0                  ;clear D0
000023DE                          2589          
000023DE                          2590  validMoveSourceModes:
000023DE                          2591          
000023DE  43F8 23C5               2592          LEA moveSourceEAmasks,A1        ;load the list of masks
000023E2  D3C0                    2593          ADDA.L D0,A1                    ;displace to a specific mask
000023E4  1A11                    2594          MOVE.B (A1),D5                  ;move the mask to D5
000023E6                          2595          
000023E6  0C05 0000               2596          CMPI.B #0,D5                    ;check if the mask is 0
000023EA  6700 ECAC               2597          BEQ falsePositive               ;branch if it is
000023EE                          2598          
000023EE  1401                    2599          MOVE.B D1,D2                    ;copy instruction to D2
000023F0  C405                    2600          AND.B D5,D2                     ;mask D2
000023F2                          2601          
000023F2  43F8 23BC               2602          LEA moveSourceEA,A1             ;load the list of valid modes
000023F6  D3C0                    2603          ADDA.L D0,A1                    ;displace to a specific mode
000023F8  1811                    2604          MOVE.B (A1),D4                  ;move mode to D4
000023FA  B404                    2605          CMP.B D4,D2                     ;compare mode to masked value
000023FC  6700 0006               2606          BEQ  checkMoveDest              ;if its match, its a valid mode and we can procede
00002400                          2607          
00002400  5280                    2608          ADDQ.L #1,D0                    ;add one to displacement
00002402  60DA                    2609          BRA validMoveSourceModes        ;check for next mode
00002404                          2610          
00002404                          2611  checkMoveDest:
00002404  7000                    2612          MOVEQ.L #0, D0                  ;clear D0
00002406                          2613          
00002406                          2614  validMoveDestModes:
00002406                          2615          
00002406  43F8 23D5               2616          LEA moveDestEAmasks,A1          ;load the list of masks
0000240A  D3C0                    2617          ADDA.L D0,A1                    ;displace to a specific mask
0000240C  1A11                    2618          MOVE.B (A1),D5                  ;move the mask to D5
0000240E                          2619          
0000240E  0C05 0000               2620          CMPI.B #0,D5                    ;check if the mask is 0
00002412  6700 EC84               2621          BEQ falsePositive               ;branch if it is
00002416                          2622          
00002416  3401                    2623          MOVE.W D1,D2                    ;copy instruction to D2
00002418  EC4A                    2624          LSR.W #6,D2                     ;move mode
0000241A  6100 06DE               2625          BSR switchModeAndReg            ;switch register and mode
0000241E  C405                    2626          AND.B D5,D2                     ;mask D2
00002420                          2627          
00002420  43F8 23CE               2628          LEA moveDestEA,A1               ;load the list of valid modes
00002424  D3C0                    2629          ADDA.L D0,A1                    ;displace to a specific mode
00002426  1811                    2630          MOVE.B (A1),D4                  ;move mode to D4
00002428  B404                    2631          CMP.B D4,D2                     ;compare mode to masked value
0000242A  6700 0006               2632          BEQ moveBody                    ;if its match, its a valid mode and we can procede
0000242E                          2633          
0000242E  5280                    2634          ADDQ.L #1,D0                    ;add one to displacement
00002430  60D4                    2635          BRA validMoveDestModes          ;check for next mode
00002432                          2636          
00002432                          2637  moveBody
00002432  3401                    2638          MOVE.W  D1,D2                   ;copy inst to D2
00002434  C47C 3000               2639          AND.W  #%0011000000000000,D2    ;mask word for size
00002438  0C42 0000               2640          CMPI.W #0,D2                    ;0 is the only non valid size
0000243C  6700 EC5A               2641          BEQ falsePositive               ; if zero, this is not move
00002440                          2642  
00002440  43F9 00002D6E           2643          LEA     moveMessage,A1          ;move string for MOVE
00002446  103C 000E               2644          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000244A                          2645                                ;string with CR, LF
0000244A  4E4F                    2646          TRAP    #15
0000244C                          2647          
0000244C  6100 0052               2648          BSR moveSize
00002450                          2649          
00002450  3401                    2650          MOVE.W  D1,D2                   ;check source mode
00002452  C43C 003F               2651          AND.B   #%00111111,D2
00002456  1A02                    2652          MOVE.B  D2,D5
00002458  48E7 4000               2653          MOVEM.L D1,-(SP)
0000245C  6100 03CC               2654          BSR     Get_Effective_Address
00002460  4CDF 0002               2655          MOVEM.L (SP)+,D1
00002464                          2656          
00002464                          2657          ;print ','
00002464  48E7 4000               2658          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002468  123C 002C               2659          MOVE.B #',',D1                  ;put ascii value of char in D1
0000246C  103C 0006               2660          MOVE.B #6,D0                    ;move task 6 into D0
00002470  4E4F                    2661          TRAP #15                        ;prin char
00002472  4CDF 0002               2662          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002476                          2663          
00002476  3401                    2664          MOVE.W  D1,D2                   ;check dest mode
00002478  EC4A                    2665          LSR.W   #6,D2
0000247A  6100 067E               2666          BSR  switchModeAndReg
0000247E  C43C 003F               2667          AND.B   #%00111111,D2
00002482  1A02                    2668          MOVE.B  D2,D5
00002484  48E7 4000               2669          MOVEM.L D1,-(SP)
00002488  6100 03A0               2670          BSR     Get_Effective_Address
0000248C  4CDF 0002               2671          MOVEM.L (SP)+,D1
00002490                          2672          
00002490                          2673          
00002490                          2674          
00002490  43F9 00002CFE           2675          LEA     clearLine,A1            ;move string for a CR and LF
00002496  103C 000E               2676          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000249A                          2677                                ;string without CR, LF
0000249A  4E4F                    2678          TRAP    #15
0000249C                          2679  
0000249C  7000                    2680          MOVEQ.L #0,D0
0000249E  4E75                    2681          RTS
000024A0                          2682          
000024A0                          2683  moveSize:
000024A0  3401                    2684          MOVE.W  D1,D2                   ;copy inst to D2
000024A2  E04A                    2685          LSR.W   #8,D2                   ;shift size
000024A4  E80A                    2686          LSR.B   #4,D2
000024A6  C4BC 00000003           2687          AND.L  #%11,D2                  ;mask for size
000024AC  7C00                    2688          MOVEQ.L #0,D6                   ;clear D6
000024AE  0C42 0002               2689          CMPI.W #2,D2                    ;compare and then branch depending on size
000024B2  6700 001C               2690          BEQ moveSizeLong
000024B6  6E00 0012               2691          BGT moveSizeWord
000024BA  6D00 0008               2692          BLT moveSizeByte
000024BE                          2693  moveSizeDone:        
000024BE  6100 0508               2694          BSR printSize
000024C2  4E75                    2695          RTS
000024C4                          2696          
000024C4                          2697  moveSizeByte:
000024C4  1C3C 0000               2698          MOVE.B #0,D6
000024C8  60F4                    2699          BRA moveSizeDone
000024CA                          2700          
000024CA                          2701  moveSizeWord:
000024CA  1C3C 0001               2702          MOVE.B #1,D6
000024CE  60EE                    2703          BRA moveSizeDone
000024D0                          2704          
000024D0                          2705  moveSizeLong:
000024D0  1C3C 0002               2706          MOVE.B #2,D6
000024D4  60E8                    2707          BRA moveSizeDone
000024D6                          2708          
000024D6= 08 00                   2709  moveADestEA        DC.B %001000,0
000024D8= 38 00                   2710  moveADestEAmasks   DC.B %111000,0
000024DA                          2711          
000024DA                          2712  MOVEA:
000024DA                          2713  
000024DA  7000                    2714          MOVEQ.L #0, D0                  ;clear D0
000024DC                          2715          
000024DC                          2716  validMoveAModes:
000024DC                          2717          
000024DC  43F8 23C5               2718          LEA moveSourceEAmasks,A1        ;load the list of masks
000024E0  D3C0                    2719          ADDA.L D0,A1                    ;displace to a specific mask
000024E2  1A11                    2720          MOVE.B (A1),D5                  ;move the mask to D5
000024E4                          2721          
000024E4  0C05 0000               2722          CMPI.B #0,D5                    ;check if the mask is 0
000024E8  6700 EBAE               2723          BEQ falsePositive               ;branch if it is
000024EC                          2724          
000024EC  1401                    2725          MOVE.B D1,D2                    ;copy instruction to D2
000024EE  C405                    2726          AND.B D5,D2                     ;mask D2
000024F0                          2727          
000024F0  43F8 23BC               2728          LEA moveSourceEA,A1             ;load the list of valid modes
000024F4  D3C0                    2729          ADDA.L D0,A1                    ;displace to a specific mode
000024F6  1811                    2730          MOVE.B (A1),D4                  ;move mode to D4
000024F8  B404                    2731          CMP.B D4,D2                     ;compare mode to masked value
000024FA  6700 0006               2732          BEQ  moveABody                  ;if its match, its a valid mode and we can procede
000024FE                          2733          
000024FE  5280                    2734          ADDQ.L #1,D0                    ;add one to displacement
00002500  60DA                    2735          BRA validMoveAModes             ;check for next mode
00002502                          2736          
00002502                          2737  moveABody:
00002502  3401                    2738          MOVE.W  D1,D2                   ;copy inst to D2
00002504  C47C 3000               2739          AND.W  #%0011000000000000,D2    ;mask word for size
00002508  0C42 0000               2740          CMPI.W #0,D2                    ;0 is the non valid size
0000250C  6700 EB8A               2741          BEQ falsePositive               ; if zero, this is not move
00002510  0C42 1000               2742          CMPI.W #%0001000000000000,D2
00002514  6700 EB82               2743          BEQ falsePositive               ; if byte, this is not movea
00002518                          2744  
00002518                          2745  
00002518  43F9 00002D7F           2746          LEA     moveAMessage,A1         ;move string for MOVE
0000251E  103C 000E               2747          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002522                          2748                                ;string without CR, LF
00002522  4E4F                    2749          TRAP    #15
00002524                          2750  
00002524  6100 FF7A               2751          BSR moveSize
00002528                          2752          
00002528                          2753          ;Do EA
00002528                          2754          
00002528  3401                    2755          MOVE.W  D1,D2                   ;check mode
0000252A  C43C 003F               2756          AND.B   #%00111111,D2
0000252E  1A02                    2757          MOVE.B  D2,D5
00002530  48E7 4000               2758          MOVEM.L D1,-(SP)
00002534  6100 02F4               2759          BSR     Get_Effective_Address
00002538  4CDF 0002               2760          MOVEM.L (SP)+,D1
0000253C                          2761          
0000253C                          2762          
0000253C                          2763          ;print ','
0000253C  48E7 4000               2764          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002540  123C 002C               2765          MOVE.B #',',D1                  ;put ascii value of char in D1
00002544  103C 0006               2766          MOVE.B #6,D0                    ;move task 6 into D0
00002548  4E4F                    2767          TRAP #15                        ;prin char
0000254A  4CDF 0002               2768          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000254E                          2769          
0000254E                          2770          
0000254E                          2771          ;Then do An
0000254E                          2772          
0000254E  3401                    2773          MOVE.W  D1,D2
00002550  E04A                    2774          LSR.W   #8,D2                   ;move reg into first byte
00002552  E20A                    2775          LSR.B   #1,D2                   ;line it up to least sig bit
00002554  C43C 0007               2776          AND.B   #%00000111,D2           ;force mode to An
00002558  5002                    2777          ADDQ.B  #8,D2
0000255A  1A02                    2778          MOVE.B  D2,D5
0000255C  48E7 4000               2779          MOVEM.L D1,-(SP)
00002560  6100 02C8               2780          BSR     Get_Effective_Address
00002564  4CDF 0002               2781          MOVEM.L (SP)+,D1
00002568                          2782          
00002568  43F9 00002CFE           2783          LEA     clearLine,A1            ;move string for a CR and LF
0000256E  103C 000E               2784          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002572                          2785                                ;string without CR, LF
00002572  4E4F                    2786          TRAP    #15
00002574                          2787  
00002574  7000                    2788          MOVEQ.L #0,D0
00002576  4E75                    2789          RTS
00002578                          2790  
00002578                          2791             
00002578                          2792  Bcc:
00002578                          2793          
00002578  48E7 4000               2794          MOVEM.L D1,-(SP)
0000257C  43F9 00002D73           2795          LEA     bccMessage,A1           ;move string for BRA info
00002582  103C 000E               2796          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002586                          2797                                ;string without CR, LF
00002586  4E4F                    2798          TRAP    #15
00002588                          2799          
00002588  7000                    2800          MOVEQ.L #0,D0                   ;clear D0
0000258A  3401                    2801          MOVE.W  D1,D2                   ;move instruction into D2 for manipulaiton
0000258C  E04A                    2802          LSR.W   #8,D2
0000258E  C47C 000F               2803          AND.W   #$0F,D2                 ;mask instruction
00002592                          2804          
00002592                          2805  checkCC:        
00002592  41F9 00002C85           2806          LEA     bccList,A0              ;get condition code signature list in A0
00002598  D1C0                    2807          ADDA.L  D0,A0                   ;get correct sig         
0000259A  B410                    2808          CMP.B   (A0),D2                 ;compare to sig
0000259C  6700 0006               2809          BEQ     foundCC                 ;if sig matches branch
000025A0  5200                    2810          ADDQ.B  #byte,D0
000025A2  60EE                    2811          BRA     checkCC
000025A4                          2812  foundCC:
000025A4  43F9 00002C96           2813          LEA     conditionCodeMessage,A1 ;get condition code message in A1
000025AA  C0FC 0004               2814          MULU.W  #long,D0                ;adjust size of D0 for a long
000025AE  D3C0                    2815          ADDA.L  D0,A1                   ;get correct message location
000025B0  2251                    2816          MOVEA.L (A1),A1                 ;get correct message
000025B2                          2817          
000025B2  103C 000E               2818          MOVE.B  #14,D0                  ;set for task to display null terminated 
000025B6                          2819                                ;string without CR, LF
000025B6  4E4F                    2820          TRAP    #15
000025B8                          2821  
000025B8                          2822          
000025B8                          2823          
000025B8  548B                    2824          ADDQ.L  #word,A3                ;move past instruction in case long displacement
000025BA  C27C 00FF               2825          AND.W   #$00FF,D1               ;check for word sized displacement
000025BE                          2826          
000025BE  B23C 0000               2827          CMP.B   #$0,D1
000025C2  6700 0028               2828          BEQ     BccWord
000025C6                          2829          
000025C6  B23C 00FF               2830          CMP.B   #$FF,D1 check for long sized displacement
000025CA  6700 002A               2831          BEQ     BccLong
000025CE                          2832          
000025CE                          2833  BccByte:
000025CE                          2834          
000025CE  1201                    2835          MOVE.B D1,D1                    ;lazy check if negative
000025D0                          2836          
000025D0  6B00 000E               2837          BMI signExtendByte
000025D4                          2838          
000025D4  C2BC 000000FF           2839          AND.L #$000000FF,D1             ;mask out rest of reg just in case
000025DA                          2840          
000025DA  7E00                    2841          MOVEQ.L #0,D7                   ;pass back no extra data followed
000025DC  6000 0020               2842          BRA     BccDone
000025E0                          2843          
000025E0                          2844  signExtendByte:        
000025E0                          2845          
000025E0  82BC FFFFFF00           2846          OR.L #$FFFFFF00,D1              ;extend to long by set all bits not part of the
000025E6                          2847                             ;least significant byte
000025E6                          2848          
000025E6  7E00                    2849          MOVEQ.L #0,D7                   ;pass back no extra data followed
000025E8  6000 0014               2850          BRA     BccDone
000025EC                          2851  
000025EC                          2852  BccWord:
000025EC  3253                    2853          MOVEA.W  (A3),A1                ;sign extend word
000025EE  2209                    2854          MOVE.L   A1,D1
000025F0  7E02                    2855          MOVEQ.L #word,D7                ;pass back an extra word followed
000025F2  6000 000A               2856          BRA     BccDone
000025F6                          2857  BccLong:
000025F6  2213                    2858          MOVE.L  (A3),D1 
000025F8  7E04                    2859          MOVEQ.L #long,D7                ;pass back an extra long followed
000025FA  6000 0002               2860          BRA     BccDone
000025FE                          2861  BccDone:
000025FE                          2862  
000025FE  303C 0003               2863          MOVE.W  #3,D0                   ;put task #15 in D0
00002602  4E4F                    2864          TRAP    #15
00002604                          2865          
00002604  43F9 00002CFE           2866          LEA     clearLine,A1            ;move string for a CR and LF
0000260A  103C 000E               2867          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000260E                          2868                                ;string without CR, LF
0000260E  4E4F                    2869          TRAP    #15
00002610                          2870          
00002610  4CDF 0002               2871          MOVEM.L (SP)+,D1
00002614  7000                    2872          MOVEQ.L #0,D0
00002616  4E75                    2873          RTS
00002618                          2874          
00002618                          2875          
00002618                          2876  unknownOpCode:
00002618  43F9 00002D79           2877          LEA     dataMessage,A1          ;move string for data info
0000261E  103C 000E               2878          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002622                          2879                                ;string without CR, LF
00002622  4E4F                    2880          TRAP    #15
00002624                          2881          
00002624                          2882          ;print word in D1
00002624  48E7 1200               2883          MOVEM.L D6/D3,-(SP)
00002628  1C3C 0001               2884          MOVE.B #1,D6                    ;put size of word in D6
0000262C  2601                    2885          MOVE.L D1,D3                    ;move data at D1 to D3
0000262E  6100 041E               2886          BSR outputHex
00002632  4CDF 0048               2887          MOVEM.L (SP)+,D6/D3
00002636                          2888          
00002636  43F9 00002CFE           2889          LEA     clearLine,A1            ;move string for a CR and LF
0000263C  103C 000E               2890          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002640                          2891                                ;string without CR, LF
00002640  4E4F                    2892          TRAP    #15
00002642                          2893          
00002642  7000                    2894          MOVEQ.L #0,D0
00002644  4E75                    2895          RTS
00002646                          2896          
00002646                          2897  handlebytedata:
00002646                          2898  
00002646  43F9 00002D79           2899          LEA     dataMessage,A1          ;move string for data info
0000264C  103C 000E               2900          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002650                          2901                                ;string without CR, LF
00002650  4E4F                    2902          TRAP    #15
00002652                          2903          
00002652  1213                    2904          MOVE.B (A3),D1                  ;copy word from other prog to analyze as instruction
00002654                          2905          
00002654  E049                    2906          LSR.W   #8,D1                   ;shift the word read into D1 by a byte
00002656                          2907          
00002656  48E7 1200               2908          MOVEM.L D6/D3,-(SP)
0000265A  1C3C 0000               2909          MOVE.B #0,D6                    ;put size of byte in D6
0000265E  1601                    2910          MOVE.B D1,D3                    ;move data at D1 to D3
00002660  6100 03EC               2911          BSR outputHex
00002664  4CDF 0048               2912          MOVEM.L (SP)+,D6/D3
00002668                          2913          
00002668  43F9 00002CFE           2914          LEA     clearLine,A1            ;move string for a CR and LF
0000266E  103C 000E               2915          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002672                          2916                                ;string without CR, LF
00002672  4E4F                    2917          TRAP    #15
00002674                          2918          
00002674  4C9F 0004               2919          MOVEM.W (SP)+,D2                ;restore D2 for next iteration in main loop
00002678  7000                    2920          MOVEQ.L #0,D0
0000267A                          2921          
0000267A  528B                    2922          ADDQ.L  #byte,A3
0000267C  6000 E99C               2923          BRA main_Loop
00002680                          2924  
00002680                          2925          
00002680                          2926          
00002680                          2927  fin:
00002680  43F9 00002E40           2928          LEA     thankyouMessage,A1      ;move string for MOVE
00002686  103C 000E               2929          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000268A                          2930                                ;string without CR, LF
0000268A  4E4F                    2931          TRAP    #15
0000268C                          2932          
0000268C                          2933          
0000268C  FFFF FFFF               2934          simhalt
00002690                          2935          
00002690                          2936  
00002690                          2937  *******************************************************************************
00002690                          2938  *                            SUB ROUTINES
00002690                          2939  *******************************************************************************
00002690                          2940  
00002690                          2941  *******************************************************************************
00002690                          2942  *                          IO ROLE ROUTINES
00002690                          2943  *******************************************************************************
00002690                          2944  
00002690                          2945  *==========================================================================
00002690                          2946  *                   Enter / Validate beginning address 
00002690                          2947  *==========================================================================
00002690                          2948   
00002690                          2949  begin_address:
00002690                          2950  
00002690                          2951         
00002690  43F9 00002B0E           2952          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00002696  2239 00002B0E           2953          MOVE.L      slPrompt,D1         ;Load display length to D1
0000269C  700E                    2954          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
0000269E  4E4F                    2955          TRAP        #15                 ;Perform task 14 (display)
000026A0                          2956          
000026A0  43F9 00002E5E           2957          LEA         startLocation,A1    ;Load address to store user input
000026A6  103C 0002               2958          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
000026AA  4E4F                    2959          TRAP        #15                 ;Perform task 2 (input)
000026AC                          2960          
000026AC                          2961          ;CMP.B       #27,(A1)            ;Check for ESC entered
000026AC                          2962          ;BEQ         address_Exit        ;Exit condition
000026AC  0C01 0071               2963          CMPI.B #'q',D1
000026B0  6700 0062               2964          BEQ address_Exit
000026B4  0C01 0051               2965          CMPI.B #'Q',D1
000026B8  6700 005A               2966          BEQ address_Exit 
000026BC                          2967          
000026BC  6100 005E               2968          BSR         enter_addr_edit_all
000026C0  B67C FFFF               2969          CMP.W       #-1,D3              ;Did the edit pass?
000026C4  67CA                    2970          BEQ         begin_address       ;No, loop and ask for correct input
000026C6                          2971          
000026C6  2643                    2972          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
000026C8                          2973          
000026C8  43F9 00002C43           2974          LEA         spc,A1              ;Load address for starting loaction prompt
000026CE  1239 00002C44           2975          MOVE.B      spc_len,D1          ;Load empty line length
000026D4  7000                    2976          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
000026D6  4E4F                    2977          TRAP        #15                 ;Perform task 14 (display)
000026D8  6000 0002               2978          BRA         end_address
000026DC                          2979  
000026DC                          2980  *===========================================================================
000026DC                          2981  *                   Enter / Validate ending address 
000026DC                          2982  *===========================================================================
000026DC                          2983  
000026DC                          2984  end_address:
000026DC                          2985          
000026DC  43F9 00002B53           2986          LEA         elPrompt,A1         ;Load address for ending loaction prompt
000026E2                          2987          ;MOVE.L     elPrompt,D1         ;Load display length to D1
000026E2  7250                    2988          MOVE.L      #80,D1              ;did not like previous command, do not know why, it should have worked
000026E4  700E                    2989          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
000026E6  4E4F                    2990          TRAP        #15                 ;Perform task 14 (display)
000026E8                          2991          
000026E8  43F9 00002E62           2992          LEA         endLocation,A1      ;Load address to store user input
000026EE  103C 0002               2993          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
000026F2  4E4F                    2994          TRAP        #15                 ;Perform task 2 (input)
000026F4                          2995          
000026F4                          2996          ;CMP.B       #27,(A1)            ;Check for ESC entered
000026F4                          2997          ;BEQ         address_Exit        ;Exit condition 
000026F4  0C01 0071               2998          CMPI.B #'q',D1
000026F8  6700 001A               2999          BEQ address_Exit
000026FC  0C01 0051               3000          CMPI.B #'Q',D1
00002700  6700 0012               3001          BEQ address_Exit
00002704                          3002          
00002704  6100 0016               3003          BSR         enter_addr_edit_all
00002708  B67C FFFF               3004          CMP.W       #-1,D3              ;Did the edit pass?
0000270C  67CE                    3005          BEQ         end_address         ;No, loop and ask for correct input
0000270E                          3006  
0000270E  2843                    3007          MOVEA.L     D3,A4               ;Ending address gets stored in A4
00002710  6000 0008               3008          BRA         address_done
00002714                          3009  
00002714                          3010  address_Exit:
00002714                          3011  
00002714  76FF                    3012          MOVE.L      #-1,D3              ;Load -1 into return parameter
00002716  6000 0002               3013          BRA         address_done
0000271A                          3014          
0000271A                          3015  address_done:
0000271A                          3016  
0000271A  4E75                    3017          RTS    
0000271C                          3018  
0000271C                          3019  *==============================================================================
0000271C                          3020  * enter_addr_edit_all - Enter address edit check to edit all errors  
0000271C                          3021  *                       using multiple different error checking routines.
0000271C                          3022  *
0000271C                          3023  * Parameters -
0000271C                          3024  *   Input   A1      The data that needs checked.
0000271C                          3025  *   Input   D1      The number of characters input     
0000271C                          3026  *   Output  D3      Returns '-1' when there is an error.
0000271C                          3027  *==============================================================================
0000271C                          3028  
0000271C                          3029  enter_addr_edit_all
0000271C                          3030  
0000271C                          3031  *------------------------------------------------------------------------------
0000271C                          3032  * Test for odd number of characters entered, not allowed
0000271C                          3033  *------------------------------------------------------------------------------
0000271C                          3034         
0000271C  6100 0024               3035          BSR         ck_boundry          ;check if the input is on a odd / even boundry
00002720  B67C FFFF               3036          CMP.W       #-1,D3              ;Is the address odd?
00002724  6700 001A               3037          BEQ         enter_addr_edit_all_exit     ;No, return
00002728                          3038  
00002728                          3039  *------------------------------------------------------------------------------
00002728                          3040  * Ttest for character entered all being valid address characters
00002728                          3041  * Note: lower case a-f, gets converted to upper case A-F in D3
00002728                          3042  *------------------------------------------------------------------------------
00002728                          3043          
00002728  6100 0062               3044          BSR         parseHexString      ;check if the input contains valid Hex characters
0000272C  B67C FFFF               3045          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
00002730  6700 000E               3046          BEQ         enter_addr_edit_all_exit     ;No, return
00002734                          3047  
00002734                          3048  *------------------------------------------------------------------------------
00002734                          3049  * Verify that the address entered is witin the range defined in the Equate
00002734                          3050  *------------------------------------------------------------------------------        
00002734                          3051          
00002734  6100 00C8               3052          BSR         ck_addr_range       ;is address entered witin the range 
00002738                          3053                                          ;   as defined in the Equate? 
00002738  B67C FFFF               3054          CMP.W       #-1,D3              ;is the address  valid?
0000273C  6700 0002               3055          BEQ         enter_addr_edit_all_exit     ;No, return
00002740                          3056  
00002740                          3057  enter_addr_edit_all_exit:
00002740                          3058  
00002740  4E75                    3059          RTS                             ;return
00002742                          3060  
00002742                          3061  *==============================================================================
00002742                          3062  * ck_boundry - Check the size of the data characters input and determine
00002742                          3063  *              if an odd number of characters was entered
00002742                          3064  *
00002742                          3065  * Parameters -
00002742                          3066  *   Input   A1      The data that needs checked for odd length.
00002742                          3067  *   Input   D1      The number of characters input     
00002742                          3068  *   Output  D3      Returns '-1' when there is an odd length.
00002742                          3069  *==============================================================================
00002742                          3070  
00002742                          3071  ck_boundry:
00002742                          3072  
00002742  4243                    3073          CLR.W       D3                  ;Clear the return
00002744                          3074  
00002744  B23C 0000               3075          CMP.B       #0,D1               ;Check for nothing entered
00002748  6700 002E               3076          BEQ         ck_size_error       ;Number of characters entered must be 
0000274C                          3077                                          ;greater than 0  
0000274C                          3078          
0000274C                          3079          
0000274C                          3080          * The program will branch to ck_size_error if D1 is greater than #8        
0000274C  B23C 0008               3081          CMP.B       #8,D1               ;Check for more than 8 characters entered
00002750  6E00 0026               3082          BGT         ck_size_error       ;Number of characters entered must be less
00002754                          3083                                          ;than 9
00002754                          3084          
00002754  7402                    3085          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
00002756  82C2                    3086          DIVU        D2,D1               ;Divide address by 2
00002758  4841                    3087          SWAP        D1                  ;get remainder
0000275A  B23C 0001               3088          CMP.B       #$01,D1             ;Check for remainder of 1
0000275E  6700 0004               3089          BEQ         ck_boundry_error    ;Number of characters entered must be an 
00002762                          3090                                          ;even number   
00002762                          3091    
00002762  4E75                    3092          RTS                             ;return
00002764                          3093  
00002764                          3094  *------------------------------------------------------------------------------
00002764                          3095  * ck_boundry_error - An odd number of characters was entered
00002764                          3096  *                  - Load error message and display it
00002764                          3097  *                  - Return error condition
00002764                          3098  *------------------------------------------------------------------------------
00002764                          3099          
00002764                          3100  ck_boundry_error:
00002764                          3101  
00002764  43F9 00002C23           3102          LEA         even_msg,A1         ;Load odd error message into A1
0000276A  2239 00002C23           3103          MOVE.L      even_msg,D1         ;Load error length to D1
00002770                          3104          
00002770  7000                    3105          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00002772                          3106                                          ; n is D1.W with CR, LF. 
00002772  4E4F                    3107          TRAP #15                        ;Display the error message
00002774  76FF                    3108          MOVE.L #-1,D3                   ;Load -1 into return parameter
00002776  4E75                    3109          RTS                             ;Return
00002778                          3110          
00002778                          3111  *------------------------------------------------------------------------------
00002778                          3112  * ck_size_error -   The number of characters entered must be more than zero
00002778                          3113  *                  - Load error message and display it
00002778                          3114  *                  - Return error condition
00002778                          3115  *------------------------------------------------------------------------------
00002778                          3116          
00002778                          3117  ck_size_error:
00002778                          3118  
00002778  43F9 00002B96           3119          LEA         invalidMsg,A1       ;Load invalid range message into A1
0000277E  2239 00002B96           3120          MOVE.L      invalidMsg,D1       ;Load error length to D1
00002784                          3121          
00002784  7000                    3122          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00002786                          3123                                          ; n is D1.W with CR, LF. 
00002786  4E4F                    3124          TRAP        #15                 ;Display the error message
00002788  76FF                    3125          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000278A  4E75                    3126          RTS                             ;Return        
0000278C                          3127  
0000278C                          3128  
0000278C                          3129  *==============================================================================
0000278C                          3130  * parseHexString - Converts user input string into a valid memory address
0000278C                          3131  *                - Stores parsed address data into D3
0000278C                          3132  *                - Stores good/bad (1/0) data in D4 
0000278C                          3133  *
0000278C                          3134  * Hex values are stored as bytes in D2, the ASCII chart shows their value
0000278C                          3135  *   The ASCII chart values we care about are in the ranges of: 
0000278C                          3136  *                            Hex            Decimal
0000278C                          3137  *       No Value           NULL = 0         0
0000278C                          3138  *       Numeric Values:     0-9 = 30-39     48-57
0000278C                          3139  *       Upper Case letters: A-F = 41-46     65-70
0000278C                          3140  *       Lower Case letterc: a-f = 61-66     97-102
0000278C                          3141  
0000278C                          3142  * Parameters -
0000278C                          3143  *   Input   A1      The data that needs checked for valid input.
0000278C                          3144  *   Output  D3      The return value, '-1' for error
0000278C                          3145  *==============================================================================
0000278C                          3146  
0000278C                          3147  parseHexString:
0000278C                          3148  
0000278C                          3149  * setup any initializing item that do not get looped through
0000278C  4243                    3150          CLR.W       D3                  ;Clear the return
0000278E                          3151  
0000278E                          3152          
0000278E                          3153  *------------------------------------------------------------------------------
0000278E                          3154  * NextHex - Loop through all bytes and vaildate the input
0000278E                          3155  * Parameters -
0000278E                          3156  *   Input   A1      The data that needs checked for valid input.
0000278E                          3157  *   Output  D3      The return value, '-1' for error
0000278E                          3158  *------------------------------------------------------------------------------
0000278E                          3159          
0000278E                          3160  NextHex:
0000278E                          3161  
0000278E  1419                    3162          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00002790  B43C 0000               3163          CMP.B       #0,D2               ;Check character for null 
00002794  6700 0066               3164          BEQ         NextHexReturn       ;Character is null (end of input)
00002798                          3165          
00002798                          3166  *................................................................................
00002798                          3167  *  Check decimal values 0-9 by testing hexadecimal values 30-39
00002798                          3168  *................................................................................
00002798                          3169                  
00002798                          3170          * The program will branch to hex_range_error if D2 is less than #30
00002798  B43C 0030               3171          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
0000279C  6D00 0048               3172          BLT         hex_range_error     ;Branch to handle range error hexidecimal
000027A0                          3173                                          ;processing
000027A0                          3174          
000027A0                          3175          * The program will branch to UcaseHex if D2 is greater than #39
000027A0  B43C 0039               3176          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
000027A4  6E00 000A               3177          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
000027A8                          3178          
000027A8                          3179          *a valid number was found within this range
000027A8  0402 0030               3180          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
000027AC  6000 0032               3181          BRA         NextHexDone         ;Done parsing this byte
000027B0                          3182  
000027B0                          3183  
000027B0                          3184  *..............................................................................
000027B0                          3185  *  Check upper case values A-F by testing hexadecimal values 41-46
000027B0                          3186  *..............................................................................
000027B0                          3187  
000027B0                          3188  UcaseHex:
000027B0                          3189  
000027B0                          3190          * The program will branch to hex_range_error if D2 is less than #41
000027B0  B43C 0041               3191          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
000027B4  6D00 0030               3192          BLT         hex_range_error     ;Branch to handle range error hexidecimal
000027B8                          3193                                          ;processing
000027B8                          3194          
000027B8  B43C 0046               3195          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
000027BC  6E00 000A               3196          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
000027C0                          3197                                          ;processing
000027C0                          3198          
000027C0                          3199          *a valid number was found within this range
000027C0  0402 0037               3200          SUBI.B      #55,D2              ;Change uppercase character to actual value
000027C4  6000 001A               3201          BRA         NextHexDone         ;Done parsing this byte
000027C8                          3202  
000027C8                          3203  
000027C8                          3204  *..............................................................................
000027C8                          3205  *  Check lower case values a-f by testing hexadecimal values 61-66
000027C8                          3206  *..............................................................................
000027C8                          3207  
000027C8                          3208  LcaseHex
000027C8                          3209          
000027C8                          3210          * The program will branch to hex_range_error if D2 is less than #61
000027C8  B43C 0061               3211          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
000027CC  6D00 0018               3212          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
000027D0                          3213                                          ;processing
000027D0                          3214  
000027D0  B43C 0066               3215          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
000027D4  6E00 0010               3216          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
000027D8                          3217                                          ;processing
000027D8                          3218  
000027D8                          3219          *a valid number was found within this range
000027D8  0402 0057               3220          SUBI.B      #87,D2              ;Change lowercase character to actual value
000027DC  6000 0002               3221          BRA         NextHexDone         ;Done parsing this byte
000027E0                          3222  
000027E0                          3223  NextHexDone:
000027E0                          3224  
000027E0  E983                    3225          ASL.L       #4,D3               ; Make rooom for new byte in the return register
000027E2  D602                    3226          ADD.B       D2,D3               ; Move the new byte into the return register
000027E4  60A8                    3227          BRA         NextHex             ; We're ready to parse the next byte
000027E6                          3228          
000027E6                          3229  *-------------------------------------------------------------------------------------
000027E6                          3230  * hex_range_error -  A character entered was within the valid range for a hex address
000027E6                          3231  *                 -  Load error message and display it
000027E6                          3232  *                 -  Return error condition
000027E6                          3233  *-------------------------------------------------------------------------------------
000027E6                          3234          
000027E6                          3235  hex_range_error:
000027E6                          3236  
000027E6  43F9 00002BDB           3237          LEA         invCharMsg,A1       ;Load invalid range message into A1
000027EC  2239 00002BDB           3238          MOVE.L      invCharMsg,D1       ;Load error length to D1
000027F2                          3239          
000027F2  7000                    3240          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
000027F4                          3241                                          ; n is D1.W with CR, LF. 
000027F4  4E4F                    3242          TRAP        #15                 ;Display the error message
000027F6  76FF                    3243          MOVE.L      #-1,D3              ;Load -1 into return parameter
000027F8  6000 0002               3244          BRA         NextHexReturn
000027FC                          3245          
000027FC                          3246  NextHexReturn:
000027FC                          3247          
000027FC  4E75                    3248          RTS                             ;Return      
000027FE                          3249  
000027FE                          3250  
000027FE                          3251  *===============================================================================
000027FE                          3252  * ck_addr_range - check the address input is within a valid memory address range
000027FE                          3253  *                - Parsed address data into D3
000027FE                          3254  *
000027FE                          3255  * Parameters -
000027FE                          3256  *   Input   A1      The data that needs checked for valid address.
000027FE                          3257  *   Output  D3      The return value, '-1' for error
000027FE                          3258  *===============================================================================
000027FE                          3259  
000027FE                          3260  
000027FE                          3261  ck_addr_range:   
000027FE                          3262  
000027FE                          3263  *------------------------------------------------------------------------------
000027FE                          3264  * Verify that the address entered is witin the 
000027FE                          3265  * beginning range ('begin') as defined in the Equate
000027FE                          3266  *------------------------------------------------------------------------------   
000027FE                          3267              
000027FE  7C00                    3268          MOVE.L      #begin,D6           * Load minimum starting address
00002800  B686                    3269          CMP.L       D6,D3               * Is input at or above minimum?
00002802  6D00 0012               3270          BLT         ck_addr_range_error 
00002806                          3271          
00002806                          3272  *------------------------------------------------------------------------------
00002806                          3273  * Verify that the address entered is witin the 
00002806                          3274  * ending range ('end') as defined in the Equate
00002806                          3275  *------------------------------------------------------------------------------
00002806                          3276          
00002806  2C3C 00FFFFFE           3277          MOVE.L      #end,D6             * Load maximum starting address
0000280C  B686                    3278          CMP.L       D6,D3               * Is input at or below maximum?
0000280E  6E00 0006               3279          BGT         ck_addr_range_error 
00002812  6000 0012               3280          BRA         ck_addr_done        ;done checking
00002816                          3281          
00002816                          3282  *..............................................................................
00002816                          3283  * ck_addr_range_error -  A address entered is not within the 
00002816                          3284  *                        valid range for a hex address
00002816                          3285  *..............................................................................
00002816                          3286          
00002816                          3287  ck_addr_range_error
00002816                          3288  
00002816  43F9 00002B96           3289          LEA         invalidMsg,A1       ;Load invalid range message into A1
0000281C                          3290          
0000281C  700D                    3291          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
0000281E                          3292                                          ;with CR, LF. 
0000281E  4E4F                    3293          TRAP        #15                 ;Display the error message
00002820  76FF                    3294          MOVE.L      #-1,D3              ;Load -1 into return parameter
00002822  6000 0002               3295          BRA         ck_addr_done 
00002826                          3296  
00002826                          3297  ck_addr_done:
00002826                          3298  
00002826  4E75                    3299          RTS                             ;Return
00002828                          3300  
00002828                          3301  *******************************************************************************
00002828                          3302  *                          OP CODE ROLE ROUTINES
00002828                          3303  *******************************************************************************
00002828                          3304  
00002828                          3305  process_op_codes:
00002828                          3306  
00002828                          3307  
00002828                          3308  
00002828                          3309  process_op_codes_exit:
00002828                          3310  
00002828  4E75                    3311          RTS
0000282A                          3312  
0000282A                          3313  
0000282A                          3314  *******************************************************************************
0000282A                          3315  *                    Effective Addressing ROLE ROUTINES
0000282A                          3316  *******************************************************************************
0000282A                          3317  
0000282A                          3318  Get_Effective_Address:
0000282A                          3319  
0000282A  48E7 0200               3320          MOVEM.L D6,-(SP)                ;save D6 data
0000282E  1C05                    3321          MOVE.B      D5,D6
00002830  E60E                    3322          LSR.B       #3,D6               ;mode
00002832  CA3C 0007               3323          And.B       #%00000111,D5       ;register
00002836                          3324          
00002836  BC3C 0000               3325          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
0000283A  6700 004A               3326          BEQ         Data_Reg_Direct
0000283E                          3327          
0000283E  BC3C 0001               3328          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
00002842  6700 005C               3329          BEQ         Addr_Reg_Direct
00002846                          3330          
00002846  BC3C 0002               3331          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
0000284A  6700 006E               3332          BEQ         Addr_Reg_Indirect
0000284E                          3333          
0000284E  BC3C 0003               3334          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
00002852  6700 0098               3335          BEQ         Addr_Reg_Indirect_Inc
00002856                          3336          
00002856  BC3C 0004               3337          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
0000285A  6700 00CE               3338          BEQ         Addr_Reg_Indirect_Dec
0000285E                          3339          
0000285E  BC3C 0007               3340          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
00002862  6700 0006               3341          BEQ         Get_Effective_Address_Other
00002866                          3342          
00002866  6000 015A               3343          BRA         invalidEA
0000286A                          3344          
0000286A                          3345  Get_Effective_Address_Other:        
0000286A                          3346          
0000286A  BA3C 0000               3347          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
0000286E  6700 00F8               3348          BEQ Addr_Abs_Short
00002872                          3349          
00002872  BA3C 0001               3350          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
00002876  6700 010A               3351          BEQ Addr_Abs_Long
0000287A                          3352          
0000287A  BA3C 0004               3353          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
0000287E  6700 011C               3354          BEQ Addr_Immediate_Data
00002882                          3355          
00002882  6000 013E               3356          BRA         invalidEA
00002886                          3357          
00002886                          3358  Data_Reg_Direct:                        ;case 0(0000)
00002886                          3359  
00002886  43F9 00002DA5           3360          LEA         letterD,A1          ;output 'D' for data register
0000288C  103C 000E               3361          MOVE.B      #14,D0              ;set for task to display null terminated 
00002890  4E4F                    3362          TRAP        #15                 ;string without CR, LF
00002892                          3363                          
00002892  4281                    3364          CLR.L       D1
00002894  1205                    3365          MOVE.B      D5,D1               ;move register number for display into D1
00002896  103C 0003               3366          MOVE.B      #3,D0               ;set for task to display null terminated 
0000289A  4E4F                    3367          TRAP        #15                 ;string without CR, LF
0000289C                          3368                 
0000289C  6000 0124               3369          BRA         Get_Effective_Address_Exit  ;return
000028A0                          3370          
000028A0                          3371          
000028A0                          3372  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
000028A0                          3373        
000028A0  43F9 00002DA3           3374          LEA         letterA,A1          ;output 'A' for address register
000028A6  103C 000E               3375          MOVE.B      #14,D0              ;set for task to display null terminated 
000028AA  4E4F                    3376          TRAP        #15                 ;string without CR, LF
000028AC                          3377          
000028AC  4281                    3378          CLR.L       D1
000028AE  1205                    3379          MOVE.B      D5,D1               ;move register number for display into D1
000028B0  103C 0003               3380          MOVE.B      #3,D0               ;set for task to display null terminated 
000028B4  4E4F                    3381          TRAP        #15                 ;string without CR, LF
000028B6                          3382          
000028B6  6000 010A               3383          BRA         Get_Effective_Address_Exit  ;return
000028BA                          3384  
000028BA                          3385  
000028BA                          3386  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
000028BA                          3387          
000028BA  43F9 00002DAB           3388          LEA         lprn,A1             ;output 'D' for data register
000028C0  103C 000E               3389          MOVE.B      #14,D0              ;set for task to display null terminated 
000028C4  4E4F                    3390          TRAP        #15                 ;string without CR, LF
000028C6                          3391  
000028C6  43F9 00002DA3           3392          LEA         letterA,A1          ;output 'A' for address register
000028CC  103C 000E               3393          MOVE.B      #14,D0              ;set for task to display null terminated 
000028D0  4E4F                    3394          TRAP        #15                 ;string without CR, LF
000028D2                          3395          
000028D2  4281                    3396          CLR.L       D1
000028D4  1205                    3397          MOVE.B      D5,D1               ;move register number for display into D1
000028D6  103C 0003               3398          MOVE.B      #3,D0               ;set for task to display null terminated 
000028DA  4E4F                    3399          TRAP        #15                 ;string without CR, LF
000028DC                          3400  
000028DC  43F9 00002DAD           3401          LEA         rprn,A1             ;output 'D' for data register
000028E2  103C 000E               3402          MOVE.B      #14,D0              ;set for task to display null terminated 
000028E6  4E4F                    3403          TRAP        #15                 ;string without CR, LF
000028E8                          3404          
000028E8  6000 00D8               3405          BRA         Get_Effective_Address_Exit  ;return
000028EC                          3406  
000028EC                          3407                 
000028EC                          3408  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
000028EC                          3409  
000028EC  43F9 00002DAB           3410          LEA         lprn,A1             ;output 'D' for data register
000028F2  103C 000E               3411          MOVE.B      #14,D0              ;set for task to display null terminated 
000028F6  4E4F                    3412          TRAP        #15                 ;string without CR, LF
000028F8                          3413  
000028F8  43F9 00002DA3           3414          LEA         letterA,A1          ;output 'A' for address register
000028FE  103C 000E               3415          MOVE.B      #14,D0              ;set for task to display null terminated 
00002902  4E4F                    3416          TRAP        #15                 ;string without CR, LF
00002904                          3417          
00002904  4281                    3418          CLR.L       D1
00002906  1205                    3419          MOVE.B      D5,D1               ;move register number for display into D1
00002908  103C 0003               3420          MOVE.B      #3,D0               ;set for task to display null terminated 
0000290C  4E4F                    3421          TRAP        #15                 ;string without CR, LF
0000290E                          3422  
0000290E  43F9 00002DAD           3423          LEA         rprn,A1             ;output 'D' for data register
00002914  103C 000E               3424          MOVE.B      #14,D0              ;set for task to display null terminated 
00002918  4E4F                    3425          TRAP        #15                 ;string without CR, LF
0000291A                          3426          
0000291A  43F9 00002DA7           3427          LEA         plus,A1             ;output 'D' for data register
00002920  103C 000E               3428          MOVE.B      #14,D0              ;set for task to display null terminated 
00002924  4E4F                    3429          TRAP        #15                 ;string without CR, LF
00002926                          3430          
00002926  6000 009A               3431          BRA         Get_Effective_Address_Exit  ;return
0000292A                          3432  
0000292A                          3433  Addr_Reg_Indirect_Dec                   ;4 = ?(An) - Address Register Indirect with Predecrement (100)
0000292A                          3434  
0000292A  43F9 00002DA9           3435          LEA         minus,A1            ;output '-' for Predecrement
00002930  103C 000E               3436          MOVE.B      #14,D0              ;set for task to display null terminated 
00002934  4E4F                    3437          TRAP        #15                 ;string without CR, LF
00002936                          3438  
00002936  43F9 00002DAB           3439          LEA         lprn,A1             ;output 'D' for data register
0000293C  103C 000E               3440          MOVE.B      #14,D0              ;set for task to display null terminated 
00002940  4E4F                    3441          TRAP        #15                 ;string without CR, LF
00002942                          3442  
00002942  43F9 00002DA3           3443          LEA         letterA,A1          ;output 'A' for address register
00002948  103C 000E               3444          MOVE.B      #14,D0              ;set for task to display null terminated 
0000294C  4E4F                    3445          TRAP        #15                 ;string without CR, LF
0000294E                          3446          
0000294E  4281                    3447          CLR.L       D1
00002950  1205                    3448          MOVE.B      D5,D1               ;move register number for display into D1
00002952  103C 0003               3449          MOVE.B      #3,D0               ;set for task to display null terminated 
00002956  4E4F                    3450          TRAP        #15                 ;string without CR, LF
00002958                          3451  
00002958  43F9 00002DAD           3452          LEA         rprn,A1             ;output 'D' for data register
0000295E  103C 000E               3453          MOVE.B      #14,D0              ;set for task to display null terminated 
00002962  4E4F                    3454          TRAP        #15                 ;string without CR, LF
00002964                          3455          
00002964  6000 005C               3456          BRA         Get_Effective_Address_Exit  ;return
00002968                          3457          
00002968                          3458                         
00002968                          3459  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00002968                          3460          
00002968                          3461          
00002968  548B                    3462          ADDA.L      #word,A3            ;move past instruction
0000296A                          3463          
0000296A                          3464          ;print word (A3)
0000296A  48E7 1200               3465          MOVEM.L D6/D3,-(SP)
0000296E  1C3C 0001               3466          MOVE.B #1,D6                    ;put size of word in D6
00002972  3613                    3467          MOVE.W (A3),D3                  ;move data at (A3) to D3
00002974  6100 00D8               3468          BSR outputHex
00002978  4CDF 0048               3469          MOVEM.L (SP)+,D6/D3
0000297C                          3470          
0000297C  5487                    3471          ADDI.L      #word,D7 
0000297E  6000 0042               3472          BRA         Get_Effective_Address_Exit  ;return
00002982                          3473                         
00002982                          3474  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
00002982                          3475          
00002982                          3476          ;LEA         xxxL,A1             ;output 'D' for data register
00002982                          3477          ;MOVE.B      #14,D0              ;set for task to display null terminated 
00002982                          3478          ;TRAP        #15                 ;string without CR, LF
00002982                          3479  
00002982  548B                    3480          ADDA.L      #word,A3
00002984                          3481          
00002984                          3482          ;print long (A3)
00002984  48E7 1200               3483          MOVEM.L D6/D3,-(SP)
00002988  1C3C 0002               3484          MOVE.B #2,D6                    ;put size of word in D6
0000298C  2613                    3485          MOVE.L (A3),D3                  ;move data at (A3) to D3
0000298E  6100 00BE               3486          BSR outputHex
00002992  4CDF 0048               3487          MOVEM.L (SP)+,D6/D3
00002996                          3488  
00002996                          3489          
00002996  5887                    3490          ADDI.L      #long,D7
00002998  6000 0028               3491          BRA         Get_Effective_Address_Exit  ;return
0000299C                          3492                         
0000299C                          3493  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
0000299C                          3494  
0000299C                          3495  *        LEA         iData,A1            ;output 'D' for data register
0000299C                          3496  *        MOVE.B      #14,D0              ;set for task to display null terminated 
0000299C                          3497  *        TRAP        #15                 ;string without CR, LF
0000299C                          3498          
0000299C  4CDF 0040               3499          MOVEM.L (SP)+,D6                 ;restore D6 data
000029A0  48E7 0200               3500          MOVEM.L D6,-(SP)                 ;save D6 data again to balance stack
000029A4                          3501  
000029A4                          3502          ;print '#'
000029A4  48E7 4000               3503          MOVEM.L D1,-(SP)                ;save D1 to the stack
000029A8  123C 0023               3504          MOVE.B #'#',D1                  ;put ascii value of char in D1
000029AC  103C 0006               3505          MOVE.B #6,D0                    ;move task 6 into D0
000029B0  4E4F                    3506          TRAP #15                        ;print char
000029B2  4CDF 0002               3507          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000029B6                          3508          
000029B6  0C06 0001               3509          CMPI.B #1,D6
000029BA  6FAC                    3510          BLE Addr_Abs_Short
000029BC  6EC4                    3511          BGT Addr_Abs_Long
000029BE                          3512          
000029BE  6000 0002               3513          BRA         Get_Effective_Address_Exit  ;return
000029C2                          3514  
000029C2                          3515  invalidEA:
000029C2                          3516  
000029C2                          3517          ;do something
000029C2                          3518   
000029C2                          3519  Get_Effective_Address_Exit:     
000029C2                          3520  
000029C2  4CDF 0040               3521          MOVEM.L (SP)+,D6                 ;restore D6 data
000029C6  4E75                    3522          RTS                             ;return
000029C8                          3523  
000029C8                          3524  ***assume size in D6. 00 = byte, 01 = word, 10 = long
000029C8                          3525  printSize:
000029C8  48E7 C000               3526          MOVEM.L D0/D1,-(SP)
000029CC                          3527          
000029CC                          3528          ;print '.'
000029CC  48E7 4000               3529          MOVEM.L D1,-(SP)                ;save D1 to the stack
000029D0  123C 002E               3530          MOVE.B #'.',D1                  ;put ascii value of char in D1
000029D4  103C 0006               3531          MOVE.B #6,D0                    ;move task 6 into D0
000029D8  4E4F                    3532          TRAP #15                        ;print char
000029DA  4CDF 0002               3533          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000029DE                          3534          
000029DE  0C06 0001               3535          CMPI.B #1,D6
000029E2  6D00 0022               3536          BLT printByteSize
000029E6  6700 0032               3537          BEQ printWordSize
000029EA  6E00 0042               3538          BGT printLongSize
000029EE                          3539  printSizeDone:
000029EE                          3540          ;print ' '
000029EE  48E7 4000               3541          MOVEM.L D1,-(SP)                ;save D1 to the stack
000029F2  123C 0020               3542          MOVE.B #' ',D1                  ;put ascii value of char in D1
000029F6  103C 0006               3543          MOVE.B #6,D0                    ;move task 6 into D0
000029FA  4E4F                    3544          TRAP #15                        ;print char
000029FC  4CDF 0002               3545          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002A00                          3546          
00002A00  4CDF 0003               3547          MOVEM.L (SP)+,D0/D1
00002A04  4E75                    3548          RTS
00002A06                          3549          
00002A06                          3550  printByteSize:
00002A06                          3551          ;print 'B'
00002A06  48E7 4000               3552          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002A0A  123C 0042               3553          MOVE.B #'B',D1                  ;put ascii value of char in D1
00002A0E  103C 0006               3554          MOVE.B #6,D0                    ;move task 6 into D0
00002A12  4E4F                    3555          TRAP #15                        ;print char
00002A14  4CDF 0002               3556          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002A18  60D4                    3557          BRA printSizeDone
00002A1A                          3558          
00002A1A                          3559  printWordSize:
00002A1A                          3560          ;print 'W'
00002A1A  48E7 4000               3561          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002A1E  123C 0057               3562          MOVE.B #'W',D1                  ;put ascii value of char in D1
00002A22  103C 0006               3563          MOVE.B #6,D0                    ;move task 6 into D0
00002A26  4E4F                    3564          TRAP #15                        ;print char
00002A28  4CDF 0002               3565          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002A2C  60C0                    3566          BRA printSizeDone
00002A2E                          3567  
00002A2E                          3568  printLongSize:
00002A2E                          3569          ;print 'L'
00002A2E  48E7 4000               3570          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002A32  123C 004C               3571          MOVE.B #'L',D1                  ;put ascii value of char in D1
00002A36  103C 0006               3572          MOVE.B #6,D0                    ;move task 6 into D0
00002A3A  4E4F                    3573          TRAP #15                        ;print char
00002A3C  4CDF 0002               3574          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002A40  60AC                    3575          BRA printSizeDone       
00002A42                          3576          
00002A42                          3577  
00002A42                          3578  ***assume hex to print is in D3***
00002A42                          3579  ***assume size in D6. 00 = byte, 01 = word, 10 = long
00002A42                          3580  
00002A42= 00000000 00000000 ...   3581  hexoutputbuffer DC.L 0,0,0
00002A4E                          3582  
00002A4E                          3583  outputHex:
00002A4E  48E7 B248               3584          MOVEM.L D0/D2/D3/D6/A1/A4,-(SP)
00002A52  49F8 2A42               3585          LEA hexoutputbuffer,A4
00002A56  0C06 0001               3586          CMPI.B #1,D6
00002A5A  6D00 006A               3587          BLT hexByte
00002A5E  6700 004C               3588          BEQ hexWord
00002A62  6E00 0016               3589          BGT hexLong
00002A66                          3590  outputHexDone:
00002A66  18BC 0000               3591          MOVE.B #0,(A4)
00002A6A                          3592          
00002A6A                          3593          ;output string of hex
00002A6A  103C 000E               3594          MOVE.B #14,D0
00002A6E  43F8 2A42               3595          LEA hexoutputbuffer,A1
00002A72  4E4F                    3596          TRAP #15
00002A74  4CDF 124D               3597          MOVEM.L (SP)+ ,D0/D2/D3/D6/A1/A4
00002A78  4E75                    3598          RTS
00002A7A                          3599          
00002A7A                          3600  hexLong:
00002A7A  E99B                    3601          ROL.L #4,D3
00002A7C  6100 0056               3602          BSR convertHexToASCII
00002A80  E99B                    3603          ROL.L #4,D3
00002A82  6100 0050               3604          BSR convertHexToASCII
00002A86  E99B                    3605          ROL.L #4,D3
00002A88  6100 004A               3606          BSR convertHexToASCII
00002A8C  E99B                    3607          ROL.L #4,D3
00002A8E  6100 0044               3608          BSR convertHexToASCII
00002A92  E99B                    3609          ROL.L #4,D3
00002A94  6100 003E               3610          BSR convertHexToASCII
00002A98  E99B                    3611          ROL.L #4,D3
00002A9A  6100 0038               3612          BSR convertHexToASCII
00002A9E  E99B                    3613          ROL.L #4,D3
00002AA0  6100 0032               3614          BSR convertHexToASCII
00002AA4  E99B                    3615          ROL.L #4,D3
00002AA6  6100 002C               3616          BSR convertHexToASCII
00002AAA                          3617          
00002AAA  60BA                    3618          BRA outputHexDone
00002AAC                          3619          
00002AAC                          3620  hexWord:
00002AAC  E95B                    3621          ROL.W #4,D3
00002AAE  6100 0024               3622          BSR convertHexToASCII
00002AB2  E95B                    3623          ROL.W #4,D3
00002AB4  6100 001E               3624          BSR convertHexToASCII
00002AB8  E95B                    3625          ROL.W #4,D3
00002ABA  6100 0018               3626          BSR convertHexToASCII
00002ABE  E95B                    3627          ROL.W #4,D3
00002AC0  6100 0012               3628          BSR convertHexToASCII
00002AC4                          3629  
00002AC4  60A0                    3630          BRA outputHexDone
00002AC6                          3631          
00002AC6                          3632  hexByte:
00002AC6  E91B                    3633          ROL.B #4,D3
00002AC8  6100 000A               3634          BSR convertHexToASCII
00002ACC  E91B                    3635          ROL.B #4,D3
00002ACE  6100 0004               3636          BSR convertHexToASCII
00002AD2                          3637          
00002AD2  6092                    3638          BRA outputHexDone
00002AD4                          3639          
00002AD4                          3640  convertHexToASCII:
00002AD4  1403                    3641          MOVE.B D3,D2
00002AD6  0202 000F               3642          ANDI.B #%00001111,D2            ;mask out all but hex at least significant nyb
00002ADA  0C02 0009               3643          CMPI.B #9,D2
00002ADE  6F00 0006               3644          BLE Number
00002AE2  6000 000A               3645          BRA Letter       
00002AE6                          3646  
00002AE6                          3647  Number:
00002AE6  0602 0030               3648          ADDI.B #'0',D2
00002AEA  18C2                    3649          MOVE.B D2,(A4)+
00002AEC  4E75                    3650          RTS
00002AEE                          3651          
00002AEE                          3652  Letter:
00002AEE  0402 000A               3653          SUBI.B #$A,D2
00002AF2  0602 0041               3654          ADDI.B #'A',D2
00002AF6  18C2                    3655          MOVE.B D2,(A4)+
00002AF8  4E75                    3656          RTS
00002AFA                          3657  
00002AFA                          3658  
00002AFA                          3659  
00002AFA                          3660  switchModeAndReg:
00002AFA                          3661  ***
00002AFA                          3662  * Assumed in D2
00002AFA                          3663  *
00002AFA                          3664  * Assumed that they are in least significant byte:
00002AFA                          3665  *
00002AFA                          3666  *            _this_
00002AFA                          3667  *           /      \
00002AFA                          3668  *  ........ ........
00002AFA                          3669  *  \                /
00002AFA                          3670  *   -----word-------
00002AFA                          3671  *
00002AFA                          3672  *  and that in that byte they are ordered:
00002AFA                          3673  *
00002AFA                          3674  *       ........   
00002AFA                          3675  *       \/\_/\_/
00002AFA                          3676  *      /  /    \
00002AFA                          3677  *    /   /      \
00002AFA                          3678  * dont  one    other
00002AFA                          3679  * care
00002AFA                          3680  *
00002AFA                          3681  * after they will be
00002AFA                          3682  *
00002AFA                          3683  *       ........   
00002AFA                          3684  *       \/\_/\_/
00002AFA                          3685  *      /  /    \
00002AFA                          3686  *    /   /      \
00002AFA                          3687  * dont other    one
00002AFA                          3688  * care
00002AFA                          3689  *** 
00002AFA  0202 003F               3690          AndI.B #%00111111,D2            ;remove unwanted bits from D2
00002AFE  0283 00000000           3691          ANDI.L #0,D3                    ;clear D3
00002B04  1602                    3692          MOVE.B D2,D3                    ;copy to D3
00002B06  E70B                    3693          LSL.B  #3,D3 
00002B08  E60A                    3694          LSR.B  #3,D2
00002B0A  D403                    3695          ADD.B  D3,D2
00002B0C  4E75                    3696          RTS
00002B0E                          3697  
00002B0E                          3698          
00002B0E                          3699  *==============================================================================
00002B0E                          3700  *                            variables and constants
00002B0E                          3701  *==============================================================================
00002B0E                          3702  
00002B0E                          3703  
00002B0E                          3704  ***initial user prompt stuff        
00002B0E= 45 6E 74 65 72 20 ...   3705  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE, "Q" or "q" to quit: $',0
00002B53= 45 6E 74 65 72 20 ...   3706  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE, "Q" or "q" to quit: $',0
00002B96                          3707  
00002B96= 20 41 64 64 72 65 ...   3708  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
00002BDB= 20 41 20 43 68 61 ...   3709  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
00002C23                          3710  
00002C23= 20 59 6F 75 20 6D ...   3711  even_msg        DC.B    ' You must enter an even address!'
00002C43                          3712  
00002C43= 20                      3713  spc             DC.B    ' '
00002C44= 01                      3714  spc_len         DC.B    spc_len-spc
00002C45                          3715  ***
00002C45                          3716  
00002C45                          3717  
00002C45                          3718  
00002C45                          3719  ***list of OP codes
00002C45                          3720  
00002C45  =00000040               3721  moveaInstruction EQU %0000000001000000
00002C45  =0000B000               3722  eorInstruction   EQU %1011000000000000
00002C45  =0000B000               3723  cmpInstruction   EQU %1011000000000000
00002C45  =00008000               3724  orInstruction    EQU %1000000000000000
00002C45  =00000880               3725  bclrdataInstruction EQU %0000100010000000
00002C45  =00000180               3726  bclrInstruction  EQU %0000000110000000
00002C45  =000041C0               3727  leaInstruction   EQU %0100000111000000
00002C45  =000081C0               3728  divsInstruction  EQU %1000000111000000
00002C45  =0000C1C0               3729  mulsInstruction  EQU %1100000111000000
00002C45  =0000E6C0               3730  rsrlweaInstruction  EQU %1110011011000000
00002C45  =0000E018               3731  rsrlregInstruction  EQU %1110000000011000
00002C45  =0000E0C0               3732  asrlweaInstruction  EQU %1110000011000000
00002C45  =0000E000               3733  asrlregInstruction  EQU %1110000000000000
00002C45  =0000E2C0               3734  lsrlweaInstruction  EQU %1110001011000000
00002C45  =0000E008               3735  lsrlregInstruction  EQU %1110000000001000
00002C45  =00005100               3736  subqInstruction  EQU %0101000100000000
00002C45  =00009000               3737  subInstruction   EQU %1001000000000000
00002C45  =0000D000               3738  addaInstruction  EQU %1101000000000000
00002C45  =0000D000               3739  addInstruction   EQU %1101000000000000
00002C45  =00004880               3740  movemInstruction EQU %0100100010000000
00002C45  =00000600               3741  addiInstruction  EQU %0000011000000000
00002C45  =00000000               3742  oriInstruction   EQU 0
00002C45  =00000C00               3743  cmpiInstruction  EQU %0000110000000000
00002C45  =00004E80               3744  jsrInstruction   EQU %0100111010000000
00002C45  =00004E75               3745  rtsInstruction   EQU %0100111001110101
00002C45  =00004E71               3746  NoOpInstruction  EQU %0100111001110001
00002C45  =00000000               3747  moveInstruction  EQU 0
00002C45  =00006000               3748  bccInstruction   EQU %0110000000000000
00002C45  =00004400               3749  negInstruction   EQU %0100010000000000
00002C45  =00000000               3750  dataInstruction  EQU 0
00002C45                          3751  
00002C45                          3752  ***
00002C45                          3753  
00002C45                          3754  ***list of OP masks
00002C45                          3755  
00002C45  =0000C1C0               3756  moveaMask EQU %1100000111000000
00002C45  =0000F000               3757  eorMask   EQU %1111000000000000
00002C45  =0000F000               3758  cmpMask   EQU %1111000000000000
00002C45  =0000F000               3759  orMask    EQU %1111000000000000
00002C45  =0000FFC0               3760  bclrdataMask EQU %1111111111000000
00002C45  =0000F1C0               3761  bclrMask  EQU %1111000111000000
00002C45  =0000F1C0               3762  leaMask   EQU %1111000111000000
00002C45  =0000F1C0               3763  divsMask  EQU %1111000111000000
00002C45  =0000F1C0               3764  mulsMask  EQU %1111000111000000
00002C45  =0000FEC0               3765  rsrlweaMask  EQU %1111111011000000
00002C45  =0000F018               3766  rsrlregMask  EQU %1111000000011000
00002C45  =0000FEC0               3767  asrlweaMask  EQU %1111111011000000
00002C45  =0000F018               3768  asrlregMask  EQU %1111000000011000
00002C45  =0000FEC0               3769  lsrlweaMask  EQU %1111111011000000
00002C45  =0000F018               3770  lsrlregMask  EQU %1111000000011000
00002C45  =0000F100               3771  subqMask  EQU %1111000100000000
00002C45  =0000F000               3772  subMask   EQU %1111000000000000
00002C45  =0000F000               3773  addaMask  EQU %1111000000000000
00002C45  =0000F000               3774  addMask   EQU %1111000000000000
00002C45  =0000FB80               3775  movemMask EQU %1111101110000000
00002C45  =0000FF00               3776  addiMask  EQU %1111111100000000
00002C45  =0000FF00               3777  oriMask   EQU %1111111100000000
00002C45  =0000FF00               3778  cmpiMask  EQU %1111111100000000
00002C45  =0000FFC0               3779  jsrMask   EQU %1111111111000000
00002C45  =0000FFFF               3780  rtsMask   EQU $FFFF
00002C45  =0000FFFF               3781  NoOpMask  EQU $FFFF
00002C45  =0000C000               3782  moveMask  EQU $C000
00002C45  =0000F000               3783  bccMask   EQU $F000
00002C45  =0000FF00               3784  negMask   EQU $FF00
00002C45  =00000000               3785  dataMask  EQU 0
00002C45                          3786  ***
00002C45                          3787  
00002C45                          3788  ***Bcc Codes***
00002C45  =00000004               3789  CC EQU $04
00002C45  =00000005               3790  CS EQU $05
00002C45  =00000007               3791  EQ EQU $07
00002C45  =0000000C               3792  GE EQU $0C
00002C45  =0000000E               3793  GT EQU $0E
00002C45  =00000002               3794  HI EQU $02
00002C45  =0000000F               3795  LE EQU $0F
00002C45  =00000003               3796  LS EQU $03
00002C45  =0000000D               3797  LT EQU $0D
00002C45  =0000000B               3798  MI EQU $0B
00002C45  =00000006               3799  NE EQU $06
00002C45  =0000000A               3800  PL EQU $0A
00002C45  =00000008               3801  VC EQU $08
00002C45  =00000009               3802  VS EQU $09
00002C45  =00000000               3803  RA EQU $00 ;not really a Condition Code
00002C45  =00000001               3804  SR EQU $01 ;not really a Condition Code
00002C45                          3805  
00002C45= 43 43 20 00             3806  CCm DC.B 'CC ',0
00002C49= 43 53 20 00             3807  CSm DC.B 'CS ',0
00002C4D= 45 51 20 00             3808  EQm DC.B 'EQ ',0
00002C51= 47 45 20 00             3809  GEm DC.B 'GE ',0
00002C55= 47 54 20 00             3810  GTm DC.B 'GT ',0
00002C59= 48 49 20 00             3811  HIm DC.B 'HI ',0
00002C5D= 4C 45 20 00             3812  LEm DC.B 'LE ',0
00002C61= 4C 53 20 00             3813  LSm DC.B 'LS ',0
00002C65= 4C 54 20 00             3814  LTm DC.B 'LT ',0
00002C69= 4D 49 20 00             3815  MIm DC.B 'MI ',0
00002C6D= 4E 45 20 00             3816  NEm DC.B 'NE ',0
00002C71= 50 4C 20 00             3817  PLm DC.B 'PL ',0
00002C75= 56 43 20 00             3818  VCm DC.B 'VC ',0
00002C79= 56 53 20 00             3819  VSm DC.B 'VS ',0
00002C7D= 52 41 20 00             3820  RAm DC.B 'RA ',0
00002C81= 53 52 20 00             3821  SRm DC.B 'SR ',0
00002C85                          3822  
00002C85= 01 04 05 07 0C 0E ...   3823  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
00002C96= 00002C81 00002C45 ...   3824  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
00002CD6                          3825  ***
00002CD6                          3826  
00002CD6= 45 6E 74 65 72 20 ...   3827  startLocationPrompt DC.B    'Enter start location',0
00002CEB= 45 6E 74 65 72 20 ...   3828  endLocationPrompt   DC.B    'Enter end location',0
00002CFE                          3829  
00002CFE= 0D 0A 00                3830  clearLine  DC.B $0D,$0A,0
00002D01                          3831  
00002D01= 45 4F 52 00             3832  eorMessage      DC.B 'EOR',0
00002D05= 43 4D 50 00             3833  cmpMessage      DC.B 'CMP',0
00002D09= 4F 52 00                3834  orMessage       DC.B 'OR',0
00002D0C= 42 43 4C 52 20 00       3835  bclrMessage     DC.B 'BCLR ',0
00002D12= 4C 45 41 20 00          3836  leaMessage      DC.B 'LEA ',0
00002D17= 44 49 56 53 00          3837  divsMessage     DC.B 'DIVS',0
00002D1C= 4D 55 4C 53 00          3838  mulsMessage     DC.B 'MULS',0
00002D21= 52 4F 4C 00             3839  rslMessage      DC.B 'ROL',0
00002D25= 52 4F 52 00             3840  rsrMessage      DC.B 'ROR',0
00002D29= 41 53 4C 00             3841  aslMessage      DC.B 'ASL',0
00002D2D= 41 53 52 00             3842  asrMessage      DC.B 'ASR',0
00002D31= 4C 53 4C 00             3843  lslMessage      DC.B 'LSL',0
00002D35= 4C 53 52 00             3844  lsrMessage      DC.B 'LSR',0
00002D39= 53 55 42 51 00          3845  subqMessage     DC.B 'SUBQ',0
00002D3E= 53 55 42 00             3846  subMessage      DC.B 'SUB',0 
00002D42= 41 44 44 41 00          3847  addaMessage     DC.B 'ADDA',0
00002D47= 41 44 44 00             3848  addMessage      DC.B 'ADD',0
00002D4B= 4D 4F 56 45 4D 00       3849  movemMessage    DC.B 'MOVEM',0
00002D51= 41 44 44 49 00          3850  addiMessage     DC.B 'ADDI',0
00002D56= 4F 52 49 00             3851  oriMessage      DC.B 'ORI',0
00002D5A= 43 4D 50 49 00          3852  cmpiMessage     DC.B 'CMPI',0
00002D5F= 4A 53 52 20 00          3853  jsrMessage      DC.B 'JSR ',0
00002D64= 52 54 53 20 00          3854  rtsMessage      DC.B 'RTS ',0
00002D69= 4E 4F 50 20 00          3855  nopMessage      DC.B 'NOP ',0 
00002D6E= 4D 4F 56 45 00          3856  moveMessage     DC.B 'MOVE',0
00002D73= 42 00                   3857  bccMessage      DC.B 'B',0
00002D75= 4E 45 47 00             3858  negMessage      DC.B 'NEG',0
00002D79= 44 41 54 41 20 00       3859  dataMessage     DC.B 'DATA ',0
00002D7F= 4D 4F 56 45 41 00       3860  moveaMessage    DC.B 'MOVEA',0
00002D85                          3861  
00002D85= 28 78 78 78 29 2E ...   3862  xxxW            DC.B '(xxx).W: ',0
00002D8F= 28 78 78 78 29 2E ...   3863  xxxL            DC.B '(xxx).L: ',0
00002D99= 23 28 64 61 74 61 ...   3864  iData           DC.B '#(data): ',0
00002DA3                          3865  
00002DA3= 41 00                   3866  letterA         DC.B 'A', 0
00002DA5= 44 00                   3867  letterD         DC.B 'D', 0
00002DA7                          3868  
00002DA7= 2B 00                   3869  plus            DC.B '+', 0
00002DA9= 2D 00                   3870  minus           DC.B '-', 0
00002DAB= 28 00                   3871  lPrn            DC.B '(', 0
00002DAD= 29 00                   3872  rPrn            DC.B ')', 0
00002DAF                          3873  
00002DAF                          3874  
00002DAF= 50 72 65 73 73 20 ...   3875  nextAddrPrompt  DC.B 'Press "Q" or "q" to quit or any other key to enter a new starting address: ',0
00002DFB= 50 72 65 73 73 20 ...   3876  continuePrompt  DC.B 'Press "S" or "s" to stop or any other key to display the next page: ',0
00002E40= 50 72 6F 67 72 61 ...   3877  thankyoumessage DC.B 'Program Complete. Thank You!',0
00002E5D                          3878  
00002E5E= 00000000                3879  startLocation       DC.L    0
00002E62= 00000000                3880  endLocation         DC.L    0
00002E66                          3881  
00002E66                          3882  
00002E66                          3883     
00002E66                          3884      END    START                        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 1D28
ADDA                1C62
ADDABODY            1CAA
ADDAINSTRUCTION     D000
ADDAMASK            F000
ADDAMESSAGE         2D42
ADDDEST             1DFC
ADDDESTEA           1D1C
ADDDESTEAMASKS      1D22
ADDI                2180
ADDIBODY            21AC
ADDIDONE            21FE
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         2D51
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          2D47
ADDPOSTREGDONE      205C
ADDPREREGDONE       20D8
ADDRESS_DONE        271A
ADDRESS_EXIT        2714
ADDR_ABS_LONG       2982
ADDR_ABS_SHORT      2968
ADDR_IMMEDIATE_DATA  299C
ADDR_REG_DIRECT     28A0
ADDR_REG_INDIRECT   28BA
ADDR_REG_INDIRECT_DEC  292A
ADDR_REG_INDIRECT_INC  28EC
ADDSOURCE           1D9E
ASLEA               187A
ASLMESSAGE          2D29
ASLREG              18C0
ASREA               186A
ASRLREG             188A
ASRLREGINSTRUCTION  E000
ASRLREGMASK         F018
ASRLWEA             182A
ASRLWEACHECKDIRECTION  1856
ASRLWEAINSTRUCTION  E0C0
ASRLWEAMASK         FEC0
ASRMESSAGE          2D2D
ASRREG              18B0
BCC                 2578
BCCBYTE             25CE
BCCDONE             25FE
BCCINSTRUCTION      6000
BCCLIST             2C85
BCCLONG             25F6
BCCMASK             F000
BCCMESSAGE          2D73
BCCWORD             25EC
BCLR                154E
BCLRBODY            157A
BCLRDATA            14B4
BCLRDATABODY        14E0
BCLRDATAINSTRUCTION  880
BCLRDATAMASK        FFC0
BCLRINSTRUCTION     180
BCLRMASK            F1C0
BCLRMESSAGE         2D0C
BEGIN               0
BEGIN_ADDRESS       2690
BYTE                1
CC                  4
CCM                 2C45
CHECKCC             2592
CHECKCONTINUE       11AE
CHECKMOVEDEST       2404
CHECKNEXTADDR       11E8
CHECKOPCODE         1078
CHECKPOSTREGADD     2056
CHECKPREREGADD      20D2
CK_ADDR_DONE        2826
CK_ADDR_RANGE       27FE
CK_ADDR_RANGE_ERROR  2816
CK_BOUNDRY          2742
CK_BOUNDRY_ERROR    2764
CK_SIZE_ERROR       2778
CLEARLINE           2CFE
CMP                 12D4
CMPBODY             1314
CMPI                22AE
CMPIBODY            22D6
CMPIDONE            232C
CMPIEA              22A0
CMPIEAMASKS         22A7
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         2D5A
CMPINSTRUCTION      B000
CMPMASK             F000
CMPMESSAGE          2D05
CONDITIONCODEMESSAGE  2C96
CONTINUEPROMPT      2DFB
CONVERTHEXTOASCII   2AD4
CS                  5
CSM                 2C49
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         2D79
DATA_REG_DIRECT     2886
DIVS                1660
DIVSBODY            168C
DIVSINSTRUCTION     81C0
DIVSMASK            F1C0
DIVSMESSAGE         2D17
ELPROMPT            2B53
END                 FFFFFE
ENDLOCATION         2E62
ENDLOCATIONPROMPT   2CEB
END_ADDRESS         26DC
ENTER_ADDR_EDIT_ALL  271C
ENTER_ADDR_EDIT_ALL_EXIT  2740
EOR                 1232
EORBODY             1276
EOREA               1224
EOREAMASKS          122B
EORINSTRUCTION      B000
EORMASK             F000
EORMESSAGE          2D01
EQ                  7
EQM                 2C4D
EVEN_MSG            2C23
FALSEPOSITIVE       1098
FARLABEL            FFE
FIN                 2680
FOUNDCC             25A4
GE                  C
GEM                 2C51
GET_EFFECTIVE_ADDRESS  282A
GET_EFFECTIVE_ADDRESS_EXIT  29C2
GET_EFFECTIVE_ADDRESS_OTHER  286A
GT                  E
GTM                 2C55
HANDLEBYTEDATA      2646
HEXBYTE             2AC6
HEXLONG             2A7A
HEXOUTPUTBUFFER     2A42
HEXWORD             2AAC
HEX_RANGE_ERROR     27E6
HI                  2
HIM                 2C59
IDATA               2D99
INSTLABELLIST       1136
INSTLABELLIST2      113E
INSTLABELLIST3      1172
INSTMASKLIST        10FA
INSTMASKLIST2       10FE
INSTMASKLIST3       1118
INSTOPLIST          10BE
INSTOPLIST2         10C2
INSTOPLIST3         10DC
INVALIDEA           29C2
INVALIDMSG          2B96
INVCHARMSG          2BDB
JSR                 2344
JSRBODY             236C
JSRDONE             238C
JSREA               233C
JSREAMASKS          2340
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          2D5F
LCASEHEX            27C8
LE                  F
LEA                 15DC
LEABODY             1604
LEAEA               15D4
LEAEAMASKS          15D8
LEAINSTRUCTION      41C0
LEAMASK             F1C0
LEAMESSAGE          2D12
LEM                 2C5D
LETTER              2AEE
LETTERA             2DA3
LETTERD             2DA5
LONG                4
LPRN                2DAB
LS                  3
LSLEA               1928
LSLMESSAGE          2D31
LSLREG              19A4
LSM                 2C61
LSREA               1918
LSRLCHECKI          1A10
LSRLCHECKIR         19FA
LSRLCHECKIRRETURN   1A0E
LSRLCHECKR          1A44
LSRLEA              18D0
LSRLEAMASKS         18D6
LSRLREG             196E
LSRLREGBODY         19B4
LSRLREGINSTRUCTION  E008
LSRLREGMASK         F018
LSRLWEA             18DC
LSRLWEABODY         1938
LSRLWEACHECKDIRECTION  1904
LSRLWEAINSTRUCTION  E2C0
LSRLWEAMASK         FEC0
LSRMESSAGE          2D35
LSRREG              1994
LT                  D
LTM                 2C65
MAIN_LOOP           101A
MATCH               109E
MI                  B
MIM                 2C69
MINUS               2DA9
MOVE                23DC
MOVEA               24DA
MOVEABODY           2502
MOVEADESTEA         24D6
MOVEADESTEAMASKS    24D8
MOVEAINSTRUCTION    40
MOVEAMASK           C1C0
MOVEAMESSAGE        2D7F
MOVEBODY            2432
MOVEDESTEA          23CE
MOVEDESTEAMASKS     23D5
MOVEINSTRUCTION     0
MOVEM               1E6E
MOVEMASK            C000
MOVEMESSAGE         2D6E
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     1E64
MOVEMMEMTOREGEAMASKS  1E69
MOVEMMESSAGE        2D4B
MOVEMPOST           1F2C
MOVEMPOSTREGLIST    1FB8
MOVEMPRE            1ED0
MOVEMPREREGLIST     1FD8
MOVEMREGLISTBUFFER  1F88
MOVEMREGTOMEMEA     1E5A
MOVEMREGTOMEMEAMASKS  1E5F
MOVESIZE            24A0
MOVESIZEBYTE        24C4
MOVESIZEDONE        24BE
MOVESIZELONG        24D0
MOVESIZEWORD        24CA
MOVESOURCEEA        23BC
MOVESOURCEEAMASKS   23C5
MULS                16FC
MULSBODY            1724
MULSEA              16EC
MULSEAMASKS         16F4
MULSINSTRUCTION     C1C0
MULSMASK            F1C0
MULSMESSAGE         2D1C
NE                  6
NEG                 2104
NEGBODY             212C
NEGDONE             215E
NEGEA               20F4
NEGEAMASKS          20FC
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          2D75
NEGSIZE             216E
NEM                 2C6D
NEXTADDRPROMPT      2DAF
NEXTHEX             278E
NEXTHEXDONE         27E0
NEXTHEXRETURN       27FC
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 239C
NOPMESSAGE          2D69
NUMBER              2AE6
OR                  1382
ORDEST              1456
ORI                 220E
ORIBODY             223A
ORIDONE             2290
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          2D56
ORINSTRUCTION       8000
ORMASK              F000
ORMESSAGE           2D09
ORSOURCE            13F8
ORSOURCEEA          1372
ORSOURCEEAMASKS     137A
OUTPUTHEX           2A4E
OUTPUTHEXDONE       2A66
OUTPUTPOSTINCREMENT  2076
OUTPUTPREINCREMENT  1FD8
PARSEHEXSTRING      278C
PL                  A
PLM                 2C71
PLUS                2DA7
POSTADDBACKSLASH    2070
POSTREGADD          205E
POSTREGADDDONE      2068
PREADDBACKSLASH     20EC
PREREGADD           20DA
PREREGADDDONE       20E4
PRGORG              1000
PRINTBYTESIZE       2A06
PRINTLONGSIZE       2A2E
PRINTSIZE           29C8
PRINTSIZEDONE       29EE
PRINTWORDSIZE       2A1A
PROCESS_OP_CODES    2828
PROCESS_OP_CODES_EXIT  2828
PROMPT_USER         1004
RA                  0
RAM                 2C7D
RPRN                2DAD
RSLEA               17D4
RSLMESSAGE          2D21
RSLREG              181A
RSREA               17C4
RSRLREG             17E4
RSRLREGINSTRUCTION  E018
RSRLREGMASK         F018
RSRLWEA             1784
RSRLWEACHECKDIRECTION  17B0
RSRLWEAINSTRUCTION  E6C0
RSRLWEAMASK         FEC0
RSRMESSAGE          2D25
RSRREG              180A
RTS                 23AC
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          2D64
SCREENLOOP          1016
SIGNEXTENDBYTE      25E0
SLPROMPT            2B0E
SPC                 2C43
SPC_LEN             2C44
SR                  1
SRM                 2C81
STACK               5000
START               1000
STARTLOCATION       2E5E
STARTLOCATIONPROMPT  2CD6
SUB                 1B2C
SUBDEST             1C04
SUBINSTRUCTION      9000
SUBMASK             F000
SUBMESSAGE          2D3E
SUBQ                1A6E
SUBQBODY            1AA6
SUBQEA              1A5E
SUBQEAMASKS         1A66
SUBQINSTRUCTION     5100
SUBQMASK            F100
SUBQMESSAGE         2D39
SUBSOURCE           1BA6
SWITCHMODEANDREG    2AFA
THANKYOUMESSAGE     2E40
TOEIGHT             1B28
UCASEHEX            27B0
UNKNOWNOPCODE       2618
VALIDADDA           1C80
VALIDADDDESTEA      1D78
VALIDADDIMODES      2182
VALIDADDSOURCEEA    1D4E
VALIDASRL           182C
VALIDBCLRDATAMODES  14B6
VALIDBCLRMODES      1550
VALIDCMPEA          12EA
VALIDCMPIMODES      22B0
VALIDDIVSMODES      1662
VALIDEOREA          1250
VALIDJSRMODES       2346
VALIDLEAMODES       15DE
VALIDLSRL           18DE
VALIDMEMTOREG       1EAA
VALIDMOVEAMODES     24DC
VALIDMOVEDESTMODES  2406
VALIDMOVESOURCEMODES  23DE
VALIDMULSMODES      16FE
VALIDNEGMODES       2106
VALIDORDESTEA       13CE
VALIDORIMODES       2210
VALIDORSOURCEEA     13A8
VALIDREGTOMEM       1E84
VALIDRSRL           1786
VALIDSUBDESTEA      1B7C
VALIDSUBQ           1A80
VALIDSUBSOURCEEA    1B52
VC                  8
VCM                 2C75
VS                  9
VSM                 2C79
WORD                2
XXXL                2D8F
XXXW                2D85
ZEROTOEIGHT         1B1E
ZEROTOEIGHTRETURN   1B26

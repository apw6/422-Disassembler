00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/13/2014 3:25:47 PM

00000000                             1  
00000000                             2  *##########################################################################
00000000                             3  * Title      : 
00000000                             4  * Written by : Andrew Watson
00000000                             5  *            : Elaine Keller
00000000                             6  *            : Robert Anderson
00000000                             7  * Date       : 11/14/2014
00000000                             8  * Description: 
00000000                             9  *##########################################################################
00000000                            10  
00000000                            11  ***Possible Bug***
00000000                            12  *can not tell data from an
00000000                            13  *unidentified instruction that is an actual
00000000                            14  *instruction therefore causing errors.
00000000                            15  *may not actually be a bug because data
00000000                            16  *is data to the machine, and if you modify
00000000                            17  *the instructions in memory for a program
00000000                            18  *by moivng data, you can modify the instuctions
00000000                            19  *executed.
00000000                            20  
00000000                            21  
00000000                            22  ***************************************************************************
00000000                            23  *                   Variable/Data Definitions
00000000                            24  ***************************************************************************
00000000                            25  
00000000  =00005000                 26  stack   EQU   $00005000
00000000  =00005001                 27  begin   EQU   $00005001
00000000  =00FFFFFE                 28  end     EQU   $00FFFFFE
00000000  =00000001                 29  byte    EQU   1
00000000  =00000002                 30  word    EQU   2
00000000  =00000004                 31  long    EQU   4
00000000  =00001000                 32  prgorg  EQU   $1000
00000000                            33  
00000FFE                            34      ORG $00000FFE
00000FFE                            35  FarLabel:
00001000                            36      ORG    prgorg
00001000                            37  start:
00001000  4FF8 5000                 38          LEA stack, SP                   ;initialize stack
00001004                            39  
00001000                            40      ORG    prgorg
00001000                            41  
00001000                            42  ******************************************************************************
00001000                            43  *                   Begin processing active code
00001000                            44  ******************************************************************************
00001000                            45      
00001000                            46  start:
00001000                            47  
00001000  4FF8 5000                 48          LEA         stack, SP           ;Initialize stack
00001004                            49          
00001004                            50  *.............................................................................
00001004                            51  * Debug Mode - Comment out when done
00001004                            52          ;MOVE.L      #snippet,A3
00001004                            53          ;MOVE.L      #snippetEnd,A4
00001004                            54  
00001004                            55  *        MOVE.L      #begin,A3
00001004                            56  *        MOVE.L      #end,A4
00001004  6000 0014                 57          BRA         screenLoop
00001008                            58  * Debug Mode - Comment out when done
00001008                            59  *.............................................................................        
00001008                            60          
00001008                            61  prompt_user:
00001008                            62  
00001008  6100 164E                 63          BSR         begin_address
0000100C  B67C FFFF                 64          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
00001010  6700 1636                 65          BEQ         fin                 ;Yes, then exit
00001014                            66          
00001014  6000 0004                 67          BRA         screenLoop
00001018                            68          ;BSR         process_op_codes
00001018  60EE                      69          BRA         prompt_user
0000101A                            70                  
0000101A                            71  ******************************************************************************
0000101A                            72  *                   Begin processing OP Codes
0000101A                            73  ******************************************************************************
0000101A                            74  
0000101A                            75  screenLoop:
0000101A                            76  
0000101A  143C 001E                 77              MOVE.B #30,D2
0000101E                            78   
0000101E                            79  main_Loop:
0000101E                            80  
0000101E  B9CB                      81          CMPA.L A3,A4                    ;check end of prog
00001020  6F00 1626                 82          BLE fin
00001024                            83          
00001024  0C02 0000                 84          CMPI.B #0,D2
00001028  6700 0188                 85          BEQ checkContinue
0000102C  5302                      86          SUBQ.B #1,D2
0000102E  48A7 2000                 87          MOVEM.W D2,-(SP)                ;save D2 for next iteration
00001032                            88          
00001032                            89          ;print memory location
00001032  48E7 1200                 90          MOVEM.L D3/D6,-(SP)
00001036  7C02                      91          MOVEQ.L #2,D6                   ;set as long hex string
00001038  260B                      92          MOVE.L  A3,D3                   ;put hex in D3
0000103A  6100 19C8                 93          BSR outputHex
0000103E  4CDF 0048                 94          MOVEM.L (SP)+,D3/D6
00001042                            95          
00001042                            96          ;print ' '
00001042  48E7 4000                 97          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001046  123C 0020                 98          MOVE.B #' ',D1                  ;put ascii value of char in D1
0000104A  103C 0006                 99          MOVE.B #6,D0                    ;move task 6 into D0
0000104E  4E4F                     100          TRAP #15                        ;prin char
00001050  4CDF 0002                101          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001054                           102          
00001054                           103          
00001054                           104          
00001054                           105          ;handle an odd memory access(instructions will never be misaligned)
00001054  240B                     106          MOVE.L A3,D2                    ; copy address to D2
00001056  0202 0001                107          ANDI.B #%00000001,D2            ;mask everything except the least significant bit
0000105A  0C02 0001                108          CMPI.B #1,D2                    ;compare the least sig bit of the address to one
0000105E  6700 15AE                109          BEQ handlebytedata              ;the least sig bit will only be one if the insrtuction
00001062                           110                             ;is odd(misaligned) and therefore not an instruction
00001062                           111          
00001062  7600                     112          MOVEQ.L #0,D3
00001064                           113          
00001064  3213                     114          MOVE.W (A3),D1                  ;copy word from other prog to analyze as instructioninstruction
00001066                           115          
00001066                           116          ***things to save A3,A4,D1(?)***
00001066  48E7 0018                117          MOVEM.L A3-A4,-(SP)
0000106A  6100 0010                118          BSR checkOPcode
0000106E  4CDF 1800                119          MOVEM.L (SP)+,A3-A4
00001072  D7C7                     120          ADDA.L  D7,A3                   ;look past data that was part of the instruction
00001074                           121          
00001074  548B                     122          ADDQ.L  #word,A3
00001076  4C9F 0004                123          MOVEM.W (SP)+,D2                ;restore D2 for next iteration
0000107A  60A2                     124          BRA     main_Loop 
0000107C                           125          
0000107C                           126  checkOPcode:
0000107C                           127  
0000107C                           128  
0000107C  7E00                     129          MOVEQ.L #0,D7
0000107E                           130          
0000107E  41F9 000010C2            131          LEA     instOPList,A0           ;get instruction signitrue list in A0
00001084  D1C3                     132          ADDA.L  D3,A0                   ;get correct sig         
00001086                           133          
00001086  43F9 000010FE            134          LEA     instMaskList,A1         ;get instruction mask in A1
0000108C  D3C3                     135          ADDA.L  D3,A1                   ;get correct mast
0000108E                           136          
0000108E  3401                     137          MOVE.W  D1,D2                   ;move instruction into D2 for manipulaiton
00001090                           138          
00001090  C451                     139          AND.W   (A1),D2                 ;mask instruction
00001092                           140          
00001092                           141          
00001092                           142          
00001092                           143          
00001092  B450                     144          CMP.W   (A0),D2                 ;compare to sig
00001094  6700 000C                145          BEQ     match                   ;if sig matches branch
00001098  5483                     146          ADDQ.L  #word,D3                ;add to D3 to check for next instruction
0000109A  60E0                     147          BRA checkOPcode
0000109C                           148          
0000109C                           149  falsePositive:
0000109C                           150          
0000109C  103C 00FF                151          MOVE.B #-1,D0
000010A0  4E75                     152          RTS
000010A2                           153  
000010A2                           154  match:
000010A2                           155          
000010A2  43F9 0000113A            156          LEA     instLabelList,A1        ;get instruction code label
000010A8  D3C3                     157          ADDA.L  D3,A1                   ;get correct label
000010AA  D3C3                     158          ADDA.L  D3,A1
000010AC  5483                     159          ADDQ.L  #word,D3                ;add to D3 incase false positive
000010AE  2251                     160          MOVEA.L (A1),A1
000010B0  48E7 1000                161          MOVEM.L D3,-(SP)                ; save D3
000010B4  4E91                     162          JSR     (A1)
000010B6  4CDF 0008                163          MOVEM.L (SP)+,D3                ;restore D3
000010BA  B03C 00FF                164          CMP.B   #-1,D0
000010BE  67BC                     165          BEQ     checkOPcode
000010C0  4E75                     166          RTS
000010C2                           167          
000010C2                           168  
000010C2= 0040 B000                169  instOPList  DC.W moveaInstruction,eorInstruction
000010C6= B000 8000 0880 0...      170  instOPList2 DC.W cmpInstruction,orInstruction,bclrdataInstruction,bclrInstruction,leaInstruction,divsInstruction,mulsInstruction,rsrlweaInstruction,rsrlregInstruction,asrlweaInstruction,asrlregInstruction,lsrlweaInstruction,lsrlregInstruction
000010E0= 5100 9000 D000 D...      171  instOPList3 DC.W subqInstruction,subInstruction,addaInstruction,addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruct
000010FE                           172      
000010FE= C1C0 F000                173  instMaskList  DC.W moveaMask,eorMask
00001102= F000 F000 FFC0 F...      174  instMaskList2 DC.W cmpMask,orMask,bclrdataMask,bclrMask,leaMask,divsMask,mulsMask,rsrlweaMask,rsrlregMask,asrlweaMask,asrlregMask,lsrlweaMask,lsrlregMask
0000111C= F100 F000 F000 F...      175  instMaskList3 DC.W subqMask,subMask,addaMask,addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
0000113A= 000024A2 000011FA        176  instLabelList  DC.L MOVEA,EOR
00001142= 0000129C 0000134A ...    177  instLabelList2 DC.L CMP,OR,BCLRDATA,BCLR,LEA,DIVS,MULS,RSRLWEA,RSRLREG,ASRLWEA,ASRLREG,LSRLWEA,LSRLREG
00001176= 00001A36 00001AF4 ...    178  instLabelList3 DC.L SUBQ,SUB,ADDA,ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
000011B2                           179  
000011B2                           180  checkContinue:
000011B2                           181          
000011B2  48A7 6040                182          MOVEM.W D1/D2/A1,-(SP)          ;save reg that are modified just in case
000011B6                           183          
000011B6  43F9 00002D3D            184          LEA     continuePrompt,A1       ;move string
000011BC  103C 000E                185          MOVE.B  #14,D0                  ;set for task to display null terminated 
000011C0                           186                                ;string without CR, LF
000011C0  4E4F                     187          TRAP    #15
000011C2                           188          
000011C2                           189          
000011C2  103C 0005                190          MOVE.B  #5,D0                   ;set for task to read single char into D1
000011C6  4E4F                     191          TRAP    #15
000011C8                           192          
000011C8  43F9 00002C8C            193          LEA     clearLine,A1            ;move string for a CR and LF
000011CE  103C 000E                194          MOVE.B  #14,D0                  ;set for task to display null terminated 
000011D2                           195                                ;string without CR, LF
000011D2  4E4F                     196          TRAP    #15
000011D4                           197          
000011D4                           198          ;if either case of 'Q' is entered, quit the program
000011D4  0C01 0071                199          CMPI.B #'q',D1
000011D8  6700 146E                200          BEQ fin
000011DC  0C01 0051                201          CMPI.B #'Q',D1
000011E0  6700 1466                202          BEQ fin
000011E4                           203          
000011E4  4C9F 0206                204          MOVEM.W (SP)+,D1/D2/A1
000011E8  6000 FE30                205          BRA screenLoop
000011EC                           206  
000011EC                           207           
000011EC                           208           
000011EC= 00 10 18 20 38 39 00     209  eorEA      Dc.B %000000,%010000,%011000,%100000,%111000,%111001,0
000011F3= 38 38 38 38 3F 3F 00     210  eorEAmasks DC.B %111000,%111000,%111000,%111000,%111111,%111111,0
000011FA                           211  
000011FA                           212  
000011FA                           213  
000011FA                           214  EOR:
000011FA                           215          
000011FA                           216  
000011FA                           217          
000011FA  7000                     218          MOVEQ.L #0, D0                  ;clear D0
000011FC                           219          
000011FC                           220          ;Figure out if EA is source or destination
000011FC  3401                     221          MOVE.W D1,D2                    ;copy inst to D2
000011FE  EC4A                     222          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001200  0202 0007                223          ANDI.B #%00000111,D2            ;mask out rest of byte
00001204  0C02 0003                224          CMPI.B #3,D2                    ;compare to 3
00001208  6F00 FE92                225          BLE falsePositive               ;3 or less is not valid
0000120C                           226          
0000120C  0C02 0007                227          CMPI.B #%111,D2                 ;compare to 7
00001210  6700 FE8A                228          BEQ falsePositive               ;thats not valid
00001214  6000 0002                229          BRA validEorEA                  ;all thats left is valid EA size 
00001218                           230          
00001218                           231  validEorEA:
00001218                           232          
00001218  43F8 11F3                233          LEA eorEAmasks,A1               ;load the list of masks
0000121C  D3C0                     234          ADDA.L D0,A1                    ;displace to a specific mask
0000121E  1A11                     235          MOVE.B (A1),D5                  ;move the mask to D5
00001220                           236          
00001220  0C05 0000                237          CMPI.B #0,D5                    ;check if the mask is 0
00001224  6700 FE76                238          BEQ falsePositive               ;branch if it is
00001228                           239          
00001228  1401                     240          MOVE.B D1,D2                    ;copy instruction to D2
0000122A  C405                     241          AND.B D5,D2                     ;mask D2
0000122C                           242          
0000122C  43F8 11EC                243          LEA eorEA,A1                    ;load the list of valid modes
00001230  D3C0                     244          ADDA.L D0,A1                    ;displace to a specific mode
00001232  1811                     245          MOVE.B (A1),D4                  ;move mode to D4
00001234  B404                     246          CMP.B D4,D2                     ;compare mode to masked value
00001236  6700 0006                247          BEQ  eorBody                    ;if its match, its a valid mode and we can procede
0000123A                           248          
0000123A  5280                     249          ADDQ.L #1,D0                    ;add one to displacement
0000123C  60DA                     250          BRA validEorEA                  ;check for next mode
0000123E                           251                  
0000123E                           252  
0000123E                           253  eorBody
0000123E                           254  
0000123E  43F9 00002C8F            255          LEA     eorMessage,A1           ;move string for MOVE
00001244  103C 000E                256          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001248                           257                                ;string with CR, LF
00001248  4E4F                     258          TRAP    #15
0000124A                           259          
0000124A  6100 0EEA                260          BSR negSize
0000124E                           261          
0000124E                           262          ;Do Dn
0000124E                           263          
0000124E  3401                     264          MOVE.W  D1,D2
00001250  E04A                     265          LSR.W   #8,D2                   ;move reg into first byte
00001252  E20A                     266          LSR.B   #1,D2                   ;line it up to least sig bit
00001254  C43C 0007                267          AND.B   #%00000111,D2           ;force mode to Dn
00001258  1A02                     268          MOVE.B  D2,D5
0000125A  48E7 4000                269          MOVEM.L D1,-(SP)
0000125E  6100 1580                270          BSR     Get_Effective_Address
00001262  4CDF 0002                271          MOVEM.L (SP)+,D1
00001266                           272          
00001266                           273          
00001266                           274          ;print ','
00001266  48E7 4000                275          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000126A  123C 002C                276          MOVE.B #',',D1                  ;put ascii value of char in D1
0000126E  103C 0006                277          MOVE.B #6,D0                    ;move task 6 into D0
00001272  4E4F                     278          TRAP #15                        ;prin char
00001274  4CDF 0002                279          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001278                           280          
00001278                           281          ;Then do EA
00001278                           282          
00001278  3401                     283          MOVE.W  D1,D2                   ;check mode
0000127A  C43C 003F                284          AND.B   #%00111111,D2
0000127E  1A02                     285          MOVE.B  D2,D5
00001280  48E7 4000                286          MOVEM.L D1,-(SP)
00001284  6100 155A                287          BSR     Get_Effective_Address
00001288  4CDF 0002                288          MOVEM.L (SP)+,D1
0000128C                           289          
0000128C                           290          
0000128C  43F9 00002C8C            291          LEA     clearLine,A1            ;move string for a CR and LF
00001292  103C 000E                292          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001296                           293                                ;string without CR, LF
00001296  4E4F                     294          TRAP    #15
00001298                           295  
00001298  7000                     296          MOVEQ.L #0,D0
0000129A  4E75                     297          RTS
0000129C                           298  
0000129C                           299  
0000129C                           300  
0000129C                           301  CMP:
0000129C                           302          
0000129C                           303  
0000129C                           304          
0000129C  7000                     305          MOVEQ.L #0, D0                  ;clear D0
0000129E                           306          
0000129E                           307          ;Figure out if EA is source or destination
0000129E  3401                     308          MOVE.W D1,D2                    ;copy inst to D2
000012A0  EC4A                     309          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
000012A2  0202 0007                310          ANDI.B #%00000111,D2            ;mask out rest of byte
000012A6  0C02 0002                311          CMPI.B #2,D2                    ;compare to 2
000012AA  6F00 0006                312          BLE validCmpEA                  ;2 or less is EA 
000012AE                           313          
000012AE  6000 FDEC                314          BRA falsePositive               ;thats not valid
000012B2                           315          
000012B2                           316  validCmpEA:
000012B2                           317          
000012B2  43F9 0000238D            318          LEA moveSourceEAmasks,A1        ;load the list of masks
000012B8  D3C0                     319          ADDA.L D0,A1                    ;displace to a specific mask
000012BA  1A11                     320          MOVE.B (A1),D5                  ;move the mask to D5
000012BC                           321          
000012BC  0C05 0000                322          CMPI.B #0,D5                    ;check if the mask is 0
000012C0  6700 FDDA                323          BEQ falsePositive               ;branch if it is
000012C4                           324          
000012C4  1401                     325          MOVE.B D1,D2                    ;copy instruction to D2
000012C6  C405                     326          AND.B D5,D2                     ;mask D2
000012C8                           327          
000012C8  43F9 00002384            328          LEA moveSourceEA,A1             ;load the list of valid modes
000012CE  D3C0                     329          ADDA.L D0,A1                    ;displace to a specific mode
000012D0  1811                     330          MOVE.B (A1),D4                  ;move mode to D4
000012D2  B404                     331          CMP.B D4,D2                     ;compare mode to masked value
000012D4  6700 0006                332          BEQ  cmpBody                    ;if its match, its a valid mode and we can procede
000012D8                           333          
000012D8  5280                     334          ADDQ.L #1,D0                    ;add one to displacement
000012DA  60D6                     335          BRA validCmpEA                  ;check for next mode
000012DC                           336          
000012DC                           337          
000012DC                           338          
000012DC                           339  cmpBody
000012DC                           340  
000012DC  43F9 00002C93            341          LEA     cmpMessage,A1           ;move string for MOVE
000012E2  103C 000E                342          MOVE.B  #14,D0                  ;set for task to display null terminated 
000012E6                           343                                ;string with CR, LF
000012E6  4E4F                     344          TRAP    #15
000012E8                           345          
000012E8  6100 0E4C                346          BSR negSize
000012EC                           347          
000012EC                           348          ;do EA
000012EC                           349          
000012EC  3401                     350          MOVE.W  D1,D2                   ;check mode
000012EE  C43C 003F                351          AND.B   #%00111111,D2
000012F2  1A02                     352          MOVE.B  D2,D5
000012F4  48E7 4000                353          MOVEM.L D1,-(SP)
000012F8  6100 14E6                354          BSR     Get_Effective_Address
000012FC  4CDF 0002                355          MOVEM.L (SP)+,D1
00001300                           356          
00001300                           357          ;print ','
00001300  48E7 4000                358          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001304  123C 002C                359          MOVE.B #',',D1                  ;put ascii value of char in D1
00001308  103C 0006                360          MOVE.B #6,D0                    ;move task 6 into D0
0000130C  4E4F                     361          TRAP #15                        ;prin char
0000130E  4CDF 0002                362          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001312                           363          
00001312                           364          ;Then do Dn
00001312                           365          
00001312  3401                     366          MOVE.W  D1,D2
00001314  E04A                     367          LSR.W   #8,D2                   ;move reg into first byte
00001316  E20A                     368          LSR.B   #1,D2                   ;line it up to least sig bit
00001318  C43C 0007                369          AND.B   #%00000111,D2           ;force mode to Dn
0000131C  1A02                     370          MOVE.B  D2,D5
0000131E  48E7 4000                371          MOVEM.L D1,-(SP)
00001322  6100 14BC                372          BSR     Get_Effective_Address
00001326  4CDF 0002                373          MOVEM.L (SP)+,D1
0000132A                           374          
0000132A  43F9 00002C8C            375          LEA     clearLine,A1            ;move string for a CR and LF
00001330  103C 000E                376          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001334                           377                                ;string without CR, LF
00001334  4E4F                     378          TRAP    #15
00001336                           379  
00001336  7000                     380          MOVEQ.L #0,D0
00001338  4E75                     381          RTS
0000133A                           382  
0000133A                           383  
0000133A                           384  
0000133A= 00 10 18 20 38 39 ...    385  orSourceEA      Dc.B %000000,%010000,%011000,%100000,%111000,%111001,%111100,0
00001342= 38 38 38 38 3F 3F ...    386  orSourceEAmasks DC.B %111000,%111000,%111000,%111000,%111111,%111111,%111111,0
0000134A                           387  
0000134A                           388  OR:
0000134A                           389          
0000134A                           390  
0000134A                           391          
0000134A  7000                     392          MOVEQ.L #0, D0                  ;clear D0
0000134C                           393          
0000134C                           394          ;Figure out if EA is source or destination
0000134C  3401                     395          MOVE.W D1,D2                    ;copy inst to D2
0000134E  EC4A                     396          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001350  0202 0007                397          ANDI.B #%00000111,D2            ;mask out rest of byte
00001354  0C02 0002                398          CMPI.B #2,D2                    ;compare to 2
00001358  6F00 0016                399          BLE validOrSourceEA             ;2 or less is EA is source
0000135C                           400          
0000135C  0C02 0007                401          CMPI.B #%111,D2                 ;compare to 7
00001360  6700 FD3A                402          BEQ falsePositive               ;thats not valid
00001364  0C02 0003                403          CMPI.B #%11,D2                  ;compare to 3
00001368  6700 FD32                404          BEQ falsePositive               ;also not valid
0000136C  6000 0028                405          BRA validOrDestEA               ;all thats left is valid EA as Dest 
00001370                           406          
00001370                           407  validORSourceEA:
00001370                           408          
00001370  43F8 1342                409          LEA orSourceEAmasks,A1          ;load the list of masks
00001374  D3C0                     410          ADDA.L D0,A1                    ;displace to a specific mask
00001376  1A11                     411          MOVE.B (A1),D5                  ;move the mask to D5
00001378                           412          
00001378  0C05 0000                413          CMPI.B #0,D5                    ;check if the mask is 0
0000137C  6700 FD1E                414          BEQ falsePositive               ;branch if it is
00001380                           415          
00001380  1401                     416          MOVE.B D1,D2                    ;copy instruction to D2
00001382  C405                     417          AND.B D5,D2                     ;mask D2
00001384                           418          
00001384  43F8 133A                419          LEA orSourceEA,A1               ;load the list of valid modes
00001388  D3C0                     420          ADDA.L D0,A1                    ;displace to a specific mode
0000138A  1811                     421          MOVE.B (A1),D4                  ;move mode to D4
0000138C  B404                     422          CMP.B D4,D2                     ;compare mode to masked value
0000138E  6700 0030                423          BEQ  orSource                   ;if its match, its a valid mode and we can procede
00001392                           424          
00001392  5280                     425          ADDQ.L #1,D0                    ;add one to displacement
00001394  60DA                     426          BRA validOrSourceEA             ;check for next mode
00001396                           427          
00001396                           428          
00001396                           429  validOrDestEA:
00001396                           430          
00001396  43F9 00001CEA            431          LEA addDestEAmasks,A1           ;load the list of masks
0000139C  D3C0                     432          ADDA.L D0,A1                    ;displace to a specific mask
0000139E  1A11                     433          MOVE.B (A1),D5                  ;move the mask to D5
000013A0                           434          
000013A0  0C05 0000                435          CMPI.B #0,D5                    ;check if the mask is 0
000013A4  6700 FCF6                436          BEQ falsePositive               ;branch if it is
000013A8                           437          
000013A8  3401                     438          MOVE.W D1,D2                    ;copy instruction to D2
000013AA  C405                     439          AND.B D5,D2                     ;mask D2
000013AC                           440          
000013AC  43F9 00001CE4            441          LEA addDestEA,A1                ;load the list of valid modes
000013B2  D3C0                     442          ADDA.L D0,A1                    ;displace to a specific mode
000013B4  1811                     443          MOVE.B (A1),D4                  ;move mode to D4
000013B6  B404                     444          CMP.B D4,D2                     ;compare mode to masked value
000013B8  6700 0064                445          BEQ orDest                      ;if its match, its a valid mode and we can procede
000013BC                           446          
000013BC  5280                     447          ADDQ.L #1,D0                    ;add one to displacement
000013BE  60D6                     448          BRA validOrDestEA               ;check for next mode
000013C0                           449          
000013C0                           450  orSource
000013C0                           451  
000013C0  43F9 00002C97            452          LEA     orMessage,A1            ;move string for MOVE
000013C6  103C 000E                453          MOVE.B  #14,D0                  ;set for task to display null terminated 
000013CA                           454                                ;string with CR, LF
000013CA  4E4F                     455          TRAP    #15
000013CC                           456          
000013CC  6100 0D68                457          BSR negSize
000013D0                           458          
000013D0                           459          ;do EA
000013D0                           460          
000013D0  3401                     461          MOVE.W  D1,D2                   ;check mode
000013D2  C43C 003F                462          AND.B   #%00111111,D2
000013D6  1A02                     463          MOVE.B  D2,D5
000013D8  48E7 4000                464          MOVEM.L D1,-(SP)
000013DC  6100 1402                465          BSR     Get_Effective_Address
000013E0  4CDF 0002                466          MOVEM.L (SP)+,D1
000013E4                           467          
000013E4                           468          ;print ','
000013E4  48E7 4000                469          MOVEM.L D1,-(SP)                ;save D1 to the stack
000013E8  123C 002C                470          MOVE.B #',',D1                  ;put ascii value of char in D1
000013EC  103C 0006                471          MOVE.B #6,D0                    ;move task 6 into D0
000013F0  4E4F                     472          TRAP #15                        ;prin char
000013F2  4CDF 0002                473          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000013F6                           474          
000013F6                           475          ;Then do Dn
000013F6                           476          
000013F6  3401                     477          MOVE.W  D1,D2
000013F8  E04A                     478          LSR.W   #8,D2                   ;move reg into first byte
000013FA  E20A                     479          LSR.B   #1,D2                   ;line it up to least sig bit
000013FC  C43C 0007                480          AND.B   #%00000111,D2           ;force mode to Dn
00001400  1A02                     481          MOVE.B  D2,D5
00001402  48E7 4000                482          MOVEM.L D1,-(SP)
00001406  6100 13D8                483          BSR     Get_Effective_Address
0000140A  4CDF 0002                484          MOVEM.L (SP)+,D1
0000140E                           485          
0000140E  43F9 00002C8C            486          LEA     clearLine,A1            ;move string for a CR and LF
00001414  103C 000E                487          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001418                           488                                ;string without CR, LF
00001418  4E4F                     489          TRAP    #15
0000141A                           490  
0000141A  7000                     491          MOVEQ.L #0,D0
0000141C  4E75                     492          RTS
0000141E                           493  
0000141E                           494  orDest
0000141E                           495  
0000141E  43F9 00002C97            496          LEA     orMessage,A1            ;move string for MOVE
00001424  103C 000E                497          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001428                           498                                ;string with CR, LF
00001428  4E4F                     499          TRAP    #15
0000142A                           500          
0000142A  6100 0D0A                501          BSR negSize
0000142E                           502          
0000142E                           503          ;Do Dn
0000142E                           504          
0000142E  3401                     505          MOVE.W  D1,D2
00001430  E04A                     506          LSR.W   #8,D2                   ;move reg into first byte
00001432  E20A                     507          LSR.B   #1,D2                   ;line it up to least sig bit
00001434  C43C 0007                508          AND.B   #%00000111,D2           ;force mode to Dn
00001438  1A02                     509          MOVE.B  D2,D5
0000143A  48E7 4000                510          MOVEM.L D1,-(SP)
0000143E  6100 13A0                511          BSR     Get_Effective_Address
00001442  4CDF 0002                512          MOVEM.L (SP)+,D1
00001446                           513          
00001446                           514          
00001446                           515          ;print ','
00001446  48E7 4000                516          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000144A  123C 002C                517          MOVE.B #',',D1                  ;put ascii value of char in D1
0000144E  103C 0006                518          MOVE.B #6,D0                    ;move task 6 into D0
00001452  4E4F                     519          TRAP #15                        ;prin char
00001454  4CDF 0002                520          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001458                           521          
00001458                           522          ;Then do EA
00001458                           523          
00001458  3401                     524          MOVE.W  D1,D2                   ;check mode
0000145A  C43C 003F                525          AND.B   #%00111111,D2
0000145E  1A02                     526          MOVE.B  D2,D5
00001460  48E7 4000                527          MOVEM.L D1,-(SP)
00001464  6100 137A                528          BSR     Get_Effective_Address
00001468  4CDF 0002                529          MOVEM.L (SP)+,D1
0000146C                           530          
0000146C                           531          
0000146C  43F9 00002C8C            532          LEA     clearLine,A1            ;move string for a CR and LF
00001472  103C 000E                533          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001476                           534                                ;string without CR, LF
00001476  4E4F                     535          TRAP    #15
00001478                           536  
00001478  7000                     537          MOVEQ.L #0,D0
0000147A  4E75                     538          RTS
0000147C                           539  
0000147C                           540  
0000147C                           541  
0000147C                           542  
0000147C                           543  BCLRDATA:
0000147C                           544  
0000147C  7000                     545          MOVEQ.L #0, D0                  ;clear D0
0000147E                           546          
0000147E                           547  validBCLRdataModes:
0000147E                           548          
0000147E  43F9 000016BC            549          LEA mulsEAmasks,A1              ;load the list of masks
00001484  D3C0                     550          ADDA.L D0,A1                    ;displace to a specific mask
00001486  1A11                     551          MOVE.B (A1),D5                  ;move the mask to D5
00001488                           552          
00001488  0C05 0000                553          CMPI.B #0,D5                    ;check if the mask is 0
0000148C  6700 FC0E                554          BEQ falsePositive               ;branch if it is
00001490                           555          
00001490  1401                     556          MOVE.B D1,D2                    ;copy instruction to D2
00001492  C405                     557          AND.B D5,D2                     ;mask D2
00001494                           558          
00001494  43F9 000016B4            559          LEA mulsEA,A1                   ;load the list of valid modes
0000149A  D3C0                     560          ADDA.L D0,A1                    ;displace to a specific mode
0000149C  1811                     561          MOVE.B (A1),D4                  ;move mode to D4
0000149E  B404                     562          CMP.B D4,D2                     ;compare mode to masked value
000014A0  6700 0006                563          BEQ  bclrdataBody               ;if its match, its a valid mode and we can procede
000014A4                           564          
000014A4  5280                     565          ADDQ.L #1,D0                    ;add one to displacement
000014A6  60D6                     566          BRA validBCLRdataModes          ;check for next mode
000014A8                           567          
000014A8                           568  bclrdataBody:
000014A8                           569          
000014A8                           570  
000014A8                           571  
000014A8  43F9 00002C9A            572          LEA     bclrMessage,A1          ;move string for MOVE
000014AE  103C 000E                573          MOVE.B  #14,D0                  ;set for task to display null terminated 
000014B2                           574                                ;string without CR, LF
000014B2  4E4F                     575          TRAP    #15
000014B4                           576  
000014B4  48E7 C010                577          MOVEM.L D0/D1/A3,-(SP)          ;save D1 and A3
000014B8  5487                     578          ADDQ.L #word,D7                 ;signal there is a word following this instruction
000014BA                           579          
000014BA                           580          ;print '#'
000014BA  48E7 4000                581          MOVEM.L D1,-(SP)                ;save D1 to the stack
000014BE  123C 0023                582          MOVE.B #'#',D1                  ;put ascii value of char in D1
000014C2  103C 0006                583          MOVE.B #6,D0                    ;move task 6 into D0
000014C6  4E4F                     584          TRAP #15                        ;prin char
000014C8  4CDF 0002                585          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000014CC                           586          
000014CC                           587          ;get following word
000014CC  548B                     588          ADDQ.L #word,A3
000014CE  3213                     589          MOVE.W (A3),D1                  ;move word at (A3)
000014D0  0281 0000FFFF            590          ANDI.L #$0000FFFF,D1            ;clear unimportant bit of D1
000014D6                           591          
000014D6                           592          ;print number
000014D6  103C 0003                593          MOVE.B #3,D0
000014DA  4E4F                     594          TRAP #15
000014DC                           595          
000014DC  4CDF 0803                596          MOVEM.L (SP)+,D0/D1/A3          ;restore D1 and A3
000014E0                           597  
000014E0                           598  
000014E0                           599  
000014E0                           600          ;print ','
000014E0  48E7 4000                601          MOVEM.L D1,-(SP)                ;save D1 to the stack
000014E4  123C 002C                602          MOVE.B #',',D1                  ;put ascii value of char in D1
000014E8  103C 0006                603          MOVE.B #6,D0                    ;move task 6 into D0
000014EC  4E4F                     604          TRAP #15                        ;prin char
000014EE  4CDF 0002                605          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000014F2                           606          
000014F2                           607          ;do dest EA
000014F2  3401                     608          MOVE.W  D1,D2                   ;check mode
000014F4  C43C 003F                609          AND.B   #%00111111,D2
000014F8  1A02                     610          MOVE.B  D2,D5
000014FA  48E7 4000                611          MOVEM.L D1,-(SP)
000014FE  6100 12E0                612          BSR     Get_Effective_Address
00001502  4CDF 0002                613          MOVEM.L (SP)+,D1
00001506                           614          
00001506  43F9 00002C8C            615          LEA     clearLine,A1            ;move string for a CR and LF
0000150C  103C 000E                616          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001510                           617                                ;string without CR, LF
00001510  4E4F                     618          TRAP    #15
00001512                           619  
00001512  7000                     620          MOVEQ.L #0,D0
00001514  4E75                     621          RTS
00001516                           622  
00001516                           623  
00001516                           624  
00001516                           625           
00001516                           626  BCLR:
00001516                           627  
00001516  7000                     628          MOVEQ.L #0, D0                  ;clear D0
00001518                           629          
00001518                           630  validBCLRModes:
00001518                           631          
00001518  43F9 000016BC            632          LEA mulsEAmasks,A1              ;load the list of masks
0000151E  D3C0                     633          ADDA.L D0,A1                    ;displace to a specific mask
00001520  1A11                     634          MOVE.B (A1),D5                  ;move the mask to D5
00001522                           635          
00001522  0C05 0000                636          CMPI.B #0,D5                    ;check if the mask is 0
00001526  6700 FB74                637          BEQ falsePositive               ;branch if it is
0000152A                           638          
0000152A  1401                     639          MOVE.B D1,D2                    ;copy instruction to D2
0000152C  C405                     640          AND.B D5,D2                     ;mask D2
0000152E                           641          
0000152E  43F9 000016B4            642          LEA mulsEA,A1                   ;load the list of valid modes
00001534  D3C0                     643          ADDA.L D0,A1                    ;displace to a specific mode
00001536  1811                     644          MOVE.B (A1),D4                  ;move mode to D4
00001538  B404                     645          CMP.B D4,D2                     ;compare mode to masked value
0000153A  6700 0006                646          BEQ  bclrBody                   ;if its match, its a valid mode and we can procede
0000153E                           647          
0000153E  5280                     648          ADDQ.L #1,D0                    ;add one to displacement
00001540  60D6                     649          BRA validBCLRModes              ;check for next mode
00001542                           650          
00001542                           651  bclrBody:
00001542                           652          
00001542                           653  
00001542                           654  
00001542  43F9 00002C9A            655          LEA     bclrMessage,A1          ;move string for MOVE
00001548  103C 000E                656          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000154C                           657                                ;string without CR, LF
0000154C  4E4F                     658          TRAP    #15
0000154E                           659  
0000154E                           660          ;do source EA
0000154E  3401                     661          MOVE.W  D1,D2                   ;check mode
00001550  C43C 003F                662          AND.B   #%00111111,D2
00001554  1A02                     663          MOVE.B  D2,D5
00001556  48E7 4000                664          MOVEM.L D1,-(SP)
0000155A  6100 1284                665          BSR     Get_Effective_Address
0000155E  4CDF 0002                666          MOVEM.L (SP)+,D1
00001562                           667  
00001562                           668          ;print ','
00001562  48E7 4000                669          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001566  123C 002C                670          MOVE.B #',',D1                  ;put ascii value of char in D1
0000156A  103C 0006                671          MOVE.B #6,D0                    ;move task 6 into D0
0000156E  4E4F                     672          TRAP #15                        ;prin char
00001570  4CDF 0002                673          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001574                           674          
00001574                           675          ;do dest data reg
00001574  3401                     676          MOVE.W  D1,D2                   ;check mode
00001576  E04A                     677          LSR.W #8,D2                     ;shift reg over
00001578  E20A                     678          LSR.B #1,D2
0000157A  C43C 0007                679          AND.B   #%00000111,D2           ;force recognition as a Dn
0000157E  1A02                     680          MOVE.B  D2,D5
00001580  48E7 4000                681          MOVEM.L D1,-(SP)
00001584  6100 125A                682          BSR     Get_Effective_Address
00001588  4CDF 0002                683          MOVEM.L (SP)+,D1
0000158C                           684          
0000158C  43F9 00002C8C            685          LEA     clearLine,A1            ;move string for a CR and LF
00001592  103C 000E                686          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001596                           687                                ;string without CR, LF
00001596  4E4F                     688          TRAP    #15
00001598                           689  
00001598  7000                     690          MOVEQ.L #0,D0
0000159A  4E75                     691          RTS
0000159C                           692  
0000159C                           693           
0000159C                           694  
0000159C= 10 38 39 00              695  leaEA        DC.B %010000,%111000,%111001,0
000015A0= 38 3F 3F 00              696  leaEAmasks   DC.B %111000,%111111,%111111,0
000015A4                           697          
000015A4                           698  LEA:
000015A4                           699  
000015A4  7000                     700          MOVEQ.L #0, D0                  ;clear D0
000015A6                           701          
000015A6                           702  validLeaModes:
000015A6                           703          
000015A6  43F8 15A0                704          LEA leaEAmasks,A1               ;load the list of masks
000015AA  D3C0                     705          ADDA.L D0,A1                    ;displace to a specific mask
000015AC  1A11                     706          MOVE.B (A1),D5                  ;move the mask to D5
000015AE                           707          
000015AE  0C05 0000                708          CMPI.B #0,D5                    ;check if the mask is 0
000015B2  6700 FAE8                709          BEQ falsePositive               ;branch if it is
000015B6                           710          
000015B6  1401                     711          MOVE.B D1,D2                    ;copy instruction to D2
000015B8  C405                     712          AND.B D5,D2                     ;mask D2
000015BA                           713          
000015BA  43F8 159C                714          LEA leaEA,A1                    ;load the list of valid modes
000015BE  D3C0                     715          ADDA.L D0,A1                    ;displace to a specific mode
000015C0  1811                     716          MOVE.B (A1),D4                  ;move mode to D4
000015C2  B404                     717          CMP.B D4,D2                     ;compare mode to masked value
000015C4  6700 0006                718          BEQ  leaBody                    ;if its match, its a valid mode and we can procede
000015C8                           719          
000015C8  5280                     720          ADDQ.L #1,D0                    ;add one to displacement
000015CA  60DA                     721          BRA validLeaModes               ;check for next mode
000015CC                           722          
000015CC                           723  leaBody:
000015CC                           724          
000015CC                           725  
000015CC                           726  
000015CC  43F9 00002CA0            727          LEA     leaMessage,A1           ;move string for MOVE
000015D2  103C 000E                728          MOVE.B  #14,D0                  ;set for task to display null terminated 
000015D6                           729                                ;string without CR, LF
000015D6  4E4F                     730          TRAP    #15
000015D8                           731  
000015D8                           732          ;do source EA
000015D8  3401                     733          MOVE.W  D1,D2                   ;check mode
000015DA  C43C 003F                734          AND.B   #%00111111,D2
000015DE  1A02                     735          MOVE.B  D2,D5
000015E0  48E7 4000                736          MOVEM.L D1,-(SP)
000015E4  6100 11FA                737          BSR     Get_Effective_Address
000015E8  4CDF 0002                738          MOVEM.L (SP)+,D1
000015EC                           739  
000015EC                           740          ;print ','
000015EC  48E7 4000                741          MOVEM.L D1,-(SP)                ;save D1 to the stack
000015F0  123C 002C                742          MOVE.B #',',D1                  ;put ascii value of char in D1
000015F4  103C 0006                743          MOVE.B #6,D0                    ;move task 6 into D0
000015F8  4E4F                     744          TRAP #15                        ;prin char
000015FA  4CDF 0002                745          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000015FE                           746          
000015FE                           747          ;do dest addr reg
000015FE  3401                     748          MOVE.W  D1,D2                   ;check mode
00001600  E04A                     749          LSR.W #8,D2                     ;shift reg over
00001602  E20A                     750          LSR.B #1,D2
00001604  C43C 0007                751          AND.B   #%00000111,D2           ;force recognition as a An
00001608  5002                     752          ADDQ.B #%1000,D2
0000160A  1A02                     753          MOVE.B  D2,D5
0000160C  48E7 4000                754          MOVEM.L D1,-(SP)
00001610  6100 11CE                755          BSR     Get_Effective_Address
00001614  4CDF 0002                756          MOVEM.L (SP)+,D1
00001618                           757          
00001618  43F9 00002C8C            758          LEA     clearLine,A1            ;move string for a CR and LF
0000161E  103C 000E                759          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001622                           760                                ;string without CR, LF
00001622  4E4F                     761          TRAP    #15
00001624                           762  
00001624  7000                     763          MOVEQ.L #0,D0
00001626  4E75                     764          RTS
00001628                           765  
00001628                           766  
00001628                           767  
00001628                           768  DIVS:
00001628                           769  
00001628  7000                     770          MOVEQ.L #0, D0                  ;clear D0
0000162A                           771          
0000162A                           772  validDivsModes:
0000162A                           773          
0000162A  43F9 000016BC            774          LEA mulsEAmasks,A1              ;load the list of masks
00001630  D3C0                     775          ADDA.L D0,A1                    ;displace to a specific mask
00001632  1A11                     776          MOVE.B (A1),D5                  ;move the mask to D5
00001634                           777          
00001634  0C05 0000                778          CMPI.B #0,D5                    ;check if the mask is 0
00001638  6700 FA62                779          BEQ falsePositive               ;branch if it is
0000163C                           780          
0000163C  1401                     781          MOVE.B D1,D2                    ;copy instruction to D2
0000163E  C405                     782          AND.B D5,D2                     ;mask D2
00001640                           783          
00001640  43F9 000016B4            784          LEA mulsEA,A1                   ;load the list of valid modes
00001646  D3C0                     785          ADDA.L D0,A1                    ;displace to a specific mode
00001648  1811                     786          MOVE.B (A1),D4                  ;move mode to D4
0000164A  B404                     787          CMP.B D4,D2                     ;compare mode to masked value
0000164C  6700 0006                788          BEQ  divsBody                   ;if its match, its a valid mode and we can procede
00001650                           789          
00001650  5280                     790          ADDQ.L #1,D0                    ;add one to displacement
00001652  60D6                     791          BRA validDivsModes              ;check for next mode
00001654                           792          
00001654                           793  divsBody:
00001654                           794          
00001654                           795  
00001654                           796  
00001654  43F9 00002CA5            797          LEA     divsMessage,A1          ;move string for MOVE
0000165A  103C 000E                798          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000165E                           799                                ;string without CR, LF
0000165E  4E4F                     800          TRAP    #15
00001660                           801          
00001660                           802          ;set size to word
00001660  7C01                     803          MOVEQ.L #1,D6
00001662  6100 131A                804          BSR printSize
00001666                           805          
00001666                           806          ;do source EA
00001666  3401                     807          MOVE.W  D1,D2                   ;check mode
00001668  C43C 003F                808          AND.B   #%00111111,D2
0000166C  1A02                     809          MOVE.B  D2,D5
0000166E  48E7 4000                810          MOVEM.L D1,-(SP)
00001672  6100 116C                811          BSR     Get_Effective_Address
00001676  4CDF 0002                812          MOVEM.L (SP)+,D1
0000167A                           813  
0000167A                           814          ;print ','
0000167A  48E7 4000                815          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000167E  123C 002C                816          MOVE.B #',',D1                  ;put ascii value of char in D1
00001682  103C 0006                817          MOVE.B #6,D0                    ;move task 6 into D0
00001686  4E4F                     818          TRAP #15                        ;prin char
00001688  4CDF 0002                819          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000168C                           820          
0000168C                           821          ;do dest data reg
0000168C  3401                     822          MOVE.W  D1,D2                   ;check mode
0000168E  E04A                     823          LSR.W #8,D2                     ;shift reg over
00001690  E20A                     824          LSR.B #1,D2
00001692  C43C 0007                825          AND.B   #%00000111,D2           ;force recognition as a Dn
00001696  1A02                     826          MOVE.B  D2,D5
00001698  48E7 4000                827          MOVEM.L D1,-(SP)
0000169C  6100 1142                828          BSR     Get_Effective_Address
000016A0  4CDF 0002                829          MOVEM.L (SP)+,D1
000016A4                           830          
000016A4  43F9 00002C8C            831          LEA     clearLine,A1            ;move string for a CR and LF
000016AA  103C 000E                832          MOVE.B  #14,D0                  ;set for task to display null terminated 
000016AE                           833                                ;string without CR, LF
000016AE  4E4F                     834          TRAP    #15
000016B0                           835  
000016B0  7000                     836          MOVEQ.L #0,D0
000016B2  4E75                     837          RTS
000016B4                           838  
000016B4                           839  
000016B4                           840  
000016B4                           841  
000016B4= 00 10 18 20 38 39 ...    842  mulsEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,%111100,0
000016BC= 38 38 38 38 3F 3F ...    843  mulsEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,%111111,0
000016C4                           844          
000016C4                           845  MULS:
000016C4                           846  
000016C4  7000                     847          MOVEQ.L #0, D0                  ;clear D0
000016C6                           848          
000016C6                           849  validMulsModes:
000016C6                           850          
000016C6  43F8 16BC                851          LEA mulsEAmasks,A1              ;load the list of masks
000016CA  D3C0                     852          ADDA.L D0,A1                    ;displace to a specific mask
000016CC  1A11                     853          MOVE.B (A1),D5                  ;move the mask to D5
000016CE                           854          
000016CE  0C05 0000                855          CMPI.B #0,D5                    ;check if the mask is 0
000016D2  6700 F9C8                856          BEQ falsePositive               ;branch if it is
000016D6                           857          
000016D6  1401                     858          MOVE.B D1,D2                    ;copy instruction to D2
000016D8  C405                     859          AND.B D5,D2                     ;mask D2
000016DA                           860          
000016DA  43F8 16B4                861          LEA mulsEA,A1                   ;load the list of valid modes
000016DE  D3C0                     862          ADDA.L D0,A1                    ;displace to a specific mode
000016E0  1811                     863          MOVE.B (A1),D4                  ;move mode to D4
000016E2  B404                     864          CMP.B D4,D2                     ;compare mode to masked value
000016E4  6700 0006                865          BEQ  mulsBody                   ;if its match, its a valid mode and we can procede
000016E8                           866          
000016E8  5280                     867          ADDQ.L #1,D0                    ;add one to displacement
000016EA  60DA                     868          BRA validMulsModes              ;check for next mode
000016EC                           869          
000016EC                           870  mulsBody:
000016EC                           871          
000016EC                           872  
000016EC                           873  
000016EC  43F9 00002CAA            874          LEA     mulsMessage,A1          ;move string for MOVE
000016F2  103C 000E                875          MOVE.B  #14,D0                  ;set for task to display null terminated 
000016F6                           876                                ;string without CR, LF
000016F6  4E4F                     877          TRAP    #15
000016F8                           878          
000016F8                           879          ;set size to word
000016F8  7C01                     880          MOVEQ.L #1,D6
000016FA  6100 1282                881          BSR printSize
000016FE                           882  
000016FE                           883          ;do source EA
000016FE  3401                     884          MOVE.W  D1,D2                   ;check mode
00001700  C43C 003F                885          AND.B   #%00111111,D2
00001704  1A02                     886          MOVE.B  D2,D5
00001706  48E7 4000                887          MOVEM.L D1,-(SP)
0000170A  6100 10D4                888          BSR     Get_Effective_Address
0000170E  4CDF 0002                889          MOVEM.L (SP)+,D1
00001712                           890  
00001712                           891          ;print ','
00001712  48E7 4000                892          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001716  123C 002C                893          MOVE.B #',',D1                  ;put ascii value of char in D1
0000171A  103C 0006                894          MOVE.B #6,D0                    ;move task 6 into D0
0000171E  4E4F                     895          TRAP #15                        ;prin char
00001720  4CDF 0002                896          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001724                           897          
00001724                           898          ;do dest data reg
00001724  3401                     899          MOVE.W  D1,D2                   ;check mode
00001726  E04A                     900          LSR.W #8,D2                     ;shift reg over
00001728  E20A                     901          LSR.B #1,D2
0000172A  C43C 0007                902          AND.B   #%00000111,D2           ;force recognition as a Dn
0000172E  1A02                     903          MOVE.B  D2,D5
00001730  48E7 4000                904          MOVEM.L D1,-(SP)
00001734  6100 10AA                905          BSR     Get_Effective_Address
00001738  4CDF 0002                906          MOVEM.L (SP)+,D1
0000173C                           907          
0000173C  43F9 00002C8C            908          LEA     clearLine,A1            ;move string for a CR and LF
00001742  103C 000E                909          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001746                           910                                ;string without CR, LF
00001746  4E4F                     911          TRAP    #15
00001748                           912  
00001748  7000                     913          MOVEQ.L #0,D0
0000174A  4E75                     914          RTS
0000174C                           915  
0000174C                           916  
0000174C                           917  
0000174C                           918  RSRLWEA:
0000174C                           919          
0000174C                           920  
0000174C                           921          
0000174C  7000                     922          MOVEQ.L #0, D0                  ;clear D0
0000174E                           923          
0000174E                           924  validRSRL:
0000174E                           925          
0000174E  43F9 0000189E            926          LEA lsrlEAmasks,A1              ;load the list of masks
00001754  D3C0                     927          ADDA.L D0,A1                    ;displace to a specific mask
00001756  1A11                     928          MOVE.B (A1),D5                  ;move the mask to D5
00001758                           929          
00001758  0C05 0000                930          CMPI.B #0,D5                    ;check if the mask is 0
0000175C  6700 F93E                931          BEQ falsePositive               ;branch if it is
00001760                           932          
00001760  1401                     933          MOVE.B D1,D2                    ;copy instruction to D2
00001762  C405                     934          AND.B D5,D2                     ;mask D2
00001764                           935          
00001764  43F9 00001898            936          LEA lsrlEA,A1                   ;load the list of valid modes
0000176A  D3C0                     937          ADDA.L D0,A1                    ;displace to a specific mode
0000176C  1811                     938          MOVE.B (A1),D4                  ;move mode to D4
0000176E  B404                     939          CMP.B D4,D2                     ;compare mode to masked value
00001770  6700 0006                940          BEQ  rsrlweaCheckDirection      ;if its match, its a valid mode and we can procede
00001774                           941          
00001774  5280                     942          ADDQ.L #1,D0                    ;add one to displacement
00001776  60D6                     943          BRA validRSRL                   ;check for next mode
00001778                           944  
00001778                           945  rsrlweaCheckDirection:
00001778                           946          ;Figure out which direction we are going
00001778  3401                     947          MOVE.W D1,D2                    ;copy inst to D2
0000177A  E04A                     948          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
0000177C  0202 0001                949          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
00001780  0C02 0000                950          CMPI.B #0,D2                    ;compare bit to zero
00001784  6700 0006                951          BEQ RSREA                       ;if zero, right
00001788  6000 0012                952          BRA RSLEA                       ;else, its left
0000178C                           953  
0000178C                           954  RSREA:
0000178C                           955  
0000178C  43F9 00002CB3            956          LEA     rsrMessage,A1           ;move string for MOVE
00001792  103C 000E                957          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001796                           958                                ;string with CR, LF
00001796  4E4F                     959          TRAP    #15
00001798  6000 0166                960          BRA lsrlweaBody
0000179C                           961          
0000179C                           962  RSLEA:
0000179C                           963          
0000179C  43F9 00002CAF            964          LEA     rslMessage,A1           ;move string for MOVE
000017A2  103C 000E                965          MOVE.B  #14,D0                  ;set for task to display null terminated 
000017A6                           966                                ;string with CR, LF
000017A6  4E4F                     967          TRAP    #15
000017A8  6000 0156                968          BRA lsrlweaBody        
000017AC                           969          
000017AC                           970  
000017AC                           971  
000017AC                           972  RSRLREG:
000017AC                           973          
000017AC                           974  
000017AC                           975          
000017AC  7000                     976          MOVEQ.L #0, D0                  ;clear D0
000017AE                           977          
000017AE                           978          ;check valid size field
000017AE  3401                     979          MOVE.W D1,D2                    ;copy inst to D2
000017B0  EC4A                     980          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
000017B2  0202 0003                981          ANDI.B #%00000011,D2            ;mask out rest of byte
000017B6  0C02 0003                982          CMPI.B #%11,D2                  ;compare to 3
000017BA  6700 F8E0                983          BEQ falsePositive               ;invalid size
000017BE                           984  
000017BE                           985          
000017BE                           986          ;Figure out which direction we are going
000017BE  3401                     987          MOVE.W D1,D2                    ;copy inst to D2
000017C0  E04A                     988          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
000017C2  0202 0001                989          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
000017C6  0C02 0000                990          CMPI.B #0,D2                    ;compare bit to zero
000017CA  6700 0006                991          BEQ RSRreg                      ;if zero, right
000017CE  6000 0012                992          BRA RSLreg                      ;else, its left        
000017D2                           993          
000017D2                           994  RSRreg:
000017D2                           995  
000017D2  43F9 00002CB3            996          LEA     rsrMessage,A1           ;move string for MOVE
000017D8  103C 000E                997          MOVE.B  #14,D0                  ;set for task to display null terminated 
000017DC                           998                                ;string with CR, LF
000017DC  4E4F                     999          TRAP    #15
000017DE  6000 019C               1000          BRA LSRLregBody
000017E2                          1001          
000017E2                          1002  RSLreg:
000017E2                          1003          
000017E2  43F9 00002CAF           1004          LEA     rslMessage,A1           ;move string for MOVE
000017E8  103C 000E               1005          MOVE.B  #14,D0                  ;set for task to display null terminated 
000017EC                          1006                                ;string with CR, LF
000017EC  4E4F                    1007          TRAP    #15
000017EE  6000 018C               1008          BRA LSRLregBody
000017F2                          1009  
000017F2                          1010       
000017F2                          1011  
000017F2                          1012  ASRLWEA:
000017F2                          1013          
000017F2                          1014  
000017F2                          1015          
000017F2  7000                    1016          MOVEQ.L #0, D0                  ;clear D0
000017F4                          1017          
000017F4                          1018  validASRL:
000017F4                          1019          
000017F4  43F9 0000189E           1020          LEA lsrlEAmasks,A1              ;load the list of masks
000017FA  D3C0                    1021          ADDA.L D0,A1                    ;displace to a specific mask
000017FC  1A11                    1022          MOVE.B (A1),D5                  ;move the mask to D5
000017FE                          1023          
000017FE  0C05 0000               1024          CMPI.B #0,D5                    ;check if the mask is 0
00001802  6700 F898               1025          BEQ falsePositive               ;branch if it is
00001806                          1026          
00001806  1401                    1027          MOVE.B D1,D2                    ;copy instruction to D2
00001808  C405                    1028          AND.B D5,D2                     ;mask D2
0000180A                          1029          
0000180A  43F9 00001898           1030          LEA lsrlEA,A1                   ;load the list of valid modes
00001810  D3C0                    1031          ADDA.L D0,A1                    ;displace to a specific mode
00001812  1811                    1032          MOVE.B (A1),D4                  ;move mode to D4
00001814  B404                    1033          CMP.B D4,D2                     ;compare mode to masked value
00001816  6700 0006               1034          BEQ  asrlweaCheckDirection      ;if its match, its a valid mode and we can procede
0000181A                          1035          
0000181A  5280                    1036          ADDQ.L #1,D0                    ;add one to displacement
0000181C  60D6                    1037          BRA validASRL                   ;check for next mode
0000181E                          1038  
0000181E                          1039  asrlweaCheckDirection:
0000181E                          1040          ;Figure out which direction we are going
0000181E  3401                    1041          MOVE.W D1,D2                    ;copy inst to D2
00001820  E04A                    1042          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
00001822  0202 0001               1043          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
00001826  0C02 0000               1044          CMPI.B #0,D2                    ;compare bit to zero
0000182A  6700 0006               1045          BEQ ASREA                       ;if zero, right
0000182E  6000 0012               1046          BRA ASLEA                       ;else, its left
00001832                          1047  
00001832                          1048  ASREA:
00001832                          1049  
00001832  43F9 00002CBB           1050          LEA     asrMessage,A1           ;move string for MOVE
00001838  103C 000E               1051          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000183C                          1052                                ;string with CR, LF
0000183C  4E4F                    1053          TRAP    #15
0000183E  6000 00C0               1054          BRA lsrlweaBody
00001842                          1055          
00001842                          1056  ASLEA:
00001842                          1057          
00001842  43F9 00002CB7           1058          LEA     aslMessage,A1           ;move string for MOVE
00001848  103C 000E               1059          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000184C                          1060                                ;string with CR, LF
0000184C  4E4F                    1061          TRAP    #15
0000184E  6000 00B0               1062          BRA lsrlweaBody        
00001852                          1063          
00001852                          1064  
00001852                          1065  
00001852                          1066  ASRLREG:
00001852                          1067          
00001852                          1068  
00001852                          1069          
00001852  7000                    1070          MOVEQ.L #0, D0                  ;clear D0
00001854                          1071          
00001854                          1072          ;check valid size field
00001854  3401                    1073          MOVE.W D1,D2                    ;copy inst to D2
00001856  EC4A                    1074          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
00001858  0202 0003               1075          ANDI.B #%00000011,D2            ;mask out rest of byte
0000185C  0C02 0003               1076          CMPI.B #%11,D2                  ;compare to 3
00001860  6700 F83A               1077          BEQ falsePositive               ;invalid size
00001864                          1078  
00001864                          1079          
00001864                          1080          ;Figure out which direction we are going
00001864  3401                    1081          MOVE.W D1,D2                    ;copy inst to D2
00001866  E04A                    1082          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
00001868  0202 0001               1083          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
0000186C  0C02 0000               1084          CMPI.B #0,D2                    ;compare bit to zero
00001870  6700 0006               1085          BEQ ASRreg                      ;if zero, right
00001874  6000 0012               1086          BRA ASLreg                      ;else, its left        
00001878                          1087          
00001878                          1088  ASRreg:
00001878                          1089  
00001878  43F9 00002CBB           1090          LEA     asrMessage,A1           ;move string for MOVE
0000187E  103C 000E               1091          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001882                          1092                                ;string with CR, LF
00001882  4E4F                    1093          TRAP    #15
00001884  6000 00F6               1094          BRA LSRLregBody
00001888                          1095          
00001888                          1096  ASLreg:
00001888                          1097          
00001888  43F9 00002CB7           1098          LEA     aslMessage,A1           ;move string for MOVE
0000188E  103C 000E               1099          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001892                          1100                                ;string with CR, LF
00001892  4E4F                    1101          TRAP    #15
00001894  6000 00E6               1102          BRA LSRLregBody
00001898                          1103  
00001898                          1104  
00001898= 10 18 20 38 39 00       1105  lsrlEA        DC.B %010000,%011000,%100000,%111000,%111001,0
0000189E= 38 38 38 3F 3F 00       1106  lsrlEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0       
000018A4                          1107  
000018A4                          1108  LSRLWEA:
000018A4                          1109          
000018A4                          1110  
000018A4                          1111          
000018A4  7000                    1112          MOVEQ.L #0, D0                  ;clear D0
000018A6                          1113          
000018A6                          1114  validLSRL:
000018A6                          1115          
000018A6  43F8 189E               1116          LEA lsrlEAmasks,A1              ;load the list of masks
000018AA  D3C0                    1117          ADDA.L D0,A1                    ;displace to a specific mask
000018AC  1A11                    1118          MOVE.B (A1),D5                  ;move the mask to D5
000018AE                          1119          
000018AE  0C05 0000               1120          CMPI.B #0,D5                    ;check if the mask is 0
000018B2  6700 F7E8               1121          BEQ falsePositive               ;branch if it is
000018B6                          1122          
000018B6  1401                    1123          MOVE.B D1,D2                    ;copy instruction to D2
000018B8  C405                    1124          AND.B D5,D2                     ;mask D2
000018BA                          1125          
000018BA  43F8 1898               1126          LEA lsrlEA,A1                   ;load the list of valid modes
000018BE  D3C0                    1127          ADDA.L D0,A1                    ;displace to a specific mode
000018C0  1811                    1128          MOVE.B (A1),D4                  ;move mode to D4
000018C2  B404                    1129          CMP.B D4,D2                     ;compare mode to masked value
000018C4  6700 0006               1130          BEQ  lsrlweaCheckDirection      ;if its match, its a valid mode and we can procede
000018C8                          1131          
000018C8  5280                    1132          ADDQ.L #1,D0                    ;add one to displacement
000018CA  60DA                    1133          BRA validLSRL                   ;check for next mode
000018CC                          1134  
000018CC                          1135  lsrlweaCheckDirection:
000018CC                          1136          ;Figure out which direction we are going
000018CC  3401                    1137          MOVE.W D1,D2                    ;copy inst to D2
000018CE  E04A                    1138          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
000018D0  0202 0001               1139          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
000018D4  0C02 0000               1140          CMPI.B #0,D2                    ;compare bit to zero
000018D8  6700 0006               1141          BEQ LSREA                       ;if zero, right
000018DC  6000 0012               1142          BRA LSLEA                       ;else, its left
000018E0                          1143  
000018E0                          1144  LSREA:
000018E0                          1145  
000018E0  43F9 00002CC3           1146          LEA     lsrMessage,A1           ;move string for MOVE
000018E6  103C 000E               1147          MOVE.B  #14,D0                  ;set for task to display null terminated 
000018EA                          1148                                ;string with CR, LF
000018EA  4E4F                    1149          TRAP    #15
000018EC  6000 0012               1150          BRA lsrlweaBody
000018F0                          1151          
000018F0                          1152  LSLEA:
000018F0                          1153          
000018F0  43F9 00002CBF           1154          LEA     lslMessage,A1           ;move string for MOVE
000018F6  103C 000E               1155          MOVE.B  #14,D0                  ;set for task to display null terminated 
000018FA                          1156                                ;string with CR, LF
000018FA  4E4F                    1157          TRAP    #15
000018FC  6000 0002               1158          BRA lsrlweaBody        
00001900                          1159          
00001900                          1160  lsrlweaBody:
00001900                          1161          
00001900                          1162          ;print ' '
00001900  48E7 4000               1163          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001904  123C 0020               1164          MOVE.B #' ',D1                  ;put ascii value of char in D1
00001908  103C 0006               1165          MOVE.B #6,D0                    ;move task 6 into D0
0000190C  4E4F                    1166          TRAP #15                        ;print char
0000190E  4CDF 0002               1167          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001912                          1168          
00001912  3401                    1169          MOVE.W  D1,D2                   ;check mode
00001914  C43C 003F               1170          AND.B   #%00111111,D2
00001918  1A02                    1171          MOVE.B  D2,D5
0000191A  48E7 4000               1172          MOVEM.L D1,-(SP)
0000191E  6100 0EC0               1173          BSR     Get_Effective_Address
00001922  4CDF 0002               1174          MOVEM.L (SP)+,D1
00001926                          1175          
00001926                          1176          
00001926  43F9 00002C8C           1177          LEA     clearLine,A1            ;move string for a CR and LF
0000192C  103C 000E               1178          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001930                          1179                                ;string without CR, LF
00001930  4E4F                    1180          TRAP    #15
00001932                          1181  
00001932  7000                    1182          MOVEQ.L #0,D0
00001934  4E75                    1183          RTS
00001936                          1184  
00001936                          1185  
00001936                          1186  LSRLREG:
00001936                          1187          
00001936                          1188  
00001936                          1189          
00001936  7000                    1190          MOVEQ.L #0, D0                  ;clear D0
00001938                          1191          
00001938                          1192          ;check valid size field
00001938  3401                    1193          MOVE.W D1,D2                    ;copy inst to D2
0000193A  EC4A                    1194          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
0000193C  0202 0003               1195          ANDI.B #%00000011,D2            ;mask out rest of byte
00001940  0C02 0003               1196          CMPI.B #%11,D2                  ;compare to 3
00001944  6700 F756               1197          BEQ falsePositive               ;invalid size
00001948                          1198  
00001948                          1199          
00001948                          1200          ;Figure out which direction we are going
00001948  3401                    1201          MOVE.W D1,D2                    ;copy inst to D2
0000194A  E04A                    1202          LSR.W #8,D2                     ;shift direction bit into most sig bit of first byte
0000194C  0202 0001               1203          ANDI.B #%00000001,D2            ;mask out everything but direction bit in first byte
00001950  0C02 0000               1204          CMPI.B #0,D2                    ;compare bit to zero
00001954  6700 0006               1205          BEQ LSRreg                      ;if zero, right
00001958  6000 0012               1206          BRA LSLreg                      ;else, its left        
0000195C                          1207          
0000195C                          1208  LSRreg:
0000195C                          1209  
0000195C  43F9 00002CC3           1210          LEA     lsrMessage,A1           ;move string for MOVE
00001962  103C 000E               1211          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001966                          1212                                ;string with CR, LF
00001966  4E4F                    1213          TRAP    #15
00001968  6000 0012               1214          BRA LSRLregBody
0000196C                          1215          
0000196C                          1216  LSLreg:
0000196C                          1217          
0000196C  43F9 00002CBF           1218          LEA     lslMessage,A1           ;move string for MOVE
00001972  103C 000E               1219          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001976                          1220                                ;string with CR, LF
00001976  4E4F                    1221          TRAP    #15
00001978  6000 0002               1222          BRA LSRLregBody
0000197C                          1223          
0000197C                          1224  LSRLregBody:
0000197C                          1225          
0000197C  6100 07B8               1226          BSR negSize        
00001980                          1227              
00001980                          1228          ;check i/r
00001980  48E7 4000               1229          MOVEM.L D1,-(SP)
00001984  6100 003C               1230          BSR LSRLcheckIR
00001988  4CDF 0002               1231          MOVEM.L (SP)+,D1
0000198C                          1232          
0000198C                          1233          ;print ','
0000198C  48E7 4000               1234          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001990  123C 002C               1235          MOVE.B #',',D1                  ;put ascii value of char in D1
00001994  103C 0006               1236          MOVE.B #6,D0                    ;move task 6 into D0
00001998  4E4F                    1237          TRAP #15                        ;prin char
0000199A  4CDF 0002               1238          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000199E                          1239          
0000199E  3401                    1240          MOVE.W  D1,D2                   ;check mode
000019A0  C43C 0007               1241          AND.B   #%00000111,D2
000019A4  1A02                    1242          MOVE.B  D2,D5
000019A6  48E7 4000               1243          MOVEM.L D1,-(SP)
000019AA  6100 0E34               1244          BSR     Get_Effective_Address
000019AE  4CDF 0002               1245          MOVEM.L (SP)+,D1
000019B2                          1246          
000019B2                          1247          
000019B2  43F9 00002C8C           1248          LEA     clearLine,A1            ;move string for a CR and LF
000019B8  103C 000E               1249          MOVE.B  #14,D0                  ;set for task to display null terminated 
000019BC                          1250                                ;string without CR, LF
000019BC  4E4F                    1251          TRAP    #15
000019BE                          1252  
000019BE  7000                    1253          MOVEQ.L #0,D0
000019C0  4E75                    1254          RTS
000019C2                          1255  
000019C2                          1256  LSRLcheckIR:
000019C2                          1257  
000019C2  1401                    1258          MOVE.B D1,D2                    ;move inst to D2
000019C4  EA0A                    1259          LSR.B  #5,D2
000019C6  C43C 0001               1260          AND.B  #%00000001,D2
000019CA  0C02 0000               1261          CMPI.B #0,D2
000019CE  6700 0008               1262          BEQ  LSRLcheckI
000019D2  6000 0038               1263          BRA  LSRLcheckR
000019D6                          1264  LSRLcheckIRreturn:
000019D6  4E75                    1265          RTS
000019D8                          1266          
000019D8                          1267  LSRLcheckI:
000019D8                          1268          ;print '#'
000019D8  48E7 4000               1269          MOVEM.L D1,-(SP)                ;save D1 to the stack
000019DC  123C 0023               1270          MOVE.B #'#',D1                  ;put ascii value of '#' in D1
000019E0  103C 0006               1271          MOVE.B #6,D0                    ;move task 6 into D0
000019E4  4E4F                    1272          TRAP #15                        ;prin char
000019E6  4CDF 0002               1273          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000019EA                          1274          
000019EA                          1275          
000019EA                          1276          ;print number
000019EA  48E7 4000               1277          MOVEM.L D1,-(SP)
000019EE  3401                    1278          MOVE.W D1,D2                    ;copy inst to d2
000019F0  E04A                    1279          LSR.W #8,D2                     ;shift data section
000019F2  E20A                    1280          LSR.B #1,D2
000019F4  C43C 0007               1281          AND.B #%00000111,D2             ;mask out rest of data
000019F8  6100 00EC               1282          BSR ZeroToEight                 ;handle zero
000019FC  7200                    1283          MOVEQ.L #0,D1                   ;clear D1
000019FE  1202                    1284          MOVE.B D2,D1                    ;move number to display into D1
00001A00  103C 0003               1285          MOVE.B #3,D0                    ;move task 3 to D0
00001A04  4E4F                    1286          TRAP #15
00001A06  4CDF 0002               1287          MOVEM.L (SP)+,D1
00001A0A  60CA                    1288          BRA LSRLcheckIRreturn
00001A0C                          1289          
00001A0C                          1290  LSRLcheckR:
00001A0C  3401                    1291          MOVE.W D1,D2                    ;copy inst to d2
00001A0E  E04A                    1292          LSR.W #8,D2                     ;shift data section
00001A10  E20A                    1293          LSR.B #1,D2
00001A12  C43C 0007               1294          AND.B #%00000111,D2             ;mask out rest of data
00001A16  1A02                    1295          MOVE.B D2,D5                    ;force Dn
00001A18  48E7 4000               1296          MOVEM.L D1,-(SP)
00001A1C  6100 0DC2               1297          BSR     Get_Effective_Address
00001A20  4CDF 0002               1298          MOVEM.L (SP)+,D1
00001A24  60B0                    1299          BRA LSRLcheckIRreturn
00001A26                          1300          
00001A26= 00 08 10 18 20 38 ...   1301  subqEA        DC.B %000000,%001000,%010000,%011000,%100000,%111000,%111001,0
00001A2E= 38 38 38 38 38 3F ...   1302  subqEAmasks   DC.B %111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001A36                          1303  
00001A36                          1304  SUBQ:
00001A36                          1305          
00001A36                          1306  
00001A36                          1307          
00001A36  7000                    1308          MOVEQ.L #0, D0                  ;clear D0
00001A38                          1309          
00001A38                          1310          ;check valid size field
00001A38  3401                    1311          MOVE.W D1,D2                    ;copy inst to D2
00001A3A  EC4A                    1312          LSR.W  #6,D2                    ;shift size to least sig bit of least sig byte
00001A3C  0202 0003               1313          ANDI.B #%00000011,D2            ;mask out rest of byte
00001A40  0C02 0003               1314          CMPI.B #%11,D2                  ;compare to 3
00001A44  6700 F656               1315          BEQ falsePositive               ;invalid size
00001A48                          1316          
00001A48                          1317  validSubq:
00001A48                          1318          
00001A48  43F8 1A2E               1319          LEA subqEAmasks,A1              ;load the list of masks
00001A4C  D3C0                    1320          ADDA.L D0,A1                    ;displace to a specific mask
00001A4E  1A11                    1321          MOVE.B (A1),D5                  ;move the mask to D5
00001A50                          1322          
00001A50  0C05 0000               1323          CMPI.B #0,D5                    ;check if the mask is 0
00001A54  6700 F646               1324          BEQ falsePositive               ;branch if it is
00001A58                          1325          
00001A58  1401                    1326          MOVE.B D1,D2                    ;copy instruction to D2
00001A5A  C405                    1327          AND.B D5,D2                     ;mask D2
00001A5C                          1328          
00001A5C  43F8 1A26               1329          LEA subqEA,A1                   ;load the list of valid modes
00001A60  D3C0                    1330          ADDA.L D0,A1                    ;displace to a specific mode
00001A62  1811                    1331          MOVE.B (A1),D4                  ;move mode to D4
00001A64  B404                    1332          CMP.B D4,D2                     ;compare mode to masked value
00001A66  6700 0006               1333          BEQ  subqBody                   ;if its match, its a valid mode and we can procede
00001A6A                          1334          
00001A6A  5280                    1335          ADDQ.L #1,D0                    ;add one to displacement
00001A6C  60DA                    1336          BRA validSubq                   ;check for next mode
00001A6E                          1337          
00001A6E                          1338          
00001A6E                          1339  subqBody
00001A6E                          1340  
00001A6E  43F9 00002CC7           1341          LEA     subqMessage,A1          ;move string for MOVE
00001A74  103C 000E               1342          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001A78                          1343                                ;string with CR, LF
00001A78  4E4F                    1344          TRAP    #15
00001A7A                          1345          
00001A7A  6100 06BA               1346          BSR negSize
00001A7E                          1347          
00001A7E                          1348          ;immediate data
00001A7E                          1349          
00001A7E                          1350          ;print '#'
00001A7E  48E7 4000               1351          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001A82  123C 0023               1352          MOVE.B #'#',D1                  ;put ascii value of '#' in D1
00001A86  103C 0006               1353          MOVE.B #6,D0                    ;move task 6 into D0
00001A8A  4E4F                    1354          TRAP #15                        ;prin char
00001A8C  4CDF 0002               1355          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001A90                          1356          
00001A90                          1357          ;print number
00001A90  48E7 4000               1358          MOVEM.L D1,-(SP)
00001A94  3401                    1359          MOVE.W D1,D2                    ;copy inst to d2
00001A96  E04A                    1360          LSR.W #8,D2                     ;shift data section
00001A98  E20A                    1361          LSR.B #1,D2
00001A9A  C43C 0007               1362          AND.B #%00000111,D2             ;mask out rest of data
00001A9E  6100 0046               1363          BSR ZeroToEight                 ;handle zero
00001AA2  7200                    1364          MOVEQ.L #0,D1                   ;clear D1
00001AA4  1202                    1365          MOVE.B D2,D1                    ;move number to display into D1
00001AA6  103C 0003               1366          MOVE.B #3,D0                    ;move task 3 to D0
00001AAA  4E4F                    1367          TRAP #15
00001AAC  4CDF 0002               1368          MOVEM.L (SP)+,D1
00001AB0                          1369          
00001AB0                          1370          ;print ','
00001AB0  48E7 4000               1371          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001AB4  123C 002C               1372          MOVE.B #',',D1                  ;put ascii value of char in D1
00001AB8  103C 0006               1373          MOVE.B #6,D0                    ;move task 6 into D0
00001ABC  4E4F                    1374          TRAP #15                        ;prin char
00001ABE  4CDF 0002               1375          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001AC2                          1376          
00001AC2                          1377          ;Then do EA
00001AC2                          1378          
00001AC2  3401                    1379          MOVE.W  D1,D2                   ;check mode
00001AC4  C43C 003F               1380          AND.B   #%00111111,D2
00001AC8  1A02                    1381          MOVE.B  D2,D5
00001ACA  48E7 4000               1382          MOVEM.L D1,-(SP)
00001ACE  6100 0D10               1383          BSR     Get_Effective_Address
00001AD2  4CDF 0002               1384          MOVEM.L (SP)+,D1
00001AD6                          1385          
00001AD6  43F9 00002C8C           1386          LEA     clearLine,A1            ;move string for a CR and LF
00001ADC  103C 000E               1387          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001AE0                          1388                                ;string without CR, LF
00001AE0  4E4F                    1389          TRAP    #15
00001AE2                          1390  
00001AE2  7000                    1391          MOVEQ.L #0,D0
00001AE4  4E75                    1392          RTS
00001AE6                          1393          
00001AE6                          1394  ZeroToEight:
00001AE6                          1395          
00001AE6  0C02 0000               1396          CMPI.B #0,D2
00001AEA  6700 0004               1397          BEQ toEight
00001AEE                          1398  ZeroToEightReturn:
00001AEE                          1399          
00001AEE  4E75                    1400          RTS
00001AF0                          1401  toEight:
00001AF0                          1402          
00001AF0  5002                    1403          ADDQ.B #8,D2
00001AF2  60FA                    1404          BRA ZeroToEightReturn
00001AF4                          1405  
00001AF4                          1406      
00001AF4                          1407  SUB:
00001AF4                          1408          
00001AF4                          1409  
00001AF4                          1410          
00001AF4  7000                    1411          MOVEQ.L #0, D0                  ;clear D0
00001AF6                          1412          
00001AF6                          1413          ;Figure out if EA is source or destination
00001AF6  3401                    1414          MOVE.W D1,D2                    ;copy inst to D2
00001AF8  EC4A                    1415          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001AFA  0202 0007               1416          ANDI.B #%00000111,D2            ;mask out rest of byte
00001AFE  0C02 0002               1417          CMPI.B #2,D2                    ;compare to 2
00001B02  6F00 0016               1418          BLE validSubSourceEA            ;2 or less is EA is source
00001B06                          1419          
00001B06  0C02 0007               1420          CMPI.B #%111,D2                 ;compare to 7
00001B0A  6700 F590               1421          BEQ falsePositive               ;thats not valid
00001B0E  0C02 0003               1422          CMPI.B #%11,D2                  ;compare to 3
00001B12  6700 F588               1423          BEQ falsePositive               ;also not valid
00001B16  6000 002C               1424          BRA validSubDestEA              ;all thats left is valid EA as Dest 
00001B1A                          1425          
00001B1A                          1426  validSubSourceEA:
00001B1A                          1427          
00001B1A  43F9 0000238D           1428          LEA moveSourceEAmasks,A1        ;load the list of masks
00001B20  D3C0                    1429          ADDA.L D0,A1                    ;displace to a specific mask
00001B22  1A11                    1430          MOVE.B (A1),D5                  ;move the mask to D5
00001B24                          1431          
00001B24  0C05 0000               1432          CMPI.B #0,D5                    ;check if the mask is 0
00001B28  6700 F572               1433          BEQ falsePositive               ;branch if it is
00001B2C                          1434          
00001B2C  1401                    1435          MOVE.B D1,D2                    ;copy instruction to D2
00001B2E  C405                    1436          AND.B D5,D2                     ;mask D2
00001B30                          1437          
00001B30  43F9 00002384           1438          LEA moveSourceEA,A1             ;load the list of valid modes
00001B36  D3C0                    1439          ADDA.L D0,A1                    ;displace to a specific mode
00001B38  1811                    1440          MOVE.B (A1),D4                  ;move mode to D4
00001B3A  B404                    1441          CMP.B D4,D2                     ;compare mode to masked value
00001B3C  6700 0030               1442          BEQ  subSource                  ;if its match, its a valid mode and we can procede
00001B40                          1443          
00001B40  5280                    1444          ADDQ.L #1,D0                    ;add one to displacement
00001B42  60D6                    1445          BRA validSubSourceEA            ;check for next mode
00001B44                          1446          
00001B44                          1447          
00001B44                          1448  validSubDestEA:
00001B44                          1449          
00001B44  43F9 00001CEA           1450          LEA addDestEAmasks,A1           ;load the list of masks
00001B4A  D3C0                    1451          ADDA.L D0,A1                    ;displace to a specific mask
00001B4C  1A11                    1452          MOVE.B (A1),D5                  ;move the mask to D5
00001B4E                          1453          
00001B4E  0C05 0000               1454          CMPI.B #0,D5                    ;check if the mask is 0
00001B52  6700 F548               1455          BEQ falsePositive               ;branch if it is
00001B56                          1456          
00001B56  3401                    1457          MOVE.W D1,D2                    ;copy instruction to D2
00001B58  C405                    1458          AND.B D5,D2                     ;mask D2
00001B5A                          1459          
00001B5A  43F9 00001CE4           1460          LEA addDestEA,A1                ;load the list of valid modes
00001B60  D3C0                    1461          ADDA.L D0,A1                    ;displace to a specific mode
00001B62  1811                    1462          MOVE.B (A1),D4                  ;move mode to D4
00001B64  B404                    1463          CMP.B D4,D2                     ;compare mode to masked value
00001B66  6700 0064               1464          BEQ subDest                     ;if its match, its a valid mode and we can procede
00001B6A                          1465          
00001B6A  5280                    1466          ADDQ.L #1,D0                    ;add one to displacement
00001B6C  60D6                    1467          BRA validSubDestEA              ;check for next mode
00001B6E                          1468          
00001B6E                          1469  subSource
00001B6E                          1470  
00001B6E  43F9 00002CCC           1471          LEA     subMessage,A1           ;move string for MOVE
00001B74  103C 000E               1472          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001B78                          1473                                ;string with CR, LF
00001B78  4E4F                    1474          TRAP    #15
00001B7A                          1475          
00001B7A  6100 05BA               1476          BSR negSize
00001B7E                          1477          
00001B7E                          1478          ;do EA
00001B7E                          1479          
00001B7E  3401                    1480          MOVE.W  D1,D2                   ;check mode
00001B80  C43C 003F               1481          AND.B   #%00111111,D2
00001B84  1A02                    1482          MOVE.B  D2,D5
00001B86  48E7 4000               1483          MOVEM.L D1,-(SP)
00001B8A  6100 0C54               1484          BSR     Get_Effective_Address
00001B8E  4CDF 0002               1485          MOVEM.L (SP)+,D1
00001B92                          1486          
00001B92                          1487          ;print ','
00001B92  48E7 4000               1488          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001B96  123C 002C               1489          MOVE.B #',',D1                  ;put ascii value of char in D1
00001B9A  103C 0006               1490          MOVE.B #6,D0                    ;move task 6 into D0
00001B9E  4E4F                    1491          TRAP #15                        ;prin char
00001BA0  4CDF 0002               1492          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001BA4                          1493          
00001BA4                          1494          ;Then do Dn
00001BA4                          1495          
00001BA4  3401                    1496          MOVE.W  D1,D2
00001BA6  E04A                    1497          LSR.W   #8,D2                   ;move reg into first byte
00001BA8  E20A                    1498          LSR.B   #1,D2                   ;line it up to least sig bit
00001BAA  C43C 0007               1499          AND.B   #%00000111,D2           ;force mode to Dn
00001BAE  1A02                    1500          MOVE.B  D2,D5
00001BB0  48E7 4000               1501          MOVEM.L D1,-(SP)
00001BB4  6100 0C2A               1502          BSR     Get_Effective_Address
00001BB8  4CDF 0002               1503          MOVEM.L (SP)+,D1
00001BBC                          1504          
00001BBC  43F9 00002C8C           1505          LEA     clearLine,A1            ;move string for a CR and LF
00001BC2  103C 000E               1506          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001BC6                          1507          ;string without CR, LF
00001BC6  4E4F                    1508          TRAP    #15
00001BC8                          1509  
00001BC8  7000                    1510          MOVEQ.L #0,D0
00001BCA  4E75                    1511          RTS
00001BCC                          1512  
00001BCC                          1513  subDest
00001BCC                          1514  
00001BCC  43F9 00002CCC           1515          LEA     subMessage,A1           ;move string for MOVE
00001BD2  103C 000E               1516          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001BD6                          1517                                          ;string with CR, LF
00001BD6  4E4F                    1518          TRAP    #15
00001BD8                          1519          
00001BD8  6100 055C               1520          BSR negSize
00001BDC                          1521          
00001BDC                          1522          ;Do Dn
00001BDC                          1523          
00001BDC  3401                    1524          MOVE.W  D1,D2
00001BDE  E04A                    1525          LSR.W   #8,D2                   ;move reg into first byte
00001BE0  E20A                    1526          LSR.B   #1,D2                   ;line it up to least sig bit
00001BE2  C43C 0007               1527          AND.B   #%00000111,D2           ;force mode to Dn
00001BE6  1A02                    1528          MOVE.B  D2,D5
00001BE8  48E7 4000               1529          MOVEM.L D1,-(SP)
00001BEC  6100 0BF2               1530          BSR     Get_Effective_Address
00001BF0  4CDF 0002               1531          MOVEM.L (SP)+,D1
00001BF4                          1532          
00001BF4                          1533          
00001BF4                          1534          ;print ','
00001BF4  48E7 4000               1535          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001BF8  123C 002C               1536          MOVE.B #',',D1                  ;put ascii value of char in D1
00001BFC  103C 0006               1537          MOVE.B #6,D0                    ;move task 6 into D0
00001C00  4E4F                    1538          TRAP #15                        ;prin char
00001C02  4CDF 0002               1539          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001C06                          1540          
00001C06                          1541          ;Then do EA
00001C06                          1542          
00001C06  3401                    1543          MOVE.W  D1,D2                   ;check mode
00001C08  C43C 003F               1544          AND.B   #%00111111,D2
00001C0C  1A02                    1545          MOVE.B  D2,D5
00001C0E  48E7 4000               1546          MOVEM.L D1,-(SP)
00001C12  6100 0BCC               1547          BSR     Get_Effective_Address
00001C16  4CDF 0002               1548          MOVEM.L (SP)+,D1
00001C1A                          1549          
00001C1A                          1550          
00001C1A  43F9 00002C8C           1551          LEA     clearLine,A1            ;move string for a CR and LF
00001C20  103C 000E               1552          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001C24                          1553          ;string without CR, LF
00001C24  4E4F                    1554          TRAP    #15
00001C26                          1555  
00001C26  7000                    1556          MOVEQ.L #0,D0
00001C28  4E75                    1557          RTS
00001C2A                          1558  
00001C2A                          1559  
00001C2A                          1560  ADDA:
00001C2A                          1561          
00001C2A                          1562  
00001C2A                          1563          
00001C2A  7000                    1564          MOVEQ.L #0, D0                  ;clear D0
00001C2C                          1565          
00001C2C                          1566          ;check opmode field
00001C2C  3401                    1567          MOVE.W D1,D2                    ;copy inst to D2
00001C2E  EC4A                    1568          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001C30  0202 0007               1569          ANDI.B #%00000111,D2            ;mask out rest of byte
00001C34  0C02 0007               1570          CMPI.B #%111,D2                 ;compare to 7
00001C38  6700 000E               1571          BEQ validAdda                   ;thats valid
00001C3C  0C02 0003               1572          CMPI.B #%11,D2                  ;compare to 3
00001C40  6700 0006               1573          BEQ validAdda                   ;also valid
00001C44  6000 F456               1574          BRA falsePositive               ;all thats left is invalid 
00001C48                          1575          
00001C48                          1576  validAdda:
00001C48                          1577          
00001C48  43F9 0000238D           1578          LEA moveSourceEAmasks,A1        ;load the list of masks
00001C4E  D3C0                    1579          ADDA.L D0,A1                    ;displace to a specific mask
00001C50  1A11                    1580          MOVE.B (A1),D5                  ;move the mask to D5
00001C52                          1581          
00001C52  0C05 0000               1582          CMPI.B #0,D5                    ;check if the mask is 0
00001C56  6700 F444               1583          BEQ falsePositive               ;branch if it is
00001C5A                          1584          
00001C5A  1401                    1585          MOVE.B D1,D2                    ;copy instruction to D2
00001C5C  C405                    1586          AND.B D5,D2                     ;mask D2
00001C5E                          1587          
00001C5E  43F9 00002384           1588          LEA moveSourceEA,A1             ;load the list of valid modes
00001C64  D3C0                    1589          ADDA.L D0,A1                    ;displace to a specific mode
00001C66  1811                    1590          MOVE.B (A1),D4                  ;move mode to D4
00001C68  B404                    1591          CMP.B D4,D2                     ;compare mode to masked value
00001C6A  6700 0006               1592          BEQ  addaBody                   ;if its match, its a valid mode and we can procede
00001C6E                          1593          
00001C6E  5280                    1594          ADDQ.L #1,D0                    ;add one to displacement
00001C70  60D6                    1595          BRA validAdda                   ;check for next mode
00001C72                          1596          
00001C72                          1597          
00001C72                          1598  addaBody
00001C72                          1599  
00001C72  43F9 00002CD0           1600          LEA     addaMessage,A1          ;move string for MOVE
00001C78  103C 000E               1601          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001C7C                          1602          ;string with CR, LF
00001C7C  4E4F                    1603          TRAP    #15
00001C7E                          1604          
00001C7E                          1605          ;size
00001C7E  48E7 4000               1606          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001C82                          1607          ;make it look like NEG's size
00001C82  E449                    1608          LSR.W #2,D1                     ;shift opmode bits over to use them as size
00001C84  C23C 007F               1609          AND.B #%01111111,D1             ;clear bit next to size
00001C88  0641 0040               1610          ADDI.W #%01000000,D1            ;add 1 to size to make it look like a word or long
00001C8C  6100 04A8               1611          BSR negSize
00001C90  4CDF 0002               1612          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001C94                          1613          
00001C94                          1614          ;do EA
00001C94                          1615          
00001C94  3401                    1616          MOVE.W  D1,D2                   ;check mode
00001C96  C43C 003F               1617          AND.B   #%00111111,D2
00001C9A  1A02                    1618          MOVE.B  D2,D5
00001C9C  48E7 4000               1619          MOVEM.L D1,-(SP)
00001CA0  6100 0B3E               1620          BSR     Get_Effective_Address
00001CA4  4CDF 0002               1621          MOVEM.L (SP)+,D1
00001CA8                          1622          
00001CA8                          1623          ;print ','
00001CA8  48E7 4000               1624          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001CAC  123C 002C               1625          MOVE.B #',',D1                  ;put ascii value of char in D1
00001CB0  103C 0006               1626          MOVE.B #6,D0                    ;move task 6 into D0
00001CB4  4E4F                    1627          TRAP #15                        ;prin char
00001CB6  4CDF 0002               1628          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001CBA                          1629          
00001CBA                          1630          ;Then do Dn
00001CBA                          1631          
00001CBA  3401                    1632          MOVE.W  D1,D2
00001CBC  E04A                    1633          LSR.W   #8,D2                   ;move reg into first byte
00001CBE  E20A                    1634          LSR.B   #1,D2                   ;line it up to least sig bit
00001CC0  C43C 0007               1635          AND.B   #%00000111,D2           ;force mode to An
00001CC4  5002                    1636          ADDI.B  #%00001000,D2 
00001CC6  1A02                    1637          MOVE.B  D2,D5
00001CC8  48E7 4000               1638          MOVEM.L D1,-(SP)
00001CCC  6100 0B12               1639          BSR     Get_Effective_Address
00001CD0  4CDF 0002               1640          MOVEM.L (SP)+,D1
00001CD4                          1641          
00001CD4  43F9 00002C8C           1642          LEA     clearLine,A1            ;move string for a CR and LF
00001CDA  103C 000E               1643          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001CDE                          1644          ;string without CR, LF
00001CDE  4E4F                    1645          TRAP    #15
00001CE0                          1646  
00001CE0  7000                    1647          MOVEQ.L #0,D0
00001CE2  4E75                    1648          RTS
00001CE4                          1649  
00001CE4                          1650  
00001CE4                          1651      
00001CE4= 10 18 20 38 39 00       1652  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
00001CEA= 38 38 38 3F 3F 00       1653  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
00001CF0                          1654  
00001CF0                          1655  ADD:
00001CF0                          1656          
00001CF0                          1657  
00001CF0                          1658          
00001CF0  7000                    1659          MOVEQ.L #0, D0                  ;clear D0
00001CF2                          1660          
00001CF2                          1661          ;Figure out if EA is source or destination
00001CF2  3401                    1662          MOVE.W D1,D2                    ;copy inst to D2
00001CF4  EC4A                    1663          LSR.W  #6,D2                    ;shift opmode to least sig bit of least sig byte
00001CF6  0202 0007               1664          ANDI.B #%00000111,D2            ;mask out rest of byte
00001CFA  0C02 0002               1665          CMPI.B #2,D2                    ;compare to 2
00001CFE  6F00 0016               1666          BLE validAddSourceEA            ;2 or less is EA is source
00001D02                          1667          
00001D02  0C02 0007               1668          CMPI.B #%111,D2                 ;compare to 7
00001D06  6700 F394               1669          BEQ falsePositive               ;thats not valid
00001D0A  0C02 0003               1670          CMPI.B #%11,D2                  ;compare to 3
00001D0E  6700 F38C               1671          BEQ falsePositive               ;also not valid
00001D12  6000 002C               1672          BRA validAddDestEA              ;all thats left is valid EA as Dest 
00001D16                          1673          
00001D16                          1674  validAddSourceEA:
00001D16                          1675          
00001D16  43F9 0000238D           1676          LEA moveSourceEAmasks,A1        ;load the list of masks
00001D1C  D3C0                    1677          ADDA.L D0,A1                    ;displace to a specific mask
00001D1E  1A11                    1678          MOVE.B (A1),D5                  ;move the mask to D5
00001D20                          1679          
00001D20  0C05 0000               1680          CMPI.B #0,D5                    ;check if the mask is 0
00001D24  6700 F376               1681          BEQ falsePositive               ;branch if it is
00001D28                          1682          
00001D28  1401                    1683          MOVE.B D1,D2                    ;copy instruction to D2
00001D2A  C405                    1684          AND.B D5,D2                     ;mask D2
00001D2C                          1685          
00001D2C  43F9 00002384           1686          LEA moveSourceEA,A1             ;load the list of valid modes
00001D32  D3C0                    1687          ADDA.L D0,A1                    ;displace to a specific mode
00001D34  1811                    1688          MOVE.B (A1),D4                  ;move mode to D4
00001D36  B404                    1689          CMP.B D4,D2                     ;compare mode to masked value
00001D38  6700 002C               1690          BEQ  addSource                  ;if its match, its a valid mode and we can procede
00001D3C                          1691          
00001D3C  5280                    1692          ADDQ.L #1,D0                    ;add one to displacement
00001D3E  60D6                    1693          BRA validAddSourceEA            ;check for next mode
00001D40                          1694          
00001D40                          1695          
00001D40                          1696  validAddDestEA:
00001D40                          1697          
00001D40  43F8 1CEA               1698          LEA addDestEAmasks,A1           ;load the list of masks
00001D44  D3C0                    1699          ADDA.L D0,A1                    ;displace to a specific mask
00001D46  1A11                    1700          MOVE.B (A1),D5                  ;move the mask to D5
00001D48                          1701          
00001D48  0C05 0000               1702          CMPI.B #0,D5                    ;check if the mask is 0
00001D4C  6700 F34E               1703          BEQ falsePositive               ;branch if it is
00001D50                          1704          
00001D50  3401                    1705          MOVE.W D1,D2                    ;copy instruction to D2
00001D52  C405                    1706          AND.B D5,D2                     ;mask D2
00001D54                          1707          
00001D54  43F8 1CE4               1708          LEA addDestEA,A1                ;load the list of valid modes
00001D58  D3C0                    1709          ADDA.L D0,A1                    ;displace to a specific mode
00001D5A  1811                    1710          MOVE.B (A1),D4                  ;move mode to D4
00001D5C  B404                    1711          CMP.B D4,D2                     ;compare mode to masked value
00001D5E  6700 0064               1712          BEQ addDest                     ;if its match, its a valid mode and we can procede
00001D62                          1713          
00001D62  5280                    1714          ADDQ.L #1,D0                    ;add one to displacement
00001D64  60DA                    1715          BRA validAddDestEA              ;check for next mode
00001D66                          1716          
00001D66                          1717  addSource
00001D66                          1718  
00001D66  43F9 00002CD5           1719          LEA     addMessage,A1           ;move string for MOVE
00001D6C  103C 000E               1720          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001D70                          1721          ;string with CR, LF
00001D70  4E4F                    1722          TRAP    #15
00001D72                          1723          
00001D72  6100 03C2               1724          BSR negSize
00001D76                          1725          
00001D76                          1726          ;do EA
00001D76                          1727          
00001D76  3401                    1728          MOVE.W  D1,D2                   ;check mode
00001D78  C43C 003F               1729          AND.B   #%00111111,D2
00001D7C  1A02                    1730          MOVE.B  D2,D5
00001D7E  48E7 4000               1731          MOVEM.L D1,-(SP)
00001D82  6100 0A5C               1732          BSR     Get_Effective_Address
00001D86  4CDF 0002               1733          MOVEM.L (SP)+,D1
00001D8A                          1734          
00001D8A                          1735          ;print ','
00001D8A  48E7 4000               1736          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001D8E  123C 002C               1737          MOVE.B #',',D1                  ;put ascii value of char in D1
00001D92  103C 0006               1738          MOVE.B #6,D0                    ;move task 6 into D0
00001D96  4E4F                    1739          TRAP #15                        ;prin char
00001D98  4CDF 0002               1740          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001D9C                          1741          
00001D9C                          1742          ;Then do Dn
00001D9C                          1743          
00001D9C  3401                    1744          MOVE.W  D1,D2
00001D9E  E04A                    1745          LSR.W   #8,D2                   ;move reg into first byte
00001DA0  E20A                    1746          LSR.B   #1,D2                   ;line it up to least sig bit
00001DA2  C43C 0007               1747          AND.B   #%00000111,D2           ;force mode to Dn
00001DA6  1A02                    1748          MOVE.B  D2,D5
00001DA8  48E7 4000               1749          MOVEM.L D1,-(SP)
00001DAC  6100 0A32               1750          BSR     Get_Effective_Address
00001DB0  4CDF 0002               1751          MOVEM.L (SP)+,D1
00001DB4                          1752          
00001DB4  43F9 00002C8C           1753          LEA     clearLine,A1            ;move string for a CR and LF
00001DBA  103C 000E               1754          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001DBE                          1755                                ;string without CR, LF
00001DBE  4E4F                    1756          TRAP    #15
00001DC0                          1757  
00001DC0  7000                    1758          MOVEQ.L #0,D0
00001DC2  4E75                    1759          RTS
00001DC4                          1760  
00001DC4                          1761  addDest
00001DC4                          1762  
00001DC4  43F9 00002CD5           1763          LEA     addMessage,A1           ;move string for MOVE
00001DCA  103C 000E               1764          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001DCE                          1765                                          ;string with CR, LF
00001DCE  4E4F                    1766          TRAP    #15
00001DD0                          1767          
00001DD0  6100 0364               1768          BSR negSize
00001DD4                          1769          
00001DD4                          1770          ;Do Dn
00001DD4                          1771          
00001DD4  3401                    1772          MOVE.W  D1,D2
00001DD6  E04A                    1773          LSR.W   #8,D2                   ;move reg into first byte
00001DD8  E20A                    1774          LSR.B   #1,D2                   ;line it up to least sig bit
00001DDA  C43C 0007               1775          AND.B   #%00000111,D2           ;force mode to Dn
00001DDE  1A02                    1776          MOVE.B  D2,D5
00001DE0  48E7 4000               1777          MOVEM.L D1,-(SP)
00001DE4  6100 09FA               1778          BSR     Get_Effective_Address
00001DE8  4CDF 0002               1779          MOVEM.L (SP)+,D1
00001DEC                          1780          
00001DEC                          1781          
00001DEC                          1782          ;print ','
00001DEC  48E7 4000               1783          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001DF0  123C 002C               1784          MOVE.B #',',D1                  ;put ascii value of char in D1
00001DF4  103C 0006               1785          MOVE.B #6,D0                    ;move task 6 into D0
00001DF8  4E4F                    1786          TRAP #15                        ;prin char
00001DFA  4CDF 0002               1787          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001DFE                          1788          
00001DFE                          1789          ;Then do EA
00001DFE                          1790          
00001DFE  3401                    1791          MOVE.W  D1,D2                   ;check mode
00001E00  C43C 003F               1792          AND.B   #%00111111,D2
00001E04  1A02                    1793          MOVE.B  D2,D5
00001E06  48E7 4000               1794          MOVEM.L D1,-(SP)
00001E0A  6100 09D4               1795          BSR     Get_Effective_Address
00001E0E  4CDF 0002               1796          MOVEM.L (SP)+,D1
00001E12                          1797          
00001E12                          1798          
00001E12  43F9 00002C8C           1799          LEA     clearLine,A1            ;move string for a CR and LF
00001E18  103C 000E               1800          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001E1C                          1801                                          ;string without CR, LF
00001E1C  4E4F                    1802          TRAP    #15
00001E1E                          1803  
00001E1E  7000                    1804          MOVEQ.L #0,D0
00001E20  4E75                    1805          RTS
00001E22                          1806  
00001E22                          1807  
00001E22= 10 20 38 39 00          1808  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
00001E27= 38 38 3F 3F 00          1809  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
00001E2C                          1810  
00001E2C= 10 18 38 39 00          1811  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
00001E31= 38 38 3F 3F 00          1812  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
00001E36                          1813  
00001E36                          1814  MOVEM:
00001E36                          1815          
00001E36                          1816  
00001E36                          1817          
00001E36  7000                    1818          MOVEQ.L #0, D0                  ;clear D0
00001E38                          1819          
00001E38                          1820          ;Figure out which direction we are going
00001E38  3401                    1821          MOVE.W D1,D2                    ;copy inst to D2
00001E3A  E64A                    1822          LSR.W #3,D2                     ;shift direction bit into most sig bit of first byte
00001E3C  0202 0080               1823          ANDI.B #%10000000,D2            ;mask out everything but direction bit in first byte
00001E40  0C02 0000               1824          CMPI.B #0,D2                    ;compare bit to zero
00001E44  6700 0006               1825          BEQ validRegToMem               ;if zero, reg to mem
00001E48  6000 0028               1826          BRA validMemToReg               ;else, its mem to reg
00001E4C                          1827          
00001E4C                          1828  validRegToMem:
00001E4C                          1829          
00001E4C  43F8 1E27               1830          LEA movemRegToMemEAmasks,A1     ;load the list of masks
00001E50  D3C0                    1831          ADDA.L D0,A1                    ;displace to a specific mask
00001E52  1A11                    1832          MOVE.B (A1),D5                  ;move the mask to D5
00001E54                          1833          
00001E54  0C05 0000               1834          CMPI.B #0,D5                    ;check if the mask is 0
00001E58  6700 F242               1835          BEQ falsePositive               ;branch if it is
00001E5C                          1836          
00001E5C  1401                    1837          MOVE.B D1,D2                    ;copy instruction to D2
00001E5E  C405                    1838          AND.B D5,D2                     ;mask D2
00001E60                          1839          
00001E60  43F8 1E22               1840          LEA movemRegToMemEA,A1          ;load the list of valid modes
00001E64  D3C0                    1841          ADDA.L D0,A1                    ;displace to a specific mode
00001E66  1811                    1842          MOVE.B (A1),D4                  ;move mode to D4
00001E68  B404                    1843          CMP.B D4,D2                     ;compare mode to masked value
00001E6A  6700 002C               1844          BEQ  movemPre                   ;if its match, its a valid mode and we can procede
00001E6E                          1845          
00001E6E  5280                    1846          ADDQ.L #1,D0                    ;add one to displacement
00001E70  60DA                    1847          BRA validRegToMem               ;check for next mode
00001E72                          1848          
00001E72                          1849          
00001E72                          1850  validMemToReg:
00001E72                          1851          
00001E72  43F8 1E31               1852          LEA movemMemToRegEAmasks,A1     ;load the list of masks
00001E76  D3C0                    1853          ADDA.L D0,A1                    ;displace to a specific mask
00001E78  1A11                    1854          MOVE.B (A1),D5                  ;move the mask to D5
00001E7A                          1855          
00001E7A  0C05 0000               1856          CMPI.B #0,D5                    ;check if the mask is 0
00001E7E  6700 F21C               1857          BEQ falsePositive               ;branch if it is
00001E82                          1858          
00001E82  3401                    1859          MOVE.W D1,D2                    ;copy instruction to D2
00001E84  C405                    1860          AND.B D5,D2                     ;mask D2
00001E86                          1861          
00001E86  43F8 1E2C               1862          LEA movemMemToRegEA,A1          ;load the list of valid modes
00001E8A  D3C0                    1863          ADDA.L D0,A1                    ;displace to a specific mode
00001E8C  1811                    1864          MOVE.B (A1),D4                  ;move mode to D4
00001E8E  B404                    1865          CMP.B D4,D2                     ;compare mode to masked value
00001E90  6700 0062               1866          BEQ movemPost                   ;if its match, its a valid mode and we can procede
00001E94                          1867          
00001E94  5280                    1868          ADDQ.L #1,D0                    ;add one to displacement
00001E96  60DA                    1869          BRA validMemToReg               ;check for next mode
00001E98                          1870  
00001E98                          1871  movemPre:
00001E98                          1872  
00001E98  43F9 00002CD9           1873          LEA     movemMessage,A1         ;move string for MOVE
00001E9E  103C 000E               1874          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001EA2                          1875                                          ;string with CR, LF
00001EA2  4E4F                    1876          TRAP    #15
00001EA4                          1877          
00001EA4                          1878          ;size
00001EA4  48E7 4000               1879          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001EA8                          1880          ;make it look like NEG's size
00001EA8  C23C 007F               1881          AND.B #%01111111,D1             ;clear bit next to size
00001EAC  0641 0040               1882          ADDI.W #%01000000,D1            ;add 1 to size to make it look like a word or long
00001EB0  6100 0284               1883          BSR negSize
00001EB4  4CDF 0002               1884          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001EB8                          1885          
00001EB8                          1886          
00001EB8                          1887          ;show list
00001EB8                          1888          
00001EB8  6100 00E6               1889          BSR outputPreIncrement     
00001EBC                          1890          
00001EBC  5487                    1891          ADDQ.L #word,D7                 ;read past the register list mask(word) following
00001EBE                          1892                                          ;the instruction
00001EBE                          1893          
00001EBE                          1894          ;print ','
00001EBE  48E7 4000               1895          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001EC2  123C 002C               1896          MOVE.B #',',D1                  ;put ascii value of char in D1
00001EC6  103C 0006               1897          MOVE.B #6,D0                    ;move task 6 into D0
00001ECA  4E4F                    1898          TRAP #15                        ;prin char
00001ECC  4CDF 0002               1899          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001ED0                          1900          
00001ED0  3401                    1901          MOVE.W  D1,D2                   ;check mode
00001ED2  C43C 003F               1902          AND.B   #%00111111,D2
00001ED6  1A02                    1903          MOVE.B  D2,D5
00001ED8  48E7 4000               1904          MOVEM.L D1,-(SP)
00001EDC  6100 0902               1905          BSR     Get_Effective_Address
00001EE0  4CDF 0002               1906          MOVEM.L (SP)+,D1
00001EE4                          1907          
00001EE4                          1908          
00001EE4  43F9 00002C8C           1909          LEA     clearLine,A1            ;move string for a CR and LF
00001EEA  103C 000E               1910          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001EEE                          1911                                          ;string without CR, LF
00001EEE  4E4F                    1912          TRAP    #15
00001EF0                          1913  
00001EF0  7000                    1914          MOVEQ.L #0,D0
00001EF2  4E75                    1915          RTS
00001EF4                          1916          
00001EF4                          1917  movemPost:
00001EF4                          1918  
00001EF4  43F9 00002CD9           1919          LEA     movemMessage,A1         ;move string for MOVE
00001EFA  103C 000E               1920          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001EFE                          1921                                          ;string with CR, LF
00001EFE  4E4F                    1922          TRAP    #15
00001F00                          1923          
00001F00                          1924          ;size
00001F00  48E7 4000               1925          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001F04                          1926          ;make it look like NEG's size
00001F04  C23C 007F               1927          AND.B #%01111111,D1             ;clear bit next to size
00001F08  0641 0040               1928          ADDI.W #%01000000,D1            ;add 1 to size to make it look like a word or long
00001F0C  6100 0228               1929          BSR negSize
00001F10  4CDF 0002               1930          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001F14                          1931  
00001F14  3401                    1932          MOVE.W  D1,D2                   ;check mode
00001F16  C43C 003F               1933          AND.B   #%00111111,D2
00001F1A  1A02                    1934          MOVE.B  D2,D5
00001F1C  48E7 4000               1935          MOVEM.L D1,-(SP)
00001F20  6100 08BE               1936          BSR     Get_Effective_Address
00001F24  4CDF 0002               1937          MOVEM.L (SP)+,D1
00001F28                          1938          
00001F28                          1939          
00001F28                          1940          ;print ','
00001F28  48E7 4000               1941          MOVEM.L D1,-(SP)                ;save D1 to the stack
00001F2C  123C 002C               1942          MOVE.B #',',D1                  ;put ascii value of char in D1
00001F30  103C 0006               1943          MOVE.B #6,D0                    ;move task 6 into D0
00001F34  4E4F                    1944          TRAP #15                        ;prin char
00001F36  4CDF 0002               1945          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00001F3A                          1946          
00001F3A                          1947  
00001F3A                          1948          
00001F3A                          1949          ;show list
00001F3A  6100 0102               1950          BSR outputPostIncrement        
00001F3E                          1951          
00001F3E  5487                    1952          ADDQ.L #word,D7                 ;read past the register list mask(word) following
00001F40                          1953                                          ;the instruction
00001F40                          1954          
00001F40  43F9 00002C8C           1955          LEA     clearLine,A1            ;move string for a CR and LF
00001F46  103C 000E               1956          MOVE.B  #14,D0                  ;set for task to display null terminated 
00001F4A                          1957                                          ;string without CR, LF
00001F4A  4E4F                    1958          TRAP    #15
00001F4C                          1959  
00001F4C  7000                    1960          MOVEQ.L #0,D0
00001F4E  4E75                    1961          RTS
00001F50                          1962  
00001F50= 00000000 00000000 ...   1963  movemRegListBuffer DC.L 0,0,0,0,0,0,0,0,0,0,0,0 
00001F80                          1964                                          ;max of 16 regs @ 2 bytes each, 
00001F80                          1965                                          ;15 possible '/' @ a byte
00001F80                          1966                                          ;byte for null terminator
00001F80                          1967                                          ; 48 bytes = 12 longs 
00001F80                          1968                              
00001F80= 41 37 41 36 41 35 ...   1969  movemPostRegList DC.B 'A7','A6','A5','A4','A3','A2','A1','A0','D7','D6','D5','D4','D3','D2','D1','D0'
00001FA0                          1970  movemPreRegList ;should be location after PostList
00001FA0                          1971          
00001FA0                          1972  outputPreincrement:
00001FA0  548B                    1973             ADDQ.L #word,A3
00001FA2  3413                    1974          MOVE.W (A3),D2
00001FA4  7600                    1975          MOVEQ.L #0,D3
00001FA6  47F8 1F50               1976          LEA movemRegListBuffer,A3
00001FAA  49F8 1FA0               1977          LEA movemPreRegList,A4        
00001FAE  558C                    1978          SUBQ.L #word,A4
00001FB0                          1979          
00001FB0  6100 00E8               1980          BSR checkPreRegAdd              ;1
00001FB4                          1981          
00001FB4  558C                    1982          SUBQ.L #word,A4
00001FB6                          1983          
00001FB6  6100 00E2               1984          BSR checkPreRegAdd              ;2
00001FBA  558C                    1985          SUBQ.L #word,A4
00001FBC  6100 00DC               1986          BSR checkPreRegAdd              ;3
00001FC0  558C                    1987          SUBQ.L #word,A4
00001FC2  6100 00D6               1988          BSR checkPreRegAdd              ;4
00001FC6  558C                    1989          SUBQ.L #word,A4
00001FC8  6100 00D0               1990          BSR checkPreRegAdd              ;5
00001FCC  558C                    1991          SUBQ.L #word,A4
00001FCE  6100 00CA               1992          BSR checkPreRegAdd              ;6
00001FD2  558C                    1993          SUBQ.L #word,A4
00001FD4  6100 00C4               1994          BSR checkPreRegAdd              ;7
00001FD8  558C                    1995          SUBQ.L #word,A4
00001FDA  6100 00BE               1996          BSR checkPreRegAdd              ;8
00001FDE  558C                    1997          SUBQ.L #word,A4
00001FE0  6100 00B8               1998          BSR checkPreRegAdd              ;9
00001FE4  558C                    1999          SUBQ.L #word,A4
00001FE6  6100 00B2               2000          BSR checkPreRegAdd              ;10
00001FEA  558C                    2001          SUBQ.L #word,A4
00001FEC  6100 00AC               2002          BSR checkPreRegAdd              ;11
00001FF0  558C                    2003          SUBQ.L #word,A4
00001FF2  6100 00A6               2004          BSR checkPreRegAdd              ;12
00001FF6  558C                    2005          SUBQ.L #word,A4
00001FF8  6100 00A0               2006          BSR checkPreRegAdd              ;13
00001FFC  558C                    2007          SUBQ.L #word,A4
00001FFE  6100 009A               2008          BSR checkPreRegAdd              ;14
00002002  558C                    2009          SUBQ.L #word,A4
00002004  6100 0094               2010          BSR checkPreRegAdd              ;15
00002008  558C                    2011          SUBQ.L #word,A4
0000200A  6100 008E               2012          BSR checkPreRegAdd              ;16
0000200E                          2013          
0000200E  16BC 0000               2014          MOVE.B #0,(A3)
00002012  43F8 1F50               2015          LEA     movemRegListBuffer,A1   ;move string for MOVE
00002016  103C 000E               2016          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000201A                          2017                                          ;string without CR, LF
0000201A  4E4F                    2018          TRAP    #15 
0000201C                          2019          
0000201C  4E75                    2020          RTS
0000201E                          2021          
0000201E                          2022  checkPostRegAdd:
0000201E  E342                    2023          ASL.W #1,D2
00002020  6500 0004               2024          BCS PostRegAdd
00002024                          2025  addPostRegDone:
00002024  4E75                    2026          RTS
00002026                          2027          
00002026                          2028  PostRegAdd:
00002026  4BF8 1F50               2029          LEA movemRegListBuffer,A5
0000202A  BBCB                    2030          CMP.L A3,A5
0000202C  6600 000A               2031          BNE postAddBackslash
00002030                          2032  PostRegAddDone:
00002030  16DC                    2033          MOVE.B (A4)+,(A3)+
00002032  16D4                    2034          MOVE.B (A4),(A3)+
00002034  538C                    2035          SUBQ.L #byte,A4
00002036  60EC                    2036          BRA addPostRegDone
00002038                          2037          
00002038                          2038  postAddBackslash:
00002038  16FC 002F               2039          MOVE.B #'/',(A3)+
0000203C  60F2                    2040          BRA PostRegAddDone
0000203E                          2041          
0000203E                          2042  
0000203E                          2043  outputPostincrement:
0000203E  548B                    2044          ADDQ.L #word,A3
00002040  3413                    2045          MOVE.W (A3),D2
00002042  7600                    2046          MOVEQ.L #0,D3
00002044  47F8 1F50               2047          LEA movemRegListBuffer,A3
00002048  49F8 1F80               2048          LEA movemPostRegList,A4
0000204C                          2049          
0000204C  61D0                    2050          BSR checkPostRegAdd             ;1
0000204E  548C                    2051          ADDQ.L #word,A4
00002050  61CC                    2052          BSR checkPostRegAdd             ;2
00002052  548C                    2053          ADDQ.L #word,A4
00002054  61C8                    2054          BSR checkPostRegAdd             ;3
00002056  548C                    2055          ADDQ.L #word,A4
00002058  61C4                    2056          BSR checkPostRegAdd             ;4
0000205A  548C                    2057          ADDQ.L #word,A4
0000205C  61C0                    2058          BSR checkPostRegAdd             ;5
0000205E  548C                    2059          ADDQ.L #word,A4
00002060  61BC                    2060          BSR checkPostRegAdd             ;6
00002062  548C                    2061          ADDQ.L #word,A4
00002064  61B8                    2062          BSR checkPostRegAdd             ;7
00002066  548C                    2063          ADDQ.L #word,A4
00002068  61B4                    2064          BSR checkPostRegAdd             ;8
0000206A  548C                    2065          ADDQ.L #word,A4
0000206C  61B0                    2066          BSR checkPostRegAdd             ;9
0000206E  548C                    2067          ADDQ.L #word,A4
00002070  61AC                    2068          BSR checkPostRegAdd             ;10
00002072  548C                    2069          ADDQ.L #word,A4
00002074  61A8                    2070          BSR checkPostRegAdd             ;11
00002076  548C                    2071          ADDQ.L #word,A4
00002078  61A4                    2072          BSR checkPostRegAdd             ;12
0000207A  548C                    2073          ADDQ.L #word,A4
0000207C  61A0                    2074          BSR checkPostRegAdd             ;13
0000207E  548C                    2075          ADDQ.L #word,A4
00002080  619C                    2076          BSR checkPostRegAdd             ;14
00002082  548C                    2077          ADDQ.L #word,A4
00002084  6198                    2078          BSR checkPostRegAdd             ;15
00002086  548C                    2079          ADDQ.L #word,A4
00002088  6194                    2080          BSR checkPostRegAdd             ;16
0000208A                          2081          
0000208A  16BC 0000               2082          MOVE.B #0,(A3)
0000208E  43F8 1F50               2083          LEA     movemRegListBuffer,A1   ;move string for MOVE
00002092  103C 000E               2084          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002096                          2085                               ;string without CR, LF
00002096  4E4F                    2086          TRAP    #15 
00002098                          2087          
00002098  4E75                    2088          RTS
0000209A                          2089          
0000209A                          2090  checkPreRegAdd:
0000209A  E342                    2091          ASL.W #1,D2
0000209C  6500 0004               2092          BCS PreRegAdd
000020A0                          2093  addPreRegDone:
000020A0  4E75                    2094          RTS
000020A2                          2095          
000020A2                          2096  PreRegAdd:
000020A2  4BF8 1F50               2097          LEA movemRegListBuffer,A5
000020A6  BBCB                    2098          CMP.L A3,A5
000020A8  6600 000A               2099          BNE preAddBackslash
000020AC                          2100  PreRegAddDone:
000020AC  16DC                    2101          MOVE.B (A4)+,(A3)+
000020AE  16D4                    2102          MOVE.B (A4),(A3)+
000020B0  538C                    2103          SUBQ.L #byte,A4
000020B2  60EC                    2104          BRA addPreRegDone
000020B4                          2105          
000020B4                          2106  preAddBackslash:
000020B4  16FC 002F               2107          MOVE.B #'/',(A3)+
000020B8  6000 FF76               2108          BRA PostRegAddDone
000020BC                          2109  
000020BC                          2110      
000020BC= 00 10 18 20 28 38 ...   2111  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
000020C4= 38 38 38 38 38 3F ...   2112  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
000020CC                          2113     
000020CC                          2114  NEG:            
000020CC                          2115       
000020CC  7000                    2116          MOVEQ.L #0, D0                  ;clear D0
000020CE                          2117          
000020CE                          2118  validNegModes:
000020CE                          2119          
000020CE  43F8 20C4               2120          LEA NegEAmasks,A1               ;load the list of masks
000020D2  D3C0                    2121          ADDA.L D0,A1                    ;displace to a specific mask
000020D4  1A11                    2122          MOVE.B (A1),D5                  ;move the mask to D5
000020D6                          2123          
000020D6  0C05 0000               2124          CMPI.B #0,D5                    ;check if the mask is 0
000020DA  6700 EFC0               2125          BEQ falsePositive               ;branch if it is
000020DE                          2126          
000020DE  1401                    2127          MOVE.B D1,D2                    ;copy instruction to D2
000020E0  C405                    2128          AND.B D5,D2                     ;mask D2
000020E2  43F8 20BC               2129          LEA NegEA,A1                    ;load the list of valid modes
000020E6  D3C0                    2130          ADDA.L D0,A1                    ;displace to a specific mode
000020E8  1811                    2131          MOVE.B (A1),D4                  ;move mode to D4
000020EA  B404                    2132          CMP.B D4,D2                     ;compare mode to masked value
000020EC  6700 0006               2133          BEQ NegBody                     ;if its match, its a valid mode and we can procede
000020F0                          2134          
000020F0  5280                    2135          ADDQ.L #1,D0                    ;add one to displacement
000020F2  60DA                    2136          BRA validNegModes               ;check for next mode
000020F4                          2137          
000020F4                          2138  NegBody:
000020F4                          2139  
000020F4                          2140  
000020F4  3401                    2141          MOVE.W  D1,D2                   ;copy inst to D2
000020F6  C47C 0600               2142          AND.W  #%0011000000000,D2       ;mask word for size
000020FA  0C42 0000               2143          CMPI.W #0,D2                    ;0 is the only non valid size
000020FE  6700 EF9C               2144          BEQ falsePositive               ; zero is not valid
00002102                          2145  
00002102  43F9 00002D03           2146          LEA     negMessage,A1           ;move string for NEG info
00002108  103C 000E               2147          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000210C                          2148                                ;string without CR, LF
0000210C  4E4F                    2149          TRAP    #15
0000210E                          2150          
0000210E  6100 0026               2151          BSR NegSize
00002112                          2152          
00002112  3401                    2153          MOVE.W D1,D2
00002114  C47C 003F               2154          AND #%000000000111111,D2
00002118  1A02                    2155          MOVE.B D2,D5
0000211A                          2156          
0000211A  48E7 4000               2157          MOVEM.L D1,-(SP)
0000211E  6100 06C0               2158          BSR     Get_Effective_Address
00002122  4CDF 0002               2159          MOVEM.L (SP)+,D1
00002126                          2160          
00002126                          2161                
00002126                          2162          
00002126                          2163  NEGdone:
00002126                          2164  
00002126  43F9 00002C8C           2165          LEA     clearLine,A1            ;move string for a CR and LF
0000212C  103C 000E               2166          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002130                          2167                                          ;string without CR, LF
00002130  4E4F                    2168          TRAP    #15
00002132  7000                    2169          MOVEQ.L #0,D0
00002134  4E75                    2170          RTS
00002136                          2171          
00002136                          2172  NegSize:
00002136  3401                    2173          MOVE.W  D1,D2                   ;copy inst to D2
00002138  EC4A                    2174          LSR.W #6,D2                     ;shift size over to first byte
0000213A  C4BC 00000003           2175          AND.L  #%11,D2                  ;mask word for size
00002140  2C02                    2176          MOVE.L D2,D6                    ;size does not need to be translated,
00002142                          2177                                          ;so moved directly to D6
00002142                          2178          
00002142  6100 083A               2179          BSR printSize
00002146                          2180          
00002146  4E75                    2181          RTS
00002148                          2182          
00002148                          2183          
00002148                          2184   ADDI:            
00002148                          2185       
00002148  7000                    2186          MOVEQ.L #0, D0                  ;clear D0
0000214A                          2187          
0000214A                          2188  validAddiModes:
0000214A                          2189          
0000214A                          2190          
0000214A  43F9 0000226F           2191          LEA cmpiEAmasks,A1              ;load the list of masks
00002150  D3C0                    2192          ADDA.L D0,A1                    ;displace to a specific mask
00002152  1A11                    2193          MOVE.B (A1),D5                  ;move the mask to D5
00002154                          2194          
00002154  0C05 0000               2195          CMPI.B #0,D5                    ;check if the mask is 0
00002158  6700 EF42               2196          BEQ falsePositive               ;branch if it is
0000215C                          2197          
0000215C  1401                    2198          MOVE.B D1,D2                    ;copy instruction to D2
0000215E  C405                    2199          AND.B D5,D2                     ;mask D2
00002160  43F9 00002268           2200          LEA cmpiEA,A1                   ;load the list of valid modes
00002166  D3C0                    2201          ADDA.L D0,A1                    ;displace to a specific mode
00002168  1811                    2202          MOVE.B (A1),D4                  ;move mode to D4
0000216A  B404                    2203          CMP.B D4,D2                     ;compare mode to masked value
0000216C  6700 0006               2204          BEQ addiBody                    ;if its match, its a valid mode and we can procede
00002170                          2205          
00002170  5280                    2206          ADDQ.L #1,D0                    ;add one to displacement
00002172  60D6                    2207          BRA validAddiModes              ;check for next mode
00002174                          2208          
00002174                          2209  addiBody:
00002174                          2210  
00002174                          2211  
00002174  3401                    2212          MOVE.W  D1,D2                   ;copy inst to D2
00002176  C47C 00C0               2213          AND.W  #%0000000011000000,D2    ;mask word for size
0000217A  0C42 00C0               2214          CMPI.W #%0000000011000000,D2    ;11 is the only non valid size
0000217E  6700 EF1C               2215          BEQ falsePositive
00002182                          2216  
00002182  43F9 00002CDF           2217          LEA     addiMessage,A1          ;move string for NEG info
00002188  103C 000E               2218          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000218C                          2219                                ;string without CR, LF
0000218C  4E4F                    2220          TRAP    #15
0000218E                          2221          
0000218E  61A6                    2222          BSR NegSize
00002190                          2223          
00002190                          2224          ;go to Effective_Address for immediate data
00002190  743C                    2225          MOVE.L #%00111100,D2
00002192  2A02                    2226          MOVE.L D2,D5
00002194  48E7 4000               2227          MOVEM.L D1,-(SP)
00002198  6100 0646               2228          BSR     Get_Effective_Address
0000219C  4CDF 0002               2229          MOVEM.L (SP)+,D1
000021A0                          2230          
000021A0                          2231          ;print ','
000021A0  48E7 4000               2232          MOVEM.L D1,-(SP)                ;save D1 to the stack
000021A4  123C 002C               2233          MOVE.B #',',D1                  ;put ascii value of char in D1
000021A8  103C 0006               2234          MOVE.B #6,D0                    ;move task 6 into D0
000021AC  4E4F                    2235          TRAP #15                        ;prin char
000021AE  4CDF 0002               2236          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000021B2                          2237          
000021B2  3401                    2238          MOVE.W D1,D2                    ;copy inst to D2
000021B4  C47C 003F               2239          AND #%000000000111111,D2        ;and out everything but modes and regs
000021B8  1A02                    2240          MOVE.B D2,D5                    ; copy to D5 for following BSR
000021BA                          2241          
000021BA  48E7 4000               2242          MOVEM.L D1,-(SP)
000021BE  6100 0620               2243          BSR     Get_Effective_Address
000021C2  4CDF 0002               2244          MOVEM.L (SP)+,D1
000021C6                          2245          
000021C6                          2246                
000021C6                          2247          
000021C6                          2248  addidone:
000021C6                          2249  
000021C6  43F9 00002C8C           2250          LEA     clearLine,A1            ;move string for a CR and LF
000021CC  103C 000E               2251          MOVE.B  #14,D0                  ;set for task to display null terminated 
000021D0                          2252                                          ;string without CR, LF
000021D0  4E4F                    2253          TRAP    #15
000021D2  7000                    2254          MOVEQ.L #0,D0
000021D4  4E75                    2255          RTS
000021D6                          2256    
000021D6                          2257  ORI:            
000021D6                          2258       
000021D6  7000                    2259          MOVEQ.L #0, D0                  ;clear D0
000021D8                          2260          
000021D8                          2261  validOriModes:
000021D8                          2262          
000021D8                          2263          
000021D8  43F9 0000226F           2264          LEA cmpiEAmasks,A1              ;load the list of masks
000021DE  D3C0                    2265          ADDA.L D0,A1                    ;displace to a specific mask
000021E0  1A11                    2266          MOVE.B (A1),D5                  ;move the mask to D5
000021E2                          2267          
000021E2  0C05 0000               2268          CMPI.B #0,D5                    ;check if the mask is 0
000021E6  6700 EEB4               2269          BEQ falsePositive               ;branch if it is
000021EA                          2270          
000021EA  1401                    2271          MOVE.B D1,D2                    ;copy instruction to D2
000021EC  C405                    2272          AND.B D5,D2                     ;mask D2
000021EE  43F9 00002268           2273          LEA cmpiEA,A1                   ;load the list of valid modes
000021F4  D3C0                    2274          ADDA.L D0,A1                    ;displace to a specific mode
000021F6  1811                    2275          MOVE.B (A1),D4                  ;move mode to D4
000021F8  B404                    2276          CMP.B D4,D2                     ;compare mode to masked value
000021FA  6700 0006               2277          BEQ oriBody                     ;if its match, its a valid mode and we can procede
000021FE                          2278          
000021FE  5280                    2279          ADDQ.L #1,D0                    ;add one to displacement
00002200  60D6                    2280          BRA validOriModes               ;check for next mode
00002202                          2281          
00002202                          2282  oriBody:
00002202                          2283  
00002202                          2284  
00002202  3401                    2285          MOVE.W  D1,D2                   ;copy inst to D2
00002204  C47C 00C0               2286          AND.W  #%0000000011000000,D2    ;mask word for size
00002208  0C42 00C0               2287          CMPI.W #%0000000011000000,D2    ;11 is the only non valid size
0000220C  6700 EE8E               2288          BEQ falsePositive
00002210                          2289  
00002210  43F9 00002CE4           2290          LEA     oriMessage,A1           ;move string for NEG info
00002216  103C 000E               2291          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000221A                          2292                                ;string without CR, LF
0000221A  4E4F                    2293          TRAP    #15
0000221C                          2294          
0000221C  6100 FF18               2295          BSR negSize
00002220                          2296          
00002220                          2297          ;go to Effective_Address for immediate data
00002220  143C 003C               2298          MOVE.B #%00111100,D2
00002224  1A02                    2299          MOVE.B D2,D5
00002226  48E7 4000               2300          MOVEM.L D1,-(SP)
0000222A  6100 05B4               2301          BSR     Get_Effective_Address
0000222E  4CDF 0002               2302          MOVEM.L (SP)+,D1
00002232                          2303          
00002232                          2304          ;print ','
00002232  48E7 4000               2305          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002236  123C 002C               2306          MOVE.B #',',D1                  ;put ascii value of char in D1
0000223A  103C 0006               2307          MOVE.B #6,D0                    ;move task 6 into D0
0000223E  4E4F                    2308          TRAP #15                        ;print char
00002240  4CDF 0002               2309          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002244                          2310          
00002244  3401                    2311          MOVE.W D1,D2                    ;copy inst to D2
00002246  C47C 003F               2312          AND #%000000000111111,D2        ;and out everything but modes and regs
0000224A  1A02                    2313          MOVE.B D2,D5                    ; copy to D5 for following BSR
0000224C                          2314          
0000224C  48E7 4000               2315          MOVEM.L D1,-(SP)
00002250  6100 058E               2316          BSR     Get_Effective_Address
00002254  4CDF 0002               2317          MOVEM.L (SP)+,D1
00002258                          2318          
00002258                          2319                
00002258                          2320          
00002258                          2321  oridone:
00002258                          2322  
00002258  43F9 00002C8C           2323          LEA     clearLine,A1            ;move string for a CR and LF
0000225E  103C 000E               2324          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002262                          2325                                          ;string without CR, LF
00002262  4E4F                    2326          TRAP    #15
00002264  7000                    2327          MOVEQ.L #0,D0
00002266  4E75                    2328          RTS
00002268                          2329  
00002268                          2330          
00002268                          2331          
00002268= 20 18 00 10 38 39 00    2332  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
0000226F= 38 38 38 38 3F 3F 00    2333  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
00002276                          2334     
00002276                          2335  CMPI:            
00002276                          2336       
00002276  7000                    2337          MOVEQ.L #0, D0                  ;clear D0
00002278                          2338          
00002278                          2339  validCmpiModes:
00002278                          2340          
00002278                          2341          
00002278  43F8 226F               2342          LEA cmpiEAmasks,A1              ;load the list of masks
0000227C  D3C0                    2343          ADDA.L D0,A1                    ;displace to a specific mask
0000227E  1A11                    2344          MOVE.B (A1),D5                  ;move the mask to D5
00002280                          2345          
00002280  0C05 0000               2346          CMPI.B #0,D5                    ;check if the mask is 0
00002284  6700 EE16               2347          BEQ falsePositive               ;branch if it is
00002288                          2348          
00002288  1401                    2349          MOVE.B D1,D2                    ;copy instruction to D2
0000228A  C405                    2350          AND.B D5,D2                     ;mask D2
0000228C  43F8 2268               2351          LEA cmpiEA,A1                   ;load the list of valid modes
00002290  D3C0                    2352          ADDA.L D0,A1                    ;displace to a specific mode
00002292  1811                    2353          MOVE.B (A1),D4                  ;move mode to D4
00002294  B404                    2354          CMP.B D4,D2                     ;compare mode to masked value
00002296  6700 0006               2355          BEQ CMPIBody                    ;if its match, its a valid mode and we can procede
0000229A                          2356          
0000229A  5280                    2357          ADDQ.L #1,D0                    ;add one to displacement
0000229C  60DA                    2358          BRA validCmpiModes              ;check for next mode
0000229E                          2359          
0000229E                          2360  CMPIBody:
0000229E                          2361  
0000229E                          2362  
0000229E  3401                    2363          MOVE.W  D1,D2                   ;copy inst to D2
000022A0  C47C 00C0               2364          AND.W  #%0000000011000000,D2    ;mask word for size
000022A4  0C42 00C0               2365          CMPI.W #%0000000011000000,D2    ;11 is the only non valid size
000022A8  6700 EDF2               2366          BEQ falsePositive
000022AC                          2367  
000022AC  43F9 00002CE8           2368          LEA     cmpiMessage,A1          ;move string for NEG info
000022B2  103C 000E               2369          MOVE.B  #14,D0                  ;set for task to display null terminated 
000022B6                          2370                                ;string without CR, LF
000022B6  4E4F                    2371          TRAP    #15
000022B8                          2372          
000022B8  6100 FE7C               2373          BSR negSize
000022BC                          2374          
000022BC                          2375          ;go to Effective_Address for immediate data
000022BC  143C 003C               2376          MOVE.B #%00111100,D2
000022C0  1A02                    2377          MOVE.B D2,D5
000022C2  48E7 4000               2378          MOVEM.L D1,-(SP)
000022C6  6100 0518               2379          BSR     Get_Effective_Address
000022CA  4CDF 0002               2380          MOVEM.L (SP)+,D1
000022CE                          2381          
000022CE                          2382          ;print ','
000022CE  48E7 4000               2383          MOVEM.L D1,-(SP)                ;save D1 to the stack
000022D2  123C 002C               2384          MOVE.B #',',D1                  ;put ascii value of char in D1
000022D6  103C 0006               2385          MOVE.B #6,D0                    ;move task 6 into D0
000022DA  4E4F                    2386          TRAP #15                        ;prin char
000022DC  4CDF 0002               2387          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000022E0                          2388          
000022E0  3401                    2389          MOVE.W D1,D2                    ;copy inst to D2
000022E2  C47C 003F               2390          AND #%000000000111111,D2        ;and out everything but modes and regs
000022E6  1A02                    2391          MOVE.B D2,D5                    ; copy to D5 for following BSR
000022E8                          2392          
000022E8  48E7 4000               2393          MOVEM.L D1,-(SP)
000022EC  6100 04F2               2394          BSR     Get_Effective_Address
000022F0  4CDF 0002               2395          MOVEM.L (SP)+,D1
000022F4                          2396          
000022F4                          2397                
000022F4                          2398          
000022F4                          2399  CMPidone:
000022F4                          2400  
000022F4  43F9 00002C8C           2401          LEA     clearLine,A1            ;move string for a CR and LF
000022FA  103C 000E               2402          MOVE.B  #14,D0                  ;set for task to display null terminated 
000022FE                          2403                                ;string without CR, LF
000022FE  4E4F                    2404          TRAP    #15
00002300  7000                    2405          MOVEQ.L #0,D0
00002302  4E75                    2406          RTS
00002304                          2407  
00002304                          2408          
00002304= 10 38 39 00             2409  JsrEA        DC.B %010000, %111000, %111001,0
00002308= 38 3F 3F 00             2410  JsrEAmasks   DC.B %111000, %111111, %111111,0
0000230C                          2411     
0000230C                          2412  JSR:            
0000230C                          2413       
0000230C  7000                    2414          MOVEQ.L #0, D0                  ;clear D0
0000230E                          2415          
0000230E                          2416  validJsrModes:
0000230E                          2417          
0000230E  43F8 2308               2418          LEA JsrEAmasks,A1               ;load the list of masks
00002312  D3C0                    2419          ADDA.L D0,A1                    ;displace to a specific mask
00002314  1A11                    2420          MOVE.B (A1),D5                  ;move the mask to D5
00002316                          2421          
00002316  0C05 0000               2422          CMPI.B #0,D5                    ;check if the mask is 0
0000231A  6700 ED80               2423          BEQ falsePositive               ;branch if it is
0000231E                          2424          
0000231E  1401                    2425          MOVE.B D1,D2                    ;copy instruction to D2
00002320  C405                    2426          AND.B D5,D2                     ;mask D2
00002322  43F8 2304               2427          LEA JsrEA,A1                    ;load the list of valid modes
00002326  D3C0                    2428          ADDA.L D0,A1                    ;displace to a specific mode
00002328  1811                    2429          MOVE.B (A1),D4                  ;move mode to D4
0000232A  B404                    2430          CMP.B D4,D2                     ;compare mode to masked value
0000232C  6700 0006               2431          BEQ JsrBody                     ;if its match, its a valid mode and we can procede
00002330                          2432          
00002330  5280                    2433          ADDQ.L #1,D0                    ;add one to displacement
00002332  60DA                    2434          BRA validJsrModes               ;check for next mode
00002334                          2435          
00002334                          2436  JsrBody:
00002334                          2437  
00002334                          2438  
00002334  43F9 00002CED           2439          LEA     jsrMessage,A1           ;move string for NEG info
0000233A  103C 000E               2440          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000233E                          2441                                ;string without CR, LF
0000233E  4E4F                    2442          TRAP    #15
00002340                          2443          
00002340  3401                    2444          MOVE.W D1,D2                    ;copy inst to D2
00002342  C47C 003F               2445          AND #%000000000111111,D2        ;and out everything but modes and regs
00002346  1A02                    2446          MOVE.B D2,D5                    ; copy to D5 for following BSR
00002348                          2447          
00002348  48E7 4000               2448          MOVEM.L D1,-(SP)
0000234C  6100 0492               2449          BSR     Get_Effective_Address
00002350  4CDF 0002               2450          MOVEM.L (SP)+,D1
00002354                          2451          
00002354                          2452                
00002354                          2453          
00002354                          2454  Jsrdone:
00002354                          2455  
00002354  43F9 00002C8C           2456          LEA     clearLine,A1            ;move string for a CR and LF
0000235A  103C 000E               2457          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000235E                          2458                                ;string without CR, LF
0000235E  4E4F                    2459          TRAP    #15
00002360  7000                    2460          MOVEQ.L #0,D0
00002362  4E75                    2461          RTS
00002364                          2462  
00002364                          2463  
00002364                          2464          
00002364                          2465  NOP:
00002364                          2466  
00002364  43F9 00002CF7           2467          LEA     nopMessage,A1           ;move string for NOP info
0000236A  103C 000D               2468          MOVE.B  #13,D0                  ;set for task to display null terminated 
0000236E                          2469                                          ;string with CR, LF
0000236E  4E4F                    2470          TRAP    #15
00002370                          2471          
00002370  7000                    2472          MOVEQ.L #0,D0
00002372  4E75                    2473          RTS
00002374                          2474          
00002374                          2475  RTS:
00002374                          2476          
00002374  43F9 00002CF2           2477          LEA     rtsMessage,A1           ;move string for rts info
0000237A  103C 000D               2478          MOVE.B  #13,D0                  ;set for task to display null terminated 
0000237E                          2479                                          ;string with CR, LF
0000237E  4E4F                    2480          TRAP    #15  
00002380                          2481     
00002380  7000                    2482          MOVEQ.L #0,D0
00002382  4E75                    2483          RTS   
00002384                          2484  
00002384= 3C 08 00 10 18 20 ...   2485  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
0000238D= 3F 38 38 38 38 38 ...   2486  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00002396                          2487  
00002396= 00 10 18 20 38 39 00    2488  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
0000239D= 38 38 38 38 3F 3F 00    2489  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
000023A4                          2490  
000023A4                          2491  MOVE:
000023A4                          2492          
000023A4                          2493  
000023A4                          2494          
000023A4  7000                    2495          MOVEQ.L #0, D0                  ;clear D0
000023A6                          2496          
000023A6                          2497  validMoveSourceModes:
000023A6                          2498          
000023A6  43F8 238D               2499          LEA moveSourceEAmasks,A1        ;load the list of masks
000023AA  D3C0                    2500          ADDA.L D0,A1                    ;displace to a specific mask
000023AC  1A11                    2501          MOVE.B (A1),D5                  ;move the mask to D5
000023AE                          2502          
000023AE  0C05 0000               2503          CMPI.B #0,D5                    ;check if the mask is 0
000023B2  6700 ECE8               2504          BEQ falsePositive               ;branch if it is
000023B6                          2505          
000023B6  1401                    2506          MOVE.B D1,D2                    ;copy instruction to D2
000023B8  C405                    2507          AND.B D5,D2                     ;mask D2
000023BA                          2508          
000023BA  43F8 2384               2509          LEA moveSourceEA,A1             ;load the list of valid modes
000023BE  D3C0                    2510          ADDA.L D0,A1                    ;displace to a specific mode
000023C0  1811                    2511          MOVE.B (A1),D4                  ;move mode to D4
000023C2  B404                    2512          CMP.B D4,D2                     ;compare mode to masked value
000023C4  6700 0006               2513          BEQ  checkMoveDest              ;if its match, its a valid mode and we can procede
000023C8                          2514          
000023C8  5280                    2515          ADDQ.L #1,D0                    ;add one to displacement
000023CA  60DA                    2516          BRA validMoveSourceModes        ;check for next mode
000023CC                          2517          
000023CC                          2518  checkMoveDest:
000023CC  7000                    2519          MOVEQ.L #0, D0                  ;clear D0
000023CE                          2520          
000023CE                          2521  validMoveDestModes:
000023CE                          2522          
000023CE  43F8 239D               2523          LEA moveDestEAmasks,A1          ;load the list of masks
000023D2  D3C0                    2524          ADDA.L D0,A1                    ;displace to a specific mask
000023D4  1A11                    2525          MOVE.B (A1),D5                  ;move the mask to D5
000023D6                          2526          
000023D6  0C05 0000               2527          CMPI.B #0,D5                    ;check if the mask is 0
000023DA  6700 ECC0               2528          BEQ falsePositive               ;branch if it is
000023DE                          2529          
000023DE  3401                    2530          MOVE.W D1,D2                    ;copy instruction to D2
000023E0  EC4A                    2531          LSR.W #6,D2                     ;move mode
000023E2  6100 06CC               2532          BSR switchModeAndReg            ;switch register and mode
000023E6  C405                    2533          AND.B D5,D2                     ;mask D2
000023E8                          2534          
000023E8  43F8 2396               2535          LEA moveDestEA,A1               ;load the list of valid modes
000023EC  D3C0                    2536          ADDA.L D0,A1                    ;displace to a specific mode
000023EE  1811                    2537          MOVE.B (A1),D4                  ;move mode to D4
000023F0  B404                    2538          CMP.B D4,D2                     ;compare mode to masked value
000023F2  6700 0006               2539          BEQ moveBody                    ;if its match, its a valid mode and we can procede
000023F6                          2540          
000023F6  5280                    2541          ADDQ.L #1,D0                    ;add one to displacement
000023F8  60D4                    2542          BRA validMoveDestModes          ;check for next mode
000023FA                          2543          
000023FA                          2544  moveBody
000023FA  3401                    2545          MOVE.W  D1,D2                   ;copy inst to D2
000023FC  C47C 3000               2546          AND.W  #%0011000000000000,D2    ;mask word for size
00002400  0C42 0000               2547          CMPI.W #0,D2                    ;0 is the only non valid size
00002404  6700 EC96               2548          BEQ falsePositive               ; if zero, this is not move
00002408                          2549  
00002408  43F9 00002CFC           2550          LEA     moveMessage,A1          ;move string for MOVE
0000240E  103C 000E               2551          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002412                          2552                                ;string with CR, LF
00002412  4E4F                    2553          TRAP    #15
00002414                          2554          
00002414  6100 0052               2555          BSR moveSize
00002418                          2556          
00002418  3401                    2557          MOVE.W  D1,D2                   ;check source mode
0000241A  C43C 003F               2558          AND.B   #%00111111,D2
0000241E  1A02                    2559          MOVE.B  D2,D5
00002420  48E7 4000               2560          MOVEM.L D1,-(SP)
00002424  6100 03BA               2561          BSR     Get_Effective_Address
00002428  4CDF 0002               2562          MOVEM.L (SP)+,D1
0000242C                          2563          
0000242C                          2564          ;print ','
0000242C  48E7 4000               2565          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002430  123C 002C               2566          MOVE.B #',',D1                  ;put ascii value of char in D1
00002434  103C 0006               2567          MOVE.B #6,D0                    ;move task 6 into D0
00002438  4E4F                    2568          TRAP #15                        ;prin char
0000243A  4CDF 0002               2569          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000243E                          2570          
0000243E  3401                    2571          MOVE.W  D1,D2                   ;check dest mode
00002440  EC4A                    2572          LSR.W   #6,D2
00002442  6100 066C               2573          BSR  switchModeAndReg
00002446  C43C 003F               2574          AND.B   #%00111111,D2
0000244A  1A02                    2575          MOVE.B  D2,D5
0000244C  48E7 4000               2576          MOVEM.L D1,-(SP)
00002450  6100 038E               2577          BSR     Get_Effective_Address
00002454  4CDF 0002               2578          MOVEM.L (SP)+,D1
00002458                          2579          
00002458                          2580          
00002458                          2581          
00002458  43F9 00002C8C           2582          LEA     clearLine,A1            ;move string for a CR and LF
0000245E  103C 000E               2583          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002462                          2584                                ;string without CR, LF
00002462  4E4F                    2585          TRAP    #15
00002464                          2586  
00002464  7000                    2587          MOVEQ.L #0,D0
00002466  4E75                    2588          RTS
00002468                          2589          
00002468                          2590  moveSize:
00002468  3401                    2591          MOVE.W  D1,D2                   ;copy inst to D2
0000246A  E04A                    2592          LSR.W   #8,D2                   ;shift size
0000246C  E80A                    2593          LSR.B   #4,D2
0000246E  C4BC 00000003           2594          AND.L  #%11,D2                  ;mask for size
00002474  7C00                    2595          MOVEQ.L #0,D6                   ;clear D6
00002476  0C42 0002               2596          CMPI.W #2,D2                    ;compare and then branch depending on size
0000247A  6700 001C               2597          BEQ moveSizeLong
0000247E  6E00 0012               2598          BGT moveSizeWord
00002482  6D00 0008               2599          BLT moveSizeByte
00002486                          2600  moveSizeDone:        
00002486  6100 04F6               2601          BSR printSize
0000248A  4E75                    2602          RTS
0000248C                          2603          
0000248C                          2604  moveSizeByte:
0000248C  1C3C 0000               2605          MOVE.B #0,D6
00002490  60F4                    2606          BRA moveSizeDone
00002492                          2607          
00002492                          2608  moveSizeWord:
00002492  1C3C 0001               2609          MOVE.B #1,D6
00002496  60EE                    2610          BRA moveSizeDone
00002498                          2611          
00002498                          2612  moveSizeLong:
00002498  1C3C 0002               2613          MOVE.B #2,D6
0000249C  60E8                    2614          BRA moveSizeDone
0000249E                          2615          
0000249E= 08 00                   2616  moveADestEA        DC.B %001000,0
000024A0= 38 00                   2617  moveADestEAmasks   DC.B %111000,0
000024A2                          2618          
000024A2                          2619  MOVEA:
000024A2                          2620  
000024A2  7000                    2621          MOVEQ.L #0, D0                  ;clear D0
000024A4                          2622          
000024A4                          2623  validMoveAModes:
000024A4                          2624          
000024A4  43F8 238D               2625          LEA moveSourceEAmasks,A1        ;load the list of masks
000024A8  D3C0                    2626          ADDA.L D0,A1                    ;displace to a specific mask
000024AA  1A11                    2627          MOVE.B (A1),D5                  ;move the mask to D5
000024AC                          2628          
000024AC  0C05 0000               2629          CMPI.B #0,D5                    ;check if the mask is 0
000024B0  6700 EBEA               2630          BEQ falsePositive               ;branch if it is
000024B4                          2631          
000024B4  1401                    2632          MOVE.B D1,D2                    ;copy instruction to D2
000024B6  C405                    2633          AND.B D5,D2                     ;mask D2
000024B8                          2634          
000024B8  43F8 2384               2635          LEA moveSourceEA,A1             ;load the list of valid modes
000024BC  D3C0                    2636          ADDA.L D0,A1                    ;displace to a specific mode
000024BE  1811                    2637          MOVE.B (A1),D4                  ;move mode to D4
000024C0  B404                    2638          CMP.B D4,D2                     ;compare mode to masked value
000024C2  6700 0006               2639          BEQ  moveABody                  ;if its match, its a valid mode and we can procede
000024C6                          2640          
000024C6  5280                    2641          ADDQ.L #1,D0                    ;add one to displacement
000024C8  60DA                    2642          BRA validMoveAModes             ;check for next mode
000024CA                          2643          
000024CA                          2644  moveABody:
000024CA  3401                    2645          MOVE.W  D1,D2                   ;copy inst to D2
000024CC  C47C 3000               2646          AND.W  #%0011000000000000,D2    ;mask word for size
000024D0  0C42 0000               2647          CMPI.W #0,D2                    ;0 is the non valid size
000024D4  6700 EBC6               2648          BEQ falsePositive               ; if zero, this is not move
000024D8  0C42 1000               2649          CMPI.W #%0001000000000000,D2
000024DC  6700 EBBE               2650          BEQ falsePositive               ; if byte, this is not movea
000024E0                          2651  
000024E0                          2652  
000024E0  43F9 00002D0D           2653          LEA     moveAMessage,A1         ;move string for MOVE
000024E6  103C 000E               2654          MOVE.B  #14,D0                  ;set for task to display null terminated 
000024EA                          2655                                ;string without CR, LF
000024EA  4E4F                    2656          TRAP    #15
000024EC                          2657  
000024EC  6100 FF7A               2658          BSR moveSize
000024F0                          2659          
000024F0                          2660          ;Do EA
000024F0                          2661          
000024F0  3401                    2662          MOVE.W  D1,D2                   ;check mode
000024F2  C43C 003F               2663          AND.B   #%00111111,D2
000024F6  1A02                    2664          MOVE.B  D2,D5
000024F8  48E7 4000               2665          MOVEM.L D1,-(SP)
000024FC  6100 02E2               2666          BSR     Get_Effective_Address
00002500  4CDF 0002               2667          MOVEM.L (SP)+,D1
00002504                          2668          
00002504                          2669          
00002504                          2670          ;print ','
00002504  48E7 4000               2671          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002508  123C 002C               2672          MOVE.B #',',D1                  ;put ascii value of char in D1
0000250C  103C 0006               2673          MOVE.B #6,D0                    ;move task 6 into D0
00002510  4E4F                    2674          TRAP #15                        ;prin char
00002512  4CDF 0002               2675          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002516                          2676          
00002516                          2677          
00002516                          2678          ;Then do An
00002516                          2679          
00002516  3401                    2680          MOVE.W  D1,D2
00002518  E04A                    2681          LSR.W   #8,D2                   ;move reg into first byte
0000251A  E20A                    2682          LSR.B   #1,D2                   ;line it up to least sig bit
0000251C  C43C 0007               2683          AND.B   #%00000111,D2           ;force mode to An
00002520  5002                    2684          ADDQ.B  #8,D2
00002522  1A02                    2685          MOVE.B  D2,D5
00002524  48E7 4000               2686          MOVEM.L D1,-(SP)
00002528  6100 02B6               2687          BSR     Get_Effective_Address
0000252C  4CDF 0002               2688          MOVEM.L (SP)+,D1
00002530                          2689          
00002530  43F9 00002C8C           2690          LEA     clearLine,A1            ;move string for a CR and LF
00002536  103C 000E               2691          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000253A                          2692                                ;string without CR, LF
0000253A  4E4F                    2693          TRAP    #15
0000253C                          2694  
0000253C  7000                    2695          MOVEQ.L #0,D0
0000253E  4E75                    2696          RTS
00002540                          2697  
00002540                          2698             
00002540                          2699  Bcc:
00002540                          2700          
00002540  48E7 4000               2701          MOVEM.L D1,-(SP)
00002544  43F9 00002D01           2702          LEA     bccMessage,A1           ;move string for BRA info
0000254A  103C 000E               2703          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000254E                          2704                                ;string without CR, LF
0000254E  4E4F                    2705          TRAP    #15
00002550                          2706          
00002550  7000                    2707          MOVEQ.L #0,D0                   ;clear D0
00002552  3401                    2708          MOVE.W  D1,D2                   ;move instruction into D2 for manipulaiton
00002554  E04A                    2709          LSR.W   #8,D2
00002556  C47C 000F               2710          AND.W   #$0F,D2                 ;mask instruction
0000255A                          2711          
0000255A                          2712  checkCC:        
0000255A  41F9 00002C13           2713          LEA     bccList,A0              ;get condition code signature list in A0
00002560  D1C0                    2714          ADDA.L  D0,A0                   ;get correct sig         
00002562  B410                    2715          CMP.B   (A0),D2                 ;compare to sig
00002564  6700 0006               2716          BEQ     foundCC                 ;if sig matches branch
00002568  5200                    2717          ADDQ.B  #byte,D0
0000256A  60EE                    2718          BRA     checkCC
0000256C                          2719  foundCC:
0000256C  43F9 00002C24           2720          LEA     conditionCodeMessage,A1 ;get condition code message in A1
00002572  C0FC 0004               2721          MULU.W  #long,D0                ;adjust size of D0 for a long
00002576  D3C0                    2722          ADDA.L  D0,A1                   ;get correct message location
00002578  2251                    2723          MOVEA.L (A1),A1                 ;get correct message
0000257A                          2724          
0000257A  103C 000E               2725          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000257E                          2726                                ;string without CR, LF
0000257E  4E4F                    2727          TRAP    #15
00002580                          2728  
00002580                          2729          
00002580                          2730          
00002580  548B                    2731          ADDQ.L  #word,A3                ;move past instruction in case long displacement
00002582  C27C 00FF               2732          AND.W   #$00FF,D1               ;check for word sized displacement
00002586                          2733          
00002586  B23C 0000               2734          CMP.B   #$0,D1
0000258A  6700 0028               2735          BEQ     BccWord
0000258E                          2736          
0000258E  B23C 00FF               2737          CMP.B   #$FF,D1 check for long sized displacement
00002592  6700 002A               2738          BEQ     BccLong
00002596                          2739          
00002596                          2740  BccByte:
00002596                          2741          
00002596  1201                    2742          MOVE.B D1,D1                    ;lazy check if negative
00002598                          2743          
00002598  6B00 000E               2744          BMI signExtendByte
0000259C                          2745          
0000259C  C2BC 000000FF           2746          AND.L #$000000FF,D1             ;mask out rest of reg just in case
000025A2                          2747          
000025A2  7E00                    2748          MOVEQ.L #0,D7                   ;pass back no extra data followed
000025A4  6000 0020               2749          BRA     BccDone
000025A8                          2750          
000025A8                          2751  signExtendByte:        
000025A8                          2752          
000025A8  82BC FFFFFF00           2753          OR.L #$FFFFFF00,D1              ;extend to long by set all bits not part of the
000025AE                          2754                             ;least significant byte
000025AE                          2755          
000025AE  7E00                    2756          MOVEQ.L #0,D7                   ;pass back no extra data followed
000025B0  6000 0014               2757          BRA     BccDone
000025B4                          2758  
000025B4                          2759  BccWord:
000025B4  3253                    2760          MOVEA.W  (A3),A1                ;sign extend word
000025B6  2209                    2761          MOVE.L   A1,D1
000025B8  7E02                    2762          MOVEQ.L #word,D7                ;pass back an extra word followed
000025BA  6000 000A               2763          BRA     BccDone
000025BE                          2764  BccLong:
000025BE  2213                    2765          MOVE.L  (A3),D1 
000025C0  7E04                    2766          MOVEQ.L #long,D7                ;pass back an extra long followed
000025C2  6000 0002               2767          BRA     BccDone
000025C6                          2768  BccDone:
000025C6                          2769  
000025C6  303C 0003               2770          MOVE.W  #3,D0                   ;put task #15 in D0
000025CA  4E4F                    2771          TRAP    #15
000025CC                          2772          
000025CC  43F9 00002C8C           2773          LEA     clearLine,A1            ;move string for a CR and LF
000025D2  103C 000E               2774          MOVE.B  #14,D0                  ;set for task to display null terminated 
000025D6                          2775                                ;string without CR, LF
000025D6  4E4F                    2776          TRAP    #15
000025D8                          2777          
000025D8  4CDF 0002               2778          MOVEM.L (SP)+,D1
000025DC  7000                    2779          MOVEQ.L #0,D0
000025DE  4E75                    2780          RTS
000025E0                          2781          
000025E0                          2782          
000025E0                          2783  unknownOpCode:
000025E0  43F9 00002D07           2784          LEA     dataMessage,A1          ;move string for data info
000025E6  103C 000E               2785          MOVE.B  #14,D0                  ;set for task to display null terminated 
000025EA                          2786                                ;string without CR, LF
000025EA  4E4F                    2787          TRAP    #15
000025EC                          2788          
000025EC                          2789          ;print word in D1
000025EC  48E7 1200               2790          MOVEM.L D6/D3,-(SP)
000025F0  1C3C 0001               2791          MOVE.B #1,D6                    ;put size of word in D6
000025F4  2601                    2792          MOVE.L D1,D3                    ;move data at D1 to D3
000025F6  6100 040C               2793          BSR outputHex
000025FA  4CDF 0048               2794          MOVEM.L (SP)+,D6/D3
000025FE                          2795          
000025FE  43F9 00002C8C           2796          LEA     clearLine,A1            ;move string for a CR and LF
00002604  103C 000E               2797          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002608                          2798                                ;string without CR, LF
00002608  4E4F                    2799          TRAP    #15
0000260A                          2800          
0000260A  7000                    2801          MOVEQ.L #0,D0
0000260C  4E75                    2802          RTS
0000260E                          2803          
0000260E                          2804  handlebytedata:
0000260E                          2805  
0000260E  43F9 00002D07           2806          LEA     dataMessage,A1          ;move string for data info
00002614  103C 000E               2807          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002618                          2808                                ;string without CR, LF
00002618  4E4F                    2809          TRAP    #15
0000261A                          2810          
0000261A  1213                    2811          MOVE.B (A3),D1                  ;copy word from other prog to analyze as instruction
0000261C                          2812          
0000261C  E049                    2813          LSR.W   #8,D1                   ;shift the word read into D1 by a byte
0000261E                          2814          
0000261E  48E7 1200               2815          MOVEM.L D6/D3,-(SP)
00002622  1C3C 0000               2816          MOVE.B #0,D6                    ;put size of byte in D6
00002626  1601                    2817          MOVE.B D1,D3                    ;move data at D1 to D3
00002628  6100 03DA               2818          BSR outputHex
0000262C  4CDF 0048               2819          MOVEM.L (SP)+,D6/D3
00002630                          2820          
00002630  43F9 00002C8C           2821          LEA     clearLine,A1            ;move string for a CR and LF
00002636  103C 000E               2822          MOVE.B  #14,D0                  ;set for task to display null terminated 
0000263A                          2823                                ;string without CR, LF
0000263A  4E4F                    2824          TRAP    #15
0000263C                          2825          
0000263C  4C9F 0004               2826          MOVEM.W (SP)+,D2                ;restore D2 for next iteration in main loop
00002640  7000                    2827          MOVEQ.L #0,D0
00002642                          2828          
00002642  528B                    2829          ADDQ.L  #byte,A3
00002644  6000 E9D8               2830          BRA main_Loop
00002648                          2831  
00002648                          2832          
00002648                          2833          
00002648                          2834  fin:
00002648  43F9 00002D75           2835          LEA     thankyouMessage,A1      ;move string for MOVE
0000264E  103C 000E               2836          MOVE.B  #14,D0                  ;set for task to display null terminated 
00002652                          2837                                ;string without CR, LF
00002652  4E4F                    2838          TRAP    #15
00002654                          2839          
00002654                          2840          
00002654  FFFF FFFF               2841          simhalt
00002658                          2842          
00002658                          2843  
00002658                          2844  *******************************************************************************
00002658                          2845  *                            SUB ROUTINES
00002658                          2846  *******************************************************************************
00002658                          2847  
00002658                          2848  *******************************************************************************
00002658                          2849  *                          IO ROLE ROUTINES
00002658                          2850  *******************************************************************************
00002658                          2851  
00002658                          2852  *==========================================================================
00002658                          2853  *                   Enter / Validate beginning address 
00002658                          2854  *==========================================================================
00002658                          2855   
00002658                          2856  begin_address:
00002658                          2857  
00002658                          2858         
00002658  43F9 00002AC4           2859          LEA         slPrompt,A1         ;Load address for starting loaction prompt
0000265E  2239 00002AC4           2860          MOVE.L      slPrompt,D1         ;Load display length to D1
00002664  700E                    2861          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00002666  4E4F                    2862          TRAP        #15                 ;Perform task 14 (display)
00002668                          2863          
00002668  43F9 00002D92           2864          LEA         startLocation,A1    ;Load address to store user input
0000266E  103C 0002               2865          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00002672  4E4F                    2866          TRAP        #15                 ;Perform task 2 (input)
00002674                          2867          
00002674  0C11 001B               2868          CMP.B       #27,(A1)            ;Check for ESC entered
00002678  6700 004C               2869          BEQ         address_Exit        ;Exit condition 
0000267C                          2870          
0000267C  6100 0050               2871          BSR         enter_addr_edit_all
00002680  B67C FFFF               2872          CMP.W       #-1,D3              ;Did the edit pass?
00002684  67D2                    2873          BEQ         begin_address       ;No, loop and ask for correct input
00002686                          2874          
00002686  2643                    2875          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
00002688                          2876          
00002688  43F9 00002BD1           2877          LEA         spc,A1              ;Load address for starting loaction prompt
0000268E  1239 00002BD2           2878          MOVE.B      spc_len,D1          ;Load empty line length
00002694  7000                    2879          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
00002696  4E4F                    2880          TRAP        #15                 ;Perform task 14 (display)
00002698  6000 0002               2881          BRA         end_address
0000269C                          2882  
0000269C                          2883  *===========================================================================
0000269C                          2884  *                   Enter / Validate ending address 
0000269C                          2885  *===========================================================================
0000269C                          2886  
0000269C                          2887  end_address:
0000269C                          2888          
0000269C  43F9 00002AF5           2889          LEA         elPrompt,A1         ;Load address for ending loaction prompt
000026A2                          2890          ;MOVE.L     elPrompt,D1         ;Load display length to D1
000026A2  7250                    2891          MOVE.L      #80,D1              ;did not like previous command, do not know why, it should have worked
000026A4  700E                    2892          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
000026A6  4E4F                    2893          TRAP        #15                 ;Perform task 14 (display)
000026A8                          2894          
000026A8  103C 0002               2895          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
000026AC  4E4F                    2896          TRAP        #15                 ;Perform task 2 (input)
000026AE                          2897          
000026AE  0C11 001B               2898          CMP.B       #27,(A1)            ;Check for ESC entered
000026B2  6700 0012               2899          BEQ         address_Exit        ;Exit condition 
000026B6                          2900          
000026B6  6100 0016               2901          BSR         enter_addr_edit_all
000026BA  B67C FFFF               2902          CMP.W       #-1,D3              ;Did the edit pass?
000026BE  67DC                    2903          BEQ         end_address         ;No, loop and ask for correct input
000026C0                          2904  
000026C0  2843                    2905          MOVEA.L     D3,A4               ;Ending address gets stored in A4
000026C2  6000 0008               2906          BRA         address_done
000026C6                          2907  
000026C6                          2908  address_Exit:
000026C6                          2909  
000026C6  76FF                    2910          MOVE.L      #-1,D3              ;Load -1 into return parameter
000026C8  6000 0002               2911          BRA         address_done
000026CC                          2912          
000026CC                          2913  address_done:
000026CC                          2914  
000026CC  4E75                    2915          RTS    
000026CE                          2916  
000026CE                          2917  *==============================================================================
000026CE                          2918  * enter_addr_edit_all - Enter address edit check to edit all errors  
000026CE                          2919  *                       using multiple different error checking routines.
000026CE                          2920  *
000026CE                          2921  * Parameters -
000026CE                          2922  *   Input   A1      The data that needs checked.
000026CE                          2923  *   Input   D1      The number of characters input     
000026CE                          2924  *   Output  D3      Returns '-1' when there is an error.
000026CE                          2925  *==============================================================================
000026CE                          2926  
000026CE                          2927  enter_addr_edit_all
000026CE                          2928  
000026CE                          2929  *------------------------------------------------------------------------------
000026CE                          2930  * Test for odd number of characters entered, not allowed
000026CE                          2931  *------------------------------------------------------------------------------
000026CE                          2932         
000026CE  6100 0024               2933          BSR         ck_boundry          ;check if the input is on a odd / even boundry
000026D2  B67C FFFF               2934          CMP.W       #-1,D3              ;Is the address odd?
000026D6  6700 001A               2935          BEQ         enter_addr_edit_all_exit     ;No, return
000026DA                          2936  
000026DA                          2937  *------------------------------------------------------------------------------
000026DA                          2938  * Ttest for character entered all being valid address characters
000026DA                          2939  * Note: lower case a-f, gets converted to upper case A-F in D3
000026DA                          2940  *------------------------------------------------------------------------------
000026DA                          2941          
000026DA  6100 0062               2942          BSR         parseHexString      ;check if the input contains valid Hex characters
000026DE  B67C FFFF               2943          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
000026E2  6700 000E               2944          BEQ         enter_addr_edit_all_exit     ;No, return
000026E6                          2945  
000026E6                          2946  *------------------------------------------------------------------------------
000026E6                          2947  * Verify that the address entered is witin the range defined in the Equate
000026E6                          2948  *------------------------------------------------------------------------------        
000026E6                          2949          
000026E6  6100 00C8               2950          BSR         ck_addr_range       ;is address entered witin the range 
000026EA                          2951                                          ;   as defined in the Equate? 
000026EA  B67C FFFF               2952          CMP.W       #-1,D3              ;is the address  valid?
000026EE  6700 0002               2953          BEQ         enter_addr_edit_all_exit     ;No, return
000026F2                          2954  
000026F2                          2955  enter_addr_edit_all_exit:
000026F2                          2956  
000026F2  4E75                    2957          RTS                             ;return
000026F4                          2958  
000026F4                          2959  *==============================================================================
000026F4                          2960  * ck_boundry - Check the size of the data characters input and determine
000026F4                          2961  *              if an odd number of characters was entered
000026F4                          2962  *
000026F4                          2963  * Parameters -
000026F4                          2964  *   Input   A1      The data that needs checked for odd length.
000026F4                          2965  *   Input   D1      The number of characters input     
000026F4                          2966  *   Output  D3      Returns '-1' when there is an odd length.
000026F4                          2967  *==============================================================================
000026F4                          2968  
000026F4                          2969  ck_boundry:
000026F4                          2970  
000026F4  4243                    2971          CLR.W       D3                  ;Clear the return
000026F6                          2972  
000026F6  B23C 0000               2973          CMP.B       #0,D1               ;Check for nothing entered
000026FA  6700 002E               2974          BEQ         ck_size_error       ;Number of characters entered must be 
000026FE                          2975                                          ;greater than 0  
000026FE                          2976          
000026FE                          2977          
000026FE                          2978          * The program will branch to ck_size_error if D1 is greater than #8        
000026FE  B23C 0008               2979          CMP.B       #8,D1               ;Check for more than 8 characters entered
00002702  6E00 0026               2980          BGT         ck_size_error       ;Number of characters entered must be less
00002706                          2981                                          ;than 9
00002706                          2982          
00002706  7402                    2983          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
00002708  82C2                    2984          DIVU        D2,D1               ;Divide address by 2
0000270A  4841                    2985          SWAP        D1                  ;get remainder
0000270C  B23C 0001               2986          CMP.B       #$01,D1             ;Check for remainder of 1
00002710  6700 0004               2987          BEQ         ck_boundry_error    ;Number of characters entered must be an 
00002714                          2988                                          ;even number   
00002714                          2989    
00002714  4E75                    2990          RTS                             ;return
00002716                          2991  
00002716                          2992  *------------------------------------------------------------------------------
00002716                          2993  * ck_boundry_error - An odd number of characters was entered
00002716                          2994  *                  - Load error message and display it
00002716                          2995  *                  - Return error condition
00002716                          2996  *------------------------------------------------------------------------------
00002716                          2997          
00002716                          2998  ck_boundry_error:
00002716                          2999  
00002716  43F9 00002BB1           3000          LEA         even_msg,A1         ;Load odd error message into A1
0000271C  2239 00002BB1           3001          MOVE.L      even_msg,D1         ;Load error length to D1
00002722                          3002          
00002722  7000                    3003          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00002724                          3004                                          ; n is D1.W with CR, LF. 
00002724  4E4F                    3005          TRAP #15                        ;Display the error message
00002726  76FF                    3006          MOVE.L #-1,D3                   ;Load -1 into return parameter
00002728  4E75                    3007          RTS                             ;Return
0000272A                          3008          
0000272A                          3009  *------------------------------------------------------------------------------
0000272A                          3010  * ck_size_error -   The number of characters entered must be more than zero
0000272A                          3011  *                  - Load error message and display it
0000272A                          3012  *                  - Return error condition
0000272A                          3013  *------------------------------------------------------------------------------
0000272A                          3014          
0000272A                          3015  ck_size_error:
0000272A                          3016  
0000272A  43F9 00002B24           3017          LEA         invalidMsg,A1       ;Load invalid range message into A1
00002730  2239 00002B24           3018          MOVE.L      invalidMsg,D1       ;Load error length to D1
00002736                          3019          
00002736  7000                    3020          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00002738                          3021                                          ; n is D1.W with CR, LF. 
00002738  4E4F                    3022          TRAP        #15                 ;Display the error message
0000273A  76FF                    3023          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000273C  4E75                    3024          RTS                             ;Return        
0000273E                          3025  
0000273E                          3026  
0000273E                          3027  *==============================================================================
0000273E                          3028  * parseHexString - Converts user input string into a valid memory address
0000273E                          3029  *                - Stores parsed address data into D3
0000273E                          3030  *                - Stores good/bad (1/0) data in D4 
0000273E                          3031  *
0000273E                          3032  * Hex values are stored as bytes in D2, the ASCII chart shows their value
0000273E                          3033  *   The ASCII chart values we care about are in the ranges of: 
0000273E                          3034  *                            Hex            Decimal
0000273E                          3035  *       No Value           NULL = 0         0
0000273E                          3036  *       Numeric Values:     0-9 = 30-39     48-57
0000273E                          3037  *       Upper Case letters: A-F = 41-46     65-70
0000273E                          3038  *       Lower Case letterc: a-f = 61-66     97-102
0000273E                          3039  
0000273E                          3040  * Parameters -
0000273E                          3041  *   Input   A1      The data that needs checked for valid input.
0000273E                          3042  *   Output  D3      The return value, '-1' for error
0000273E                          3043  *==============================================================================
0000273E                          3044  
0000273E                          3045  parseHexString:
0000273E                          3046  
0000273E                          3047  * setup any initializing item that do not get looped through
0000273E  4243                    3048          CLR.W       D3                  ;Clear the return
00002740                          3049  
00002740                          3050          
00002740                          3051  *------------------------------------------------------------------------------
00002740                          3052  * NextHex - Loop through all bytes and vaildate the input
00002740                          3053  * Parameters -
00002740                          3054  *   Input   A1      The data that needs checked for valid input.
00002740                          3055  *   Output  D3      The return value, '-1' for error
00002740                          3056  *------------------------------------------------------------------------------
00002740                          3057          
00002740                          3058  NextHex:
00002740                          3059  
00002740  1419                    3060          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00002742  B43C 0000               3061          CMP.B       #0,D2               ;Check character for null 
00002746  6700 0066               3062          BEQ         NextHexReturn       ;Character is null (end of input)
0000274A                          3063          
0000274A                          3064  *................................................................................
0000274A                          3065  *  Check decimal values 0-9 by testing hexadecimal values 30-39
0000274A                          3066  *................................................................................
0000274A                          3067                  
0000274A                          3068          * The program will branch to hex_range_error if D2 is less than #30
0000274A  B43C 0030               3069          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
0000274E  6D00 0048               3070          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00002752                          3071                                          ;processing
00002752                          3072          
00002752                          3073          * The program will branch to UcaseHex if D2 is greater than #39
00002752  B43C 0039               3074          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
00002756  6E00 000A               3075          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
0000275A                          3076          
0000275A                          3077          *a valid number was found within this range
0000275A  0402 0030               3078          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
0000275E  6000 0032               3079          BRA         NextHexDone         ;Done parsing this byte
00002762                          3080  
00002762                          3081  
00002762                          3082  *..............................................................................
00002762                          3083  *  Check upper case values A-F by testing hexadecimal values 41-46
00002762                          3084  *..............................................................................
00002762                          3085  
00002762                          3086  UcaseHex:
00002762                          3087  
00002762                          3088          * The program will branch to hex_range_error if D2 is less than #41
00002762  B43C 0041               3089          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
00002766  6D00 0030               3090          BLT         hex_range_error     ;Branch to handle range error hexidecimal
0000276A                          3091                                          ;processing
0000276A                          3092          
0000276A  B43C 0046               3093          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
0000276E  6E00 000A               3094          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
00002772                          3095                                          ;processing
00002772                          3096          
00002772                          3097          *a valid number was found within this range
00002772  0402 0037               3098          SUBI.B      #55,D2              ;Change uppercase character to actual value
00002776  6000 001A               3099          BRA         NextHexDone         ;Done parsing this byte
0000277A                          3100  
0000277A                          3101  
0000277A                          3102  *..............................................................................
0000277A                          3103  *  Check lower case values a-f by testing hexadecimal values 61-66
0000277A                          3104  *..............................................................................
0000277A                          3105  
0000277A                          3106  LcaseHex
0000277A                          3107          
0000277A                          3108          * The program will branch to hex_range_error if D2 is less than #61
0000277A  B43C 0061               3109          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
0000277E  6D00 0018               3110          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
00002782                          3111                                          ;processing
00002782                          3112  
00002782  B43C 0066               3113          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
00002786  6E00 0010               3114          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
0000278A                          3115                                          ;processing
0000278A                          3116  
0000278A                          3117          *a valid number was found within this range
0000278A  0402 0057               3118          SUBI.B      #87,D2              ;Change lowercase character to actual value
0000278E  6000 0002               3119          BRA         NextHexDone         ;Done parsing this byte
00002792                          3120  
00002792                          3121  NextHexDone:
00002792                          3122  
00002792  E983                    3123          ASL.L       #4,D3               ; Make rooom for new byte in the return register
00002794  D602                    3124          ADD.B       D2,D3               ; Move the new byte into the return register
00002796  60A8                    3125          BRA         NextHex             ; We're ready to parse the next byte
00002798                          3126          
00002798                          3127  *-------------------------------------------------------------------------------------
00002798                          3128  * hex_range_error -  A character entered was within the valid range for a hex address
00002798                          3129  *                 -  Load error message and display it
00002798                          3130  *                 -  Return error condition
00002798                          3131  *-------------------------------------------------------------------------------------
00002798                          3132          
00002798                          3133  hex_range_error:
00002798                          3134  
00002798  43F9 00002B69           3135          LEA         invCharMsg,A1       ;Load invalid range message into A1
0000279E  2239 00002B69           3136          MOVE.L      invCharMsg,D1       ;Load error length to D1
000027A4                          3137          
000027A4  7000                    3138          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
000027A6                          3139                                          ; n is D1.W with CR, LF. 
000027A6  4E4F                    3140          TRAP        #15                 ;Display the error message
000027A8  76FF                    3141          MOVE.L      #-1,D3              ;Load -1 into return parameter
000027AA  6000 0002               3142          BRA         NextHexReturn
000027AE                          3143          
000027AE                          3144  NextHexReturn:
000027AE                          3145          
000027AE  4E75                    3146          RTS                             ;Return      
000027B0                          3147  
000027B0                          3148  
000027B0                          3149  *===============================================================================
000027B0                          3150  * ck_addr_range - check the address input is within a valid memory address range
000027B0                          3151  *                - Parsed address data into D3
000027B0                          3152  *
000027B0                          3153  * Parameters -
000027B0                          3154  *   Input   A1      The data that needs checked for valid address.
000027B0                          3155  *   Output  D3      The return value, '-1' for error
000027B0                          3156  *===============================================================================
000027B0                          3157  
000027B0                          3158  
000027B0                          3159  ck_addr_range:   
000027B0                          3160  
000027B0                          3161  *------------------------------------------------------------------------------
000027B0                          3162  * Verify that the address entered is witin the 
000027B0                          3163  * beginning range ('begin') as defined in the Equate
000027B0                          3164  *------------------------------------------------------------------------------   
000027B0                          3165              
000027B0  2C3C 00005001           3166          MOVE.L      #begin,D6           * Load minimum starting address
000027B6  B686                    3167          CMP.L       D6,D3               * Is input at or above minimum?
000027B8  6D00 0012               3168          BLT         ck_addr_range_error 
000027BC                          3169          
000027BC                          3170  *------------------------------------------------------------------------------
000027BC                          3171  * Verify that the address entered is witin the 
000027BC                          3172  * ending range ('end') as defined in the Equate
000027BC                          3173  *------------------------------------------------------------------------------
000027BC                          3174          
000027BC  2C3C 00FFFFFE           3175          MOVE.L      #end,D6             * Load maximum starting address
000027C2  B686                    3176          CMP.L       D6,D3               * Is input at or below maximum?
000027C4  6E00 0006               3177          BGT         ck_addr_range_error 
000027C8  6000 0012               3178          BRA         ck_addr_done        ;done checking
000027CC                          3179          
000027CC                          3180  *..............................................................................
000027CC                          3181  * ck_addr_range_error -  A address entered is not within the 
000027CC                          3182  *                        valid range for a hex address
000027CC                          3183  *..............................................................................
000027CC                          3184          
000027CC                          3185  ck_addr_range_error
000027CC                          3186  
000027CC  43F9 00002B24           3187          LEA         invalidMsg,A1       ;Load invalid range message into A1
000027D2                          3188          
000027D2  700D                    3189          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
000027D4                          3190                                          ;with CR, LF. 
000027D4  4E4F                    3191          TRAP        #15                 ;Display the error message
000027D6  76FF                    3192          MOVE.L      #-1,D3              ;Load -1 into return parameter
000027D8  6000 0002               3193          BRA         ck_addr_done 
000027DC                          3194  
000027DC                          3195  ck_addr_done:
000027DC                          3196  
000027DC  4E75                    3197          RTS                             ;Return
000027DE                          3198  
000027DE                          3199  *******************************************************************************
000027DE                          3200  *                          OP CODE ROLE ROUTINES
000027DE                          3201  *******************************************************************************
000027DE                          3202  
000027DE                          3203  process_op_codes:
000027DE                          3204  
000027DE                          3205  
000027DE                          3206  
000027DE                          3207  process_op_codes_exit:
000027DE                          3208  
000027DE  4E75                    3209          RTS
000027E0                          3210  
000027E0                          3211  
000027E0                          3212  *******************************************************************************
000027E0                          3213  *                    Effective Addressing ROLE ROUTINES
000027E0                          3214  *******************************************************************************
000027E0                          3215  
000027E0                          3216  Get_Effective_Address:
000027E0                          3217  
000027E0  48E7 0200               3218          MOVEM.L D6,-(SP)                ;save D6 data
000027E4  1C05                    3219          MOVE.B      D5,D6
000027E6  E60E                    3220          LSR.B       #3,D6               ;mode
000027E8  CA3C 0007               3221          And.B       #%00000111,D5       ;register
000027EC                          3222          
000027EC  BC3C 0000               3223          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
000027F0  6700 004A               3224          BEQ         Data_Reg_Direct
000027F4                          3225          
000027F4  BC3C 0001               3226          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
000027F8  6700 005C               3227          BEQ         Addr_Reg_Direct
000027FC                          3228          
000027FC  BC3C 0002               3229          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
00002800  6700 006E               3230          BEQ         Addr_Reg_Indirect
00002804                          3231          
00002804  BC3C 0003               3232          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
00002808  6700 0098               3233          BEQ         Addr_Reg_Indirect_Inc
0000280C                          3234          
0000280C  BC3C 0004               3235          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
00002810  6700 00CE               3236          BEQ         Addr_Reg_Indirect_Dec
00002814                          3237          
00002814  BC3C 0007               3238          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
00002818  6700 0006               3239          BEQ         Get_Effective_Address_Other
0000281C                          3240          
0000281C  6000 015A               3241          BRA         invalidEA
00002820                          3242          
00002820                          3243  Get_Effective_Address_Other:        
00002820                          3244          
00002820  BA3C 0000               3245          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00002824  6700 00F8               3246          BEQ Addr_Abs_Short
00002828                          3247          
00002828  BA3C 0001               3248          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
0000282C  6700 010A               3249          BEQ Addr_Abs_Long
00002830                          3250          
00002830  BA3C 0004               3251          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
00002834  6700 011C               3252          BEQ Addr_Immediate_Data
00002838                          3253          
00002838  6000 013E               3254          BRA         invalidEA
0000283C                          3255          
0000283C                          3256  Data_Reg_Direct:                        ;case 0(0000)
0000283C                          3257  
0000283C  43F9 00002D33           3258          LEA         letterD,A1          ;output 'D' for data register
00002842  103C 000E               3259          MOVE.B      #14,D0              ;set for task to display null terminated 
00002846  4E4F                    3260          TRAP        #15                 ;string without CR, LF
00002848                          3261                          
00002848  4281                    3262          CLR.L       D1
0000284A  1205                    3263          MOVE.B      D5,D1               ;move register number for display into D1
0000284C  103C 0003               3264          MOVE.B      #3,D0               ;set for task to display null terminated 
00002850  4E4F                    3265          TRAP        #15                 ;string without CR, LF
00002852                          3266                 
00002852  6000 0124               3267          BRA         Get_Effective_Address_Exit  ;return
00002856                          3268          
00002856                          3269          
00002856                          3270  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
00002856                          3271        
00002856  43F9 00002D31           3272          LEA         letterA,A1          ;output 'A' for address register
0000285C  103C 000E               3273          MOVE.B      #14,D0              ;set for task to display null terminated 
00002860  4E4F                    3274          TRAP        #15                 ;string without CR, LF
00002862                          3275          
00002862  4281                    3276          CLR.L       D1
00002864  1205                    3277          MOVE.B      D5,D1               ;move register number for display into D1
00002866  103C 0003               3278          MOVE.B      #3,D0               ;set for task to display null terminated 
0000286A  4E4F                    3279          TRAP        #15                 ;string without CR, LF
0000286C                          3280          
0000286C  6000 010A               3281          BRA         Get_Effective_Address_Exit  ;return
00002870                          3282  
00002870                          3283  
00002870                          3284  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
00002870                          3285          
00002870  43F9 00002D39           3286          LEA         lprn,A1             ;output 'D' for data register
00002876  103C 000E               3287          MOVE.B      #14,D0              ;set for task to display null terminated 
0000287A  4E4F                    3288          TRAP        #15                 ;string without CR, LF
0000287C                          3289  
0000287C  43F9 00002D31           3290          LEA         letterA,A1          ;output 'A' for address register
00002882  103C 000E               3291          MOVE.B      #14,D0              ;set for task to display null terminated 
00002886  4E4F                    3292          TRAP        #15                 ;string without CR, LF
00002888                          3293          
00002888  4281                    3294          CLR.L       D1
0000288A  1205                    3295          MOVE.B      D5,D1               ;move register number for display into D1
0000288C  103C 0003               3296          MOVE.B      #3,D0               ;set for task to display null terminated 
00002890  4E4F                    3297          TRAP        #15                 ;string without CR, LF
00002892                          3298  
00002892  43F9 00002D3B           3299          LEA         rprn,A1             ;output 'D' for data register
00002898  103C 000E               3300          MOVE.B      #14,D0              ;set for task to display null terminated 
0000289C  4E4F                    3301          TRAP        #15                 ;string without CR, LF
0000289E                          3302          
0000289E  6000 00D8               3303          BRA         Get_Effective_Address_Exit  ;return
000028A2                          3304  
000028A2                          3305                 
000028A2                          3306  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
000028A2                          3307  
000028A2  43F9 00002D39           3308          LEA         lprn,A1             ;output 'D' for data register
000028A8  103C 000E               3309          MOVE.B      #14,D0              ;set for task to display null terminated 
000028AC  4E4F                    3310          TRAP        #15                 ;string without CR, LF
000028AE                          3311  
000028AE  43F9 00002D31           3312          LEA         letterA,A1          ;output 'A' for address register
000028B4  103C 000E               3313          MOVE.B      #14,D0              ;set for task to display null terminated 
000028B8  4E4F                    3314          TRAP        #15                 ;string without CR, LF
000028BA                          3315          
000028BA  4281                    3316          CLR.L       D1
000028BC  1205                    3317          MOVE.B      D5,D1               ;move register number for display into D1
000028BE  103C 0003               3318          MOVE.B      #3,D0               ;set for task to display null terminated 
000028C2  4E4F                    3319          TRAP        #15                 ;string without CR, LF
000028C4                          3320  
000028C4  43F9 00002D3B           3321          LEA         rprn,A1             ;output 'D' for data register
000028CA  103C 000E               3322          MOVE.B      #14,D0              ;set for task to display null terminated 
000028CE  4E4F                    3323          TRAP        #15                 ;string without CR, LF
000028D0                          3324          
000028D0  43F9 00002D35           3325          LEA         plus,A1             ;output 'D' for data register
000028D6  103C 000E               3326          MOVE.B      #14,D0              ;set for task to display null terminated 
000028DA  4E4F                    3327          TRAP        #15                 ;string without CR, LF
000028DC                          3328          
000028DC  6000 009A               3329          BRA         Get_Effective_Address_Exit  ;return
000028E0                          3330  
000028E0                          3331  Addr_Reg_Indirect_Dec                   ;4 = ?(An) - Address Register Indirect with Predecrement (100)
000028E0                          3332  
000028E0  43F9 00002D37           3333          LEA         minus,A1            ;output '-' for Predecrement
000028E6  103C 000E               3334          MOVE.B      #14,D0              ;set for task to display null terminated 
000028EA  4E4F                    3335          TRAP        #15                 ;string without CR, LF
000028EC                          3336  
000028EC  43F9 00002D39           3337          LEA         lprn,A1             ;output 'D' for data register
000028F2  103C 000E               3338          MOVE.B      #14,D0              ;set for task to display null terminated 
000028F6  4E4F                    3339          TRAP        #15                 ;string without CR, LF
000028F8                          3340  
000028F8  43F9 00002D31           3341          LEA         letterA,A1          ;output 'A' for address register
000028FE  103C 000E               3342          MOVE.B      #14,D0              ;set for task to display null terminated 
00002902  4E4F                    3343          TRAP        #15                 ;string without CR, LF
00002904                          3344          
00002904  4281                    3345          CLR.L       D1
00002906  1205                    3346          MOVE.B      D5,D1               ;move register number for display into D1
00002908  103C 0003               3347          MOVE.B      #3,D0               ;set for task to display null terminated 
0000290C  4E4F                    3348          TRAP        #15                 ;string without CR, LF
0000290E                          3349  
0000290E  43F9 00002D3B           3350          LEA         rprn,A1             ;output 'D' for data register
00002914  103C 000E               3351          MOVE.B      #14,D0              ;set for task to display null terminated 
00002918  4E4F                    3352          TRAP        #15                 ;string without CR, LF
0000291A                          3353          
0000291A  6000 005C               3354          BRA         Get_Effective_Address_Exit  ;return
0000291E                          3355          
0000291E                          3356                         
0000291E                          3357  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
0000291E                          3358          
0000291E                          3359          
0000291E  548B                    3360          ADDA.L      #word,A3            ;move past instruction
00002920                          3361          
00002920                          3362          ;print word (A3)
00002920  48E7 1200               3363          MOVEM.L D6/D3,-(SP)
00002924  1C3C 0001               3364          MOVE.B #1,D6                    ;put size of word in D6
00002928  3613                    3365          MOVE.W (A3),D3                  ;move data at (A3) to D3
0000292A  6100 00D8               3366          BSR outputHex
0000292E  4CDF 0048               3367          MOVEM.L (SP)+,D6/D3
00002932                          3368          
00002932  5487                    3369          ADDI.L      #word,D7 
00002934  6000 0042               3370          BRA         Get_Effective_Address_Exit  ;return
00002938                          3371                         
00002938                          3372  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
00002938                          3373          
00002938                          3374          ;LEA         xxxL,A1             ;output 'D' for data register
00002938                          3375          ;MOVE.B      #14,D0              ;set for task to display null terminated 
00002938                          3376          ;TRAP        #15                 ;string without CR, LF
00002938                          3377  
00002938  548B                    3378          ADDA.L      #word,A3
0000293A                          3379          
0000293A                          3380          ;print long (A3)
0000293A  48E7 1200               3381          MOVEM.L D6/D3,-(SP)
0000293E  1C3C 0002               3382          MOVE.B #2,D6                    ;put size of word in D6
00002942  2613                    3383          MOVE.L (A3),D3                  ;move data at (A3) to D3
00002944  6100 00BE               3384          BSR outputHex
00002948  4CDF 0048               3385          MOVEM.L (SP)+,D6/D3
0000294C                          3386  
0000294C                          3387          
0000294C  5887                    3388          ADDI.L      #long,D7
0000294E  6000 0028               3389          BRA         Get_Effective_Address_Exit  ;return
00002952                          3390                         
00002952                          3391  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
00002952                          3392  
00002952                          3393  *        LEA         iData,A1            ;output 'D' for data register
00002952                          3394  *        MOVE.B      #14,D0              ;set for task to display null terminated 
00002952                          3395  *        TRAP        #15                 ;string without CR, LF
00002952                          3396          
00002952  4CDF 0040               3397          MOVEM.L (SP)+,D6                 ;restore D6 data
00002956  48E7 0200               3398          MOVEM.L D6,-(SP)                 ;save D6 data again to balance stack
0000295A                          3399  
0000295A                          3400          ;print '#'
0000295A  48E7 4000               3401          MOVEM.L D1,-(SP)                ;save D1 to the stack
0000295E  123C 0023               3402          MOVE.B #'#',D1                  ;put ascii value of char in D1
00002962  103C 0006               3403          MOVE.B #6,D0                    ;move task 6 into D0
00002966  4E4F                    3404          TRAP #15                        ;print char
00002968  4CDF 0002               3405          MOVEM.L (SP)+,D1                ;pull D1 off the stack
0000296C                          3406          
0000296C  0C06 0001               3407          CMPI.B #1,D6
00002970  6FAC                    3408          BLE Addr_Abs_Short
00002972  6EC4                    3409          BGT Addr_Abs_Long
00002974                          3410          
00002974  6000 0002               3411          BRA         Get_Effective_Address_Exit  ;return
00002978                          3412  
00002978                          3413  invalidEA:
00002978                          3414  
00002978                          3415          ;do something
00002978                          3416   
00002978                          3417  Get_Effective_Address_Exit:     
00002978                          3418  
00002978  4CDF 0040               3419          MOVEM.L (SP)+,D6                 ;restore D6 data
0000297C  4E75                    3420          RTS                             ;return
0000297E                          3421  
0000297E                          3422  ***assume size in D6. 00 = byte, 01 = word, 10 = long
0000297E                          3423  printSize:
0000297E  48E7 C000               3424          MOVEM.L D0/D1,-(SP)
00002982                          3425          
00002982                          3426          ;print '.'
00002982  48E7 4000               3427          MOVEM.L D1,-(SP)                ;save D1 to the stack
00002986  123C 002E               3428          MOVE.B #'.',D1                  ;put ascii value of char in D1
0000298A  103C 0006               3429          MOVE.B #6,D0                    ;move task 6 into D0
0000298E  4E4F                    3430          TRAP #15                        ;print char
00002990  4CDF 0002               3431          MOVEM.L (SP)+,D1                ;pull D1 off the stack
00002994                          3432          
00002994  0C06 0001               3433          CMPI.B #1,D6
00002998  6D00 0022               3434          BLT printByteSize
0000299C  6700 0032               3435          BEQ printWordSize
000029A0  6E00 0042               3436          BGT printLongSize
000029A4                          3437  printSizeDone:
000029A4                          3438          ;print ' '
000029A4  48E7 4000               3439          MOVEM.L D1,-(SP)                ;save D1 to the stack
000029A8  123C 0020               3440          MOVE.B #' ',D1                  ;put ascii value of char in D1
000029AC  103C 0006               3441          MOVE.B #6,D0                    ;move task 6 into D0
000029B0  4E4F                    3442          TRAP #15                        ;print char
000029B2  4CDF 0002               3443          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000029B6                          3444          
000029B6  4CDF 0003               3445          MOVEM.L (SP)+,D0/D1
000029BA  4E75                    3446          RTS
000029BC                          3447          
000029BC                          3448  printByteSize:
000029BC                          3449          ;print 'B'
000029BC  48E7 4000               3450          MOVEM.L D1,-(SP)                ;save D1 to the stack
000029C0  123C 0042               3451          MOVE.B #'B',D1                  ;put ascii value of char in D1
000029C4  103C 0006               3452          MOVE.B #6,D0                    ;move task 6 into D0
000029C8  4E4F                    3453          TRAP #15                        ;print char
000029CA  4CDF 0002               3454          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000029CE  60D4                    3455          BRA printSizeDone
000029D0                          3456          
000029D0                          3457  printWordSize:
000029D0                          3458          ;print 'W'
000029D0  48E7 4000               3459          MOVEM.L D1,-(SP)                ;save D1 to the stack
000029D4  123C 0057               3460          MOVE.B #'W',D1                  ;put ascii value of char in D1
000029D8  103C 0006               3461          MOVE.B #6,D0                    ;move task 6 into D0
000029DC  4E4F                    3462          TRAP #15                        ;print char
000029DE  4CDF 0002               3463          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000029E2  60C0                    3464          BRA printSizeDone
000029E4                          3465  
000029E4                          3466  printLongSize:
000029E4                          3467          ;print 'L'
000029E4  48E7 4000               3468          MOVEM.L D1,-(SP)                ;save D1 to the stack
000029E8  123C 004C               3469          MOVE.B #'L',D1                  ;put ascii value of char in D1
000029EC  103C 0006               3470          MOVE.B #6,D0                    ;move task 6 into D0
000029F0  4E4F                    3471          TRAP #15                        ;print char
000029F2  4CDF 0002               3472          MOVEM.L (SP)+,D1                ;pull D1 off the stack
000029F6  60AC                    3473          BRA printSizeDone       
000029F8                          3474          
000029F8                          3475  
000029F8                          3476  ***assume hex to print is in D3***
000029F8                          3477  ***assume size in D6. 00 = byte, 01 = word, 10 = long
000029F8                          3478  
000029F8= 00000000 00000000 ...   3479  hexoutputbuffer DC.L 0,0,0
00002A04                          3480  
00002A04                          3481  outputHex:
00002A04  48E7 B248               3482          MOVEM.L D0/D2/D3/D6/A1/A4,-(SP)
00002A08  49F8 29F8               3483          LEA hexoutputbuffer,A4
00002A0C  0C06 0001               3484          CMPI.B #1,D6
00002A10  6D00 006A               3485          BLT hexByte
00002A14  6700 004C               3486          BEQ hexWord
00002A18  6E00 0016               3487          BGT hexLong
00002A1C                          3488  outputHexDone:
00002A1C  18BC 0000               3489          MOVE.B #0,(A4)
00002A20                          3490          
00002A20                          3491          ;output string of hex
00002A20  103C 000E               3492          MOVE.B #14,D0
00002A24  43F8 29F8               3493          LEA hexoutputbuffer,A1
00002A28  4E4F                    3494          TRAP #15
00002A2A  4CDF 124D               3495          MOVEM.L (SP)+ ,D0/D2/D3/D6/A1/A4
00002A2E  4E75                    3496          RTS
00002A30                          3497          
00002A30                          3498  hexLong:
00002A30  E99B                    3499          ROL.L #4,D3
00002A32  6100 0056               3500          BSR convertHexToASCII
00002A36  E99B                    3501          ROL.L #4,D3
00002A38  6100 0050               3502          BSR convertHexToASCII
00002A3C  E99B                    3503          ROL.L #4,D3
00002A3E  6100 004A               3504          BSR convertHexToASCII
00002A42  E99B                    3505          ROL.L #4,D3
00002A44  6100 0044               3506          BSR convertHexToASCII
00002A48  E99B                    3507          ROL.L #4,D3
00002A4A  6100 003E               3508          BSR convertHexToASCII
00002A4E  E99B                    3509          ROL.L #4,D3
00002A50  6100 0038               3510          BSR convertHexToASCII
00002A54  E99B                    3511          ROL.L #4,D3
00002A56  6100 0032               3512          BSR convertHexToASCII
00002A5A  E99B                    3513          ROL.L #4,D3
00002A5C  6100 002C               3514          BSR convertHexToASCII
00002A60                          3515          
00002A60  60BA                    3516          BRA outputHexDone
00002A62                          3517          
00002A62                          3518  hexWord:
00002A62  E95B                    3519          ROL.W #4,D3
00002A64  6100 0024               3520          BSR convertHexToASCII
00002A68  E95B                    3521          ROL.W #4,D3
00002A6A  6100 001E               3522          BSR convertHexToASCII
00002A6E  E95B                    3523          ROL.W #4,D3
00002A70  6100 0018               3524          BSR convertHexToASCII
00002A74  E95B                    3525          ROL.W #4,D3
00002A76  6100 0012               3526          BSR convertHexToASCII
00002A7A                          3527  
00002A7A  60A0                    3528          BRA outputHexDone
00002A7C                          3529          
00002A7C                          3530  hexByte:
00002A7C  E91B                    3531          ROL.B #4,D3
00002A7E  6100 000A               3532          BSR convertHexToASCII
00002A82  E91B                    3533          ROL.B #4,D3
00002A84  6100 0004               3534          BSR convertHexToASCII
00002A88                          3535          
00002A88  6092                    3536          BRA outputHexDone
00002A8A                          3537          
00002A8A                          3538  convertHexToASCII:
00002A8A  1403                    3539          MOVE.B D3,D2
00002A8C  0202 000F               3540          ANDI.B #%00001111,D2            ;mask out all but hex at least significant nyb
00002A90  0C02 0009               3541          CMPI.B #9,D2
00002A94  6F00 0006               3542          BLE Number
00002A98  6000 000A               3543          BRA Letter       
00002A9C                          3544  
00002A9C                          3545  Number:
00002A9C  0602 0030               3546          ADDI.B #'0',D2
00002AA0  18C2                    3547          MOVE.B D2,(A4)+
00002AA2  4E75                    3548          RTS
00002AA4                          3549          
00002AA4                          3550  Letter:
00002AA4  0402 000A               3551          SUBI.B #$A,D2
00002AA8  0602 0041               3552          ADDI.B #'A',D2
00002AAC  18C2                    3553          MOVE.B D2,(A4)+
00002AAE  4E75                    3554          RTS
00002AB0                          3555  
00002AB0                          3556  
00002AB0                          3557  
00002AB0                          3558  switchModeAndReg:
00002AB0                          3559  ***
00002AB0                          3560  * Assumed in D2
00002AB0                          3561  *
00002AB0                          3562  * Assumed that they are in least significant byte:
00002AB0                          3563  *
00002AB0                          3564  *            _this_
00002AB0                          3565  *           /      \
00002AB0                          3566  *  ........ ........
00002AB0                          3567  *  \                /
00002AB0                          3568  *   -----word-------
00002AB0                          3569  *
00002AB0                          3570  *  and that in that byte they are ordered:
00002AB0                          3571  *
00002AB0                          3572  *       ........   
00002AB0                          3573  *       \/\_/\_/
00002AB0                          3574  *      /  /    \
00002AB0                          3575  *    /   /      \
00002AB0                          3576  * dont  one    other
00002AB0                          3577  * care
00002AB0                          3578  *
00002AB0                          3579  * after they will be
00002AB0                          3580  *
00002AB0                          3581  *       ........   
00002AB0                          3582  *       \/\_/\_/
00002AB0                          3583  *      /  /    \
00002AB0                          3584  *    /   /      \
00002AB0                          3585  * dont other    one
00002AB0                          3586  * care
00002AB0                          3587  *** 
00002AB0  0202 003F               3588          AndI.B #%00111111,D2            ;remove unwanted bits from D2
00002AB4  0283 00000000           3589          ANDI.L #0,D3                    ;clear D3
00002ABA  1602                    3590          MOVE.B D2,D3                    ;copy to D3
00002ABC  E70B                    3591          LSL.B  #3,D3 
00002ABE  E60A                    3592          LSR.B  #3,D2
00002AC0  D403                    3593          ADD.B  D3,D2
00002AC2  4E75                    3594          RTS
00002AC4                          3595  
00002AC4                          3596          
00002AC4                          3597  *==============================================================================
00002AC4                          3598  *                            variables and constants
00002AC4                          3599  *==============================================================================
00002AC4                          3600  
00002AC4                          3601  
00002AC4                          3602  ***initial user prompt stuff        
00002AC4= 45 6E 74 65 72 20 ...   3603  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE: $',0
00002AF5= 45 6E 74 65 72 20 ...   3604  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE: $',0
00002B24                          3605  
00002B24= 20 41 64 64 72 65 ...   3606  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
00002B69= 20 41 20 43 68 61 ...   3607  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
00002BB1                          3608  
00002BB1= 20 59 6F 75 20 6D ...   3609  even_msg        DC.B    ' You must enter an even address!'
00002BD1                          3610  
00002BD1= 20                      3611  spc             DC.B    ' '
00002BD2= 01                      3612  spc_len         DC.B    spc_len-spc
00002BD3                          3613  ***
00002BD3                          3614  
00002BD3                          3615  
00002BD3                          3616  
00002BD3                          3617  ***list of OP codes
00002BD3                          3618  
00002BD3  =00000040               3619  moveaInstruction EQU %0000000001000000
00002BD3  =0000B000               3620  eorInstruction   EQU %1011000000000000
00002BD3  =0000B000               3621  cmpInstruction   EQU %1011000000000000
00002BD3  =00008000               3622  orInstruction    EQU %1000000000000000
00002BD3  =00000880               3623  bclrdataInstruction EQU %0000100010000000
00002BD3  =00000180               3624  bclrInstruction  EQU %0000000110000000
00002BD3  =000041C0               3625  leaInstruction   EQU %0100000111000000
00002BD3  =000081C0               3626  divsInstruction  EQU %1000000111000000
00002BD3  =0000C1C0               3627  mulsInstruction  EQU %1100000111000000
00002BD3  =0000E6C0               3628  rsrlweaInstruction  EQU %1110011011000000
00002BD3  =0000E018               3629  rsrlregInstruction  EQU %1110000000011000
00002BD3  =0000E0C0               3630  asrlweaInstruction  EQU %1110000011000000
00002BD3  =0000E000               3631  asrlregInstruction  EQU %1110000000000000
00002BD3  =0000E2C0               3632  lsrlweaInstruction  EQU %1110001011000000
00002BD3  =0000E008               3633  lsrlregInstruction  EQU %1110000000001000
00002BD3  =00005100               3634  subqInstruction  EQU %0101000100000000
00002BD3  =00009000               3635  subInstruction   EQU %1001000000000000
00002BD3  =0000D000               3636  addaInstruction  EQU %1101000000000000
00002BD3  =0000D000               3637  addInstruction   EQU %1101000000000000
00002BD3  =00004880               3638  movemInstruction EQU %0100100010000000
00002BD3  =00000600               3639  addiInstruction  EQU %0000011000000000
00002BD3  =00000000               3640  oriInstruction   EQU 0
00002BD3  =00000C00               3641  cmpiInstruction  EQU %0000110000000000
00002BD3  =00004E80               3642  jsrInstruction   EQU %0100111010000000
00002BD3  =00004E75               3643  rtsInstruction   EQU %0100111001110101
00002BD3  =00004E71               3644  NoOpInstruction  EQU %0100111001110001
00002BD3  =00000000               3645  moveInstruction  EQU 0
00002BD3  =00006000               3646  bccInstruction   EQU %0110000000000000
00002BD3  =00004400               3647  negInstruction   EQU %0100010000000000
00002BD3  =00000000               3648  dataInstruction  EQU 0
00002BD3                          3649  
00002BD3                          3650  ***
00002BD3                          3651  
00002BD3                          3652  ***list of OP masks
00002BD3                          3653  
00002BD3  =0000C1C0               3654  moveaMask EQU %1100000111000000
00002BD3  =0000F000               3655  eorMask   EQU %1111000000000000
00002BD3  =0000F000               3656  cmpMask   EQU %1111000000000000
00002BD3  =0000F000               3657  orMask    EQU %1111000000000000
00002BD3  =0000FFC0               3658  bclrdataMask EQU %1111111111000000
00002BD3  =0000F1C0               3659  bclrMask  EQU %1111000111000000
00002BD3  =0000F1C0               3660  leaMask   EQU %1111000111000000
00002BD3  =0000F1C0               3661  divsMask  EQU %1111000111000000
00002BD3  =0000F1C0               3662  mulsMask  EQU %1111000111000000
00002BD3  =0000FEC0               3663  rsrlweaMask  EQU %1111111011000000
00002BD3  =0000F018               3664  rsrlregMask  EQU %1111000000011000
00002BD3  =0000FEC0               3665  asrlweaMask  EQU %1111111011000000
00002BD3  =0000F018               3666  asrlregMask  EQU %1111000000011000
00002BD3  =0000FEC0               3667  lsrlweaMask  EQU %1111111011000000
00002BD3  =0000F018               3668  lsrlregMask  EQU %1111000000011000
00002BD3  =0000F100               3669  subqMask  EQU %1111000100000000
00002BD3  =0000F000               3670  subMask   EQU %1111000000000000
00002BD3  =0000F000               3671  addaMask  EQU %1111000000000000
00002BD3  =0000F000               3672  addMask   EQU %1111000000000000
00002BD3  =0000FB80               3673  movemMask EQU %1111101110000000
00002BD3  =0000FF00               3674  addiMask  EQU %1111111100000000
00002BD3  =0000FF00               3675  oriMask   EQU %1111111100000000
00002BD3  =0000FF00               3676  cmpiMask  EQU %1111111100000000
00002BD3  =0000FFC0               3677  jsrMask   EQU %1111111111000000
00002BD3  =0000FFFF               3678  rtsMask   EQU $FFFF
00002BD3  =0000FFFF               3679  NoOpMask  EQU $FFFF
00002BD3  =0000C000               3680  moveMask  EQU $C000
00002BD3  =0000F000               3681  bccMask   EQU $F000
00002BD3  =0000FF00               3682  negMask   EQU $FF00
00002BD3  =00000000               3683  dataMask  EQU 0
00002BD3                          3684  ***
00002BD3                          3685  
00002BD3                          3686  ***Bcc Codes***
00002BD3  =00000004               3687  CC EQU $04
00002BD3  =00000005               3688  CS EQU $05
00002BD3  =00000007               3689  EQ EQU $07
00002BD3  =0000000C               3690  GE EQU $0C
00002BD3  =0000000E               3691  GT EQU $0E
00002BD3  =00000002               3692  HI EQU $02
00002BD3  =0000000F               3693  LE EQU $0F
00002BD3  =00000003               3694  LS EQU $03
00002BD3  =0000000D               3695  LT EQU $0D
00002BD3  =0000000B               3696  MI EQU $0B
00002BD3  =00000006               3697  NE EQU $06
00002BD3  =0000000A               3698  PL EQU $0A
00002BD3  =00000008               3699  VC EQU $08
00002BD3  =00000009               3700  VS EQU $09
00002BD3  =00000000               3701  RA EQU $00 ;not really a Condition Code
00002BD3  =00000001               3702  SR EQU $01 ;not really a Condition Code
00002BD3                          3703  
00002BD3= 43 43 20 00             3704  CCm DC.B 'CC ',0
00002BD7= 43 53 20 00             3705  CSm DC.B 'CS ',0
00002BDB= 45 51 20 00             3706  EQm DC.B 'EQ ',0
00002BDF= 47 45 20 00             3707  GEm DC.B 'GE ',0
00002BE3= 47 54 20 00             3708  GTm DC.B 'GT ',0
00002BE7= 48 49 20 00             3709  HIm DC.B 'HI ',0
00002BEB= 4C 45 20 00             3710  LEm DC.B 'LE ',0
00002BEF= 4C 53 20 00             3711  LSm DC.B 'LS ',0
00002BF3= 4C 54 20 00             3712  LTm DC.B 'LT ',0
00002BF7= 4D 49 20 00             3713  MIm DC.B 'MI ',0
00002BFB= 4E 45 20 00             3714  NEm DC.B 'NE ',0
00002BFF= 50 4C 20 00             3715  PLm DC.B 'PL ',0
00002C03= 56 43 20 00             3716  VCm DC.B 'VC ',0
00002C07= 56 53 20 00             3717  VSm DC.B 'VS ',0
00002C0B= 52 41 20 00             3718  RAm DC.B 'RA ',0
00002C0F= 53 52 20 00             3719  SRm DC.B 'SR ',0
00002C13                          3720  
00002C13= 01 04 05 07 0C 0E ...   3721  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
00002C24= 00002C0F 00002BD3 ...   3722  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
00002C64                          3723  ***
00002C64                          3724  
00002C64= 45 6E 74 65 72 20 ...   3725  startLocationPrompt DC.B    'Enter start location',0
00002C79= 45 6E 74 65 72 20 ...   3726  endLocationPrompt   DC.B    'Enter end location',0
00002C8C                          3727  
00002C8C= 0D 0A 00                3728  clearLine  DC.B $0D,$0A,0
00002C8F                          3729  
00002C8F= 45 4F 52 00             3730  eorMessage      DC.B 'EOR',0
00002C93= 43 4D 50 00             3731  cmpMessage      DC.B 'CMP',0
00002C97= 4F 52 00                3732  orMessage       DC.B 'OR',0
00002C9A= 42 43 4C 52 20 00       3733  bclrMessage     DC.B 'BCLR ',0
00002CA0= 4C 45 41 20 00          3734  leaMessage      DC.B 'LEA ',0
00002CA5= 44 49 56 53 00          3735  divsMessage     DC.B 'DIVS',0
00002CAA= 4D 55 4C 53 00          3736  mulsMessage     DC.B 'MULS',0
00002CAF= 52 4F 4C 00             3737  rslMessage      DC.B 'ROL',0
00002CB3= 52 4F 52 00             3738  rsrMessage      DC.B 'ROR',0
00002CB7= 41 53 4C 00             3739  aslMessage      DC.B 'ASL',0
00002CBB= 41 53 52 00             3740  asrMessage      DC.B 'ASR',0
00002CBF= 4C 53 4C 00             3741  lslMessage      DC.B 'LSL',0
00002CC3= 4C 53 52 00             3742  lsrMessage      DC.B 'LSR',0
00002CC7= 53 55 42 51 00          3743  subqMessage     DC.B 'SUBQ',0
00002CCC= 53 55 42 00             3744  subMessage      DC.B 'SUB',0 
00002CD0= 41 44 44 41 00          3745  addaMessage     DC.B 'ADDA',0
00002CD5= 41 44 44 00             3746  addMessage      DC.B 'ADD',0
00002CD9= 4D 4F 56 45 4D 00       3747  movemMessage    DC.B 'MOVEM',0
00002CDF= 41 44 44 49 00          3748  addiMessage     DC.B 'ADDI',0
00002CE4= 4F 52 49 00             3749  oriMessage      DC.B 'ORI',0
00002CE8= 43 4D 50 49 00          3750  cmpiMessage     DC.B 'CMPI',0
00002CED= 4A 53 52 20 00          3751  jsrMessage      DC.B 'JSR ',0
00002CF2= 52 54 53 20 00          3752  rtsMessage      DC.B 'RTS ',0
00002CF7= 4E 4F 50 20 00          3753  nopMessage      DC.B 'NOP ',0 
00002CFC= 4D 4F 56 45 00          3754  moveMessage     DC.B 'MOVE',0
00002D01= 42 00                   3755  bccMessage      DC.B 'B',0
00002D03= 4E 45 47 00             3756  negMessage      DC.B 'NEG',0
00002D07= 44 41 54 41 20 00       3757  dataMessage     DC.B 'DATA ',0
00002D0D= 4D 4F 56 45 41 00       3758  moveaMessage    DC.B 'MOVEA',0
00002D13                          3759  
00002D13= 28 78 78 78 29 2E ...   3760  xxxW            DC.B '(xxx).W: ',0
00002D1D= 28 78 78 78 29 2E ...   3761  xxxL            DC.B '(xxx).L: ',0
00002D27= 23 28 64 61 74 61 ...   3762  iData           DC.B '#(data): ',0
00002D31                          3763  
00002D31= 41 00                   3764  letterA         DC.B 'A', 0
00002D33= 44 00                   3765  letterD         DC.B 'D', 0
00002D35                          3766  
00002D35= 2B 00                   3767  plus            DC.B '+', 0
00002D37= 2D 00                   3768  minus           DC.B '-', 0
00002D39= 28 00                   3769  lPrn            DC.B '(', 0
00002D3B= 29 00                   3770  rPrn            DC.B ')', 0
00002D3D                          3771  
00002D3D= 45 6E 74 65 72 20 ...   3772  continuePrompt  DC.B 'Enter "Q" or "q" to quit or any other key to continue: ',0
00002D75= 50 72 6F 67 72 61 ...   3773  thankyoumessage DC.B 'Program Complete. Thank You!',0
00002D92                          3774  
00002D92= 00000000                3775  startLocation       DC.L    0
00002D96= 00000000                3776  endLocation         DC.L    0
00002D9A                          3777  
00002D9A                          3778  
00002D9A                          3779     
00002D9A                          3780      END    START                        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 1CF0
ADDA                1C2A
ADDABODY            1C72
ADDAINSTRUCTION     D000
ADDAMASK            F000
ADDAMESSAGE         2CD0
ADDDEST             1DC4
ADDDESTEA           1CE4
ADDDESTEAMASKS      1CEA
ADDI                2148
ADDIBODY            2174
ADDIDONE            21C6
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         2CDF
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          2CD5
ADDPOSTREGDONE      2024
ADDPREREGDONE       20A0
ADDRESS_DONE        26CC
ADDRESS_EXIT        26C6
ADDR_ABS_LONG       2938
ADDR_ABS_SHORT      291E
ADDR_IMMEDIATE_DATA  2952
ADDR_REG_DIRECT     2856
ADDR_REG_INDIRECT   2870
ADDR_REG_INDIRECT_DEC  28E0
ADDR_REG_INDIRECT_INC  28A2
ADDSOURCE           1D66
ASLEA               1842
ASLMESSAGE          2CB7
ASLREG              1888
ASREA               1832
ASRLREG             1852
ASRLREGINSTRUCTION  E000
ASRLREGMASK         F018
ASRLWEA             17F2
ASRLWEACHECKDIRECTION  181E
ASRLWEAINSTRUCTION  E0C0
ASRLWEAMASK         FEC0
ASRMESSAGE          2CBB
ASRREG              1878
BCC                 2540
BCCBYTE             2596
BCCDONE             25C6
BCCINSTRUCTION      6000
BCCLIST             2C13
BCCLONG             25BE
BCCMASK             F000
BCCMESSAGE          2D01
BCCWORD             25B4
BCLR                1516
BCLRBODY            1542
BCLRDATA            147C
BCLRDATABODY        14A8
BCLRDATAINSTRUCTION  880
BCLRDATAMASK        FFC0
BCLRINSTRUCTION     180
BCLRMASK            F1C0
BCLRMESSAGE         2C9A
BEGIN               5001
BEGIN_ADDRESS       2658
BYTE                1
CC                  4
CCM                 2BD3
CHECKCC             255A
CHECKCONTINUE       11B2
CHECKMOVEDEST       23CC
CHECKOPCODE         107C
CHECKPOSTREGADD     201E
CHECKPREREGADD      209A
CK_ADDR_DONE        27DC
CK_ADDR_RANGE       27B0
CK_ADDR_RANGE_ERROR  27CC
CK_BOUNDRY          26F4
CK_BOUNDRY_ERROR    2716
CK_SIZE_ERROR       272A
CLEARLINE           2C8C
CMP                 129C
CMPBODY             12DC
CMPI                2276
CMPIBODY            229E
CMPIDONE            22F4
CMPIEA              2268
CMPIEAMASKS         226F
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         2CE8
CMPINSTRUCTION      B000
CMPMASK             F000
CMPMESSAGE          2C93
CONDITIONCODEMESSAGE  2C24
CONTINUEPROMPT      2D3D
CONVERTHEXTOASCII   2A8A
CS                  5
CSM                 2BD7
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         2D07
DATA_REG_DIRECT     283C
DIVS                1628
DIVSBODY            1654
DIVSINSTRUCTION     81C0
DIVSMASK            F1C0
DIVSMESSAGE         2CA5
ELPROMPT            2AF5
END                 FFFFFE
ENDLOCATION         2D96
ENDLOCATIONPROMPT   2C79
END_ADDRESS         269C
ENTER_ADDR_EDIT_ALL  26CE
ENTER_ADDR_EDIT_ALL_EXIT  26F2
EOR                 11FA
EORBODY             123E
EOREA               11EC
EOREAMASKS          11F3
EORINSTRUCTION      B000
EORMASK             F000
EORMESSAGE          2C8F
EQ                  7
EQM                 2BDB
EVEN_MSG            2BB1
FALSEPOSITIVE       109C
FARLABEL            FFE
FIN                 2648
FOUNDCC             256C
GE                  C
GEM                 2BDF
GET_EFFECTIVE_ADDRESS  27E0
GET_EFFECTIVE_ADDRESS_EXIT  2978
GET_EFFECTIVE_ADDRESS_OTHER  2820
GT                  E
GTM                 2BE3
HANDLEBYTEDATA      260E
HEXBYTE             2A7C
HEXLONG             2A30
HEXOUTPUTBUFFER     29F8
HEXWORD             2A62
HEX_RANGE_ERROR     2798
HI                  2
HIM                 2BE7
IDATA               2D27
INSTLABELLIST       113A
INSTLABELLIST2      1142
INSTLABELLIST3      1176
INSTMASKLIST        10FE
INSTMASKLIST2       1102
INSTMASKLIST3       111C
INSTOPLIST          10C2
INSTOPLIST2         10C6
INSTOPLIST3         10E0
INVALIDEA           2978
INVALIDMSG          2B24
INVCHARMSG          2B69
JSR                 230C
JSRBODY             2334
JSRDONE             2354
JSREA               2304
JSREAMASKS          2308
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          2CED
LCASEHEX            277A
LE                  F
LEA                 15A4
LEABODY             15CC
LEAEA               159C
LEAEAMASKS          15A0
LEAINSTRUCTION      41C0
LEAMASK             F1C0
LEAMESSAGE          2CA0
LEM                 2BEB
LETTER              2AA4
LETTERA             2D31
LETTERD             2D33
LONG                4
LPRN                2D39
LS                  3
LSLEA               18F0
LSLMESSAGE          2CBF
LSLREG              196C
LSM                 2BEF
LSREA               18E0
LSRLCHECKI          19D8
LSRLCHECKIR         19C2
LSRLCHECKIRRETURN   19D6
LSRLCHECKR          1A0C
LSRLEA              1898
LSRLEAMASKS         189E
LSRLREG             1936
LSRLREGBODY         197C
LSRLREGINSTRUCTION  E008
LSRLREGMASK         F018
LSRLWEA             18A4
LSRLWEABODY         1900
LSRLWEACHECKDIRECTION  18CC
LSRLWEAINSTRUCTION  E2C0
LSRLWEAMASK         FEC0
LSRMESSAGE          2CC3
LSRREG              195C
LT                  D
LTM                 2BF3
MAIN_LOOP           101E
MATCH               10A2
MI                  B
MIM                 2BF7
MINUS               2D37
MOVE                23A4
MOVEA               24A2
MOVEABODY           24CA
MOVEADESTEA         249E
MOVEADESTEAMASKS    24A0
MOVEAINSTRUCTION    40
MOVEAMASK           C1C0
MOVEAMESSAGE        2D0D
MOVEBODY            23FA
MOVEDESTEA          2396
MOVEDESTEAMASKS     239D
MOVEINSTRUCTION     0
MOVEM               1E36
MOVEMASK            C000
MOVEMESSAGE         2CFC
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     1E2C
MOVEMMEMTOREGEAMASKS  1E31
MOVEMMESSAGE        2CD9
MOVEMPOST           1EF4
MOVEMPOSTREGLIST    1F80
MOVEMPRE            1E98
MOVEMPREREGLIST     1FA0
MOVEMREGLISTBUFFER  1F50
MOVEMREGTOMEMEA     1E22
MOVEMREGTOMEMEAMASKS  1E27
MOVESIZE            2468
MOVESIZEBYTE        248C
MOVESIZEDONE        2486
MOVESIZELONG        2498
MOVESIZEWORD        2492
MOVESOURCEEA        2384
MOVESOURCEEAMASKS   238D
MULS                16C4
MULSBODY            16EC
MULSEA              16B4
MULSEAMASKS         16BC
MULSINSTRUCTION     C1C0
MULSMASK            F1C0
MULSMESSAGE         2CAA
NE                  6
NEG                 20CC
NEGBODY             20F4
NEGDONE             2126
NEGEA               20BC
NEGEAMASKS          20C4
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          2D03
NEGSIZE             2136
NEM                 2BFB
NEXTHEX             2740
NEXTHEXDONE         2792
NEXTHEXRETURN       27AE
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 2364
NOPMESSAGE          2CF7
NUMBER              2A9C
OR                  134A
ORDEST              141E
ORI                 21D6
ORIBODY             2202
ORIDONE             2258
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          2CE4
ORINSTRUCTION       8000
ORMASK              F000
ORMESSAGE           2C97
ORSOURCE            13C0
ORSOURCEEA          133A
ORSOURCEEAMASKS     1342
OUTPUTHEX           2A04
OUTPUTHEXDONE       2A1C
OUTPUTPOSTINCREMENT  203E
OUTPUTPREINCREMENT  1FA0
PARSEHEXSTRING      273E
PL                  A
PLM                 2BFF
PLUS                2D35
POSTADDBACKSLASH    2038
POSTREGADD          2026
POSTREGADDDONE      2030
PREADDBACKSLASH     20B4
PREREGADD           20A2
PREREGADDDONE       20AC
PRGORG              1000
PRINTBYTESIZE       29BC
PRINTLONGSIZE       29E4
PRINTSIZE           297E
PRINTSIZEDONE       29A4
PRINTWORDSIZE       29D0
PROCESS_OP_CODES    27DE
PROCESS_OP_CODES_EXIT  27DE
PROMPT_USER         1008
RA                  0
RAM                 2C0B
RPRN                2D3B
RSLEA               179C
RSLMESSAGE          2CAF
RSLREG              17E2
RSREA               178C
RSRLREG             17AC
RSRLREGINSTRUCTION  E018
RSRLREGMASK         F018
RSRLWEA             174C
RSRLWEACHECKDIRECTION  1778
RSRLWEAINSTRUCTION  E6C0
RSRLWEAMASK         FEC0
RSRMESSAGE          2CB3
RSRREG              17D2
RTS                 2374
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          2CF2
SCREENLOOP          101A
SIGNEXTENDBYTE      25A8
SLPROMPT            2AC4
SPC                 2BD1
SPC_LEN             2BD2
SR                  1
SRM                 2C0F
STACK               5000
START               1000
STARTLOCATION       2D92
STARTLOCATIONPROMPT  2C64
SUB                 1AF4
SUBDEST             1BCC
SUBINSTRUCTION      9000
SUBMASK             F000
SUBMESSAGE          2CCC
SUBQ                1A36
SUBQBODY            1A6E
SUBQEA              1A26
SUBQEAMASKS         1A2E
SUBQINSTRUCTION     5100
SUBQMASK            F100
SUBQMESSAGE         2CC7
SUBSOURCE           1B6E
SWITCHMODEANDREG    2AB0
THANKYOUMESSAGE     2D75
TOEIGHT             1AF0
UCASEHEX            2762
UNKNOWNOPCODE       25E0
VALIDADDA           1C48
VALIDADDDESTEA      1D40
VALIDADDIMODES      214A
VALIDADDSOURCEEA    1D16
VALIDASRL           17F4
VALIDBCLRDATAMODES  147E
VALIDBCLRMODES      1518
VALIDCMPEA          12B2
VALIDCMPIMODES      2278
VALIDDIVSMODES      162A
VALIDEOREA          1218
VALIDJSRMODES       230E
VALIDLEAMODES       15A6
VALIDLSRL           18A6
VALIDMEMTOREG       1E72
VALIDMOVEAMODES     24A4
VALIDMOVEDESTMODES  23CE
VALIDMOVESOURCEMODES  23A6
VALIDMULSMODES      16C6
VALIDNEGMODES       20CE
VALIDORDESTEA       1396
VALIDORIMODES       21D8
VALIDORSOURCEEA     1370
VALIDREGTOMEM       1E4C
VALIDRSRL           174E
VALIDSUBDESTEA      1B44
VALIDSUBQ           1A48
VALIDSUBSOURCEEA    1B1A
VC                  8
VCM                 2C03
VS                  9
VSM                 2C07
WORD                2
XXXL                2D1D
XXXW                2D13
ZEROTOEIGHT         1AE6
ZEROTOEIGHTRETURN   1AEE

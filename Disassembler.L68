00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/6/2014 12:45:06 AM

00000000                             1  *##########################################################################
00000000                             2  * Title      : 
00000000                             3  * Written by : Andrew Watson
00000000                             4  *            : Elaine Keller
00000000                             5  *            : Robert Anderson
00000000                             6  * Date       : 11/14/2014
00000000                             7  * Description: 
00000000                             8  *##########################################################################
00000000                             9  
00000000                            10  ***Possible Bug***
00000000                            11  *can not tell data from an
00000000                            12  *unidentified instruction from an actual
00000000                            13  *instruction therefore causing errors.
00000000                            14  *may not actually be a bug because data
00000000                            15  *is data to the machine, and if you modify
00000000                            16  *the instructions in memory for a program
00000000                            17  *by moivng data, you can modify the instuctions
00000000                            18  *executed.
00000000                            19  
00000000                            20  
00000000                            21  ***************************************************************************
00000000                            22  *                   Variable/Data Definitions
00000000                            23  ***************************************************************************
00000000                            24  
00000000  =00005000                 25  stack   EQU   $00005000
00000000  =00005001                 26  begin   EQU   $00005001
00000000  =00FFFFFE                 27  end     EQU   $00FFFFFE
00000000  =00000001                 28  byte    EQU   1
00000000  =00000002                 29  word    EQU   2
00000000  =00000004                 30  long    EQU   4
00000000  =00001000                 31  prgorg  EQU   $1000
00000000                            32  
00000FFE                            33      ORG $00000FFE
00000FFE                            34  FarLabel:
00001000                            35      ORG    prgorg
00001000                            36  start:
00001000  4FF8 5000                 37          LEA stack, SP ;initialize stack
00001004                            38  
00001000                            39      ORG    prgorg
00001000                            40  
00001000                            41  ******************************************************************************
00001000                            42  *                   Begin processing active code
00001000                            43  ******************************************************************************
00001000                            44      
00001000                            45  start:
00001000                            46  
00001000  4FF8 5000                 47          LEA         stack, SP           ;Initialize stack
00001004                            48          
00001004                            49  *.............................................................................
00001004                            50  * Debug Mode - Comment out when done
00001004  267C 000010F6             51          MOVE.L      #snippet,A3
0000100A  287C 0000112A             52          MOVE.L      #snippetEnd,A4
00001010  6000 0014                 53          BRA         main_Loop
00001014                            54  * Debug Mode - Comment out when done
00001014                            55  *.............................................................................        
00001014                            56          
00001014                            57  prompt_user:
00001014                            58  
00001014  6100 06FC                 59          BSR         begin_address
00001018  B67C FFFF                 60          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000101C  6700 06F0                 61          BEQ         fin                 ;Yes, then exit
00001020                            62          
00001020  6000 0004                 63          BRA         main_Loop
00001024                            64          ;BSR         process_op_codes
00001024  60EE                      65          BRA         prompt_user
00001026                            66                  
00001026                            67  ******************************************************************************
00001026                            68  *                   Begin processing OP Codes
00001026                            69  ******************************************************************************
00001026                            70   
00001026                            71  main_Loop:
00001026                            72  
00001026  B9CB                      73          CMPA.L A3,A4 ;check end of prog
00001028  6700 06E4                 74          BEQ fin
0000102C                            75          
0000102C  3213                      76          MOVE.W (A3),D1 ;copy word from other prog to analyze as instruction
0000102E                            77          
0000102E                            78          ;handle an odd memory access(instructions will never be misaligned)
0000102E  240B                      79          MOVE.L A3,D2 ; copy address to D2
00001030  0202 0001                 80          ANDI.B #%00000001,D2 ;mask everything except the least significant bit
00001034  0C02 0001                 81          CMPI.B #1,D2 ;compare the least sig bit of the address to one
00001038  6700 06A8                 82          BEQ handlebytedata ;the least sig bit will only be one if the insrtuction
0000103C                            83                             ;is odd(misaligned) and therefore not an instruction
0000103C                            84          
0000103C  7600                      85          MOVEQ.L #0,D3
0000103E                            86          
0000103E                            87          ***things to save A3,A4,D1(?)***
0000103E  48E7 0018                 88          MOVEM.L A3-A4,-(SP)
00001042  6100 000C                 89          BSR checkOPcode
00001046  4CDF 1800                 90          MOVEM.L (SP)+,A3-A4
0000104A  D7C7                      91          ADDA.L  D7,A3 ;look past data that was part of the instruction
0000104C                            92          
0000104C  548B                      93          ADDQ.L  #word,A3
0000104E  60D6                      94          BRA     main_Loop 
00001050                            95          
00001050                            96  checkOPcode:
00001050                            97  
00001050                            98  
00001050  7E00                      99          MOVEQ.L #0,D7
00001052                           100          
00001052  41F9 00001096            101          LEA     instOPList,A0 ;get instruction signitrue list in A0
00001058  D1C3                     102          ADDA.L  D3,A0 ;get correct sig         
0000105A                           103          
0000105A  43F9 000010AE            104          LEA     instMaskList,A1 ;get instruction mask in A1
00001060  D3C3                     105          ADDA.L  D3,A1  ;get correct mast
00001062                           106          
00001062  3401                     107          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001064                           108          
00001064  C451                     109          AND.W   (A1),D2 ;mask instruction
00001066                           110          
00001066                           111          
00001066                           112          
00001066                           113          
00001066  B450                     114          CMP.W   (A0),D2 ;compare to sig
00001068  6700 000C                115          BEQ     match ;if sig matches branch
0000106C  5483                     116          ADDQ.L  #word,D3 ;add to D3 to check for next instruction
0000106E  60E0                     117          BRA checkOPcode
00001070                           118          
00001070                           119  falsePositive:
00001070                           120          
00001070  103C 00FF                121          MOVE.B #-1,D0
00001074  4E75                     122          RTS
00001076                           123  
00001076                           124  match:
00001076                           125          
00001076  43F9 000010C6            126          LEA     instLabelList,A1 ;get instruction code label
0000107C  D3C3                     127          ADDA.L  D3,A1 ;get correct label
0000107E  D3C3                     128          ADDA.L  D3,A1
00001080  5483                     129          ADDQ.L  #word,D3 ;add to D3 incase false positive
00001082  2251                     130          MOVEA.L (A1),A1
00001084  48E7 1000                131          MOVEM.L D3,-(SP) ; save D3
00001088  4E91                     132          JSR     (A1)
0000108A  4CDF 0008                133          MOVEM.L (SP)+,D3 ;restore D3
0000108E  B03C 00FF                134          CMP.B   #-1,D0
00001092  67BC                     135          BEQ     checkOPcode
00001094  4E75                     136          RTS
00001096                           137          
00001096                           138  
00001096= D000 4880 0600 0...      139  instOPList DC.W addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruction         
000010AE= F000 FB80 FF00 F...      140  instMaskList DC.W addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
000010C6= 0000113A 0000123A ...    141  instLabelList DC.L ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
000010F6                           142  
000010F6                           143  snippet:
000010F6  4E71                     144           NOP
000010F8  60FC                     145           BRA snippet
000010FA  6000 FF02                146           BRA FarLabel
000010FE  67F6                     147           BEQ snippet
00001100  6E00 01DC                148           BGT NEG
00001104  61F0                     149           BSR snippet
00001106  4441                     150           NEG D1
00001108  3239 00008500            151           MOVE.W $8500,D1
0000110E  0645 001E                152           ADDI.W #30,D5
00001112  4E75                     153           RTS
00001114  4EB8 0054                154           JSR $54
00001118  0C41 0003                155           CMPI #3,D1
0000111C  0041 0003                156           ORI  #3,D1
00001120  48E7 0018                157           MOVEM.L A3-A4,-(SP)
00001124  D401                     158           ADD.B D1,D2
00001126  0603 000A                159           ADD.B #10,D3
0000112A                           160  
0000112A                           161           
0000112A                           162  snippetEnd:
0000112A  FFFF FFFF                163           SIMHALT
0000112E                           164      
0000112E= 10 18 20 38 39 00        165  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
00001134= 38 38 38 3F 3F 00        166  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
0000113A                           167  
0000113A                           168  ADD:
0000113A                           169          
0000113A                           170  
0000113A                           171          
0000113A  7000                     172          MOVEQ.L #0, D0 ;clear D0
0000113C                           173          
0000113C                           174          ;Figure out if EA is source or destination
0000113C  3401                     175          MOVE.W D1,D2 ;copy inst to D2
0000113E  EC4A                     176          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
00001140  0202 0007                177          ANDI.B #%00000111,D2 ;mask out rest of byte
00001144  0C02 0002                178          CMPI.B #2,D2 ;compare to 2
00001148  6F00 0016                179          BLE validAddSourceEA ;2 or less is EA is source
0000114C                           180          
0000114C  0C02 0007                181          CMPI.B #%111,D2 ;compare to 7
00001150  6700 FF1E                182          BEQ falsePositive ;thats not valid
00001154  0C02 0003                183          CMPI.B #%11,D2 ;compare to 3
00001158  6700 FF16                184          BEQ falsePositive ;also not valid
0000115C  6000 002C                185          BRA validAddDestEA ;all thats left is valid EA as Dest 
00001160                           186          
00001160                           187  validAddSourceEA:
00001160                           188          
00001160  43F9 00001505            189          LEA moveSourceEAmasks,A1 ;load the list of masks
00001166  D3C0                     190          ADDA.L D0,A1 ;displace to a specific mask
00001168  1A11                     191          MOVE.B (A1),D5 ;move the mask to D5
0000116A                           192          
0000116A  0C05 0000                193          CMPI.B #0,D5 ;check if the mask is 0
0000116E  6700 FF00                194          BEQ falsePositive ;branch if it is
00001172                           195          
00001172  1401                     196          MOVE.B D1,D2 ;copy instruction to D2
00001174  C405                     197          AND.B D5,D2  ;mask D2
00001176                           198          
00001176  43F9 000014FC            199          LEA moveSourceEA,A1 ;load the list of valid modes
0000117C  D3C0                     200          ADDA.L D0,A1 ;displace to a specific mode
0000117E  1811                     201          MOVE.B (A1),D4 ;move mode to D4
00001180  B404                     202          CMP.B D4,D2 ;compare mode to masked value
00001182  6700 0032                203          BEQ  addSource ;if its match, its a valid mode and we can procede
00001186                           204          
00001186  5280                     205          ADDQ.L #1,D0 ;add one to displacement
00001188  60D6                     206          BRA validAddSourceEA ;check for next mode
0000118A                           207          
0000118A                           208          
0000118A                           209  validAddDestEA:
0000118A                           210          
0000118A  43F8 1134                211          LEA addDestEAmasks,A1 ;load the list of masks
0000118E  D3C0                     212          ADDA.L D0,A1 ;displace to a specific mask
00001190  1A11                     213          MOVE.B (A1),D5 ;move the mask to D5
00001192                           214          
00001192  0C05 0000                215          CMPI.B #0,D5 ;check if the mask is 0
00001196  6700 FED8                216          BEQ falsePositive ;branch if it is
0000119A                           217          
0000119A  3401                     218          MOVE.W D1,D2 ;copy instruction to D2
0000119C  EC4A                     219          LSR.W #6,D2  ;move mode
0000119E  6100 086E                220          BSR switchModeAndReg ;switch register and mode
000011A2  C405                     221          AND.B D5,D2  ;mask D2
000011A4                           222          
000011A4  43F8 112E                223          LEA addDestEA,A1 ;load the list of valid modes
000011A8  D3C0                     224          ADDA.L D0,A1 ;displace to a specific mode
000011AA  1811                     225          MOVE.B (A1),D4 ;move mode to D4
000011AC  B404                     226          CMP.B D4,D2 ;compare mode to masked value
000011AE  6700 003E                227          BEQ addDest ;if its match, its a valid mode and we can procede
000011B2                           228          
000011B2  5280                     229          ADDQ.L #1,D0 ;add one to displacement
000011B4  60D4                     230          BRA validAddDestEA ;check for next mode
000011B6                           231          
000011B6                           232  addSource
000011B6                           233  
000011B6  43F9 00001BED            234          LEA     addMessage,A1  ;move string for MOVE
000011BC  103C 000E                235          MOVE.B  #14,D0        ;set for task to display null terminated 
000011C0                           236                                ;string with CR, LF
000011C0  4E4F                     237          TRAP    #15
000011C2                           238          
000011C2                           239          ;do EA
000011C2                           240          
000011C2  3401                     241          MOVE.W  D1,D2 ;check mode
000011C4  C43C 003F                242          AND.B   #%00111111,D2
000011C8  1A02                     243          MOVE.B  D2,D5
000011CA  6100 06CE                244          BSR     Get_Effective_Address
000011CE                           245          
000011CE                           246          ;print separator
000011CE                           247          
000011CE                           248          ;Then do Dn
000011CE                           249          
000011CE  3401                     250          MOVE.W  D1,D2
000011D0  E04A                     251          LSR.W   #8,D2 ;move reg into first byte
000011D2  E20A                     252          LSR.B   #1,D2 ;line it up to least sig bit
000011D4  C43C 0007                253          AND.B   #%00000111,D2 ;force mode to Dn
000011D8  1A02                     254          MOVE.B  D2,D5
000011DA  6100 06BE                255          BSR     Get_Effective_Address
000011DE                           256          
000011DE                           257          
000011DE  43F9 00001BEA            258          LEA     clearLine,A1  ;move string for a CR and LF
000011E4  103C 000E                259          MOVE.B  #14,D0        ;set for task to display null terminated 
000011E8                           260                                ;string without CR, LF
000011E8  4E4F                     261          TRAP    #15
000011EA                           262  
000011EA  7000                     263          MOVEQ.L #0,D0
000011EC  4E75                     264          RTS
000011EE                           265  
000011EE                           266  addDest
000011EE                           267  
000011EE  43F9 00001BED            268          LEA     addMessage,A1  ;move string for MOVE
000011F4  103C 000E                269          MOVE.B  #14,D0        ;set for task to display null terminated 
000011F8                           270                                ;string with CR, LF
000011F8  4E4F                     271          TRAP    #15
000011FA                           272          
000011FA                           273          ;Do Dn
000011FA                           274          
000011FA  3401                     275          MOVE.W  D1,D2
000011FC  E04A                     276          LSR.W   #8,D2 ;move reg into first byte
000011FE  E20A                     277          LSR.B   #1,D2 ;line it up to least sig bit
00001200  C43C 0007                278          AND.B   #%00000111,D2 ;force mode to Dn
00001204  1A02                     279          MOVE.B  D2,D5
00001206  6100 0692                280          BSR     Get_Effective_Address
0000120A                           281          
0000120A                           282          
0000120A                           283          ;print separator
0000120A                           284          
0000120A                           285          ;Then do EA
0000120A                           286          
0000120A  3401                     287          MOVE.W  D1,D2 ;check mode
0000120C  C43C 003F                288          AND.B   #%00111111,D2
00001210  1A02                     289          MOVE.B  D2,D5
00001212  6100 0686                290          BSR     Get_Effective_Address
00001216                           291          
00001216                           292          
00001216  43F9 00001BEA            293          LEA     clearLine,A1  ;move string for a CR and LF
0000121C  103C 000E                294          MOVE.B  #14,D0        ;set for task to display null terminated 
00001220                           295                                ;string without CR, LF
00001220  4E4F                     296          TRAP    #15
00001222                           297  
00001222  7000                     298          MOVEQ.L #0,D0
00001224  4E75                     299          RTS
00001226                           300  
00001226                           301  
00001226= 10 20 38 39 00           302  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
0000122B= 38 38 3F 3F 00           303  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
00001230                           304  
00001230= 10 18 38 39 00           305  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
00001235= 38 38 3F 3F 00           306  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
0000123A                           307  
0000123A                           308  MOVEM:
0000123A                           309          
0000123A                           310  
0000123A                           311          
0000123A  7000                     312          MOVEQ.L #0, D0 ;clear D0
0000123C                           313          
0000123C                           314          ;Figure out which direction we are going
0000123C  3401                     315          MOVE.W D1,D2 ;copy inst to D2
0000123E  E64A                     316          LSR.W #3,D2 ;shift direction bit into most sig bit of first byte
00001240  0202 0080                317          ANDI.B #%10000000,D2 ;mask out everything but direction bit in first byte
00001244  0C02 0000                318          CMPI.B #0,D2 ;compare bit to zero
00001248  6700 0006                319          BEQ validRegToMem ;if zero, reg to mem
0000124C  6000 0028                320          BRA validMemToReg ;else, its mem to reg
00001250                           321          
00001250                           322  validRegToMem:
00001250                           323          
00001250  43F8 122B                324          LEA movemRegToMemEAmasks,A1 ;load the list of masks
00001254  D3C0                     325          ADDA.L D0,A1 ;displace to a specific mask
00001256  1A11                     326          MOVE.B (A1),D5 ;move the mask to D5
00001258                           327          
00001258  0C05 0000                328          CMPI.B #0,D5 ;check if the mask is 0
0000125C  6700 FE12                329          BEQ falsePositive ;branch if it is
00001260                           330          
00001260  1401                     331          MOVE.B D1,D2 ;copy instruction to D2
00001262  C405                     332          AND.B D5,D2  ;mask D2
00001264                           333          
00001264  43F8 1226                334          LEA movemRegToMemEA,A1 ;load the list of valid modes
00001268  D3C0                     335          ADDA.L D0,A1 ;displace to a specific mode
0000126A  1811                     336          MOVE.B (A1),D4 ;move mode to D4
0000126C  B404                     337          CMP.B D4,D2 ;compare mode to masked value
0000126E  6700 0034                338          BEQ  movemBody ;if its match, its a valid mode and we can procede
00001272                           339          
00001272  5280                     340          ADDQ.L #1,D0 ;add one to displacement
00001274  60DA                     341          BRA validRegToMem ;check for next mode
00001276                           342          
00001276                           343          
00001276                           344  validMemToReg:
00001276                           345          
00001276  43F8 1235                346          LEA movemMemToRegEAmasks,A1 ;load the list of masks
0000127A  D3C0                     347          ADDA.L D0,A1 ;displace to a specific mask
0000127C  1A11                     348          MOVE.B (A1),D5 ;move the mask to D5
0000127E                           349          
0000127E  0C05 0000                350          CMPI.B #0,D5 ;check if the mask is 0
00001282  6700 FDEC                351          BEQ falsePositive ;branch if it is
00001286                           352          
00001286  3401                     353          MOVE.W D1,D2 ;copy instruction to D2
00001288  EC4A                     354          LSR.W #6,D2  ;move mode
0000128A  6100 0782                355          BSR switchModeAndReg ;switch register and mode
0000128E  C405                     356          AND.B D5,D2  ;mask D2
00001290                           357          
00001290  43F8 1230                358          LEA movemMemToRegEA,A1 ;load the list of valid modes
00001294  D3C0                     359          ADDA.L D0,A1 ;displace to a specific mode
00001296  1811                     360          MOVE.B (A1),D4 ;move mode to D4
00001298  B404                     361          CMP.B D4,D2 ;compare mode to masked value
0000129A  6700 0008                362          BEQ movemBody ;if its match, its a valid mode and we can procede
0000129E                           363          
0000129E  5280                     364          ADDQ.L #1,D0 ;add one to displacement
000012A0  6000 02A4                365          BRA validMoveDestModes ;check for next mode
000012A4                           366          
000012A4                           367  movemBody
000012A4                           368  
000012A4  43F9 00001BF3            369          LEA     movemMessage,A1  ;move string for MOVE
000012AA  103C 000E                370          MOVE.B  #14,D0        ;set for task to display null terminated 
000012AE                           371                                ;string with CR, LF
000012AE  4E4F                     372          TRAP    #15
000012B0                           373          
000012B0                           374          ;show list
000012B0                           375          
000012B0  5487                     376          ADDQ.L #word,D7 ;read past the register list mask(word) following
000012B2                           377                          ;the instruction
000012B2                           378          
000012B2                           379          ;print separator
000012B2                           380          
000012B2  3401                     381          MOVE.W  D1,D2 ;check mode
000012B4  C43C 003F                382          AND.B   #%00111111,D2
000012B8  1A02                     383          MOVE.B  D2,D5
000012BA  6100 05DE                384          BSR     Get_Effective_Address
000012BE                           385          
000012BE                           386          
000012BE  43F9 00001BEA            387          LEA     clearLine,A1  ;move string for a CR and LF
000012C4  103C 000E                388          MOVE.B  #14,D0        ;set for task to display null terminated 
000012C8                           389                                ;string without CR, LF
000012C8  4E4F                     390          TRAP    #15
000012CA                           391  
000012CA  7000                     392          MOVEQ.L #0,D0
000012CC  4E75                     393          RTS
000012CE                           394  
000012CE                           395  
000012CE                           396      
000012CE= 00 10 18 20 28 38 ...    397  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
000012D6= 38 38 38 38 38 3F ...    398  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
000012DE                           399     
000012DE                           400  NEG:            
000012DE                           401       
000012DE  7000                     402          MOVEQ.L #0, D0 ;clear D0
000012E0                           403          
000012E0                           404  validNegModes:
000012E0                           405          
000012E0  43F8 12D6                406          LEA NegEAmasks,A1 ;load the list of masks
000012E4  D3C0                     407          ADDA.L D0,A1 ;displace to a specific mask
000012E6  1A11                     408          MOVE.B (A1),D5 ;move the mask to D5
000012E8                           409          
000012E8  0C05 0000                410          CMPI.B #0,D5 ;check if the mask is 0
000012EC  6700 FD82                411          BEQ falsePositive ;branch if it is
000012F0                           412          
000012F0  1401                     413          MOVE.B D1,D2 ;copy instruction to D2
000012F2  C405                     414          AND.B D5,D2  ;mask D2
000012F4  43F8 12CE                415          LEA NegEA,A1 ;load the list of valid modes
000012F8  D3C0                     416          ADDA.L D0,A1 ;displace to a specific mode
000012FA  1811                     417          MOVE.B (A1),D4 ;move mode to D4
000012FC  B404                     418          CMP.B D4,D2 ;compare mode to masked value
000012FE  6700 0006                419          BEQ NegBody ;if its match, its a valid mode and we can procede
00001302                           420          
00001302  5280                     421          ADDQ.L #1,D0 ;add one to displacement
00001304  60DA                     422          BRA validNegModes ;check for next mode
00001306                           423          
00001306                           424  NegBody:
00001306                           425  
00001306                           426  
00001306  3401                     427          MOVE.W  D1,D2 ;copy inst to D2
00001308  C47C 0600                428          AND.W  #%0011000000000,D2 ;mask word for size
0000130C  0C42 0000                429          CMPI.W #0,D2 ;0 is the only non valid size
00001310  6700 FD5E                430          BEQ falsePositive ; zero is not valid
00001314                           431  
00001314  43F9 00001C29            432          LEA     negMessage,A1  ;move string for NEG info
0000131A  103C 000E                433          MOVE.B  #14,D0        ;set for task to display null terminated 
0000131E                           434                                ;string without CR, LF
0000131E  4E4F                     435          TRAP    #15
00001320                           436          
00001320  3401                     437          MOVE.W D1,D2
00001322  C47C 003F                438          AND #%000000000111111,D2
00001326  1A02                     439          MOVE.B D2,D5
00001328                           440          
00001328  6100 0570                441          BSR     Get_Effective_Address
0000132C                           442          
0000132C                           443                
0000132C                           444          
0000132C                           445  NEGdone:
0000132C                           446  
0000132C  43F9 00001BEA            447          LEA     clearLine,A1  ;move string for a CR and LF
00001332  103C 000E                448          MOVE.B  #14,D0        ;set for task to display null terminated 
00001336                           449                                ;string without CR, LF
00001336  4E4F                     450          TRAP    #15
00001338  7000                     451          MOVEQ.L #0,D0
0000133A  4E75                     452          RTS
0000133C                           453          
0000133C                           454   ADDI:            
0000133C                           455       
0000133C  7000                     456          MOVEQ.L #0, D0 ;clear D0
0000133E                           457          
0000133E                           458  validAddiModes:
0000133E                           459          
0000133E                           460          
0000133E  43F9 00001417            461          LEA cmpiEAmasks,A1 ;load the list of masks
00001344  D3C0                     462          ADDA.L D0,A1 ;displace to a specific mask
00001346  1A11                     463          MOVE.B (A1),D5 ;move the mask to D5
00001348                           464          
00001348  0C05 0000                465          CMPI.B #0,D5 ;check if the mask is 0
0000134C  6700 FD22                466          BEQ falsePositive ;branch if it is
00001350                           467          
00001350  1401                     468          MOVE.B D1,D2 ;copy instruction to D2
00001352  C405                     469          AND.B D5,D2  ;mask D2
00001354  43F9 00001410            470          LEA cmpiEA,A1 ;load the list of valid modes
0000135A  D3C0                     471          ADDA.L D0,A1 ;displace to a specific mode
0000135C  1811                     472          MOVE.B (A1),D4 ;move mode to D4
0000135E  B404                     473          CMP.B D4,D2 ;compare mode to masked value
00001360  6700 0006                474          BEQ addiBody ;if its match, its a valid mode and we can procede
00001364                           475          
00001364  5280                     476          ADDQ.L #1,D0 ;add one to displacement
00001366  60D6                     477          BRA validAddiModes ;check for next mode
00001368                           478          
00001368                           479  addiBody:
00001368                           480  
00001368                           481  
00001368  3401                     482          MOVE.W  D1,D2 ;copy inst to D2
0000136A  C47C 00C0                483          AND.W  #%0000000011000000,D2 ;mask word for size
0000136E  0C42 00C0                484          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001372  6700 FCFC                485          BEQ falsePositive
00001376                           486  
00001376  43F9 00001BFB            487          LEA     addiMessage,A1  ;move string for NEG info
0000137C  103C 000E                488          MOVE.B  #14,D0        ;set for task to display null terminated 
00001380                           489                                ;string without CR, LF
00001380  4E4F                     490          TRAP    #15
00001382                           491          
00001382                           492          ;go to Effective_Address for immediate data
00001382  143C 003C                493          MOVE.B #%00111100,D2
00001386  6100 0512                494          BSR Get_Effective_Address
0000138A                           495          
0000138A  3401                     496          MOVE.W D1,D2 ;copy inst to D2
0000138C  C47C 003F                497          AND #%000000000111111,D2 ;and out everything but modes and regs
00001390  1A02                     498          MOVE.B D2,D5 ; copy to D5 for following BSR
00001392                           499          
00001392  6100 0506                500          BSR Get_Effective_Address
00001396                           501          
00001396                           502                
00001396                           503          
00001396                           504  addidone:
00001396                           505  
00001396  43F9 00001BEA            506          LEA     clearLine,A1  ;move string for a CR and LF
0000139C  103C 000E                507          MOVE.B  #14,D0        ;set for task to display null terminated 
000013A0                           508                                ;string without CR, LF
000013A0  4E4F                     509          TRAP    #15
000013A2  7000                     510          MOVEQ.L #0,D0
000013A4  4E75                     511          RTS
000013A6                           512    
000013A6                           513  ORI:            
000013A6                           514       
000013A6  7000                     515          MOVEQ.L #0, D0 ;clear D0
000013A8                           516          
000013A8                           517  validOriModes:
000013A8                           518          
000013A8                           519          
000013A8  43F9 00001417            520          LEA cmpiEAmasks,A1 ;load the list of masks
000013AE  D3C0                     521          ADDA.L D0,A1 ;displace to a specific mask
000013B0  1A11                     522          MOVE.B (A1),D5 ;move the mask to D5
000013B2                           523          
000013B2  0C05 0000                524          CMPI.B #0,D5 ;check if the mask is 0
000013B6  6700 FCB8                525          BEQ falsePositive ;branch if it is
000013BA                           526          
000013BA  1401                     527          MOVE.B D1,D2 ;copy instruction to D2
000013BC  C405                     528          AND.B D5,D2  ;mask D2
000013BE  43F9 00001410            529          LEA cmpiEA,A1 ;load the list of valid modes
000013C4  D3C0                     530          ADDA.L D0,A1 ;displace to a specific mode
000013C6  1811                     531          MOVE.B (A1),D4 ;move mode to D4
000013C8  B404                     532          CMP.B D4,D2 ;compare mode to masked value
000013CA  6700 0006                533          BEQ oriBody ;if its match, its a valid mode and we can procede
000013CE                           534          
000013CE  5280                     535          ADDQ.L #1,D0 ;add one to displacement
000013D0  60D6                     536          BRA validOriModes ;check for next mode
000013D2                           537          
000013D2                           538  oriBody:
000013D2                           539  
000013D2                           540  
000013D2  3401                     541          MOVE.W  D1,D2 ;copy inst to D2
000013D4  C47C 00C0                542          AND.W  #%0000000011000000,D2 ;mask word for size
000013D8  0C42 00C0                543          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
000013DC  6700 FC92                544          BEQ falsePositive
000013E0                           545  
000013E0  43F9 00001C02            546          LEA     oriMessage,A1  ;move string for NEG info
000013E6  103C 000E                547          MOVE.B  #14,D0        ;set for task to display null terminated 
000013EA                           548                                ;string without CR, LF
000013EA  4E4F                     549          TRAP    #15
000013EC                           550          
000013EC                           551          ;go to Effective_Address for immediate data
000013EC  143C 003C                552          MOVE.B #%00111100,D2
000013F0  6100 04A8                553          BSR Get_Effective_Address
000013F4                           554          
000013F4  3401                     555          MOVE.W D1,D2 ;copy inst to D2
000013F6  C47C 003F                556          AND #%000000000111111,D2 ;and out everything but modes and regs
000013FA  1A02                     557          MOVE.B D2,D5 ; copy to D5 for following BSR
000013FC                           558          
000013FC  6100 049C                559          BSR Get_Effective_Address
00001400                           560          
00001400                           561                
00001400                           562          
00001400                           563  oridone:
00001400                           564  
00001400  43F9 00001BEA            565          LEA     clearLine,A1  ;move string for a CR and LF
00001406  103C 000E                566          MOVE.B  #14,D0        ;set for task to display null terminated 
0000140A                           567                                ;string without CR, LF
0000140A  4E4F                     568          TRAP    #15
0000140C  7000                     569          MOVEQ.L #0,D0
0000140E  4E75                     570          RTS
00001410                           571  
00001410                           572          
00001410                           573          
00001410= 20 18 00 10 38 39 00     574  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
00001417= 38 38 38 38 3F 3F 00     575  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
0000141E                           576     
0000141E                           577  CMPI:            
0000141E                           578       
0000141E  7000                     579          MOVEQ.L #0, D0 ;clear D0
00001420                           580          
00001420                           581  validCmpiModes:
00001420                           582          
00001420                           583          
00001420  43F8 1417                584          LEA cmpiEAmasks,A1 ;load the list of masks
00001424  D3C0                     585          ADDA.L D0,A1 ;displace to a specific mask
00001426  1A11                     586          MOVE.B (A1),D5 ;move the mask to D5
00001428                           587          
00001428  0C05 0000                588          CMPI.B #0,D5 ;check if the mask is 0
0000142C  6700 FC42                589          BEQ falsePositive ;branch if it is
00001430                           590          
00001430  1401                     591          MOVE.B D1,D2 ;copy instruction to D2
00001432  C405                     592          AND.B D5,D2  ;mask D2
00001434  43F8 1410                593          LEA cmpiEA,A1 ;load the list of valid modes
00001438  D3C0                     594          ADDA.L D0,A1 ;displace to a specific mode
0000143A  1811                     595          MOVE.B (A1),D4 ;move mode to D4
0000143C  B404                     596          CMP.B D4,D2 ;compare mode to masked value
0000143E  6700 0006                597          BEQ CMPIBody ;if its match, its a valid mode and we can procede
00001442                           598          
00001442  5280                     599          ADDQ.L #1,D0 ;add one to displacement
00001444  60DA                     600          BRA validCmpiModes ;check for next mode
00001446                           601          
00001446                           602  CMPIBody:
00001446                           603  
00001446                           604  
00001446  3401                     605          MOVE.W  D1,D2 ;copy inst to D2
00001448  C47C 00C0                606          AND.W  #%0000000011000000,D2 ;mask word for size
0000144C  0C42 00C0                607          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001450  6700 FC1E                608          BEQ falsePositive
00001454                           609  
00001454  43F9 00001C08            610          LEA     cmpiMessage,A1  ;move string for NEG info
0000145A  103C 000E                611          MOVE.B  #14,D0        ;set for task to display null terminated 
0000145E                           612                                ;string without CR, LF
0000145E  4E4F                     613          TRAP    #15
00001460                           614          
00001460                           615          ;go to Effective_Address for immediate data
00001460  143C 003C                616          MOVE.B #%00111100,D2
00001464  6100 0434                617          BSR Get_Effective_Address
00001468                           618          
00001468  3401                     619          MOVE.W D1,D2 ;copy inst to D2
0000146A  C47C 003F                620          AND #%000000000111111,D2 ;and out everything but modes and regs
0000146E  1A02                     621          MOVE.B D2,D5 ; copy to D5 for following BSR
00001470                           622          
00001470  6100 0428                623          BSR Get_Effective_Address
00001474                           624          
00001474                           625                
00001474                           626          
00001474                           627  CMPidone:
00001474                           628  
00001474  43F9 00001BEA            629          LEA     clearLine,A1  ;move string for a CR and LF
0000147A  103C 000E                630          MOVE.B  #14,D0        ;set for task to display null terminated 
0000147E                           631                                ;string without CR, LF
0000147E  4E4F                     632          TRAP    #15
00001480  7000                     633          MOVEQ.L #0,D0
00001482  4E75                     634          RTS
00001484                           635  
00001484                           636          
00001484= 10 38 39 00              637  JsrEA        DC.B %010000, %111000, %111001,0
00001488= 38 3F 3F 00              638  JsrEAmasks   DC.B %111000, %111111, %111111,0
0000148C                           639     
0000148C                           640  JSR:            
0000148C                           641       
0000148C  7000                     642          MOVEQ.L #0, D0 ;clear D0
0000148E                           643          
0000148E                           644  validJsrModes:
0000148E                           645          
0000148E  43F8 1488                646          LEA JsrEAmasks,A1 ;load the list of masks
00001492  D3C0                     647          ADDA.L D0,A1 ;displace to a specific mask
00001494  1A11                     648          MOVE.B (A1),D5 ;move the mask to D5
00001496                           649          
00001496  0C05 0000                650          CMPI.B #0,D5 ;check if the mask is 0
0000149A  6700 FBD4                651          BEQ falsePositive ;branch if it is
0000149E                           652          
0000149E  1401                     653          MOVE.B D1,D2 ;copy instruction to D2
000014A0  C405                     654          AND.B D5,D2  ;mask D2
000014A2  43F8 1484                655          LEA JsrEA,A1 ;load the list of valid modes
000014A6  D3C0                     656          ADDA.L D0,A1 ;displace to a specific mode
000014A8  1811                     657          MOVE.B (A1),D4 ;move mode to D4
000014AA  B404                     658          CMP.B D4,D2 ;compare mode to masked value
000014AC  6700 0006                659          BEQ JsrBody ;if its match, its a valid mode and we can procede
000014B0                           660          
000014B0  5280                     661          ADDQ.L #1,D0 ;add one to displacement
000014B2  60DA                     662          BRA validJsrModes ;check for next mode
000014B4                           663          
000014B4                           664  JsrBody:
000014B4                           665  
000014B4                           666  
000014B4  43F9 00001C0F            667          LEA     jsrMessage,A1  ;move string for NEG info
000014BA  103C 000E                668          MOVE.B  #14,D0        ;set for task to display null terminated 
000014BE                           669                                ;string without CR, LF
000014BE  4E4F                     670          TRAP    #15
000014C0                           671          
000014C0  3401                     672          MOVE.W D1,D2 ;copy inst to D2
000014C2  C47C 003F                673          AND #%000000000111111,D2 ;and out everything but modes and regs
000014C6  1A02                     674          MOVE.B D2,D5 ; copy to D5 for following BSR
000014C8                           675          
000014C8  6100 03D0                676          BSR     Get_Effective_Address
000014CC                           677          
000014CC                           678                
000014CC                           679          
000014CC                           680  Jsrdone:
000014CC                           681  
000014CC  43F9 00001BEA            682          LEA     clearLine,A1  ;move string for a CR and LF
000014D2  103C 000E                683          MOVE.B  #14,D0        ;set for task to display null terminated 
000014D6                           684                                ;string without CR, LF
000014D6  4E4F                     685          TRAP    #15
000014D8  7000                     686          MOVEQ.L #0,D0
000014DA  4E75                     687          RTS
000014DC                           688  
000014DC                           689  
000014DC                           690          
000014DC                           691  NOP:
000014DC                           692  
000014DC  43F9 00001C1A            693          LEA     nopMessage,A1 ;move string for NOP info
000014E2  103C 000D                694          MOVE.B  #13,D0        ;set for task to display null terminated 
000014E6                           695                                ;string with CR, LF
000014E6  4E4F                     696          TRAP    #15
000014E8                           697          
000014E8  7000                     698          MOVEQ.L #0,D0
000014EA  4E75                     699          RTS
000014EC                           700          
000014EC                           701  RTS:
000014EC                           702          
000014EC  43F9 00001C15            703          LEA     rtsMessage,A1  ;move string for rts info
000014F2  103C 000D                704          MOVE.B  #13,D0        ;set for task to display null terminated 
000014F6                           705                                ;string with CR, LF
000014F6  4E4F                     706          TRAP    #15  
000014F8                           707     
000014F8  7000                     708          MOVEQ.L #0,D0
000014FA  4E75                     709          RTS   
000014FC                           710  
000014FC= 3C 08 00 10 18 20 ...    711  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
00001505= 3F 38 38 38 38 38 ...    712  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
0000150E                           713  
0000150E= 00 10 18 20 38 39 00     714  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
00001515= 38 38 38 38 3F 3F 00     715  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
0000151C                           716  
0000151C                           717  MOVE:
0000151C                           718          
0000151C                           719  
0000151C                           720          
0000151C  7000                     721          MOVEQ.L #0, D0 ;clear D0
0000151E                           722          
0000151E                           723  validMoveSourceModes:
0000151E                           724          
0000151E  43F8 1505                725          LEA moveSourceEAmasks,A1 ;load the list of masks
00001522  D3C0                     726          ADDA.L D0,A1 ;displace to a specific mask
00001524  1A11                     727          MOVE.B (A1),D5 ;move the mask to D5
00001526                           728          
00001526  0C05 0000                729          CMPI.B #0,D5 ;check if the mask is 0
0000152A  6700 FB44                730          BEQ falsePositive ;branch if it is
0000152E                           731          
0000152E  1401                     732          MOVE.B D1,D2 ;copy instruction to D2
00001530  C405                     733          AND.B D5,D2  ;mask D2
00001532                           734          
00001532  43F8 14FC                735          LEA moveSourceEA,A1 ;load the list of valid modes
00001536  D3C0                     736          ADDA.L D0,A1 ;displace to a specific mode
00001538  1811                     737          MOVE.B (A1),D4 ;move mode to D4
0000153A  B404                     738          CMP.B D4,D2 ;compare mode to masked value
0000153C  6700 0006                739          BEQ  checkMoveDest ;if its match, its a valid mode and we can procede
00001540                           740          
00001540  5280                     741          ADDQ.L #1,D0 ;add one to displacement
00001542  60DA                     742          BRA validMoveSourceModes ;check for next mode
00001544                           743          
00001544                           744  checkMoveDest:
00001544  7000                     745          MOVEQ.L #0, D0 ;clear D0
00001546                           746          
00001546                           747  validMoveDestModes:
00001546                           748          
00001546  43F8 1515                749          LEA moveDestEAmasks,A1 ;load the list of masks
0000154A  D3C0                     750          ADDA.L D0,A1 ;displace to a specific mask
0000154C  1A11                     751          MOVE.B (A1),D5 ;move the mask to D5
0000154E                           752          
0000154E  0C05 0000                753          CMPI.B #0,D5 ;check if the mask is 0
00001552  6700 FB1C                754          BEQ falsePositive ;branch if it is
00001556                           755          
00001556  3401                     756          MOVE.W D1,D2 ;copy instruction to D2
00001558  EC4A                     757          LSR.W #6,D2  ;move mode
0000155A  6100 04B2                758          BSR switchModeAndReg ;switch register and mode
0000155E  C405                     759          AND.B D5,D2  ;mask D2
00001560                           760          
00001560  43F8 150E                761          LEA moveDestEA,A1 ;load the list of valid modes
00001564  D3C0                     762          ADDA.L D0,A1 ;displace to a specific mode
00001566  1811                     763          MOVE.B (A1),D4 ;move mode to D4
00001568  B404                     764          CMP.B D4,D2 ;compare mode to masked value
0000156A  6700 0006                765          BEQ moveBody ;if its match, its a valid mode and we can procede
0000156E                           766          
0000156E  5280                     767          ADDQ.L #1,D0 ;add one to displacement
00001570  60D4                     768          BRA validMoveDestModes ;check for next mode
00001572                           769          
00001572                           770  moveBody
00001572  3401                     771          MOVE.W  D1,D2 ;copy inst to D2
00001574  C47C 3000                772          AND.W  #%0011000000000000,D2 ;mask word for size
00001578  0C42 0000                773          CMPI.W #0,D2 ;0 is the only non valid size
0000157C  6700 FAF2                774          BEQ falsePositive ; if zero, this is not move
00001580                           775  
00001580  43F9 00001C20            776          LEA     moveMessage,A1  ;move string for MOVE
00001586  103C 000E                777          MOVE.B  #14,D0        ;set for task to display null terminated 
0000158A                           778                                ;string with CR, LF
0000158A  4E4F                     779          TRAP    #15
0000158C                           780          
0000158C                           781          
0000158C  3401                     782          MOVE.W  D1,D2 ;check source mode
0000158E  C43C 003F                783          AND.B   #%00111111,D2
00001592  1A02                     784          MOVE.B  D2,D5
00001594  6100 0304                785          BSR     Get_Effective_Address
00001598                           786          
00001598                           787          ;print separator
00001598                           788          
00001598  3401                     789          MOVE.W  D1,D2 ;check dest mode
0000159A  EC4A                     790          LSR.W   #6,D2
0000159C  6100 0470                791          BSR  switchModeAndReg
000015A0  C43C 003F                792          AND.B   #%00111111,D2
000015A4  1A02                     793          MOVE.B  D2,D5
000015A6  6100 02F2                794          BSR     Get_Effective_Address
000015AA                           795          
000015AA                           796          
000015AA                           797          
000015AA  43F9 00001BEA            798          LEA     clearLine,A1  ;move string for a CR and LF
000015B0  103C 000E                799          MOVE.B  #14,D0        ;set for task to display null terminated 
000015B4                           800                                ;string without CR, LF
000015B4  4E4F                     801          TRAP    #15
000015B6                           802  
000015B6  7000                     803          MOVEQ.L #0,D0
000015B8  4E75                     804          RTS
000015BA                           805          
000015BA= 08 00                    806  moveADestEA        DC.B %001000,0
000015BC= 38 00                    807  moveADestEAmasks   DC.B %111000,0
000015BE                           808          
000015BE                           809  MOVEA:
000015BE                           810  
000015BE  7000                     811          MOVEQ.L #0, D0 ;clear D0
000015C0                           812          
000015C0                           813  validMoveASourceModes:
000015C0                           814          
000015C0  43F8 1505                815          LEA moveSourceEAmasks,A1 ;load the list of masks
000015C4  D3C0                     816          ADDA.L D0,A1 ;displace to a specific mask
000015C6  1A11                     817          MOVE.B (A1),D5 ;move the mask to D5
000015C8                           818          
000015C8  0C05 0000                819          CMPI.B #0,D5 ;check if the mask is 0
000015CC  6700 FAA2                820          BEQ falsePositive ;branch if it is
000015D0                           821          
000015D0  1401                     822          MOVE.B D1,D2 ;copy instruction to D2
000015D2  C405                     823          AND.B D5,D2  ;mask D2
000015D4                           824          
000015D4  43F8 14FC                825          LEA moveSourceEA,A1 ;load the list of valid modes
000015D8  D3C0                     826          ADDA.L D0,A1 ;displace to a specific mode
000015DA  1811                     827          MOVE.B (A1),D4 ;move mode to D4
000015DC  B404                     828          CMP.B D4,D2 ;compare mode to masked value
000015DE  6700 0006                829          BEQ  checkMoveADest ;if its match, its a valid mode and we can procede
000015E2                           830          
000015E2  5280                     831          ADDQ.L #1,D0 ;add one to displacement
000015E4  60DA                     832          BRA validMoveASourceModes ;check for next mode
000015E6                           833          
000015E6                           834  checkMoveADest:
000015E6  7000                     835          MOVEQ.L #0, D0 ;clear D0
000015E8                           836  validMoveADestModes:
000015E8                           837          
000015E8  43F8 15BC                838          LEA moveADestEAmasks,A1 ;load the list of masks
000015EC  D3C0                     839          ADDA.L D0,A1 ;displace to a specific mask
000015EE  1A11                     840          MOVE.B (A1),D5 ;move the mask to D5
000015F0                           841          
000015F0  0C05 0000                842          CMPI.B #0,D5 ;check if the mask is 0
000015F4  6700 FA7A                843          BEQ falsePositive ;branch if it is
000015F8                           844          
000015F8  3401                     845          MOVE.W D1,D2 ;copy instruction to D2
000015FA  EA4A                     846          LSR.W #5,D2  ;move mode
000015FC  6100 0410                847          BSR switchModeAndReg ;switch register and mode
00001600  C405                     848          AND.B D5,D2  ;mask D2
00001602                           849          
00001602  43F8 15BA                850          LEA moveADestEA,A1 ;load the list of valid modes
00001606  D3C0                     851          ADDA.L D0,A1 ;displace to a specific mode
00001608  1811                     852          MOVE.B (A1),D4 ;move mode to D4
0000160A  B404                     853          CMP.B D4,D2 ;compare mode to masked value
0000160C  6700 0006                854          BEQ moveABody ;if its match, its a valid mode and we can procede
00001610                           855          
00001610  5280                     856          ADDQ.L #1,D0 ;add one to displacement
00001612  60D4                     857          BRA validMoveADestModes ;check for next mode
00001614                           858  moveABody:
00001614  3401                     859          MOVE.W  D1,D2 ;copy inst to D2
00001616  C47C 3000                860          AND.W  #%0011000000000000,D2 ;mask word for size
0000161A  0C42 0000                861          CMPI.W #0,D2 ;0 is the non valid size
0000161E  6700 FA50                862          BEQ falsePositive ; if zero, this is not move
00001622  0C42 1000                863          CMPI.W #%0001000000000000,D2
00001626  6700 FA48                864          BEQ falsePositive ; if byte, this is not movea
0000162A                           865  
0000162A                           866  
0000162A  43F9 00001C36            867          LEA     moveAMessage,A1  ;move string for MOVE
00001630  103C 000D                868          MOVE.B  #13,D0        ;set for task to display null terminated 
00001634                           869                                ;string with CR, LF
00001634  4E4F                     870          TRAP    #15
00001636                           871  
00001636  7000                     872          MOVEQ.L #0,D0
00001638  4E75                     873          RTS
0000163A                           874  
0000163A                           875             
0000163A                           876  Bcc:
0000163A                           877  
0000163A  43F9 00001C27            878          LEA     bccMessage,A1  ;move string for BRA info
00001640  103C 000E                879          MOVE.B  #14,D0        ;set for task to display null terminated 
00001644                           880                                ;string without CR, LF
00001644  4E4F                     881          TRAP    #15
00001646                           882          
00001646  7000                     883          MOVEQ.L #0,D0 ;clear D0
00001648  3401                     884          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
0000164A  E04A                     885          LSR.W   #8,D2
0000164C  C47C 000F                886          AND.W   #$0F,D2 ;mask instruction
00001650                           887          
00001650                           888  checkCC:        
00001650  41F9 00001B71            889          LEA     bccList,A0 ;get condition code signature list in A0
00001656  D1C0                     890          ADDA.L  D0,A0 ;get correct sig         
00001658  B410                     891          CMP.B   (A0),D2 ;compare to sig
0000165A  6700 0006                892          BEQ     foundCC ;if sig matches branch
0000165E  5200                     893          ADDQ.B  #byte,D0
00001660  60EE                     894          BRA     checkCC
00001662                           895  foundCC:
00001662  43F9 00001B82            896          LEA     conditionCodeMessage,A1 ;get condition code message in A1
00001668  C0FC 0004                897          MULU.W  #long,D0 ;adjust size of D0 for a long
0000166C  D3C0                     898          ADDA.L  D0,A1 ;get correct message location
0000166E  2251                     899          MOVEA.L (A1),A1 ;get correct message
00001670                           900          
00001670  103C 000E                901          MOVE.B  #14,D0        ;set for task to display null terminated 
00001674                           902                                ;string without CR, LF
00001674  4E4F                     903          TRAP    #15
00001676                           904  
00001676                           905          
00001676                           906          
00001676  548B                     907          ADDQ.L  #word,A3 ;move past instruction in case long displacement
00001678  C27C 00FF                908          AND.W   #$00FF,D1   ;check for word sized displacement
0000167C                           909          
0000167C  B23C 0000                910          CMP.B   #$0,D1
00001680  6700 0010                911          BEQ     BccWord
00001684                           912          
00001684  B23C 00FF                913          CMP.B   #$FF,D1 check for long sized displacement
00001688  6700 0010                914          BEQ     BccLong
0000168C                           915          
0000168C                           916  BccByte:
0000168C                           917          
0000168C  7E00                     918          MOVEQ.L #0,D7 ;pass back no extra data followed
0000168E  6000 0012                919          BRA     BccDone
00001692                           920  BccWord:
00001692  3213                     921          MOVE.W  (A3),D1
00001694                           922          
00001694  7E02                     923          MOVEQ.L #word,D7 ;pass back an extra word followed
00001696  6000 000A                924          BRA     BccDone
0000169A                           925  BccLong:
0000169A  2213                     926          MOVE.L  (A3),D1
0000169C                           927          
0000169C  7E04                     928          MOVEQ.L #long,D7 ;pass back an extra long followed
0000169E  6000 0002                929          BRA     BccDone
000016A2                           930  BccDone:
000016A2                           931  
000016A2  343C 0010                932          MOVE.W  #16,D2 ;put base in D2
000016A6  303C 000F                933          MOVE.W  #15,D0  ;put task #15 in D0
000016AA  4E4F                     934          TRAP    #15
000016AC                           935          
000016AC  43F9 00001BEA            936          LEA     clearLine,A1  ;move string for a CR and LF
000016B2  103C 000E                937          MOVE.B  #14,D0        ;set for task to display null terminated 
000016B6                           938                                ;string without CR, LF
000016B6  4E4F                     939          TRAP    #15
000016B8                           940  
000016B8  7000                     941          MOVEQ.L #0,D0
000016BA  4E75                     942          RTS
000016BC                           943          
000016BC                           944          
000016BC                           945  unknownOpCode:
000016BC  43F9 00001C2F            946          LEA     dataMessage,A1 ;move string for data info
000016C2  103C 000E                947          MOVE.B  #14,D0        ;set for task to display null terminated 
000016C6                           948                                ;string without CR, LF
000016C6  4E4F                     949          TRAP    #15
000016C8                           950          
000016C8  143C 0010                951          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
000016CC  103C 000F                952          MOVE.B  #15,D0
000016D0  4E4F                     953          TRAP    #15
000016D2                           954          
000016D2  43F9 00001BEA            955          LEA     clearLine,A1  ;move string for a CR and LF
000016D8  103C 000E                956          MOVE.B  #14,D0        ;set for task to display null terminated 
000016DC                           957                                ;string without CR, LF
000016DC  4E4F                     958          TRAP    #15
000016DE                           959          
000016DE  7000                     960          MOVEQ.L #0,D0
000016E0  4E75                     961          RTS
000016E2                           962          
000016E2                           963  handlebytedata:
000016E2                           964  
000016E2  43F9 00001C2F            965          LEA     dataMessage,A1 ;move string for data info
000016E8  103C 000E                966          MOVE.B  #14,D0        ;set for task to display null terminated 
000016EC                           967                                ;string without CR, LF
000016EC  4E4F                     968          TRAP    #15
000016EE                           969          
000016EE  E049                     970          LSR.W   #8,D1 ;shift the word read into D1 by a byte
000016F0                           971          
000016F0  143C 0010                972          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
000016F4  103C 000F                973          MOVE.B  #15,D0
000016F8  4E4F                     974          TRAP    #15
000016FA                           975          
000016FA  43F9 00001BEA            976          LEA     clearLine,A1  ;move string for a CR and LF
00001700  103C 000E                977          MOVE.B  #14,D0        ;set for task to display null terminated 
00001704                           978                                ;string without CR, LF
00001704  4E4F                     979          TRAP    #15
00001706                           980          
00001706  7000                     981          MOVEQ.L #0,D0
00001708                           982          
00001708  528B                     983          ADDQ.L  #byte,A3
0000170A  6000 F91A                984          BRA main_Loop
0000170E                           985  
0000170E                           986          
0000170E                           987          
0000170E                           988  fin
0000170E                           989  
0000170E                           990          
0000170E                           991          
0000170E  FFFF FFFF                992          simhalt
00001712                           993          
00001712                           994  
00001712                           995  *******************************************************************************
00001712                           996  *                            SUB ROUTINES
00001712                           997  *******************************************************************************
00001712                           998  
00001712                           999  *******************************************************************************
00001712                          1000  *                          IO ROLE ROUTINES
00001712                          1001  *******************************************************************************
00001712                          1002  
00001712                          1003  *==========================================================================
00001712                          1004  *                   Enter / Validate beginning address 
00001712                          1005  *==========================================================================
00001712                          1006   
00001712                          1007  begin_address:
00001712                          1008  
00001712                          1009         
00001712  43F9 00001A22           1010          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00001718  2239 00001A22           1011          MOVE.L      slPrompt,D1         ;Load display length to D1
0000171E  700E                    1012          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001720  4E4F                    1013          TRAP        #15                 ;Perform task 14 (display)
00001722                          1014          
00001722  43F9 00001C68           1015          LEA         startLocation,A1    ;Load address to store user input
00001728  103C 0002               1016          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
0000172C  4E4F                    1017          TRAP        #15                 ;Perform task 2 (input)
0000172E                          1018          
0000172E  0C11 001B               1019          CMP.B       #27,(A1)            ;Check for ESC entered
00001732  6700 004C               1020          BEQ         address_Exit        ;Exit condition 
00001736                          1021          
00001736  6100 0050               1022          BSR         enter_addr_edit_all
0000173A  B67C FFFF               1023          CMP.W       #-1,D3              ;Did the edit pass?
0000173E  67D2                    1024          BEQ         begin_address       ;No, loop and ask for correct input
00001740                          1025          
00001740  2643                    1026          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
00001742                          1027          
00001742  43F9 00001B2F           1028          LEA         spc,A1              ;Load address for starting loaction prompt
00001748  1239 00001B30           1029          MOVE.B      spc_len,D1          ;Load empty line length
0000174E  7000                    1030          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
00001750  4E4F                    1031          TRAP        #15                 ;Perform task 14 (display)
00001752  6000 0002               1032          BRA         end_address
00001756                          1033  
00001756                          1034  *===========================================================================
00001756                          1035  *                   Enter / Validate ending address 
00001756                          1036  *===========================================================================
00001756                          1037  
00001756                          1038  end_address:
00001756                          1039          
00001756  43F9 00001A53           1040          LEA         elPrompt,A1         ;Load address for ending loaction prompt
0000175C                          1041          ;MOVE.L     elPrompt,D1         ;Load display length to D1
0000175C  7250                    1042          MOVE.L      #80,D1       ;did not like previous command, do not know why, it should have worked
0000175E  700E                    1043          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001760  4E4F                    1044          TRAP        #15                 ;Perform task 14 (display)
00001762                          1045          
00001762  103C 0002               1046          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001766  4E4F                    1047          TRAP        #15                 ;Perform task 2 (input)
00001768                          1048          
00001768  0C11 001B               1049          CMP.B       #27,(A1)            ;Check for ESC entered
0000176C  6700 0012               1050          BEQ         address_Exit        ;Exit condition 
00001770                          1051          
00001770  6100 0016               1052          BSR         enter_addr_edit_all
00001774  B67C FFFF               1053          CMP.W       #-1,D3              ;Did the edit pass?
00001778  67DC                    1054          BEQ         end_address         ;No, loop and ask for correct input
0000177A                          1055  
0000177A  2843                    1056          MOVEA.L     D3,A4               ;Ending address gets stored in A4
0000177C  6000 0008               1057          BRA         address_done
00001780                          1058  
00001780                          1059  address_Exit:
00001780                          1060  
00001780  76FF                    1061          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001782  6000 0002               1062          BRA         address_done
00001786                          1063          
00001786                          1064  address_done:
00001786                          1065  
00001786  4E75                    1066          RTS    
00001788                          1067  
00001788                          1068  *==============================================================================
00001788                          1069  * enter_addr_edit_all - Enter address edit check to edit all errors  
00001788                          1070  *                       using multiple different error checking routines.
00001788                          1071  *
00001788                          1072  * Parameters -
00001788                          1073  *   Input   A1      The data that needs checked.
00001788                          1074  *   Input   D1      The number of characters input     
00001788                          1075  *   Output  D3      Returns '-1' when there is an error.
00001788                          1076  *==============================================================================
00001788                          1077  
00001788                          1078  enter_addr_edit_all
00001788                          1079  
00001788                          1080  *------------------------------------------------------------------------------
00001788                          1081  * Test for odd number of characters entered, not allowed
00001788                          1082  *------------------------------------------------------------------------------
00001788                          1083         
00001788  6100 0024               1084          BSR         ck_boundry          ;check if the input is on a odd / even boundry
0000178C  B67C FFFF               1085          CMP.W       #-1,D3              ;Is the address odd?
00001790  6700 001A               1086          BEQ         enter_addr_edit_all_exit     ;No, return
00001794                          1087  
00001794                          1088  *------------------------------------------------------------------------------
00001794                          1089  * Ttest for character entered all being valid address characters
00001794                          1090  * Note: lower case a-f, gets converted to upper case A-F in D3
00001794                          1091  *------------------------------------------------------------------------------
00001794                          1092          
00001794  6100 0062               1093          BSR         parseHexString      ;check if the input contains valid Hex characters
00001798  B67C FFFF               1094          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
0000179C  6700 000E               1095          BEQ         enter_addr_edit_all_exit     ;No, return
000017A0                          1096  
000017A0                          1097  *------------------------------------------------------------------------------
000017A0                          1098  * Verify that the address entered is witin the range defined in the Equate
000017A0                          1099  *------------------------------------------------------------------------------        
000017A0                          1100          
000017A0  6100 00C8               1101          BSR         ck_addr_range       ;is address entered witin the range 
000017A4                          1102                                          ;   as defined in the Equate? 
000017A4  B67C FFFF               1103          CMP.W       #-1,D3              ;is the address  valid?
000017A8  6700 0002               1104          BEQ         enter_addr_edit_all_exit     ;No, return
000017AC                          1105  
000017AC                          1106  enter_addr_edit_all_exit:
000017AC                          1107  
000017AC  4E75                    1108          RTS                             ;return
000017AE                          1109  
000017AE                          1110  *==============================================================================
000017AE                          1111  * ck_boundry - Check the size of the data characters input and determine
000017AE                          1112  *              if an odd number of characters was entered
000017AE                          1113  *
000017AE                          1114  * Parameters -
000017AE                          1115  *   Input   A1      The data that needs checked for odd length.
000017AE                          1116  *   Input   D1      The number of characters input     
000017AE                          1117  *   Output  D3      Returns '-1' when there is an odd length.
000017AE                          1118  *==============================================================================
000017AE                          1119  
000017AE                          1120  ck_boundry:
000017AE                          1121  
000017AE  4243                    1122          CLR.W       D3                  ;Clear the return
000017B0                          1123  
000017B0  B23C 0000               1124          CMP.B       #0,D1               ;Check for nothing entered
000017B4  6700 002E               1125          BEQ         ck_size_error       ;Number of characters entered must be 
000017B8                          1126                                          ;greater than 0  
000017B8                          1127          
000017B8                          1128          
000017B8                          1129          * The program will branch to ck_size_error if D1 is greater than #8        
000017B8  B23C 0008               1130          CMP.B       #8,D1               ;Check for more than 8 characters entered
000017BC  6E00 0026               1131          BGT         ck_size_error       ;Number of characters entered must be less
000017C0                          1132                                          ;than 9
000017C0                          1133          
000017C0  7402                    1134          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
000017C2  82C2                    1135          DIVU        D2,D1               ;Divide address by 2
000017C4  4841                    1136          SWAP        D1                  ;get remainder
000017C6  B23C 0001               1137          CMP.B       #$01,D1             ;Check for remainder of 1
000017CA  6700 0004               1138          BEQ         ck_boundry_error    ;Number of characters entered must be an 
000017CE                          1139                                          ;even number   
000017CE                          1140    
000017CE  4E75                    1141          RTS                             ;return
000017D0                          1142  
000017D0                          1143  *------------------------------------------------------------------------------
000017D0                          1144  * ck_boundry_error - An odd number of characters was entered
000017D0                          1145  *                  - Load error message and display it
000017D0                          1146  *                  - Return error condition
000017D0                          1147  *------------------------------------------------------------------------------
000017D0                          1148          
000017D0                          1149  ck_boundry_error:
000017D0                          1150  
000017D0  43F9 00001B0F           1151          LEA         even_msg,A1         ;Load odd error message into A1
000017D6  2239 00001B0F           1152          MOVE.L      even_msg,D1         ;Load error length to D1
000017DC                          1153          
000017DC  7000                    1154          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
000017DE                          1155                                          ; n is D1.W with CR, LF. 
000017DE  4E4F                    1156          TRAP #15                        ;Display the error message
000017E0  76FF                    1157          MOVE.L #-1,D3                   ;Load -1 into return parameter
000017E2  4E75                    1158          RTS                             ;Return
000017E4                          1159          
000017E4                          1160  *------------------------------------------------------------------------------
000017E4                          1161  * ck_size_error -   The number of characters entered must be more than zero
000017E4                          1162  *                  - Load error message and display it
000017E4                          1163  *                  - Return error condition
000017E4                          1164  *------------------------------------------------------------------------------
000017E4                          1165          
000017E4                          1166  ck_size_error:
000017E4                          1167  
000017E4  43F9 00001A82           1168          LEA         invalidMsg,A1       ;Load invalid range message into A1
000017EA  2239 00001A82           1169          MOVE.L      invalidMsg,D1       ;Load error length to D1
000017F0                          1170          
000017F0  7000                    1171          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
000017F2                          1172                                          ; n is D1.W with CR, LF. 
000017F2  4E4F                    1173          TRAP        #15                 ;Display the error message
000017F4  76FF                    1174          MOVE.L      #-1,D3              ;Load -1 into return parameter
000017F6  4E75                    1175          RTS                             ;Return        
000017F8                          1176  
000017F8                          1177  
000017F8                          1178  *==============================================================================
000017F8                          1179  * parseHexString - Converts user input string into a valid memory address
000017F8                          1180  *                - Stores parsed address data into D3
000017F8                          1181  *                - Stores good/bad (1/0) data in D4 
000017F8                          1182  *
000017F8                          1183  * Hex values are stored as bytes in D2, the ASCII chart shows their value
000017F8                          1184  *   The ASCII chart values we care about are in the ranges of: 
000017F8                          1185  *                            Hex            Decimal
000017F8                          1186  *       No Value           NULL = 0         0
000017F8                          1187  *       Numeric Values:     0-9 = 30-39     48-57
000017F8                          1188  *       Upper Case letters: A-F = 41-46     65-70
000017F8                          1189  *       Lower Case letterc: a-f = 61-66     97-102
000017F8                          1190  
000017F8                          1191  * Parameters -
000017F8                          1192  *   Input   A1      The data that needs checked for valid input.
000017F8                          1193  *   Output  D3      The return value, '-1' for error
000017F8                          1194  *==============================================================================
000017F8                          1195  
000017F8                          1196  parseHexString:
000017F8                          1197  
000017F8                          1198  * setup any initializing item that do not get looped through
000017F8  4243                    1199          CLR.W       D3                  ;Clear the return
000017FA                          1200  
000017FA                          1201          
000017FA                          1202  *------------------------------------------------------------------------------
000017FA                          1203  * NextHex - Loop through all bytes and vaildate the input
000017FA                          1204  * Parameters -
000017FA                          1205  *   Input   A1      The data that needs checked for valid input.
000017FA                          1206  *   Output  D3      The return value, '-1' for error
000017FA                          1207  *------------------------------------------------------------------------------
000017FA                          1208          
000017FA                          1209  NextHex:
000017FA                          1210  
000017FA  1419                    1211          MOVE.B      (A1)+,D2            ;Examine next character and decode it
000017FC  B43C 0000               1212          CMP.B       #0,D2               ;Check character for null 
00001800  6700 0066               1213          BEQ         NextHexReturn       ;Character is null (end of input)
00001804                          1214          
00001804                          1215  *................................................................................
00001804                          1216  *  Check decimal values 0-9 by testing hexadecimal values 30-39
00001804                          1217  *................................................................................
00001804                          1218                  
00001804                          1219          * The program will branch to hex_range_error if D2 is less than #30
00001804  B43C 0030               1220          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
00001808  6D00 0048               1221          BLT         hex_range_error     ;Branch to handle range error hexidecimal
0000180C                          1222                                          ;processing
0000180C                          1223          
0000180C                          1224          * The program will branch to UcaseHex if D2 is greater than #39
0000180C  B43C 0039               1225          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
00001810  6E00 000A               1226          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
00001814                          1227          
00001814                          1228          *a valid number was found within this range
00001814  0402 0030               1229          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
00001818  6000 0032               1230          BRA         NextHexDone         ;Done parsing this byte
0000181C                          1231  
0000181C                          1232  
0000181C                          1233  *..............................................................................
0000181C                          1234  *  Check upper case values A-F by testing hexadecimal values 41-46
0000181C                          1235  *..............................................................................
0000181C                          1236  
0000181C                          1237  UcaseHex:
0000181C                          1238  
0000181C                          1239          * The program will branch to hex_range_error if D2 is less than #41
0000181C  B43C 0041               1240          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
00001820  6D00 0030               1241          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001824                          1242                                          ;processing
00001824                          1243          
00001824  B43C 0046               1244          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
00001828  6E00 000A               1245          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
0000182C                          1246                                          ;processing
0000182C                          1247          
0000182C                          1248          *a valid number was found within this range
0000182C  0402 0037               1249          SUBI.B      #55,D2              ;Change uppercase character to actual value
00001830  6000 001A               1250          BRA         NextHexDone         ;Done parsing this byte
00001834                          1251  
00001834                          1252  
00001834                          1253  *..............................................................................
00001834                          1254  *  Check lower case values a-f by testing hexadecimal values 61-66
00001834                          1255  *..............................................................................
00001834                          1256  
00001834                          1257  LcaseHex
00001834                          1258          
00001834                          1259          * The program will branch to hex_range_error if D2 is less than #61
00001834  B43C 0061               1260          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
00001838  6D00 0018               1261          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
0000183C                          1262                                          ;processing
0000183C                          1263  
0000183C  B43C 0066               1264          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
00001840  6E00 0010               1265          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
00001844                          1266                                          ;processing
00001844                          1267  
00001844                          1268          *a valid number was found within this range
00001844  0402 0057               1269          SUBI.B      #87,D2              ;Change lowercase character to actual value
00001848  6000 0002               1270          BRA         NextHexDone         ;Done parsing this byte
0000184C                          1271  
0000184C                          1272  NextHexDone:
0000184C                          1273  
0000184C  E983                    1274          ASL.L       #4,D3               ; Make rooom for new byte in the return register
0000184E  D602                    1275          ADD.B       D2,D3               ; Move the new byte into the return register
00001850  60A8                    1276          BRA         NextHex             ; We're ready to parse the next byte
00001852                          1277          
00001852                          1278  *-------------------------------------------------------------------------------------
00001852                          1279  * hex_range_error -  A character entered was within the valid range for a hex address
00001852                          1280  *                 -  Load error message and display it
00001852                          1281  *                 -  Return error condition
00001852                          1282  *-------------------------------------------------------------------------------------
00001852                          1283          
00001852                          1284  hex_range_error:
00001852                          1285  
00001852  43F9 00001AC7           1286          LEA         invCharMsg,A1       ;Load invalid range message into A1
00001858  2239 00001AC7           1287          MOVE.L      invCharMsg,D1       ;Load error length to D1
0000185E                          1288          
0000185E  7000                    1289          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001860                          1290                                          ; n is D1.W with CR, LF. 
00001860  4E4F                    1291          TRAP        #15                 ;Display the error message
00001862  76FF                    1292          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001864  6000 0002               1293          BRA         NextHexReturn
00001868                          1294          
00001868                          1295  NextHexReturn:
00001868                          1296          
00001868  4E75                    1297          RTS                             ;Return      
0000186A                          1298  
0000186A                          1299  
0000186A                          1300  *===============================================================================
0000186A                          1301  * ck_addr_range - check the address input is within a valid memory address range
0000186A                          1302  *                - Parsed address data into D3
0000186A                          1303  *
0000186A                          1304  * Parameters -
0000186A                          1305  *   Input   A1      The data that needs checked for valid address.
0000186A                          1306  *   Output  D3      The return value, '-1' for error
0000186A                          1307  *===============================================================================
0000186A                          1308  
0000186A                          1309  
0000186A                          1310  ck_addr_range:   
0000186A                          1311  
0000186A                          1312  *------------------------------------------------------------------------------
0000186A                          1313  * Verify that the address entered is witin the 
0000186A                          1314  * beginning range ('begin') as defined in the Equate
0000186A                          1315  *------------------------------------------------------------------------------   
0000186A                          1316              
0000186A  2C3C 00005001           1317          MOVE.L      #begin,D6           * Load minimum starting address
00001870  B686                    1318          CMP.L       D6,D3               * Is input at or above minimum?
00001872  6D00 0012               1319          BLT         ck_addr_range_error 
00001876                          1320          
00001876                          1321  *------------------------------------------------------------------------------
00001876                          1322  * Verify that the address entered is witin the 
00001876                          1323  * ending range ('end') as defined in the Equate
00001876                          1324  *------------------------------------------------------------------------------
00001876                          1325          
00001876  2C3C 00FFFFFE           1326          MOVE.L      #end,D6             * Load maximum starting address
0000187C  B686                    1327          CMP.L       D6,D3               * Is input at or below maximum?
0000187E  6E00 0006               1328          BGT         ck_addr_range_error 
00001882  6000 0012               1329          BRA         ck_addr_done        ;done checking
00001886                          1330          
00001886                          1331  *..............................................................................
00001886                          1332  * ck_addr_range_error -  A address entered is not within the 
00001886                          1333  *                        valid range for a hex address
00001886                          1334  *..............................................................................
00001886                          1335          
00001886                          1336  ck_addr_range_error
00001886                          1337  
00001886  43F9 00001A82           1338          LEA         invalidMsg,A1       ;Load invalid range message into A1
0000188C                          1339          
0000188C  700D                    1340          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
0000188E                          1341                                          ;with CR, LF. 
0000188E  4E4F                    1342          TRAP        #15                 ;Display the error message
00001890  76FF                    1343          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001892  6000 0002               1344          BRA         ck_addr_done 
00001896                          1345  
00001896                          1346  ck_addr_done:
00001896                          1347  
00001896  4E75                    1348          RTS                             ;Return
00001898                          1349  
00001898                          1350  *******************************************************************************
00001898                          1351  *                          OP CODE ROLE ROUTINES
00001898                          1352  *******************************************************************************
00001898                          1353  
00001898                          1354  process_op_codes:
00001898                          1355  
00001898                          1356  
00001898                          1357  
00001898                          1358  process_op_codes_exit:
00001898                          1359  
00001898  4E75                    1360          RTS
0000189A                          1361  
0000189A                          1362  
0000189A                          1363  *******************************************************************************
0000189A                          1364  *                    Effective Addressing ROLE ROUTINES
0000189A                          1365  *******************************************************************************
0000189A                          1366  
0000189A                          1367  Get_Effective_Address:
0000189A                          1368  
0000189A  1C05                    1369          MOVE.B      D5,D6
0000189C  E60E                    1370          LSR.B       #3,D6               ;mode
0000189E  CA3C 0007               1371          And.B       #%00000111,D5       ;register
000018A2                          1372          
000018A2  BC3C 0000               1373          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
000018A6  6700 004A               1374          BEQ         Data_Reg_Direct
000018AA                          1375          
000018AA  BC3C 0001               1376          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
000018AE  6700 0076               1377          BEQ         Addr_Reg_Indirect
000018B2                          1378          
000018B2  BC3C 0002               1379          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
000018B6  6700 006E               1380          BEQ         Addr_Reg_Indirect
000018BA                          1381          
000018BA  BC3C 0003               1382          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
000018BE  6700 0098               1383          BEQ         Addr_Reg_Indirect_Inc
000018C2                          1384          
000018C2  BC3C 0004               1385          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
000018C6  6700 00CE               1386          BEQ         Addr_Reg_Indirect_Dec
000018CA                          1387          
000018CA  BC3C 0007               1388          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
000018CE  6700 0006               1389          BEQ         Get_Effective_Address_Other
000018D2                          1390          
000018D2  6000 0138               1391          BRA         invalidEA
000018D6                          1392          
000018D6                          1393  Get_Effective_Address_Other:        
000018D6                          1394          
000018D6  BA3C 0000               1395          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
000018DA  6700 00F8               1396          BEQ Addr_Abs_Short
000018DE                          1397          
000018DE  BA3C 0001               1398          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
000018E2  6700 0104               1399          BEQ Addr_Abs_Long
000018E6                          1400          
000018E6  BA3C 0004               1401          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
000018EA  6700 0110               1402          BEQ Addr_Immediate_Data
000018EE                          1403          
000018EE  6000 011C               1404          BRA         invalidEA
000018F2                          1405          
000018F2                          1406  Data_Reg_Direct:                        ;case 0(0000)
000018F2                          1407  
000018F2  43F9 00001C5E           1408          LEA         letterD,A1          ;output 'D' for data register
000018F8  103C 000E               1409          MOVE.B      #14,D0              ;set for task to display null terminated 
000018FC  4E4F                    1410          TRAP        #15                 ;string without CR, LF
000018FE                          1411                          
000018FE  4281                    1412          CLR.L       D1
00001900  1205                    1413          MOVE.B      D5,D1               ;move register number for display into D1
00001902  103C 0003               1414          MOVE.B      #3,D0               ;set for task to display null terminated 
00001906  4E4F                    1415          TRAP        #15                 ;string without CR, LF
00001908                          1416                 
00001908  6000 0102               1417          BRA         Get_Effective_Address_Exit  ;return
0000190C                          1418          
0000190C                          1419          
0000190C                          1420  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
0000190C                          1421        
0000190C  43F9 00001C5C           1422          LEA         letterA,A1          ;output 'A' for address register
00001912  103C 000E               1423          MOVE.B      #14,D0              ;set for task to display null terminated 
00001916  4E4F                    1424          TRAP        #15                 ;string without CR, LF
00001918                          1425          
00001918  4281                    1426          CLR.L       D1
0000191A  1205                    1427          MOVE.B      D5,D1               ;move register number for display into D1
0000191C  103C 0003               1428          MOVE.B      #3,D0               ;set for task to display null terminated 
00001920  4E4F                    1429          TRAP        #15                 ;string without CR, LF
00001922                          1430          
00001922  6000 00E8               1431          BRA         Get_Effective_Address_Exit  ;return
00001926                          1432  
00001926                          1433  
00001926                          1434  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
00001926                          1435          
00001926  43F9 00001C64           1436          LEA         lprn,A1             ;output 'D' for data register
0000192C  103C 000E               1437          MOVE.B      #14,D0              ;set for task to display null terminated 
00001930  4E4F                    1438          TRAP        #15                 ;string without CR, LF
00001932                          1439  
00001932  43F9 00001C5C           1440          LEA         letterA,A1          ;output 'A' for address register
00001938  103C 000E               1441          MOVE.B      #14,D0              ;set for task to display null terminated 
0000193C  4E4F                    1442          TRAP        #15                 ;string without CR, LF
0000193E                          1443          
0000193E  4281                    1444          CLR.L       D1
00001940  1205                    1445          MOVE.B      D5,D1               ;move register number for display into D1
00001942  103C 0003               1446          MOVE.B      #3,D0               ;set for task to display null terminated 
00001946  4E4F                    1447          TRAP        #15                 ;string without CR, LF
00001948                          1448  
00001948  43F9 00001C66           1449          LEA         rprn,A1             ;output 'D' for data register
0000194E  103C 000E               1450          MOVE.B      #14,D0              ;set for task to display null terminated 
00001952  4E4F                    1451          TRAP        #15                 ;string without CR, LF
00001954                          1452          
00001954  6000 00B6               1453          BRA         Get_Effective_Address_Exit  ;return
00001958                          1454  
00001958                          1455                 
00001958                          1456  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
00001958                          1457  
00001958  43F9 00001C64           1458          LEA         lprn,A1             ;output 'D' for data register
0000195E  103C 000E               1459          MOVE.B      #14,D0              ;set for task to display null terminated 
00001962  4E4F                    1460          TRAP        #15                 ;string without CR, LF
00001964                          1461  
00001964  43F9 00001C5C           1462          LEA         letterA,A1          ;output 'A' for address register
0000196A  103C 000E               1463          MOVE.B      #14,D0              ;set for task to display null terminated 
0000196E  4E4F                    1464          TRAP        #15                 ;string without CR, LF
00001970                          1465          
00001970  4281                    1466          CLR.L       D1
00001972  1205                    1467          MOVE.B      D5,D1               ;move register number for display into D1
00001974  103C 0003               1468          MOVE.B      #3,D0               ;set for task to display null terminated 
00001978  4E4F                    1469          TRAP        #15                 ;string without CR, LF
0000197A                          1470  
0000197A  43F9 00001C66           1471          LEA         rprn,A1             ;output 'D' for data register
00001980  103C 000E               1472          MOVE.B      #14,D0              ;set for task to display null terminated 
00001984  4E4F                    1473          TRAP        #15                 ;string without CR, LF
00001986                          1474          
00001986  43F9 00001C60           1475          LEA         plus,A1             ;output 'D' for data register
0000198C  103C 000E               1476          MOVE.B      #14,D0              ;set for task to display null terminated 
00001990  4E4F                    1477          TRAP        #15                 ;string without CR, LF
00001992                          1478          
00001992  6000 0078               1479          BRA         Get_Effective_Address_Exit  ;return
00001996                          1480  
00001996                          1481  Addr_Reg_Indirect_Dec                   ;4 = (An) - Address Register Indirect with Predecrement (100)
00001996                          1482  
00001996  43F9 00001C62           1483          LEA         minus,A1            ;output '-' for Predecrement
0000199C  103C 000E               1484          MOVE.B      #14,D0              ;set for task to display null terminated 
000019A0  4E4F                    1485          TRAP        #15                 ;string without CR, LF
000019A2                          1486  
000019A2  43F9 00001C64           1487          LEA         lprn,A1             ;output 'D' for data register
000019A8  103C 000E               1488          MOVE.B      #14,D0              ;set for task to display null terminated 
000019AC  4E4F                    1489          TRAP        #15                 ;string without CR, LF
000019AE                          1490  
000019AE  43F9 00001C5C           1491          LEA         letterA,A1          ;output 'A' for address register
000019B4  103C 000E               1492          MOVE.B      #14,D0              ;set for task to display null terminated 
000019B8  4E4F                    1493          TRAP        #15                 ;string without CR, LF
000019BA                          1494          
000019BA  4281                    1495          CLR.L       D1
000019BC  1205                    1496          MOVE.B      D5,D1               ;move register number for display into D1
000019BE  103C 0003               1497          MOVE.B      #3,D0               ;set for task to display null terminated 
000019C2  4E4F                    1498          TRAP        #15                 ;string without CR, LF
000019C4                          1499  
000019C4  43F9 00001C66           1500          LEA         rprn,A1             ;output 'D' for data register
000019CA  103C 000E               1501          MOVE.B      #14,D0              ;set for task to display null terminated 
000019CE  4E4F                    1502          TRAP        #15                 ;string without CR, LF
000019D0                          1503          
000019D0  6000 003A               1504          BRA         Get_Effective_Address_Exit  ;return
000019D4                          1505          
000019D4                          1506                         
000019D4                          1507  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
000019D4                          1508          
000019D4                          1509          
000019D4  43F9 00001C3E           1510          LEA         xxxW,A1             ;output 'D' for data register
000019DA  103C 000E               1511          MOVE.B      #14,D0              ;set for task to display null terminated 
000019DE  4E4F                    1512          TRAP        #15                 ;string without CR, LF
000019E0                          1513  
000019E0  548B                    1514          ADDA.L      #word,A3
000019E2                          1515          
000019E2                          1516          ;print word (A3)
000019E2                          1517          ;MOVE.W      A3,(A1)
000019E2                          1518          ;MOVE.B      #14,D0              ;set for task to display null terminated 
000019E2                          1519          ;TRAP        #15                 ;string without CR, LF
000019E2                          1520          
000019E2  5487                    1521          ADDI.L      #word,D7 
000019E4  6000 0026               1522          BRA         Get_Effective_Address_Exit  ;return
000019E8                          1523                         
000019E8                          1524  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
000019E8                          1525          
000019E8  43F9 00001C48           1526          LEA         xxxL,A1             ;output 'D' for data register
000019EE  103C 000E               1527          MOVE.B      #14,D0              ;set for task to display null terminated 
000019F2  4E4F                    1528          TRAP        #15                 ;string without CR, LF
000019F4                          1529  
000019F4  548B                    1530          ADDA.L      #word,A3
000019F6                          1531          
000019F6                          1532          ;print long (A3)
000019F6                          1533          ;MOVE.L      A3,(A1)
000019F6                          1534          ;MOVE.B      #14,D0              ;set for task to display null terminated 
000019F6                          1535          ;TRAP        #15                 ;string without CR, LF
000019F6                          1536          
000019F6  5887                    1537          ADDI.L      #long,D7
000019F8  6000 0012               1538          BRA         Get_Effective_Address_Exit  ;return
000019FC                          1539                         
000019FC                          1540  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
000019FC                          1541  
000019FC  43F9 00001C52           1542          LEA         iData,A1            ;output 'D' for data register
00001A02  103C 000E               1543          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A06  4E4F                    1544          TRAP        #15                 ;string without CR, LF
00001A08                          1545          
00001A08                          1546          *need another input param for size
00001A08  6000 0002               1547          BRA         Get_Effective_Address_Exit  ;return
00001A0C                          1548  
00001A0C                          1549  invalidEA:
00001A0C                          1550  
00001A0C                          1551          ;do something
00001A0C                          1552   
00001A0C                          1553  Get_Effective_Address_Exit:     
00001A0C                          1554  
00001A0C  4E75                    1555          RTS                             ;return
00001A0E                          1556  
00001A0E                          1557  switchModeAndReg:
00001A0E                          1558  ***
00001A0E                          1559  * Assumed in D2
00001A0E                          1560  *
00001A0E                          1561  * Assumed that they are in least significant byte:
00001A0E                          1562  *
00001A0E                          1563  *            _this_
00001A0E                          1564  *           /      \
00001A0E                          1565  *  ........ ........
00001A0E                          1566  *  \                /
00001A0E                          1567  *   -----word-------
00001A0E                          1568  *
00001A0E                          1569  *  and that in that byte they are ordered:
00001A0E                          1570  *
00001A0E                          1571  *       ........   
00001A0E                          1572  *       \/\_/\_/
00001A0E                          1573  *      /  /    \
00001A0E                          1574  *    /   /      \
00001A0E                          1575  * dont  one    other
00001A0E                          1576  * care
00001A0E                          1577  *
00001A0E                          1578  * after they will be
00001A0E                          1579  *
00001A0E                          1580  *       ........   
00001A0E                          1581  *       \/\_/\_/
00001A0E                          1582  *      /  /    \
00001A0E                          1583  *    /   /      \
00001A0E                          1584  * dont other    one
00001A0E                          1585  * care
00001A0E                          1586  *** 
00001A0E  0202 003F               1587          AndI.B #%00111111,D2 ;remove unwanted bits from D2
00001A12  0283 00000000           1588          ANDI.L #0,D3 ;clear D3
00001A18  1602                    1589          MOVE.B D2,D3 ;copy to D3
00001A1A  E70B                    1590          LSL.B  #3,D3 
00001A1C  E60A                    1591          LSR.B  #3,D2
00001A1E  D403                    1592          ADD.B  D3,D2
00001A20  4E75                    1593          RTS
00001A22                          1594  
00001A22                          1595          
00001A22                          1596  *==============================================================================
00001A22                          1597  *                            variables and constants
00001A22                          1598  *==============================================================================
00001A22                          1599  
00001A22                          1600  
00001A22                          1601  ***initial user prompt stuff        
00001A22= 45 6E 74 65 72 20 ...   1602  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE: $',0
00001A53= 45 6E 74 65 72 20 ...   1603  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE: $',0
00001A82                          1604  
00001A82= 20 41 64 64 72 65 ...   1605  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
00001AC7= 20 41 20 43 68 61 ...   1606  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
00001B0F                          1607  
00001B0F= 20 59 6F 75 20 6D ...   1608  even_msg        DC.B    ' You must enter an even address!'
00001B2F                          1609  
00001B2F= 20                      1610  spc             DC.B    ' '
00001B30= 01                      1611  spc_len         DC.B    spc_len-spc
00001B31                          1612  ***
00001B31                          1613  
00001B31                          1614  
00001B31                          1615  
00001B31                          1616  ***list of OP codes
00001B31                          1617  
00001B31  =0000D000               1618  addInstruction   EQU %1101000000000000
00001B31  =00004880               1619  movemInstruction EQU %0100100010000000
00001B31  =00000600               1620  addiInstruction  EQU %0000011000000000
00001B31  =00000000               1621  oriInstruction   EQU 0
00001B31  =00000C00               1622  cmpiInstruction  EQU %0000110000000000
00001B31  =00004E80               1623  jsrInstruction   EQU %0100111010000000
00001B31  =00004E75               1624  rtsInstruction   EQU %0100111001110101
00001B31  =00004E71               1625  NoOpInstruction  EQU %0100111001110001
00001B31  =00000000               1626  moveInstruction  EQU 0
00001B31  =00006000               1627  bccInstruction   EQU %0110000000000000
00001B31  =00004400               1628  negInstruction   EQU %0100010000000000
00001B31  =00000000               1629  dataInstruction  EQU 0
00001B31                          1630  
00001B31                          1631  ***
00001B31                          1632  
00001B31                          1633  ***list of OP masks
00001B31                          1634  
00001B31  =0000F000               1635  addMask   EQU %1111000000000000
00001B31  =0000FB80               1636  movemMask EQU %1111101110000000
00001B31  =0000FF00               1637  addiMask  EQU %1111111100000000
00001B31  =0000FF00               1638  oriMask   EQU %1111111100000000
00001B31  =0000FF00               1639  cmpiMask  EQU %1111111100000000
00001B31  =0000FFC0               1640  jsrMask   EQU %1111111111000000
00001B31  =0000FFFF               1641  rtsMask   EQU $FFFF
00001B31  =0000FFFF               1642  NoOpMask  EQU $FFFF
00001B31  =0000C000               1643  moveMask  EQU $C000
00001B31  =0000F000               1644  bccMask   EQU $F000
00001B31  =0000FF00               1645  negMask   EQU $FF00
00001B31  =00000000               1646  dataMask  EQU 0
00001B31                          1647  ***
00001B31                          1648  
00001B31                          1649  ***Bcc Codes***
00001B31  =00000004               1650  CC EQU $04
00001B31  =00000005               1651  CS EQU $05
00001B31  =00000007               1652  EQ EQU $07
00001B31  =0000000C               1653  GE EQU $0C
00001B31  =0000000E               1654  GT EQU $0E
00001B31  =00000002               1655  HI EQU $02
00001B31  =0000000F               1656  LE EQU $0F
00001B31  =00000003               1657  LS EQU $03
00001B31  =0000000D               1658  LT EQU $0D
00001B31  =0000000B               1659  MI EQU $0B
00001B31  =00000006               1660  NE EQU $06
00001B31  =0000000A               1661  PL EQU $0A
00001B31  =00000008               1662  VC EQU $08
00001B31  =00000009               1663  VS EQU $09
00001B31  =00000000               1664  RA EQU $00 ;not really a Condition Code
00001B31  =00000001               1665  SR EQU $01 ;not really a Condition Code
00001B31                          1666  
00001B31= 43 43 20 00             1667  CCm DC.B 'CC ',0
00001B35= 43 53 20 00             1668  CSm DC.B 'CS ',0
00001B39= 45 51 20 00             1669  EQm DC.B 'EQ ',0
00001B3D= 47 45 20 00             1670  GEm DC.B 'GE ',0
00001B41= 47 54 20 00             1671  GTm DC.B 'GT ',0
00001B45= 48 49 20 00             1672  HIm DC.B 'HI ',0
00001B49= 4C 45 20 00             1673  LEm DC.B 'LE ',0
00001B4D= 4C 53 20 00             1674  LSm DC.B 'LS ',0
00001B51= 4C 54 20 00             1675  LTm DC.B 'LT ',0
00001B55= 4D 49 20 00             1676  MIm DC.B 'MI ',0
00001B59= 4E 45 20 00             1677  NEm DC.B 'NE ',0
00001B5D= 50 4C 20 00             1678  PLm DC.B 'PL ',0
00001B61= 56 43 20 00             1679  VCm DC.B 'VC ',0
00001B65= 56 53 20 00             1680  VSm DC.B 'VS ',0
00001B69= 52 41 20 00             1681  RAm DC.B 'RA ',0
00001B6D= 53 52 20 00             1682  SRm DC.B 'SR ',0
00001B71                          1683  
00001B71= 01 04 05 07 0C 0E ...   1684  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
00001B82= 00001B6D 00001B31 ...   1685  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
00001BC2                          1686  ***
00001BC2                          1687  
00001BC2= 45 6E 74 65 72 20 ...   1688  startLocationPrompt DC.B    'Enter start location',0
00001BD7= 45 6E 74 65 72 20 ...   1689  endLocationPrompt   DC.B    'Enter end location',0
00001BEA                          1690  
00001BEA= 0D 0A 00                1691  clearLine  DC.B $0D,$0A,0
00001BED                          1692  
00001BED= 41 44 44 3A 20 00       1693  addMessage      DC.B 'ADD: ',0
00001BF3= 4D 4F 56 45 4D 3A ...   1694  movemMessage    DC.B 'MOVEM: ',0
00001BFB= 41 44 44 49 3A 20 00    1695  addiMessage     DC.B 'ADDI: ',0
00001C02= 4F 52 49 3A 20 00       1696  oriMessage      DC.B 'ORI: ',0
00001C08= 43 4D 50 49 3A 20 00    1697  cmpiMessage     DC.B 'CMPI: ',0
00001C0F= 4A 53 52 3A 20 00       1698  jsrMessage      DC.B 'JSR: ',0
00001C15= 52 54 53 20 00          1699  rtsMessage      DC.B 'RTS ',0
00001C1A= 4E 4F 50 3A 20 00       1700  nopMessage      DC.B 'NOP: ',0 
00001C20= 4D 4F 56 45 3A 20 00    1701  moveMessage     DC.B 'MOVE: ',0
00001C27= 42 00                   1702  bccMessage      DC.B 'B',0
00001C29= 4E 45 47 3A 20 00       1703  negMessage      DC.B 'NEG: ',0
00001C2F= 44 41 54 41 3A 20 00    1704  dataMessage     DC.B 'DATA: ',0
00001C36                          1705  
00001C36= 4D 4F 56 45 41 3A ...   1706  moveaMessage    DC.B 'MOVEA: ',0
00001C3E                          1707  
00001C3E= 28 78 78 78 29 2E ...   1708  xxxW            DC.B '(xxx).W: ',0
00001C48= 28 78 78 78 29 2E ...   1709  xxxL            DC.B '(xxx).L: ',0
00001C52= 23 28 64 61 74 61 ...   1710  iData           DC.B '#(data): ',0
00001C5C                          1711  
00001C5C= 41 00                   1712  letterA         DC.B 'A', 0
00001C5E= 44 00                   1713  letterD         DC.B 'D', 0
00001C60                          1714  
00001C60= 2B 00                   1715  plus            DC.B '+', 0
00001C62= 2D 00                   1716  minus           DC.B '-', 0
00001C64= 28 00                   1717  lPrn            DC.B '(', 0
00001C66= 29 00                   1718  rPrn            DC.B ')', 0
00001C68                          1719  
00001C68                          1720  
00001C68= 00000000                1721  startLocation       DC.L    0
00001C6C= 00000000                1722  endLocation         DC.L    0
00001C70                          1723  
00001C70                          1724  
00001C70                          1725     
00001C70                          1726      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 113A
ADDDEST             11EE
ADDDESTEA           112E
ADDDESTEAMASKS      1134
ADDI                133C
ADDIBODY            1368
ADDIDONE            1396
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         1BFB
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          1BED
ADDRESS_DONE        1786
ADDRESS_EXIT        1780
ADDR_ABS_LONG       19E8
ADDR_ABS_SHORT      19D4
ADDR_IMMEDIATE_DATA  19FC
ADDR_REG_DIRECT     190C
ADDR_REG_INDIRECT   1926
ADDR_REG_INDIRECT_DEC  1996
ADDR_REG_INDIRECT_INC  1958
ADDSOURCE           11B6
BCC                 163A
BCCBYTE             168C
BCCDONE             16A2
BCCINSTRUCTION      6000
BCCLIST             1B71
BCCLONG             169A
BCCMASK             F000
BCCMESSAGE          1C27
BCCWORD             1692
BEGIN               5001
BEGIN_ADDRESS       1712
BYTE                1
CC                  4
CCM                 1B31
CHECKCC             1650
CHECKMOVEADEST      15E6
CHECKMOVEDEST       1544
CHECKOPCODE         1050
CK_ADDR_DONE        1896
CK_ADDR_RANGE       186A
CK_ADDR_RANGE_ERROR  1886
CK_BOUNDRY          17AE
CK_BOUNDRY_ERROR    17D0
CK_SIZE_ERROR       17E4
CLEARLINE           1BEA
CMPI                141E
CMPIBODY            1446
CMPIDONE            1474
CMPIEA              1410
CMPIEAMASKS         1417
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         1C08
CONDITIONCODEMESSAGE  1B82
CS                  5
CSM                 1B35
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         1C2F
DATA_REG_DIRECT     18F2
ELPROMPT            1A53
END                 FFFFFE
ENDLOCATION         1C6C
ENDLOCATIONPROMPT   1BD7
END_ADDRESS         1756
ENTER_ADDR_EDIT_ALL  1788
ENTER_ADDR_EDIT_ALL_EXIT  17AC
EQ                  7
EQM                 1B39
EVEN_MSG            1B0F
FALSEPOSITIVE       1070
FARLABEL            FFE
FIN                 170E
FOUNDCC             1662
GE                  C
GEM                 1B3D
GET_EFFECTIVE_ADDRESS  189A
GET_EFFECTIVE_ADDRESS_EXIT  1A0C
GET_EFFECTIVE_ADDRESS_OTHER  18D6
GT                  E
GTM                 1B41
HANDLEBYTEDATA      16E2
HEX_RANGE_ERROR     1852
HI                  2
HIM                 1B45
IDATA               1C52
INSTLABELLIST       10C6
INSTMASKLIST        10AE
INSTOPLIST          1096
INVALIDEA           1A0C
INVALIDMSG          1A82
INVCHARMSG          1AC7
JSR                 148C
JSRBODY             14B4
JSRDONE             14CC
JSREA               1484
JSREAMASKS          1488
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          1C0F
LCASEHEX            1834
LE                  F
LEM                 1B49
LETTERA             1C5C
LETTERD             1C5E
LONG                4
LPRN                1C64
LS                  3
LSM                 1B4D
LT                  D
LTM                 1B51
MAIN_LOOP           1026
MATCH               1076
MI                  B
MIM                 1B55
MINUS               1C62
MOVE                151C
MOVEA               15BE
MOVEABODY           1614
MOVEADESTEA         15BA
MOVEADESTEAMASKS    15BC
MOVEAMESSAGE        1C36
MOVEBODY            1572
MOVEDESTEA          150E
MOVEDESTEAMASKS     1515
MOVEINSTRUCTION     0
MOVEM               123A
MOVEMASK            C000
MOVEMBODY           12A4
MOVEMESSAGE         1C20
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     1230
MOVEMMEMTOREGEAMASKS  1235
MOVEMMESSAGE        1BF3
MOVEMREGTOMEMEA     1226
MOVEMREGTOMEMEAMASKS  122B
MOVESOURCEEA        14FC
MOVESOURCEEAMASKS   1505
NE                  6
NEG                 12DE
NEGBODY             1306
NEGDONE             132C
NEGEA               12CE
NEGEAMASKS          12D6
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          1C29
NEM                 1B59
NEXTHEX             17FA
NEXTHEXDONE         184C
NEXTHEXRETURN       1868
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 14DC
NOPMESSAGE          1C1A
ORI                 13A6
ORIBODY             13D2
ORIDONE             1400
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          1C02
PARSEHEXSTRING      17F8
PL                  A
PLM                 1B5D
PLUS                1C60
PRGORG              1000
PROCESS_OP_CODES    1898
PROCESS_OP_CODES_EXIT  1898
PROMPT_USER         1014
RA                  0
RAM                 1B69
RPRN                1C66
RTS                 14EC
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          1C15
SLPROMPT            1A22
SNIPPET             10F6
SNIPPETEND          112A
SPC                 1B2F
SPC_LEN             1B30
SR                  1
SRM                 1B6D
STACK               5000
START               1000
STARTLOCATION       1C68
STARTLOCATIONPROMPT  1BC2
SWITCHMODEANDREG    1A0E
UCASEHEX            181C
UNKNOWNOPCODE       16BC
VALIDADDDESTEA      118A
VALIDADDIMODES      133E
VALIDADDSOURCEEA    1160
VALIDCMPIMODES      1420
VALIDJSRMODES       148E
VALIDMEMTOREG       1276
VALIDMOVEADESTMODES  15E8
VALIDMOVEASOURCEMODES  15C0
VALIDMOVEDESTMODES  1546
VALIDMOVESOURCEMODES  151E
VALIDNEGMODES       12E0
VALIDORIMODES       13A8
VALIDREGTOMEM       1250
VC                  8
VCM                 1B61
VS                  9
VSM                 1B65
WORD                2
XXXL                1C48
XXXW                1C3E

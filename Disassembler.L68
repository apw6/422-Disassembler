00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/5/2014 11:12:02 PM

00000000                             1  *##########################################################################
00000000                             2  * Title      : 
00000000                             3  * Written by : Andrew Watson
00000000                             4  *            : Elaine Keller
00000000                             5  *            : Robert Anderson
00000000                             6  * Date       : 11/14/2014
00000000                             7  * Description: 
00000000                             8  *##########################################################################
00000000                             9  
00000000                            10  ***Possible Bug***
00000000                            11  *can not tell data from an
00000000                            12  *unidentified instruction from an actual
00000000                            13  *instruction therefore causing errors.
00000000                            14  *may not actually be a bug because data
00000000                            15  *is data to the machine, and if you modify
00000000                            16  *the instructions in memory for a program
00000000                            17  *by moivng data, you can modify the instuctions
00000000                            18  *executed.
00000000                            19  
00000000                            20  
00000000                            21  ***************************************************************************
00000000                            22  *                   Variable/Data Definitions
00000000                            23  ***************************************************************************
00000000                            24  
00000000  =00005000                 25  stack   EQU   $00005000
00000000  =00005001                 26  begin   EQU   $00005001
00000000  =00FFFFFE                 27  end     EQU   $00FFFFFE
00000000  =00000001                 28  byte    EQU   1
00000000  =00000002                 29  word    EQU   2
00000000  =00000004                 30  long    EQU   4
00000000  =00001000                 31  prgorg  EQU   $1000
00000000                            32  
00000FFE                            33      ORG $00000FFE
00000FFE                            34  FarLabel:
00001000                            35      ORG    prgorg
00001000                            36  start:
00001000  4FF8 5000                 37          LEA stack, SP ;initialize stack
00001004                            38  
00001000                            39      ORG    prgorg
00001000                            40  
00001000                            41  ******************************************************************************
00001000                            42  *                   Begin processing active code
00001000                            43  ******************************************************************************
00001000                            44      
00001000                            45  start:
00001000                            46  
00001000  4FF8 5000                 47          LEA         stack, SP           ;Initialize stack
00001004                            48          
00001004                            49  *.............................................................................
00001004                            50  * Debug Mode - Comment out when done
00001004  267C 000010EE             51          MOVE.L      #snippet,A3
0000100A  287C 0000111C             52          MOVE.L      #snippetEnd,A4
00001010  6000 0014                 53          BRA         main_Loop
00001014                            54  * Debug Mode - Comment out when done
00001014                            55  *.............................................................................        
00001014                            56          
00001014                            57  prompt_user:
00001014                            58  
00001014  6100 05F6                 59          BSR         begin_address
00001018  B67C FFFF                 60          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000101C  6700 05EA                 61          BEQ         fin                 ;Yes, then exit
00001020                            62          
00001020  6000 0004                 63          BRA         main_Loop
00001024                            64          ;BSR         process_op_codes
00001024  60EE                      65          BRA         prompt_user
00001026                            66                  
00001026                            67  ******************************************************************************
00001026                            68  *                   Begin processing OP Codes
00001026                            69  ******************************************************************************
00001026                            70   
00001026                            71  main_Loop:
00001026                            72  
00001026  B9CB                      73          CMPA.L A3,A4 ;check end of prog
00001028  6700 05DE                 74          BEQ fin
0000102C                            75          
0000102C  3213                      76          MOVE.W (A3),D1 ;copy word from other prog to analyze as instruction
0000102E                            77          
0000102E                            78          ;handle an odd memory access(instructions will never be misaligned)
0000102E  240B                      79          MOVE.L A3,D2 ; copy address to D2
00001030  0202 0001                 80          ANDI.B #%00000001,D2 ;mask everything except the least significant bit
00001034  0C02 0001                 81          CMPI.B #1,D2 ;compare the least sig bit of the address to one
00001038  6700 05A2                 82          BEQ handlebytedata ;the least sig bit will only be one if the insrtuction
0000103C                            83                             ;is odd(misaligned) and therefore not an instruction
0000103C                            84          
0000103C  7600                      85          MOVEQ.L #0,D3
0000103E                            86          
0000103E                            87          ***things to save A3,A4,D1(?)***
0000103E  48E7 0018                 88          MOVEM.L A3-A4,-(SP)
00001042  6100 000C                 89          BSR checkOPcode
00001046  4CDF 1800                 90          MOVEM.L (SP)+,A3-A4
0000104A  D7C7                      91          ADDA.L  D7,A3 ;look past data that was part of the instruction
0000104C                            92          
0000104C  548B                      93          ADDQ.L  #word,A3
0000104E  60D6                      94          BRA     main_Loop 
00001050                            95          
00001050                            96  checkOPcode:
00001050                            97  
00001050                            98  
00001050  7E00                      99          MOVEQ.L #0,D7
00001052                           100          
00001052  41F9 00001096            101          LEA     instOPList,A0 ;get instruction signitrue list in A0
00001058  D1C3                     102          ADDA.L  D3,A0 ;get correct sig         
0000105A                           103          
0000105A  43F9 000010AC            104          LEA     instMaskList,A1 ;get instruction mask in A1
00001060  D3C3                     105          ADDA.L  D3,A1  ;get correct mast
00001062                           106          
00001062  3401                     107          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001064                           108          
00001064  C451                     109          AND.W   (A1),D2 ;mask instruction
00001066                           110          
00001066                           111          
00001066                           112          
00001066                           113          
00001066  B450                     114          CMP.W   (A0),D2 ;compare to sig
00001068  6700 000C                115          BEQ     match ;if sig matches branch
0000106C  5483                     116          ADDQ.L  #word,D3 ;add to D3 to check for next instruction
0000106E  60E0                     117          BRA checkOPcode
00001070                           118          
00001070                           119  falsePositive:
00001070                           120          
00001070  103C 00FF                121          MOVE.B #-1,D0
00001074  4E75                     122          RTS
00001076                           123  
00001076                           124  match:
00001076                           125          
00001076  43F9 000010C2            126          LEA     instLabelList,A1 ;get instruction code label
0000107C  D3C3                     127          ADDA.L  D3,A1 ;get correct label
0000107E  D3C3                     128          ADDA.L  D3,A1
00001080  5483                     129          ADDQ.L  #word,D3 ;add to D3 incase false positive
00001082  2251                     130          MOVEA.L (A1),A1
00001084  48E7 1000                131          MOVEM.L D3,-(SP) ; save D3
00001088  4E91                     132          JSR     (A1)
0000108A  4CDF 0008                133          MOVEM.L (SP)+,D3 ;restore D3
0000108E  B03C 00FF                134          CMP.B   #-1,D0
00001092  67BC                     135          BEQ     checkOPcode
00001094  4E75                     136          RTS
00001096                           137          
00001096                           138  
00001096= 4880 0600 0000 0...      139  instOPList DC.W movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruction         
000010AC= FB80 FF00 FF00 F...      140  instMaskList DC.W movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
000010C2= 00001134 00001236 ...    141  instLabelList DC.L MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
000010EE                           142  
000010EE                           143  snippet:
000010EE  4E71                     144           NOP
000010F0  60FC                     145           BRA snippet
000010F2  6000 FF0A                146           BRA FarLabel
000010F6  67F6                     147           BEQ snippet
000010F8  6E00 00DE                148           BGT NEG
000010FC  61F0                     149           BSR snippet
000010FE  4441                     150           NEG D1
00001100  3239 00008500            151           MOVE.W $8500,D1
00001106  0645 001E                152           ADDI.W #30,D5
0000110A  4E75                     153           RTS
0000110C  4EB8 0054                154           JSR $54
00001110  0C41 0003                155           CMPI #3,D1
00001114  0041 0003                156           ORI  #3,D1
00001118  48E7 0018                157           MOVEM.L A3-A4,-(SP)
0000111C                           158  
0000111C                           159           
0000111C                           160  snippetEnd:
0000111C  FFFF FFFF                161           SIMHALT
00001120                           162      
00001120                           163  
00001120                           164  
00001120= 10 20 38 39 00           165  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
00001125= 38 38 3F 3F 00           166  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
0000112A                           167  
0000112A= 10 18 38 39 00           168  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
0000112F= 38 38 3F 3F 00           169  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
00001134                           170  
00001134                           171  MOVEM:
00001134                           172          
00001134                           173  
00001134                           174          
00001134  7000                     175          MOVEQ.L #0, D0 ;clear D0
00001136                           176          
00001136                           177          ;Figure out which direction we are going
00001136  3401                     178          MOVE.W D1,D2 ;copy inst to D2
00001138  E64A                     179          LSR.W #3,D2 ;shift direction bit into most sig bit of first byte
0000113A  0202 0080                180          ANDI.B #%10000000,D2 ;mask out everything but direction bit in first byte
0000113E  0C02 0000                181          CMPI.B #0,D2 ;compare bit to zero
00001142  6700 0006                182          BEQ validRegToMem ;if zero, reg to mem
00001146  6000 0028                183          BRA validMemToReg ;else, its mem to reg
0000114A                           184          
0000114A                           185  validRegToMem:
0000114A                           186          
0000114A  43F8 1125                187          LEA movemRegToMemEAmasks,A1 ;load the list of masks
0000114E  D3C0                     188          ADDA.L D0,A1 ;displace to a specific mask
00001150  1A11                     189          MOVE.B (A1),D5 ;move the mask to D5
00001152                           190          
00001152  0C05 0000                191          CMPI.B #0,D5 ;check if the mask is 0
00001156  6700 FF18                192          BEQ falsePositive ;branch if it is
0000115A                           193          
0000115A  1401                     194          MOVE.B D1,D2 ;copy instruction to D2
0000115C  C405                     195          AND.B D5,D2  ;mask D2
0000115E                           196          
0000115E  43F8 1120                197          LEA movemRegToMemEA,A1 ;load the list of valid modes
00001162  D3C0                     198          ADDA.L D0,A1 ;displace to a specific mode
00001164  1811                     199          MOVE.B (A1),D4 ;move mode to D4
00001166  B404                     200          CMP.B D4,D2 ;compare mode to masked value
00001168  6700 0034                201          BEQ  movemBody ;if its match, its a valid mode and we can procede
0000116C                           202          
0000116C  5280                     203          ADDQ.L #1,D0 ;add one to displacement
0000116E  60DA                     204          BRA validRegToMem ;check for next mode
00001170                           205          
00001170                           206          
00001170                           207  validMemToReg:
00001170                           208          
00001170  43F8 112F                209          LEA movemMemToRegEAmasks,A1 ;load the list of masks
00001174  D3C0                     210          ADDA.L D0,A1 ;displace to a specific mask
00001176  1A11                     211          MOVE.B (A1),D5 ;move the mask to D5
00001178                           212          
00001178  0C05 0000                213          CMPI.B #0,D5 ;check if the mask is 0
0000117C  6700 FEF2                214          BEQ falsePositive ;branch if it is
00001180                           215          
00001180  3401                     216          MOVE.W D1,D2 ;copy instruction to D2
00001182  EC4A                     217          LSR.W #6,D2  ;move mode
00001184  6100 0782                218          BSR switchModeAndReg ;switch register and mode
00001188  C405                     219          AND.B D5,D2  ;mask D2
0000118A                           220          
0000118A  43F8 112A                221          LEA movemMemToRegEA,A1 ;load the list of valid modes
0000118E  D3C0                     222          ADDA.L D0,A1 ;displace to a specific mode
00001190  1811                     223          MOVE.B (A1),D4 ;move mode to D4
00001192  B404                     224          CMP.B D4,D2 ;compare mode to masked value
00001194  6700 0008                225          BEQ movemBody ;if its match, its a valid mode and we can procede
00001198                           226          
00001198  5280                     227          ADDQ.L #1,D0 ;add one to displacement
0000119A  6000 02A4                228          BRA validMoveDestModes ;check for next mode
0000119E                           229          
0000119E                           230  movemBody
0000119E                           231  
0000119E  43F9 00001AE7            232          LEA     movemMessage,A1  ;move string for MOVE
000011A4  103C 000E                233          MOVE.B  #14,D0        ;set for task to display null terminated 
000011A8                           234                                ;string with CR, LF
000011A8  4E4F                     235          TRAP    #15
000011AA                           236          
000011AA                           237          ;show list
000011AA                           238          
000011AA  5487                     239          ADDQ.L #word,D7 ;read past the register list mask(word) following
000011AC                           240                          ;the instruction
000011AC                           241          
000011AC                           242          ;print separator
000011AC                           243          
000011AC  3401                     244          MOVE.W  D1,D2 ;check mode
000011AE  C43C 003F                245          AND.B   #%00111111,D2
000011B2  1A02                     246          MOVE.B  D2,D5
000011B4  6100 05DE                247          BSR     Get_Effective_Address
000011B8                           248          
000011B8                           249          
000011B8  43F9 00001AE4            250          LEA     clearLine,A1  ;move string for a CR and LF
000011BE  103C 000E                251          MOVE.B  #14,D0        ;set for task to display null terminated 
000011C2                           252                                ;string without CR, LF
000011C2  4E4F                     253          TRAP    #15
000011C4                           254  
000011C4  7000                     255          MOVEQ.L #0,D0
000011C6  4E75                     256          RTS
000011C8                           257  
000011C8                           258  
000011C8                           259      
000011C8= 00 10 18 20 28 38 ...    260  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
000011D0= 38 38 38 38 38 3F ...    261  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
000011D8                           262     
000011D8                           263  NEG:            
000011D8                           264       
000011D8  7000                     265          MOVEQ.L #0, D0 ;clear D0
000011DA                           266          
000011DA                           267  validNegModes:
000011DA                           268          
000011DA  43F8 11D0                269          LEA NegEAmasks,A1 ;load the list of masks
000011DE  D3C0                     270          ADDA.L D0,A1 ;displace to a specific mask
000011E0  1A11                     271          MOVE.B (A1),D5 ;move the mask to D5
000011E2                           272          
000011E2  0C05 0000                273          CMPI.B #0,D5 ;check if the mask is 0
000011E6  6700 FE88                274          BEQ falsePositive ;branch if it is
000011EA                           275          
000011EA  1401                     276          MOVE.B D1,D2 ;copy instruction to D2
000011EC  C405                     277          AND.B D5,D2  ;mask D2
000011EE  43F8 11C8                278          LEA NegEA,A1 ;load the list of valid modes
000011F2  D3C0                     279          ADDA.L D0,A1 ;displace to a specific mode
000011F4  1811                     280          MOVE.B (A1),D4 ;move mode to D4
000011F6  B404                     281          CMP.B D4,D2 ;compare mode to masked value
000011F8  6700 0006                282          BEQ NegBody ;if its match, its a valid mode and we can procede
000011FC                           283          
000011FC  5280                     284          ADDQ.L #1,D0 ;add one to displacement
000011FE  60DA                     285          BRA validNegModes ;check for next mode
00001200                           286          
00001200                           287  NegBody:
00001200                           288  
00001200                           289  
00001200  3401                     290          MOVE.W  D1,D2 ;copy inst to D2
00001202  C47C 0600                291          AND.W  #%0011000000000,D2 ;mask word for size
00001206  0C42 0000                292          CMPI.W #0,D2 ;0 is the only non valid size
0000120A  6700 FE64                293          BEQ falsePositive ; zero is not valid
0000120E                           294  
0000120E  43F9 00001B1D            295          LEA     negMessage,A1  ;move string for NEG info
00001214  103C 000E                296          MOVE.B  #14,D0        ;set for task to display null terminated 
00001218                           297                                ;string without CR, LF
00001218  4E4F                     298          TRAP    #15
0000121A                           299          
0000121A  3401                     300          MOVE.W D1,D2
0000121C  C47C 003F                301          AND #%000000000111111,D2
00001220  1A02                     302          MOVE.B D2,D5
00001222                           303          
00001222  6100 0570                304          BSR     Get_Effective_Address
00001226                           305          
00001226                           306                
00001226                           307          
00001226                           308  NEGdone:
00001226                           309  
00001226  43F9 00001AE4            310          LEA     clearLine,A1  ;move string for a CR and LF
0000122C  103C 000E                311          MOVE.B  #14,D0        ;set for task to display null terminated 
00001230                           312                                ;string without CR, LF
00001230  4E4F                     313          TRAP    #15
00001232  7000                     314          MOVEQ.L #0,D0
00001234  4E75                     315          RTS
00001236                           316          
00001236                           317   ADDI:            
00001236                           318       
00001236  7000                     319          MOVEQ.L #0, D0 ;clear D0
00001238                           320          
00001238                           321  validAddiModes:
00001238                           322          
00001238                           323          
00001238  43F9 00001311            324          LEA cmpiEAmasks,A1 ;load the list of masks
0000123E  D3C0                     325          ADDA.L D0,A1 ;displace to a specific mask
00001240  1A11                     326          MOVE.B (A1),D5 ;move the mask to D5
00001242                           327          
00001242  0C05 0000                328          CMPI.B #0,D5 ;check if the mask is 0
00001246  6700 FE28                329          BEQ falsePositive ;branch if it is
0000124A                           330          
0000124A  1401                     331          MOVE.B D1,D2 ;copy instruction to D2
0000124C  C405                     332          AND.B D5,D2  ;mask D2
0000124E  43F9 0000130A            333          LEA cmpiEA,A1 ;load the list of valid modes
00001254  D3C0                     334          ADDA.L D0,A1 ;displace to a specific mode
00001256  1811                     335          MOVE.B (A1),D4 ;move mode to D4
00001258  B404                     336          CMP.B D4,D2 ;compare mode to masked value
0000125A  6700 0006                337          BEQ addiBody ;if its match, its a valid mode and we can procede
0000125E                           338          
0000125E  5280                     339          ADDQ.L #1,D0 ;add one to displacement
00001260  60D6                     340          BRA validAddiModes ;check for next mode
00001262                           341          
00001262                           342  addiBody:
00001262                           343  
00001262                           344  
00001262  3401                     345          MOVE.W  D1,D2 ;copy inst to D2
00001264  C47C 00C0                346          AND.W  #%0000000011000000,D2 ;mask word for size
00001268  0C42 00C0                347          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
0000126C  6700 FE02                348          BEQ falsePositive
00001270                           349  
00001270  43F9 00001AEF            350          LEA     addiMessage,A1  ;move string for NEG info
00001276  103C 000E                351          MOVE.B  #14,D0        ;set for task to display null terminated 
0000127A                           352                                ;string without CR, LF
0000127A  4E4F                     353          TRAP    #15
0000127C                           354          
0000127C                           355          ;go to Effective_Address for immediate data
0000127C  143C 003C                356          MOVE.B #%00111100,D2
00001280  6100 0512                357          BSR Get_Effective_Address
00001284                           358          
00001284  3401                     359          MOVE.W D1,D2 ;copy inst to D2
00001286  C47C 003F                360          AND #%000000000111111,D2 ;and out everything but modes and regs
0000128A  1A02                     361          MOVE.B D2,D5 ; copy to D5 for following BSR
0000128C                           362          
0000128C  6100 0506                363          BSR Get_Effective_Address
00001290                           364          
00001290                           365                
00001290                           366          
00001290                           367  addidone:
00001290                           368  
00001290  43F9 00001AE4            369          LEA     clearLine,A1  ;move string for a CR and LF
00001296  103C 000E                370          MOVE.B  #14,D0        ;set for task to display null terminated 
0000129A                           371                                ;string without CR, LF
0000129A  4E4F                     372          TRAP    #15
0000129C  7000                     373          MOVEQ.L #0,D0
0000129E  4E75                     374          RTS
000012A0                           375    
000012A0                           376  ORI:            
000012A0                           377       
000012A0  7000                     378          MOVEQ.L #0, D0 ;clear D0
000012A2                           379          
000012A2                           380  validOriModes:
000012A2                           381          
000012A2                           382          
000012A2  43F9 00001311            383          LEA cmpiEAmasks,A1 ;load the list of masks
000012A8  D3C0                     384          ADDA.L D0,A1 ;displace to a specific mask
000012AA  1A11                     385          MOVE.B (A1),D5 ;move the mask to D5
000012AC                           386          
000012AC  0C05 0000                387          CMPI.B #0,D5 ;check if the mask is 0
000012B0  6700 FDBE                388          BEQ falsePositive ;branch if it is
000012B4                           389          
000012B4  1401                     390          MOVE.B D1,D2 ;copy instruction to D2
000012B6  C405                     391          AND.B D5,D2  ;mask D2
000012B8  43F9 0000130A            392          LEA cmpiEA,A1 ;load the list of valid modes
000012BE  D3C0                     393          ADDA.L D0,A1 ;displace to a specific mode
000012C0  1811                     394          MOVE.B (A1),D4 ;move mode to D4
000012C2  B404                     395          CMP.B D4,D2 ;compare mode to masked value
000012C4  6700 0006                396          BEQ oriBody ;if its match, its a valid mode and we can procede
000012C8                           397          
000012C8  5280                     398          ADDQ.L #1,D0 ;add one to displacement
000012CA  60D6                     399          BRA validOriModes ;check for next mode
000012CC                           400          
000012CC                           401  oriBody:
000012CC                           402  
000012CC                           403  
000012CC  3401                     404          MOVE.W  D1,D2 ;copy inst to D2
000012CE  C47C 00C0                405          AND.W  #%0000000011000000,D2 ;mask word for size
000012D2  0C42 00C0                406          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
000012D6  6700 FD98                407          BEQ falsePositive
000012DA                           408  
000012DA  43F9 00001AF6            409          LEA     oriMessage,A1  ;move string for NEG info
000012E0  103C 000E                410          MOVE.B  #14,D0        ;set for task to display null terminated 
000012E4                           411                                ;string without CR, LF
000012E4  4E4F                     412          TRAP    #15
000012E6                           413          
000012E6                           414          ;go to Effective_Address for immediate data
000012E6  143C 003C                415          MOVE.B #%00111100,D2
000012EA  6100 04A8                416          BSR Get_Effective_Address
000012EE                           417          
000012EE  3401                     418          MOVE.W D1,D2 ;copy inst to D2
000012F0  C47C 003F                419          AND #%000000000111111,D2 ;and out everything but modes and regs
000012F4  1A02                     420          MOVE.B D2,D5 ; copy to D5 for following BSR
000012F6                           421          
000012F6  6100 049C                422          BSR Get_Effective_Address
000012FA                           423          
000012FA                           424                
000012FA                           425          
000012FA                           426  oridone:
000012FA                           427  
000012FA  43F9 00001AE4            428          LEA     clearLine,A1  ;move string for a CR and LF
00001300  103C 000E                429          MOVE.B  #14,D0        ;set for task to display null terminated 
00001304                           430                                ;string without CR, LF
00001304  4E4F                     431          TRAP    #15
00001306  7000                     432          MOVEQ.L #0,D0
00001308  4E75                     433          RTS
0000130A                           434  
0000130A                           435          
0000130A                           436          
0000130A= 20 18 00 10 38 39 00     437  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
00001311= 38 38 38 38 3F 3F 00     438  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
00001318                           439     
00001318                           440  CMPI:            
00001318                           441       
00001318  7000                     442          MOVEQ.L #0, D0 ;clear D0
0000131A                           443          
0000131A                           444  validCmpiModes:
0000131A                           445          
0000131A                           446          
0000131A  43F8 1311                447          LEA cmpiEAmasks,A1 ;load the list of masks
0000131E  D3C0                     448          ADDA.L D0,A1 ;displace to a specific mask
00001320  1A11                     449          MOVE.B (A1),D5 ;move the mask to D5
00001322                           450          
00001322  0C05 0000                451          CMPI.B #0,D5 ;check if the mask is 0
00001326  6700 FD48                452          BEQ falsePositive ;branch if it is
0000132A                           453          
0000132A  1401                     454          MOVE.B D1,D2 ;copy instruction to D2
0000132C  C405                     455          AND.B D5,D2  ;mask D2
0000132E  43F8 130A                456          LEA cmpiEA,A1 ;load the list of valid modes
00001332  D3C0                     457          ADDA.L D0,A1 ;displace to a specific mode
00001334  1811                     458          MOVE.B (A1),D4 ;move mode to D4
00001336  B404                     459          CMP.B D4,D2 ;compare mode to masked value
00001338  6700 0006                460          BEQ CMPIBody ;if its match, its a valid mode and we can procede
0000133C                           461          
0000133C  5280                     462          ADDQ.L #1,D0 ;add one to displacement
0000133E  60DA                     463          BRA validCmpiModes ;check for next mode
00001340                           464          
00001340                           465  CMPIBody:
00001340                           466  
00001340                           467  
00001340  3401                     468          MOVE.W  D1,D2 ;copy inst to D2
00001342  C47C 00C0                469          AND.W  #%0000000011000000,D2 ;mask word for size
00001346  0C42 00C0                470          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
0000134A  6700 FD24                471          BEQ falsePositive
0000134E                           472  
0000134E  43F9 00001AFC            473          LEA     cmpiMessage,A1  ;move string for NEG info
00001354  103C 000E                474          MOVE.B  #14,D0        ;set for task to display null terminated 
00001358                           475                                ;string without CR, LF
00001358  4E4F                     476          TRAP    #15
0000135A                           477          
0000135A                           478          ;go to Effective_Address for immediate data
0000135A  143C 003C                479          MOVE.B #%00111100,D2
0000135E  6100 0434                480          BSR Get_Effective_Address
00001362                           481          
00001362  3401                     482          MOVE.W D1,D2 ;copy inst to D2
00001364  C47C 003F                483          AND #%000000000111111,D2 ;and out everything but modes and regs
00001368  1A02                     484          MOVE.B D2,D5 ; copy to D5 for following BSR
0000136A                           485          
0000136A  6100 0428                486          BSR Get_Effective_Address
0000136E                           487          
0000136E                           488                
0000136E                           489          
0000136E                           490  CMPidone:
0000136E                           491  
0000136E  43F9 00001AE4            492          LEA     clearLine,A1  ;move string for a CR and LF
00001374  103C 000E                493          MOVE.B  #14,D0        ;set for task to display null terminated 
00001378                           494                                ;string without CR, LF
00001378  4E4F                     495          TRAP    #15
0000137A  7000                     496          MOVEQ.L #0,D0
0000137C  4E75                     497          RTS
0000137E                           498  
0000137E                           499          
0000137E= 10 38 39 00              500  JsrEA        DC.B %010000, %111000, %111001,0
00001382= 38 3F 3F 00              501  JsrEAmasks   DC.B %111000, %111111, %111111,0
00001386                           502     
00001386                           503  JSR:            
00001386                           504       
00001386  7000                     505          MOVEQ.L #0, D0 ;clear D0
00001388                           506          
00001388                           507  validJsrModes:
00001388                           508          
00001388  43F8 1382                509          LEA JsrEAmasks,A1 ;load the list of masks
0000138C  D3C0                     510          ADDA.L D0,A1 ;displace to a specific mask
0000138E  1A11                     511          MOVE.B (A1),D5 ;move the mask to D5
00001390                           512          
00001390  0C05 0000                513          CMPI.B #0,D5 ;check if the mask is 0
00001394  6700 FCDA                514          BEQ falsePositive ;branch if it is
00001398                           515          
00001398  1401                     516          MOVE.B D1,D2 ;copy instruction to D2
0000139A  C405                     517          AND.B D5,D2  ;mask D2
0000139C  43F8 137E                518          LEA JsrEA,A1 ;load the list of valid modes
000013A0  D3C0                     519          ADDA.L D0,A1 ;displace to a specific mode
000013A2  1811                     520          MOVE.B (A1),D4 ;move mode to D4
000013A4  B404                     521          CMP.B D4,D2 ;compare mode to masked value
000013A6  6700 0006                522          BEQ JsrBody ;if its match, its a valid mode and we can procede
000013AA                           523          
000013AA  5280                     524          ADDQ.L #1,D0 ;add one to displacement
000013AC  60DA                     525          BRA validJsrModes ;check for next mode
000013AE                           526          
000013AE                           527  JsrBody:
000013AE                           528  
000013AE                           529  
000013AE  43F9 00001B03            530          LEA     jsrMessage,A1  ;move string for NEG info
000013B4  103C 000E                531          MOVE.B  #14,D0        ;set for task to display null terminated 
000013B8                           532                                ;string without CR, LF
000013B8  4E4F                     533          TRAP    #15
000013BA                           534          
000013BA  3401                     535          MOVE.W D1,D2 ;copy inst to D2
000013BC  C47C 003F                536          AND #%000000000111111,D2 ;and out everything but modes and regs
000013C0  1A02                     537          MOVE.B D2,D5 ; copy to D5 for following BSR
000013C2                           538          
000013C2  6100 03D0                539          BSR     Get_Effective_Address
000013C6                           540          
000013C6                           541                
000013C6                           542          
000013C6                           543  Jsrdone:
000013C6                           544  
000013C6  43F9 00001AE4            545          LEA     clearLine,A1  ;move string for a CR and LF
000013CC  103C 000E                546          MOVE.B  #14,D0        ;set for task to display null terminated 
000013D0                           547                                ;string without CR, LF
000013D0  4E4F                     548          TRAP    #15
000013D2  7000                     549          MOVEQ.L #0,D0
000013D4  4E75                     550          RTS
000013D6                           551  
000013D6                           552  
000013D6                           553          
000013D6                           554  NOP:
000013D6                           555  
000013D6  43F9 00001B0E            556          LEA     nopMessage,A1 ;move string for NOP info
000013DC  103C 000D                557          MOVE.B  #13,D0        ;set for task to display null terminated 
000013E0                           558                                ;string with CR, LF
000013E0  4E4F                     559          TRAP    #15
000013E2                           560          
000013E2  7000                     561          MOVEQ.L #0,D0
000013E4  4E75                     562          RTS
000013E6                           563          
000013E6                           564  RTS:
000013E6                           565          
000013E6  43F9 00001B09            566          LEA     rtsMessage,A1  ;move string for rts info
000013EC  103C 000D                567          MOVE.B  #13,D0        ;set for task to display null terminated 
000013F0                           568                                ;string with CR, LF
000013F0  4E4F                     569          TRAP    #15  
000013F2                           570     
000013F2  7000                     571          MOVEQ.L #0,D0
000013F4  4E75                     572          RTS   
000013F6                           573  
000013F6= 3C 08 00 10 18 20 ...    574  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
000013FF= 3F 38 38 38 38 38 ...    575  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001408                           576  
00001408= 00 10 18 20 38 39 00     577  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
0000140F= 38 38 38 38 3F 3F 00     578  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
00001416                           579  
00001416                           580  MOVE:
00001416                           581          
00001416                           582  
00001416                           583          
00001416  7000                     584          MOVEQ.L #0, D0 ;clear D0
00001418                           585          
00001418                           586  validMoveSourceModes:
00001418                           587          
00001418  43F8 13FF                588          LEA moveSourceEAmasks,A1 ;load the list of masks
0000141C  D3C0                     589          ADDA.L D0,A1 ;displace to a specific mask
0000141E  1A11                     590          MOVE.B (A1),D5 ;move the mask to D5
00001420                           591          
00001420  0C05 0000                592          CMPI.B #0,D5 ;check if the mask is 0
00001424  6700 FC4A                593          BEQ falsePositive ;branch if it is
00001428                           594          
00001428  1401                     595          MOVE.B D1,D2 ;copy instruction to D2
0000142A  C405                     596          AND.B D5,D2  ;mask D2
0000142C                           597          
0000142C  43F8 13F6                598          LEA moveSourceEA,A1 ;load the list of valid modes
00001430  D3C0                     599          ADDA.L D0,A1 ;displace to a specific mode
00001432  1811                     600          MOVE.B (A1),D4 ;move mode to D4
00001434  B404                     601          CMP.B D4,D2 ;compare mode to masked value
00001436  6700 0006                602          BEQ  checkMoveDest ;if its match, its a valid mode and we can procede
0000143A                           603          
0000143A  5280                     604          ADDQ.L #1,D0 ;add one to displacement
0000143C  60DA                     605          BRA validMoveSourceModes ;check for next mode
0000143E                           606          
0000143E                           607  checkMoveDest:
0000143E  7000                     608          MOVEQ.L #0, D0 ;clear D0
00001440                           609          
00001440                           610  validMoveDestModes:
00001440                           611          
00001440  43F8 140F                612          LEA moveDestEAmasks,A1 ;load the list of masks
00001444  D3C0                     613          ADDA.L D0,A1 ;displace to a specific mask
00001446  1A11                     614          MOVE.B (A1),D5 ;move the mask to D5
00001448                           615          
00001448  0C05 0000                616          CMPI.B #0,D5 ;check if the mask is 0
0000144C  6700 FC22                617          BEQ falsePositive ;branch if it is
00001450                           618          
00001450  3401                     619          MOVE.W D1,D2 ;copy instruction to D2
00001452  EC4A                     620          LSR.W #6,D2  ;move mode
00001454  6100 04B2                621          BSR switchModeAndReg ;switch register and mode
00001458  C405                     622          AND.B D5,D2  ;mask D2
0000145A                           623          
0000145A  43F8 1408                624          LEA moveDestEA,A1 ;load the list of valid modes
0000145E  D3C0                     625          ADDA.L D0,A1 ;displace to a specific mode
00001460  1811                     626          MOVE.B (A1),D4 ;move mode to D4
00001462  B404                     627          CMP.B D4,D2 ;compare mode to masked value
00001464  6700 0006                628          BEQ moveBody ;if its match, its a valid mode and we can procede
00001468                           629          
00001468  5280                     630          ADDQ.L #1,D0 ;add one to displacement
0000146A  60D4                     631          BRA validMoveDestModes ;check for next mode
0000146C                           632          
0000146C                           633  moveBody
0000146C  3401                     634          MOVE.W  D1,D2 ;copy inst to D2
0000146E  C47C 3000                635          AND.W  #%0011000000000000,D2 ;mask word for size
00001472  0C42 0000                636          CMPI.W #0,D2 ;0 is the only non valid size
00001476  6700 FBF8                637          BEQ falsePositive ; if zero, this is not move
0000147A                           638  
0000147A  43F9 00001B14            639          LEA     moveMessage,A1  ;move string for MOVE
00001480  103C 000E                640          MOVE.B  #14,D0        ;set for task to display null terminated 
00001484                           641                                ;string with CR, LF
00001484  4E4F                     642          TRAP    #15
00001486                           643          
00001486                           644          
00001486  3401                     645          MOVE.W  D1,D2 ;check source mode
00001488  C43C 003F                646          AND.B   #%00111111,D2
0000148C  1A02                     647          MOVE.B  D2,D5
0000148E  6100 0304                648          BSR     Get_Effective_Address
00001492                           649          
00001492                           650          ;print separator
00001492                           651          
00001492  3401                     652          MOVE.W  D1,D2 ;check dest mode
00001494  EC4A                     653          LSR.W   #6,D2
00001496  6100 0470                654          BSR  switchModeAndReg
0000149A  C43C 003F                655          AND.B   #%00111111,D2
0000149E  1A02                     656          MOVE.B  D2,D5
000014A0  6100 02F2                657          BSR     Get_Effective_Address
000014A4                           658          
000014A4                           659          
000014A4                           660          
000014A4  43F9 00001AE4            661          LEA     clearLine,A1  ;move string for a CR and LF
000014AA  103C 000E                662          MOVE.B  #14,D0        ;set for task to display null terminated 
000014AE                           663                                ;string without CR, LF
000014AE  4E4F                     664          TRAP    #15
000014B0                           665  
000014B0  7000                     666          MOVEQ.L #0,D0
000014B2  4E75                     667          RTS
000014B4                           668          
000014B4= 08 00                    669  moveADestEA        DC.B %001000,0
000014B6= 38 00                    670  moveADestEAmasks   DC.B %111000,0
000014B8                           671          
000014B8                           672  MOVEA:
000014B8                           673  
000014B8  7000                     674          MOVEQ.L #0, D0 ;clear D0
000014BA                           675          
000014BA                           676  validMoveASourceModes:
000014BA                           677          
000014BA  43F8 13FF                678          LEA moveSourceEAmasks,A1 ;load the list of masks
000014BE  D3C0                     679          ADDA.L D0,A1 ;displace to a specific mask
000014C0  1A11                     680          MOVE.B (A1),D5 ;move the mask to D5
000014C2                           681          
000014C2  0C05 0000                682          CMPI.B #0,D5 ;check if the mask is 0
000014C6  6700 FBA8                683          BEQ falsePositive ;branch if it is
000014CA                           684          
000014CA  1401                     685          MOVE.B D1,D2 ;copy instruction to D2
000014CC  C405                     686          AND.B D5,D2  ;mask D2
000014CE                           687          
000014CE  43F8 13F6                688          LEA moveSourceEA,A1 ;load the list of valid modes
000014D2  D3C0                     689          ADDA.L D0,A1 ;displace to a specific mode
000014D4  1811                     690          MOVE.B (A1),D4 ;move mode to D4
000014D6  B404                     691          CMP.B D4,D2 ;compare mode to masked value
000014D8  6700 0006                692          BEQ  checkMoveADest ;if its match, its a valid mode and we can procede
000014DC                           693          
000014DC  5280                     694          ADDQ.L #1,D0 ;add one to displacement
000014DE  60DA                     695          BRA validMoveASourceModes ;check for next mode
000014E0                           696          
000014E0                           697  checkMoveADest:
000014E0  7000                     698          MOVEQ.L #0, D0 ;clear D0
000014E2                           699  validMoveADestModes:
000014E2                           700          
000014E2  43F8 14B6                701          LEA moveADestEAmasks,A1 ;load the list of masks
000014E6  D3C0                     702          ADDA.L D0,A1 ;displace to a specific mask
000014E8  1A11                     703          MOVE.B (A1),D5 ;move the mask to D5
000014EA                           704          
000014EA  0C05 0000                705          CMPI.B #0,D5 ;check if the mask is 0
000014EE  6700 FB80                706          BEQ falsePositive ;branch if it is
000014F2                           707          
000014F2  3401                     708          MOVE.W D1,D2 ;copy instruction to D2
000014F4  EA4A                     709          LSR.W #5,D2  ;move mode
000014F6  6100 0410                710          BSR switchModeAndReg ;switch register and mode
000014FA  C405                     711          AND.B D5,D2  ;mask D2
000014FC                           712          
000014FC  43F8 14B4                713          LEA moveADestEA,A1 ;load the list of valid modes
00001500  D3C0                     714          ADDA.L D0,A1 ;displace to a specific mode
00001502  1811                     715          MOVE.B (A1),D4 ;move mode to D4
00001504  B404                     716          CMP.B D4,D2 ;compare mode to masked value
00001506  6700 0006                717          BEQ moveABody ;if its match, its a valid mode and we can procede
0000150A                           718          
0000150A  5280                     719          ADDQ.L #1,D0 ;add one to displacement
0000150C  60D4                     720          BRA validMoveADestModes ;check for next mode
0000150E                           721  moveABody:
0000150E  3401                     722          MOVE.W  D1,D2 ;copy inst to D2
00001510  C47C 3000                723          AND.W  #%0011000000000000,D2 ;mask word for size
00001514  0C42 0000                724          CMPI.W #0,D2 ;0 is the non valid size
00001518  6700 FB56                725          BEQ falsePositive ; if zero, this is not move
0000151C  0C42 1000                726          CMPI.W #%0001000000000000,D2
00001520  6700 FB4E                727          BEQ falsePositive ; if byte, this is not movea
00001524                           728  
00001524                           729  
00001524  43F9 00001B2A            730          LEA     moveAMessage,A1  ;move string for MOVE
0000152A  103C 000D                731          MOVE.B  #13,D0        ;set for task to display null terminated 
0000152E                           732                                ;string with CR, LF
0000152E  4E4F                     733          TRAP    #15
00001530                           734  
00001530  7000                     735          MOVEQ.L #0,D0
00001532  4E75                     736          RTS
00001534                           737  
00001534                           738             
00001534                           739  Bcc:
00001534                           740  
00001534  43F9 00001B1B            741          LEA     bccMessage,A1  ;move string for BRA info
0000153A  103C 000E                742          MOVE.B  #14,D0        ;set for task to display null terminated 
0000153E                           743                                ;string without CR, LF
0000153E  4E4F                     744          TRAP    #15
00001540                           745          
00001540  7000                     746          MOVEQ.L #0,D0 ;clear D0
00001542  3401                     747          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001544  E04A                     748          LSR.W   #8,D2
00001546  C47C 000F                749          AND.W   #$0F,D2 ;mask instruction
0000154A                           750          
0000154A                           751  checkCC:        
0000154A  41F9 00001A6B            752          LEA     bccList,A0 ;get condition code signature list in A0
00001550  D1C0                     753          ADDA.L  D0,A0 ;get correct sig         
00001552  B410                     754          CMP.B   (A0),D2 ;compare to sig
00001554  6700 0006                755          BEQ     foundCC ;if sig matches branch
00001558  5200                     756          ADDQ.B  #byte,D0
0000155A  60EE                     757          BRA     checkCC
0000155C                           758  foundCC:
0000155C  43F9 00001A7C            759          LEA     conditionCodeMessage,A1 ;get condition code message in A1
00001562  C0FC 0004                760          MULU.W  #long,D0 ;adjust size of D0 for a long
00001566  D3C0                     761          ADDA.L  D0,A1 ;get correct message location
00001568  2251                     762          MOVEA.L (A1),A1 ;get correct message
0000156A                           763          
0000156A  103C 000E                764          MOVE.B  #14,D0        ;set for task to display null terminated 
0000156E                           765                                ;string without CR, LF
0000156E  4E4F                     766          TRAP    #15
00001570                           767  
00001570                           768          
00001570                           769          
00001570  548B                     770          ADDQ.L  #word,A3 ;move past instruction in case long displacement
00001572  C27C 00FF                771          AND.W   #$00FF,D1   ;check for word sized displacement
00001576                           772          
00001576  B23C 0000                773          CMP.B   #$0,D1
0000157A  6700 0010                774          BEQ     BccWord
0000157E                           775          
0000157E  B23C 00FF                776          CMP.B   #$FF,D1 check for long sized displacement
00001582  6700 0010                777          BEQ     BccLong
00001586                           778          
00001586                           779  BccByte:
00001586                           780          
00001586  7E00                     781          MOVEQ.L #0,D7 ;pass back no extra data followed
00001588  6000 0012                782          BRA     BccDone
0000158C                           783  BccWord:
0000158C  3213                     784          MOVE.W  (A3),D1
0000158E                           785          
0000158E  7E02                     786          MOVEQ.L #word,D7 ;pass back an extra word followed
00001590  6000 000A                787          BRA     BccDone
00001594                           788  BccLong:
00001594  2213                     789          MOVE.L  (A3),D1
00001596                           790          
00001596  7E04                     791          MOVEQ.L #long,D7 ;pass back an extra long followed
00001598  6000 0002                792          BRA     BccDone
0000159C                           793  BccDone:
0000159C                           794  
0000159C  343C 0010                795          MOVE.W  #16,D2 ;put base in D2
000015A0  303C 000F                796          MOVE.W  #15,D0  ;put task #15 in D0
000015A4  4E4F                     797          TRAP    #15
000015A6                           798          
000015A6  43F9 00001AE4            799          LEA     clearLine,A1  ;move string for a CR and LF
000015AC  103C 000E                800          MOVE.B  #14,D0        ;set for task to display null terminated 
000015B0                           801                                ;string without CR, LF
000015B0  4E4F                     802          TRAP    #15
000015B2                           803  
000015B2  7000                     804          MOVEQ.L #0,D0
000015B4  4E75                     805          RTS
000015B6                           806          
000015B6                           807          
000015B6                           808  unknownOpCode:
000015B6  43F9 00001B23            809          LEA     dataMessage,A1 ;move string for data info
000015BC  103C 000E                810          MOVE.B  #14,D0        ;set for task to display null terminated 
000015C0                           811                                ;string without CR, LF
000015C0  4E4F                     812          TRAP    #15
000015C2                           813          
000015C2  143C 0010                814          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
000015C6  103C 000F                815          MOVE.B  #15,D0
000015CA  4E4F                     816          TRAP    #15
000015CC                           817          
000015CC  43F9 00001AE4            818          LEA     clearLine,A1  ;move string for a CR and LF
000015D2  103C 000E                819          MOVE.B  #14,D0        ;set for task to display null terminated 
000015D6                           820                                ;string without CR, LF
000015D6  4E4F                     821          TRAP    #15
000015D8                           822          
000015D8  7000                     823          MOVEQ.L #0,D0
000015DA  4E75                     824          RTS
000015DC                           825          
000015DC                           826  handlebytedata:
000015DC                           827  
000015DC  43F9 00001B23            828          LEA     dataMessage,A1 ;move string for data info
000015E2  103C 000E                829          MOVE.B  #14,D0        ;set for task to display null terminated 
000015E6                           830                                ;string without CR, LF
000015E6  4E4F                     831          TRAP    #15
000015E8                           832          
000015E8  E049                     833          LSR.W   #8,D1 ;shift the word read into D1 by a byte
000015EA                           834          
000015EA  143C 0010                835          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
000015EE  103C 000F                836          MOVE.B  #15,D0
000015F2  4E4F                     837          TRAP    #15
000015F4                           838          
000015F4  43F9 00001AE4            839          LEA     clearLine,A1  ;move string for a CR and LF
000015FA  103C 000E                840          MOVE.B  #14,D0        ;set for task to display null terminated 
000015FE                           841                                ;string without CR, LF
000015FE  4E4F                     842          TRAP    #15
00001600                           843          
00001600  7000                     844          MOVEQ.L #0,D0
00001602                           845          
00001602  528B                     846          ADDQ.L  #byte,A3
00001604  6000 FA20                847          BRA main_Loop
00001608                           848  
00001608                           849          
00001608                           850          
00001608                           851  fin
00001608                           852  
00001608                           853          
00001608                           854          
00001608  FFFF FFFF                855          simhalt
0000160C                           856          
0000160C                           857  
0000160C                           858  *******************************************************************************
0000160C                           859  *                            SUB ROUTINES
0000160C                           860  *******************************************************************************
0000160C                           861  
0000160C                           862  *******************************************************************************
0000160C                           863  *                          IO ROLE ROUTINES
0000160C                           864  *******************************************************************************
0000160C                           865  
0000160C                           866  *==========================================================================
0000160C                           867  *                   Enter / Validate beginning address 
0000160C                           868  *==========================================================================
0000160C                           869   
0000160C                           870  begin_address:
0000160C                           871  
0000160C                           872         
0000160C  43F9 0000191C            873          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00001612  2239 0000191C            874          MOVE.L      slPrompt,D1         ;Load display length to D1
00001618  700E                     875          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
0000161A  4E4F                     876          TRAP        #15                 ;Perform task 14 (display)
0000161C                           877          
0000161C  43F9 00001B5C            878          LEA         startLocation,A1    ;Load address to store user input
00001622  103C 0002                879          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001626  4E4F                     880          TRAP        #15                 ;Perform task 2 (input)
00001628                           881          
00001628  0C11 001B                882          CMP.B       #27,(A1)            ;Check for ESC entered
0000162C  6700 004C                883          BEQ         address_Exit        ;Exit condition 
00001630                           884          
00001630  6100 0050                885          BSR         enter_addr_edit_all
00001634  B67C FFFF                886          CMP.W       #-1,D3              ;Did the edit pass?
00001638  67D2                     887          BEQ         begin_address       ;No, loop and ask for correct input
0000163A                           888          
0000163A  2643                     889          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
0000163C                           890          
0000163C  43F9 00001A29            891          LEA         spc,A1              ;Load address for starting loaction prompt
00001642  1239 00001A2A            892          MOVE.B      spc_len,D1          ;Load empty line length
00001648  7000                     893          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
0000164A  4E4F                     894          TRAP        #15                 ;Perform task 14 (display)
0000164C  6000 0002                895          BRA         end_address
00001650                           896  
00001650                           897  *===========================================================================
00001650                           898  *                   Enter / Validate ending address 
00001650                           899  *===========================================================================
00001650                           900  
00001650                           901  end_address:
00001650                           902          
00001650  43F9 0000194D            903          LEA         elPrompt,A1         ;Load address for ending loaction prompt
00001656                           904          ;MOVE.L     elPrompt,D1         ;Load display length to D1
00001656  7250                     905          MOVE.L      #80,D1       ;did not like previous command, do not know why, it should have worked
00001658  700E                     906          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
0000165A  4E4F                     907          TRAP        #15                 ;Perform task 14 (display)
0000165C                           908          
0000165C  103C 0002                909          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001660  4E4F                     910          TRAP        #15                 ;Perform task 2 (input)
00001662                           911          
00001662  0C11 001B                912          CMP.B       #27,(A1)            ;Check for ESC entered
00001666  6700 0012                913          BEQ         address_Exit        ;Exit condition 
0000166A                           914          
0000166A  6100 0016                915          BSR         enter_addr_edit_all
0000166E  B67C FFFF                916          CMP.W       #-1,D3              ;Did the edit pass?
00001672  67DC                     917          BEQ         end_address         ;No, loop and ask for correct input
00001674                           918  
00001674  2843                     919          MOVEA.L     D3,A4               ;Ending address gets stored in A4
00001676  6000 0008                920          BRA         address_done
0000167A                           921  
0000167A                           922  address_Exit:
0000167A                           923  
0000167A  76FF                     924          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000167C  6000 0002                925          BRA         address_done
00001680                           926          
00001680                           927  address_done:
00001680                           928  
00001680  4E75                     929          RTS    
00001682                           930  
00001682                           931  *==============================================================================
00001682                           932  * enter_addr_edit_all - Enter address edit check to edit all errors  
00001682                           933  *                       using multiple different error checking routines.
00001682                           934  *
00001682                           935  * Parameters -
00001682                           936  *   Input   A1      The data that needs checked.
00001682                           937  *   Input   D1      The number of characters input     
00001682                           938  *   Output  D3      Returns '-1' when there is an error.
00001682                           939  *==============================================================================
00001682                           940  
00001682                           941  enter_addr_edit_all
00001682                           942  
00001682                           943  *------------------------------------------------------------------------------
00001682                           944  * Test for odd number of characters entered, not allowed
00001682                           945  *------------------------------------------------------------------------------
00001682                           946         
00001682  6100 0024                947          BSR         ck_boundry          ;check if the input is on a odd / even boundry
00001686  B67C FFFF                948          CMP.W       #-1,D3              ;Is the address odd?
0000168A  6700 001A                949          BEQ         enter_addr_edit_all_exit     ;No, return
0000168E                           950  
0000168E                           951  *------------------------------------------------------------------------------
0000168E                           952  * Ttest for character entered all being valid address characters
0000168E                           953  * Note: lower case a-f, gets converted to upper case A-F in D3
0000168E                           954  *------------------------------------------------------------------------------
0000168E                           955          
0000168E  6100 0062                956          BSR         parseHexString      ;check if the input contains valid Hex characters
00001692  B67C FFFF                957          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
00001696  6700 000E                958          BEQ         enter_addr_edit_all_exit     ;No, return
0000169A                           959  
0000169A                           960  *------------------------------------------------------------------------------
0000169A                           961  * Verify that the address entered is witin the range defined in the Equate
0000169A                           962  *------------------------------------------------------------------------------        
0000169A                           963          
0000169A  6100 00C8                964          BSR         ck_addr_range       ;is address entered witin the range 
0000169E                           965                                          ;   as defined in the Equate? 
0000169E  B67C FFFF                966          CMP.W       #-1,D3              ;is the address  valid?
000016A2  6700 0002                967          BEQ         enter_addr_edit_all_exit     ;No, return
000016A6                           968  
000016A6                           969  enter_addr_edit_all_exit:
000016A6                           970  
000016A6  4E75                     971          RTS                             ;return
000016A8                           972  
000016A8                           973  *==============================================================================
000016A8                           974  * ck_boundry - Check the size of the data characters input and determine
000016A8                           975  *              if an odd number of characters was entered
000016A8                           976  *
000016A8                           977  * Parameters -
000016A8                           978  *   Input   A1      The data that needs checked for odd length.
000016A8                           979  *   Input   D1      The number of characters input     
000016A8                           980  *   Output  D3      Returns '-1' when there is an odd length.
000016A8                           981  *==============================================================================
000016A8                           982  
000016A8                           983  ck_boundry:
000016A8                           984  
000016A8  4243                     985          CLR.W       D3                  ;Clear the return
000016AA                           986  
000016AA  B23C 0000                987          CMP.B       #0,D1               ;Check for nothing entered
000016AE  6700 002E                988          BEQ         ck_size_error       ;Number of characters entered must be 
000016B2                           989                                          ;greater than 0  
000016B2                           990          
000016B2                           991          
000016B2                           992          * The program will branch to ck_size_error if D1 is greater than #8        
000016B2  B23C 0008                993          CMP.B       #8,D1               ;Check for more than 8 characters entered
000016B6  6E00 0026                994          BGT         ck_size_error       ;Number of characters entered must be less
000016BA                           995                                          ;than 9
000016BA                           996          
000016BA  7402                     997          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
000016BC  82C2                     998          DIVU        D2,D1               ;Divide address by 2
000016BE  4841                     999          SWAP        D1                  ;get remainder
000016C0  B23C 0001               1000          CMP.B       #$01,D1             ;Check for remainder of 1
000016C4  6700 0004               1001          BEQ         ck_boundry_error    ;Number of characters entered must be an 
000016C8                          1002                                          ;even number   
000016C8                          1003    
000016C8  4E75                    1004          RTS                             ;return
000016CA                          1005  
000016CA                          1006  *------------------------------------------------------------------------------
000016CA                          1007  * ck_boundry_error - An odd number of characters was entered
000016CA                          1008  *                  - Load error message and display it
000016CA                          1009  *                  - Return error condition
000016CA                          1010  *------------------------------------------------------------------------------
000016CA                          1011          
000016CA                          1012  ck_boundry_error:
000016CA                          1013  
000016CA  43F9 00001A09           1014          LEA         even_msg,A1         ;Load odd error message into A1
000016D0  2239 00001A09           1015          MOVE.L      even_msg,D1         ;Load error length to D1
000016D6                          1016          
000016D6  7000                    1017          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
000016D8                          1018                                          ; n is D1.W with CR, LF. 
000016D8  4E4F                    1019          TRAP #15                        ;Display the error message
000016DA  76FF                    1020          MOVE.L #-1,D3                   ;Load -1 into return parameter
000016DC  4E75                    1021          RTS                             ;Return
000016DE                          1022          
000016DE                          1023  *------------------------------------------------------------------------------
000016DE                          1024  * ck_size_error -   The number of characters entered must be more than zero
000016DE                          1025  *                  - Load error message and display it
000016DE                          1026  *                  - Return error condition
000016DE                          1027  *------------------------------------------------------------------------------
000016DE                          1028          
000016DE                          1029  ck_size_error:
000016DE                          1030  
000016DE  43F9 0000197C           1031          LEA         invalidMsg,A1       ;Load invalid range message into A1
000016E4  2239 0000197C           1032          MOVE.L      invalidMsg,D1       ;Load error length to D1
000016EA                          1033          
000016EA  7000                    1034          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
000016EC                          1035                                          ; n is D1.W with CR, LF. 
000016EC  4E4F                    1036          TRAP        #15                 ;Display the error message
000016EE  76FF                    1037          MOVE.L      #-1,D3              ;Load -1 into return parameter
000016F0  4E75                    1038          RTS                             ;Return        
000016F2                          1039  
000016F2                          1040  
000016F2                          1041  *==============================================================================
000016F2                          1042  * parseHexString - Converts user input string into a valid memory address
000016F2                          1043  *                - Stores parsed address data into D3
000016F2                          1044  *                - Stores good/bad (1/0) data in D4 
000016F2                          1045  *
000016F2                          1046  * Hex values are stored as bytes in D2, the ASCII chart shows their value
000016F2                          1047  *   The ASCII chart values we care about are in the ranges of: 
000016F2                          1048  *                            Hex            Decimal
000016F2                          1049  *       No Value           NULL = 0         0
000016F2                          1050  *       Numeric Values:     0-9 = 30-39     48-57
000016F2                          1051  *       Upper Case letters: A-F = 41-46     65-70
000016F2                          1052  *       Lower Case letterc: a-f = 61-66     97-102
000016F2                          1053  
000016F2                          1054  * Parameters -
000016F2                          1055  *   Input   A1      The data that needs checked for valid input.
000016F2                          1056  *   Output  D3      The return value, '-1' for error
000016F2                          1057  *==============================================================================
000016F2                          1058  
000016F2                          1059  parseHexString:
000016F2                          1060  
000016F2                          1061  * setup any initializing item that do not get looped through
000016F2  4243                    1062          CLR.W       D3                  ;Clear the return
000016F4                          1063  
000016F4                          1064          
000016F4                          1065  *------------------------------------------------------------------------------
000016F4                          1066  * NextHex - Loop through all bytes and vaildate the input
000016F4                          1067  * Parameters -
000016F4                          1068  *   Input   A1      The data that needs checked for valid input.
000016F4                          1069  *   Output  D3      The return value, '-1' for error
000016F4                          1070  *------------------------------------------------------------------------------
000016F4                          1071          
000016F4                          1072  NextHex:
000016F4                          1073  
000016F4  1419                    1074          MOVE.B      (A1)+,D2            ;Examine next character and decode it
000016F6  B43C 0000               1075          CMP.B       #0,D2               ;Check character for null 
000016FA  6700 0066               1076          BEQ         NextHexReturn       ;Character is null (end of input)
000016FE                          1077          
000016FE                          1078  *................................................................................
000016FE                          1079  *  Check decimal values 0-9 by testing hexadecimal values 30-39
000016FE                          1080  *................................................................................
000016FE                          1081                  
000016FE                          1082          * The program will branch to hex_range_error if D2 is less than #30
000016FE  B43C 0030               1083          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
00001702  6D00 0048               1084          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001706                          1085                                          ;processing
00001706                          1086          
00001706                          1087          * The program will branch to UcaseHex if D2 is greater than #39
00001706  B43C 0039               1088          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
0000170A  6E00 000A               1089          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
0000170E                          1090          
0000170E                          1091          *a valid number was found within this range
0000170E  0402 0030               1092          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
00001712  6000 0032               1093          BRA         NextHexDone         ;Done parsing this byte
00001716                          1094  
00001716                          1095  
00001716                          1096  *..............................................................................
00001716                          1097  *  Check upper case values A-F by testing hexadecimal values 41-46
00001716                          1098  *..............................................................................
00001716                          1099  
00001716                          1100  UcaseHex:
00001716                          1101  
00001716                          1102          * The program will branch to hex_range_error if D2 is less than #41
00001716  B43C 0041               1103          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
0000171A  6D00 0030               1104          BLT         hex_range_error     ;Branch to handle range error hexidecimal
0000171E                          1105                                          ;processing
0000171E                          1106          
0000171E  B43C 0046               1107          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
00001722  6E00 000A               1108          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
00001726                          1109                                          ;processing
00001726                          1110          
00001726                          1111          *a valid number was found within this range
00001726  0402 0037               1112          SUBI.B      #55,D2              ;Change uppercase character to actual value
0000172A  6000 001A               1113          BRA         NextHexDone         ;Done parsing this byte
0000172E                          1114  
0000172E                          1115  
0000172E                          1116  *..............................................................................
0000172E                          1117  *  Check lower case values a-f by testing hexadecimal values 61-66
0000172E                          1118  *..............................................................................
0000172E                          1119  
0000172E                          1120  LcaseHex
0000172E                          1121          
0000172E                          1122          * The program will branch to hex_range_error if D2 is less than #61
0000172E  B43C 0061               1123          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
00001732  6D00 0018               1124          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
00001736                          1125                                          ;processing
00001736                          1126  
00001736  B43C 0066               1127          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
0000173A  6E00 0010               1128          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
0000173E                          1129                                          ;processing
0000173E                          1130  
0000173E                          1131          *a valid number was found within this range
0000173E  0402 0057               1132          SUBI.B      #87,D2              ;Change lowercase character to actual value
00001742  6000 0002               1133          BRA         NextHexDone         ;Done parsing this byte
00001746                          1134  
00001746                          1135  NextHexDone:
00001746                          1136  
00001746  E983                    1137          ASL.L       #4,D3               ; Make rooom for new byte in the return register
00001748  D602                    1138          ADD.B       D2,D3               ; Move the new byte into the return register
0000174A  60A8                    1139          BRA         NextHex             ; We're ready to parse the next byte
0000174C                          1140          
0000174C                          1141  *-------------------------------------------------------------------------------------
0000174C                          1142  * hex_range_error -  A character entered was within the valid range for a hex address
0000174C                          1143  *                 -  Load error message and display it
0000174C                          1144  *                 -  Return error condition
0000174C                          1145  *-------------------------------------------------------------------------------------
0000174C                          1146          
0000174C                          1147  hex_range_error:
0000174C                          1148  
0000174C  43F9 000019C1           1149          LEA         invCharMsg,A1       ;Load invalid range message into A1
00001752  2239 000019C1           1150          MOVE.L      invCharMsg,D1       ;Load error length to D1
00001758                          1151          
00001758  7000                    1152          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
0000175A                          1153                                          ; n is D1.W with CR, LF. 
0000175A  4E4F                    1154          TRAP        #15                 ;Display the error message
0000175C  76FF                    1155          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000175E  6000 0002               1156          BRA         NextHexReturn
00001762                          1157          
00001762                          1158  NextHexReturn:
00001762                          1159          
00001762  4E75                    1160          RTS                             ;Return      
00001764                          1161  
00001764                          1162  
00001764                          1163  *===============================================================================
00001764                          1164  * ck_addr_range - check the address input is within a valid memory address range
00001764                          1165  *                - Parsed address data into D3
00001764                          1166  *
00001764                          1167  * Parameters -
00001764                          1168  *   Input   A1      The data that needs checked for valid address.
00001764                          1169  *   Output  D3      The return value, '-1' for error
00001764                          1170  *===============================================================================
00001764                          1171  
00001764                          1172  
00001764                          1173  ck_addr_range:   
00001764                          1174  
00001764                          1175  *------------------------------------------------------------------------------
00001764                          1176  * Verify that the address entered is witin the 
00001764                          1177  * beginning range ('begin') as defined in the Equate
00001764                          1178  *------------------------------------------------------------------------------   
00001764                          1179              
00001764  2C3C 00005001           1180          MOVE.L      #begin,D6           * Load minimum starting address
0000176A  B686                    1181          CMP.L       D6,D3               * Is input at or above minimum?
0000176C  6D00 0012               1182          BLT         ck_addr_range_error 
00001770                          1183          
00001770                          1184  *------------------------------------------------------------------------------
00001770                          1185  * Verify that the address entered is witin the 
00001770                          1186  * ending range ('end') as defined in the Equate
00001770                          1187  *------------------------------------------------------------------------------
00001770                          1188          
00001770  2C3C 00FFFFFE           1189          MOVE.L      #end,D6             * Load maximum starting address
00001776  B686                    1190          CMP.L       D6,D3               * Is input at or below maximum?
00001778  6E00 0006               1191          BGT         ck_addr_range_error 
0000177C  6000 0012               1192          BRA         ck_addr_done        ;done checking
00001780                          1193          
00001780                          1194  *..............................................................................
00001780                          1195  * ck_addr_range_error -  A address entered is not within the 
00001780                          1196  *                        valid range for a hex address
00001780                          1197  *..............................................................................
00001780                          1198          
00001780                          1199  ck_addr_range_error
00001780                          1200  
00001780  43F9 0000197C           1201          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001786                          1202          
00001786  700D                    1203          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
00001788                          1204                                          ;with CR, LF. 
00001788  4E4F                    1205          TRAP        #15                 ;Display the error message
0000178A  76FF                    1206          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000178C  6000 0002               1207          BRA         ck_addr_done 
00001790                          1208  
00001790                          1209  ck_addr_done:
00001790                          1210  
00001790  4E75                    1211          RTS                             ;Return
00001792                          1212  
00001792                          1213  *******************************************************************************
00001792                          1214  *                          OP CODE ROLE ROUTINES
00001792                          1215  *******************************************************************************
00001792                          1216  
00001792                          1217  process_op_codes:
00001792                          1218  
00001792                          1219  
00001792                          1220  
00001792                          1221  process_op_codes_exit:
00001792                          1222  
00001792  4E75                    1223          RTS
00001794                          1224  
00001794                          1225  
00001794                          1226  *******************************************************************************
00001794                          1227  *                    Effective Addressing ROLE ROUTINES
00001794                          1228  *******************************************************************************
00001794                          1229  
00001794                          1230  Get_Effective_Address:
00001794                          1231  
00001794  1C05                    1232          MOVE.B      D5,D6
00001796  E60E                    1233          LSR.B       #3,D6               ;mode
00001798  CA3C 0007               1234          And.B       #%00000111,D5       ;register
0000179C                          1235          
0000179C  BC3C 0000               1236          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
000017A0  6700 004A               1237          BEQ         Data_Reg_Direct
000017A4                          1238          
000017A4  BC3C 0001               1239          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
000017A8  6700 0076               1240          BEQ         Addr_Reg_Indirect
000017AC                          1241          
000017AC  BC3C 0002               1242          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
000017B0  6700 006E               1243          BEQ         Addr_Reg_Indirect
000017B4                          1244          
000017B4  BC3C 0003               1245          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
000017B8  6700 0098               1246          BEQ         Addr_Reg_Indirect_Inc
000017BC                          1247          
000017BC  BC3C 0004               1248          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
000017C0  6700 00CE               1249          BEQ         Addr_Reg_Indirect_Dec
000017C4                          1250          
000017C4  BC3C 0007               1251          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
000017C8  6700 0006               1252          BEQ         Get_Effective_Address_Other
000017CC                          1253          
000017CC  6000 0138               1254          BRA         invalidEA
000017D0                          1255          
000017D0                          1256  Get_Effective_Address_Other:        
000017D0                          1257          
000017D0  BA3C 0000               1258          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
000017D4  6700 00F8               1259          BEQ Addr_Abs_Short
000017D8                          1260          
000017D8  BA3C 0001               1261          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
000017DC  6700 0104               1262          BEQ Addr_Abs_Long
000017E0                          1263          
000017E0  BA3C 0004               1264          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
000017E4  6700 0110               1265          BEQ Addr_Immediate_Data
000017E8                          1266          
000017E8  6000 011C               1267          BRA         invalidEA
000017EC                          1268          
000017EC                          1269  Data_Reg_Direct:                        ;case 0(0000)
000017EC                          1270  
000017EC  43F9 00001B52           1271          LEA         letterD,A1          ;output 'D' for data register
000017F2  103C 000E               1272          MOVE.B      #14,D0              ;set for task to display null terminated 
000017F6  4E4F                    1273          TRAP        #15                 ;string without CR, LF
000017F8                          1274                          
000017F8  4281                    1275          CLR.L       D1
000017FA  1205                    1276          MOVE.B      D5,D1               ;move register number for display into D1
000017FC  103C 0003               1277          MOVE.B      #3,D0               ;set for task to display null terminated 
00001800  4E4F                    1278          TRAP        #15                 ;string without CR, LF
00001802                          1279                 
00001802  6000 0102               1280          BRA         Get_Effective_Address_Exit  ;return
00001806                          1281          
00001806                          1282          
00001806                          1283  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
00001806                          1284        
00001806  43F9 00001B50           1285          LEA         letterA,A1          ;output 'A' for address register
0000180C  103C 000E               1286          MOVE.B      #14,D0              ;set for task to display null terminated 
00001810  4E4F                    1287          TRAP        #15                 ;string without CR, LF
00001812                          1288          
00001812  4281                    1289          CLR.L       D1
00001814  1205                    1290          MOVE.B      D5,D1               ;move register number for display into D1
00001816  103C 0003               1291          MOVE.B      #3,D0               ;set for task to display null terminated 
0000181A  4E4F                    1292          TRAP        #15                 ;string without CR, LF
0000181C                          1293          
0000181C  6000 00E8               1294          BRA         Get_Effective_Address_Exit  ;return
00001820                          1295  
00001820                          1296  
00001820                          1297  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
00001820                          1298          
00001820  43F9 00001B58           1299          LEA         lprn,A1             ;output 'D' for data register
00001826  103C 000E               1300          MOVE.B      #14,D0              ;set for task to display null terminated 
0000182A  4E4F                    1301          TRAP        #15                 ;string without CR, LF
0000182C                          1302  
0000182C  43F9 00001B50           1303          LEA         letterA,A1          ;output 'A' for address register
00001832  103C 000E               1304          MOVE.B      #14,D0              ;set for task to display null terminated 
00001836  4E4F                    1305          TRAP        #15                 ;string without CR, LF
00001838                          1306          
00001838  4281                    1307          CLR.L       D1
0000183A  1205                    1308          MOVE.B      D5,D1               ;move register number for display into D1
0000183C  103C 0003               1309          MOVE.B      #3,D0               ;set for task to display null terminated 
00001840  4E4F                    1310          TRAP        #15                 ;string without CR, LF
00001842                          1311  
00001842  43F9 00001B5A           1312          LEA         rprn,A1             ;output 'D' for data register
00001848  103C 000E               1313          MOVE.B      #14,D0              ;set for task to display null terminated 
0000184C  4E4F                    1314          TRAP        #15                 ;string without CR, LF
0000184E                          1315          
0000184E  6000 00B6               1316          BRA         Get_Effective_Address_Exit  ;return
00001852                          1317  
00001852                          1318                 
00001852                          1319  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
00001852                          1320  
00001852  43F9 00001B58           1321          LEA         lprn,A1             ;output 'D' for data register
00001858  103C 000E               1322          MOVE.B      #14,D0              ;set for task to display null terminated 
0000185C  4E4F                    1323          TRAP        #15                 ;string without CR, LF
0000185E                          1324  
0000185E  43F9 00001B50           1325          LEA         letterA,A1          ;output 'A' for address register
00001864  103C 000E               1326          MOVE.B      #14,D0              ;set for task to display null terminated 
00001868  4E4F                    1327          TRAP        #15                 ;string without CR, LF
0000186A                          1328          
0000186A  4281                    1329          CLR.L       D1
0000186C  1205                    1330          MOVE.B      D5,D1               ;move register number for display into D1
0000186E  103C 0003               1331          MOVE.B      #3,D0               ;set for task to display null terminated 
00001872  4E4F                    1332          TRAP        #15                 ;string without CR, LF
00001874                          1333  
00001874  43F9 00001B5A           1334          LEA         rprn,A1             ;output 'D' for data register
0000187A  103C 000E               1335          MOVE.B      #14,D0              ;set for task to display null terminated 
0000187E  4E4F                    1336          TRAP        #15                 ;string without CR, LF
00001880                          1337          
00001880  43F9 00001B54           1338          LEA         plus,A1             ;output 'D' for data register
00001886  103C 000E               1339          MOVE.B      #14,D0              ;set for task to display null terminated 
0000188A  4E4F                    1340          TRAP        #15                 ;string without CR, LF
0000188C                          1341          
0000188C  6000 0078               1342          BRA         Get_Effective_Address_Exit  ;return
00001890                          1343  
00001890                          1344  Addr_Reg_Indirect_Dec                   ;4 = (An) - Address Register Indirect with Predecrement (100)
00001890                          1345  
00001890  43F9 00001B56           1346          LEA         minus,A1            ;output '-' for Predecrement
00001896  103C 000E               1347          MOVE.B      #14,D0              ;set for task to display null terminated 
0000189A  4E4F                    1348          TRAP        #15                 ;string without CR, LF
0000189C                          1349  
0000189C  43F9 00001B58           1350          LEA         lprn,A1             ;output 'D' for data register
000018A2  103C 000E               1351          MOVE.B      #14,D0              ;set for task to display null terminated 
000018A6  4E4F                    1352          TRAP        #15                 ;string without CR, LF
000018A8                          1353  
000018A8  43F9 00001B50           1354          LEA         letterA,A1          ;output 'A' for address register
000018AE  103C 000E               1355          MOVE.B      #14,D0              ;set for task to display null terminated 
000018B2  4E4F                    1356          TRAP        #15                 ;string without CR, LF
000018B4                          1357          
000018B4  4281                    1358          CLR.L       D1
000018B6  1205                    1359          MOVE.B      D5,D1               ;move register number for display into D1
000018B8  103C 0003               1360          MOVE.B      #3,D0               ;set for task to display null terminated 
000018BC  4E4F                    1361          TRAP        #15                 ;string without CR, LF
000018BE                          1362  
000018BE  43F9 00001B5A           1363          LEA         rprn,A1             ;output 'D' for data register
000018C4  103C 000E               1364          MOVE.B      #14,D0              ;set for task to display null terminated 
000018C8  4E4F                    1365          TRAP        #15                 ;string without CR, LF
000018CA                          1366          
000018CA  6000 003A               1367          BRA         Get_Effective_Address_Exit  ;return
000018CE                          1368          
000018CE                          1369                         
000018CE                          1370  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
000018CE                          1371          
000018CE                          1372          
000018CE  43F9 00001B32           1373          LEA         xxxW,A1             ;output 'D' for data register
000018D4  103C 000E               1374          MOVE.B      #14,D0              ;set for task to display null terminated 
000018D8  4E4F                    1375          TRAP        #15                 ;string without CR, LF
000018DA                          1376  
000018DA  548B                    1377          ADDA.L      #word,A3
000018DC                          1378          
000018DC                          1379          ;print word (A3)
000018DC                          1380          ;MOVE.W      A3,(A1)
000018DC                          1381          ;MOVE.B      #14,D0              ;set for task to display null terminated 
000018DC                          1382          ;TRAP        #15                 ;string without CR, LF
000018DC                          1383          
000018DC  5487                    1384          ADDI.L      #word,D7 
000018DE  6000 0026               1385          BRA         Get_Effective_Address_Exit  ;return
000018E2                          1386                         
000018E2                          1387  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
000018E2                          1388          
000018E2  43F9 00001B3C           1389          LEA         xxxL,A1             ;output 'D' for data register
000018E8  103C 000E               1390          MOVE.B      #14,D0              ;set for task to display null terminated 
000018EC  4E4F                    1391          TRAP        #15                 ;string without CR, LF
000018EE                          1392  
000018EE  548B                    1393          ADDA.L      #word,A3
000018F0                          1394          
000018F0                          1395          ;print long (A3)
000018F0                          1396          ;MOVE.L      A3,(A1)
000018F0                          1397          ;MOVE.B      #14,D0              ;set for task to display null terminated 
000018F0                          1398          ;TRAP        #15                 ;string without CR, LF
000018F0                          1399          
000018F0  5887                    1400          ADDI.L      #long,D7
000018F2  6000 0012               1401          BRA         Get_Effective_Address_Exit  ;return
000018F6                          1402                         
000018F6                          1403  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
000018F6                          1404  
000018F6  43F9 00001B46           1405          LEA         iData,A1            ;output 'D' for data register
000018FC  103C 000E               1406          MOVE.B      #14,D0              ;set for task to display null terminated 
00001900  4E4F                    1407          TRAP        #15                 ;string without CR, LF
00001902                          1408          
00001902                          1409          *need another input param for size
00001902  6000 0002               1410          BRA         Get_Effective_Address_Exit  ;return
00001906                          1411  
00001906                          1412  invalidEA:
00001906                          1413  
00001906                          1414          ;do something
00001906                          1415   
00001906                          1416  Get_Effective_Address_Exit:     
00001906                          1417  
00001906  4E75                    1418          RTS                             ;return
00001908                          1419  
00001908                          1420  switchModeAndReg:
00001908                          1421  ***
00001908                          1422  * Assumed in D2
00001908                          1423  *
00001908                          1424  * Assumed that they are in least significant byte:
00001908                          1425  *
00001908                          1426  *            _this_
00001908                          1427  *           /      \
00001908                          1428  *  ........ ........
00001908                          1429  *  \                /
00001908                          1430  *   -----word-------
00001908                          1431  *
00001908                          1432  *  and that in that byte they are ordered:
00001908                          1433  *
00001908                          1434  *       ........   
00001908                          1435  *       \/\_/\_/
00001908                          1436  *      /  /    \
00001908                          1437  *    /   /      \
00001908                          1438  * dont  one    other
00001908                          1439  * care
00001908                          1440  *
00001908                          1441  * after they will be
00001908                          1442  *
00001908                          1443  *       ........   
00001908                          1444  *       \/\_/\_/
00001908                          1445  *      /  /    \
00001908                          1446  *    /   /      \
00001908                          1447  * dont other    one
00001908                          1448  * care
00001908                          1449  *** 
00001908  0202 003F               1450          AndI.B #%00111111,D2 ;remove unwanted bits from D2
0000190C  0283 00000000           1451          ANDI.L #0,D3 ;clear D3
00001912  1602                    1452          MOVE.B D2,D3 ;copy to D3
00001914  E70B                    1453          LSL.B  #3,D3 
00001916  E60A                    1454          LSR.B  #3,D2
00001918  D403                    1455          ADD.B  D3,D2
0000191A  4E75                    1456          RTS
0000191C                          1457  
0000191C                          1458          
0000191C                          1459  *==============================================================================
0000191C                          1460  *                            variables and constants
0000191C                          1461  *==============================================================================
0000191C                          1462  
0000191C                          1463  
0000191C                          1464  ***initial user prompt stuff        
0000191C= 45 6E 74 65 72 20 ...   1465  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE: $',0
0000194D= 45 6E 74 65 72 20 ...   1466  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE: $',0
0000197C                          1467  
0000197C= 20 41 64 64 72 65 ...   1468  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
000019C1= 20 41 20 43 68 61 ...   1469  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
00001A09                          1470  
00001A09= 20 59 6F 75 20 6D ...   1471  even_msg        DC.B    ' You must enter an even address!'
00001A29                          1472  
00001A29= 20                      1473  spc             DC.B    ' '
00001A2A= 01                      1474  spc_len         DC.B    spc_len-spc
00001A2B                          1475  ***
00001A2B                          1476  
00001A2B                          1477  
00001A2B                          1478  
00001A2B                          1479  ***list of OP codes
00001A2B                          1480  
00001A2B  =00004880               1481  movemInstruction EQU %0100100010000000
00001A2B  =00000600               1482  addiInstruction  EQU %0000011000000000
00001A2B  =00000000               1483  oriInstruction   EQU 0
00001A2B  =00000C00               1484  cmpiInstruction  EQU %0000110000000000
00001A2B  =00004E80               1485  jsrInstruction   EQU %0100111010000000
00001A2B  =00004E75               1486  rtsInstruction   EQU %0100111001110101
00001A2B  =00004E71               1487  NoOpInstruction  EQU %0100111001110001
00001A2B  =00000000               1488  moveInstruction  EQU 0
00001A2B  =00006000               1489  bccInstruction   EQU %0110000000000000
00001A2B  =00004400               1490  negInstruction   EQU %0100010000000000
00001A2B  =00000000               1491  dataInstruction  EQU 0
00001A2B                          1492  
00001A2B                          1493  ***
00001A2B                          1494  
00001A2B                          1495  ***list of OP masks
00001A2B                          1496  
00001A2B  =0000FB80               1497  movemMask EQU %1111101110000000
00001A2B  =0000FF00               1498  addiMask  EQU %1111111100000000
00001A2B  =0000FF00               1499  oriMask   EQU %1111111100000000
00001A2B  =0000FF00               1500  cmpiMask  EQU %1111111100000000
00001A2B  =0000FFC0               1501  jsrMask   EQU %1111111111000000
00001A2B  =0000FFFF               1502  rtsMask   EQU $FFFF
00001A2B  =0000FFFF               1503  NoOpMask  EQU $FFFF
00001A2B  =0000C000               1504  moveMask  EQU $C000
00001A2B  =0000F000               1505  bccMask   EQU $F000
00001A2B  =0000FF00               1506  negMask   EQU $FF00
00001A2B  =00000000               1507  dataMask  EQU 0
00001A2B                          1508  ***
00001A2B                          1509  
00001A2B                          1510  ***Bcc Codes***
00001A2B  =00000004               1511  CC EQU $04
00001A2B  =00000005               1512  CS EQU $05
00001A2B  =00000007               1513  EQ EQU $07
00001A2B  =0000000C               1514  GE EQU $0C
00001A2B  =0000000E               1515  GT EQU $0E
00001A2B  =00000002               1516  HI EQU $02
00001A2B  =0000000F               1517  LE EQU $0F
00001A2B  =00000003               1518  LS EQU $03
00001A2B  =0000000D               1519  LT EQU $0D
00001A2B  =0000000B               1520  MI EQU $0B
00001A2B  =00000006               1521  NE EQU $06
00001A2B  =0000000A               1522  PL EQU $0A
00001A2B  =00000008               1523  VC EQU $08
00001A2B  =00000009               1524  VS EQU $09
00001A2B  =00000000               1525  RA EQU $00 ;not really a Condition Code
00001A2B  =00000001               1526  SR EQU $01 ;not really a Condition Code
00001A2B                          1527  
00001A2B= 43 43 20 00             1528  CCm DC.B 'CC ',0
00001A2F= 43 53 20 00             1529  CSm DC.B 'CS ',0
00001A33= 45 51 20 00             1530  EQm DC.B 'EQ ',0
00001A37= 47 45 20 00             1531  GEm DC.B 'GE ',0
00001A3B= 47 54 20 00             1532  GTm DC.B 'GT ',0
00001A3F= 48 49 20 00             1533  HIm DC.B 'HI ',0
00001A43= 4C 45 20 00             1534  LEm DC.B 'LE ',0
00001A47= 4C 53 20 00             1535  LSm DC.B 'LS ',0
00001A4B= 4C 54 20 00             1536  LTm DC.B 'LT ',0
00001A4F= 4D 49 20 00             1537  MIm DC.B 'MI ',0
00001A53= 4E 45 20 00             1538  NEm DC.B 'NE ',0
00001A57= 50 4C 20 00             1539  PLm DC.B 'PL ',0
00001A5B= 56 43 20 00             1540  VCm DC.B 'VC ',0
00001A5F= 56 53 20 00             1541  VSm DC.B 'VS ',0
00001A63= 52 41 20 00             1542  RAm DC.B 'RA ',0
00001A67= 53 52 20 00             1543  SRm DC.B 'SR ',0
00001A6B                          1544  
00001A6B= 01 04 05 07 0C 0E ...   1545  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
00001A7C= 00001A67 00001A2B ...   1546  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
00001ABC                          1547  ***
00001ABC                          1548  
00001ABC= 45 6E 74 65 72 20 ...   1549  startLocationPrompt DC.B    'Enter start location',0
00001AD1= 45 6E 74 65 72 20 ...   1550  endLocationPrompt   DC.B    'Enter end location',0
00001AE4                          1551  
00001AE4= 0D 0A 00                1552  clearLine  DC.B $0D,$0A,0
00001AE7                          1553  
00001AE7= 4D 4F 56 45 4D 3A ...   1554  movemMessage    DC.B 'MOVEM: ',0
00001AEF= 41 44 44 49 3A 20 00    1555  addiMessage     DC.B 'ADDI: ',0
00001AF6= 4F 52 49 3A 20 00       1556  oriMessage      DC.B 'ORI: ',0
00001AFC= 43 4D 50 49 3A 20 00    1557  cmpiMessage     DC.B 'CMPI: ',0
00001B03= 4A 53 52 3A 20 00       1558  jsrMessage      DC.B 'JSR: ',0
00001B09= 52 54 53 20 00          1559  rtsMessage      DC.B 'RTS ',0
00001B0E= 4E 4F 50 3A 20 00       1560  nopMessage      DC.B 'NOP: ',0 
00001B14= 4D 4F 56 45 3A 20 00    1561  moveMessage     DC.B 'MOVE: ',0
00001B1B= 42 00                   1562  bccMessage      DC.B 'B',0
00001B1D= 4E 45 47 3A 20 00       1563  negMessage      DC.B 'NEG: ',0
00001B23= 44 41 54 41 3A 20 00    1564  dataMessage     DC.B 'DATA: ',0
00001B2A                          1565  
00001B2A= 4D 4F 56 45 41 3A ...   1566  moveaMessage    DC.B 'MOVEA: ',0
00001B32                          1567  
00001B32= 28 78 78 78 29 2E ...   1568  xxxW            DC.B '(xxx).W: ',0
00001B3C= 28 78 78 78 29 2E ...   1569  xxxL            DC.B '(xxx).L: ',0
00001B46= 23 28 64 61 74 61 ...   1570  iData           DC.B '#(data): ',0
00001B50                          1571  
00001B50= 41 00                   1572  letterA         DC.B 'A', 0
00001B52= 44 00                   1573  letterD         DC.B 'D', 0
00001B54                          1574  
00001B54= 2B 00                   1575  plus            DC.B '+', 0
00001B56= 2D 00                   1576  minus           DC.B '-', 0
00001B58= 28 00                   1577  lPrn            DC.B '(', 0
00001B5A= 29 00                   1578  rPrn            DC.B ')', 0
00001B5C                          1579  
00001B5C                          1580  
00001B5C= 00000000                1581  startLocation       DC.L    0
00001B60= 00000000                1582  endLocation         DC.L    0
00001B64                          1583  
00001B64                          1584  
00001B64                          1585     
00001B64                          1586      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                1236
ADDIBODY            1262
ADDIDONE            1290
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         1AEF
ADDRESS_DONE        1680
ADDRESS_EXIT        167A
ADDR_ABS_LONG       18E2
ADDR_ABS_SHORT      18CE
ADDR_IMMEDIATE_DATA  18F6
ADDR_REG_DIRECT     1806
ADDR_REG_INDIRECT   1820
ADDR_REG_INDIRECT_DEC  1890
ADDR_REG_INDIRECT_INC  1852
BCC                 1534
BCCBYTE             1586
BCCDONE             159C
BCCINSTRUCTION      6000
BCCLIST             1A6B
BCCLONG             1594
BCCMASK             F000
BCCMESSAGE          1B1B
BCCWORD             158C
BEGIN               5001
BEGIN_ADDRESS       160C
BYTE                1
CC                  4
CCM                 1A2B
CHECKCC             154A
CHECKMOVEADEST      14E0
CHECKMOVEDEST       143E
CHECKOPCODE         1050
CK_ADDR_DONE        1790
CK_ADDR_RANGE       1764
CK_ADDR_RANGE_ERROR  1780
CK_BOUNDRY          16A8
CK_BOUNDRY_ERROR    16CA
CK_SIZE_ERROR       16DE
CLEARLINE           1AE4
CMPI                1318
CMPIBODY            1340
CMPIDONE            136E
CMPIEA              130A
CMPIEAMASKS         1311
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         1AFC
CONDITIONCODEMESSAGE  1A7C
CS                  5
CSM                 1A2F
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         1B23
DATA_REG_DIRECT     17EC
ELPROMPT            194D
END                 FFFFFE
ENDLOCATION         1B60
ENDLOCATIONPROMPT   1AD1
END_ADDRESS         1650
ENTER_ADDR_EDIT_ALL  1682
ENTER_ADDR_EDIT_ALL_EXIT  16A6
EQ                  7
EQM                 1A33
EVEN_MSG            1A09
FALSEPOSITIVE       1070
FARLABEL            FFE
FIN                 1608
FOUNDCC             155C
GE                  C
GEM                 1A37
GET_EFFECTIVE_ADDRESS  1794
GET_EFFECTIVE_ADDRESS_EXIT  1906
GET_EFFECTIVE_ADDRESS_OTHER  17D0
GT                  E
GTM                 1A3B
HANDLEBYTEDATA      15DC
HEX_RANGE_ERROR     174C
HI                  2
HIM                 1A3F
IDATA               1B46
INSTLABELLIST       10C2
INSTMASKLIST        10AC
INSTOPLIST          1096
INVALIDEA           1906
INVALIDMSG          197C
INVCHARMSG          19C1
JSR                 1386
JSRBODY             13AE
JSRDONE             13C6
JSREA               137E
JSREAMASKS          1382
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          1B03
LCASEHEX            172E
LE                  F
LEM                 1A43
LETTERA             1B50
LETTERD             1B52
LONG                4
LPRN                1B58
LS                  3
LSM                 1A47
LT                  D
LTM                 1A4B
MAIN_LOOP           1026
MATCH               1076
MI                  B
MIM                 1A4F
MINUS               1B56
MOVE                1416
MOVEA               14B8
MOVEABODY           150E
MOVEADESTEA         14B4
MOVEADESTEAMASKS    14B6
MOVEAMESSAGE        1B2A
MOVEBODY            146C
MOVEDESTEA          1408
MOVEDESTEAMASKS     140F
MOVEINSTRUCTION     0
MOVEM               1134
MOVEMASK            C000
MOVEMBODY           119E
MOVEMESSAGE         1B14
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     112A
MOVEMMEMTOREGEAMASKS  112F
MOVEMMESSAGE        1AE7
MOVEMREGTOMEMEA     1120
MOVEMREGTOMEMEAMASKS  1125
MOVESOURCEEA        13F6
MOVESOURCEEAMASKS   13FF
NE                  6
NEG                 11D8
NEGBODY             1200
NEGDONE             1226
NEGEA               11C8
NEGEAMASKS          11D0
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          1B1D
NEM                 1A53
NEXTHEX             16F4
NEXTHEXDONE         1746
NEXTHEXRETURN       1762
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 13D6
NOPMESSAGE          1B0E
ORI                 12A0
ORIBODY             12CC
ORIDONE             12FA
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          1AF6
PARSEHEXSTRING      16F2
PL                  A
PLM                 1A57
PLUS                1B54
PRGORG              1000
PROCESS_OP_CODES    1792
PROCESS_OP_CODES_EXIT  1792
PROMPT_USER         1014
RA                  0
RAM                 1A63
RPRN                1B5A
RTS                 13E6
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          1B09
SLPROMPT            191C
SNIPPET             10EE
SNIPPETEND          111C
SPC                 1A29
SPC_LEN             1A2A
SR                  1
SRM                 1A67
STACK               5000
START               1000
STARTLOCATION       1B5C
STARTLOCATIONPROMPT  1ABC
SWITCHMODEANDREG    1908
UCASEHEX            1716
UNKNOWNOPCODE       15B6
VALIDADDIMODES      1238
VALIDCMPIMODES      131A
VALIDJSRMODES       1388
VALIDMEMTOREG       1170
VALIDMOVEADESTMODES  14E2
VALIDMOVEASOURCEMODES  14BA
VALIDMOVEDESTMODES  1440
VALIDMOVESOURCEMODES  1418
VALIDNEGMODES       11DA
VALIDORIMODES       12A2
VALIDREGTOMEM       114A
VC                  8
VCM                 1A5B
VS                  9
VSM                 1A5F
WORD                2
XXXL                1B3C
XXXW                1B32

00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/9/2014 5:53:49 PM

00000000                             1  *##########################################################################
00000000                             2  * Title      : 
00000000                             3  * Written by : Andrew Watson
00000000                             4  *            : Elaine Keller
00000000                             5  *            : Robert Anderson
00000000                             6  * Date       : 11/14/2014
00000000                             7  * Description: 
00000000                             8  *##########################################################################
00000000                             9  
00000000                            10  ***Possible Bug***
00000000                            11  *can not tell data from an
00000000                            12  *unidentified instruction from an actual
00000000                            13  *instruction therefore causing errors.
00000000                            14  *may not actually be a bug because data
00000000                            15  *is data to the machine, and if you modify
00000000                            16  *the instructions in memory for a program
00000000                            17  *by moivng data, you can modify the instuctions
00000000                            18  *executed.
00000000                            19  
00000000                            20  
00000000                            21  ***************************************************************************
00000000                            22  *                   Variable/Data Definitions
00000000                            23  ***************************************************************************
00000000                            24  
00000000  =00005000                 25  stack   EQU   $00005000
00000000  =00005001                 26  begin   EQU   $00005001
00000000  =00FFFFFE                 27  end     EQU   $00FFFFFE
00000000  =00000001                 28  byte    EQU   1
00000000  =00000002                 29  word    EQU   2
00000000  =00000004                 30  long    EQU   4
00000000  =00001000                 31  prgorg  EQU   $1000
00000000                            32  
00000FFE                            33      ORG $00000FFE
00000FFE                            34  FarLabel:
00001000                            35      ORG    prgorg
00001000                            36  start:
00001000  4FF8 5000                 37          LEA stack, SP ;initialize stack
00001004                            38  
00001000                            39      ORG    prgorg
00001000                            40  
00001000                            41  ******************************************************************************
00001000                            42  *                   Begin processing active code
00001000                            43  ******************************************************************************
00001000                            44      
00001000                            45  start:
00001000                            46  
00001000  4FF8 5000                 47          LEA         stack, SP           ;Initialize stack
00001004                            48          
00001004                            49  *.............................................................................
00001004                            50  * Debug Mode - Comment out when done
00001004  267C 00001146             51          MOVE.L      #snippet,A3
0000100A  287C 000011C0             52          MOVE.L      #snippetEnd,A4
00001010  6000 0014                 53          BRA         main_Loop
00001014                            54  * Debug Mode - Comment out when done
00001014                            55  *.............................................................................        
00001014                            56          
00001014                            57  prompt_user:
00001014                            58  
00001014  6100 0D96                 59          BSR         begin_address
00001018  B67C FFFF                 60          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000101C  6700 0D8A                 61          BEQ         fin                 ;Yes, then exit
00001020                            62          
00001020  6000 0004                 63          BRA         main_Loop
00001024                            64          ;BSR         process_op_codes
00001024  60EE                      65          BRA         prompt_user
00001026                            66                  
00001026                            67  ******************************************************************************
00001026                            68  *                   Begin processing OP Codes
00001026                            69  ******************************************************************************
00001026                            70   
00001026                            71  main_Loop:
00001026                            72  
00001026  B9CB                      73          CMPA.L A3,A4 ;check end of prog
00001028  6700 0D7E                 74          BEQ fin
0000102C                            75          
0000102C  3213                      76          MOVE.W (A3),D1 ;copy word from other prog to analyze as instruction
0000102E                            77          
0000102E                            78          ;handle an odd memory access(instructions will never be misaligned)
0000102E  240B                      79          MOVE.L A3,D2 ; copy address to D2
00001030  0202 0001                 80          ANDI.B #%00000001,D2 ;mask everything except the least significant bit
00001034  0C02 0001                 81          CMPI.B #1,D2 ;compare the least sig bit of the address to one
00001038  6700 0D42                 82          BEQ handlebytedata ;the least sig bit will only be one if the insrtuction
0000103C                            83                             ;is odd(misaligned) and therefore not an instruction
0000103C                            84          
0000103C  7600                      85          MOVEQ.L #0,D3
0000103E                            86          
0000103E                            87          ***things to save A3,A4,D1(?)***
0000103E  48E7 0018                 88          MOVEM.L A3-A4,-(SP)
00001042  6100 000C                 89          BSR checkOPcode
00001046  4CDF 1800                 90          MOVEM.L (SP)+,A3-A4
0000104A  D7C7                      91          ADDA.L  D7,A3 ;look past data that was part of the instruction
0000104C                            92          
0000104C  548B                      93          ADDQ.L  #word,A3
0000104E  60D6                      94          BRA     main_Loop 
00001050                            95          
00001050                            96  checkOPcode:
00001050                            97  
00001050                            98  
00001050  7E00                      99          MOVEQ.L #0,D7
00001052                           100          
00001052  41F9 00001096            101          LEA     instOPList,A0 ;get instruction signitrue list in A0
00001058  D1C3                     102          ADDA.L  D3,A0 ;get correct sig         
0000105A                           103          
0000105A  43F9 000010C2            104          LEA     instMaskList,A1 ;get instruction mask in A1
00001060  D3C3                     105          ADDA.L  D3,A1  ;get correct mast
00001062                           106          
00001062  3401                     107          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001064                           108          
00001064  C451                     109          AND.W   (A1),D2 ;mask instruction
00001066                           110          
00001066                           111          
00001066                           112          
00001066                           113          
00001066  B450                     114          CMP.W   (A0),D2 ;compare to sig
00001068  6700 000C                115          BEQ     match ;if sig matches branch
0000106C  5483                     116          ADDQ.L  #word,D3 ;add to D3 to check for next instruction
0000106E  60E0                     117          BRA checkOPcode
00001070                           118          
00001070                           119  falsePositive:
00001070                           120          
00001070  103C 00FF                121          MOVE.B #-1,D0
00001074  4E75                     122          RTS
00001076                           123  
00001076                           124  match:
00001076                           125          
00001076  43F9 000010EE            126          LEA     instLabelList,A1 ;get instruction code label
0000107C  D3C3                     127          ADDA.L  D3,A1 ;get correct label
0000107E  D3C3                     128          ADDA.L  D3,A1
00001080  5483                     129          ADDQ.L  #word,D3 ;add to D3 incase false positive
00001082  2251                     130          MOVEA.L (A1),A1
00001084  48E7 1000                131          MOVEM.L D3,-(SP) ; save D3
00001088  4E91                     132          JSR     (A1)
0000108A  4CDF 0008                133          MOVEM.L (SP)+,D3 ;restore D3
0000108E  B03C 00FF                134          CMP.B   #-1,D0
00001092  67BC                     135          BEQ     checkOPcode
00001094  4E75                     136          RTS
00001096                           137          
00001096                           138  
00001096= C1C0 E6C0 E018 E...      139  instOPList  DC.W mulsInstruction,rsrlweaInstruction,rsrlregInstruction,asrlweaInstruction,asrlregInstruction,lsrlweaInstruction,lsrlregInstruction
000010A4= 5100 9000 D000 D...      140  instOPList2 DC.W subqInstruction,subInstruction,addaInstruction,addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruct
000010C2                           141      
000010C2= F1C0 FEC0 F018 F...      142  instMaskList DC.W mulsMask,rsrlweaMask,rsrlregMask,asrlweaMask,asrlregMask,lsrlweaMask,lsrlregMask,subqMask,subMask,addaMask,addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
000010EE= 000011D4 00001244 ...    143  instLabelList DC.L MULS,RSRLWEA,RSRLREG,ASRLWEA,ASRLREG,LSRLWEA,LSRLREG,SUBQ,SUB,ADDA,ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
00001146                           144  
00001146                           145  snippet:
00001146  4E71                     146           NOP
00001148  60FC                     147           BRA snippet
0000114A  6000 FEB2                148           BRA FarLabel
0000114E  67F6                     149           BEQ snippet
00001150  6E00 07D6                150           BGT NEG
00001154  61F0                     151           BSR snippet
00001156  4441                     152           NEG D1
00001158  3239 00008500            153           MOVE.W $8500,D1
0000115E  0645 001E                154           ADDI.W #30,D5
00001162  4E75                     155           RTS
00001164  4EB8 0054                156           JSR $54
00001168  0C41 0003                157           CMPI #3,D1
0000116C  0041 0003                158           ORI  #3,D1
00001170  48E7 0018                159           MOVEM.L A3-A4,-(SP)
00001174  D401                     160           ADD.B D1,D2
00001176  0603 000A                161           ADD.B #10,D3
0000117A  D7FC 00000463            162           ADDA.L #1123,A3
00001180  9A43                     163           SUB.W D3,D5
00001182  5105                     164           SUBQ.B #8,D5
00001184  5305                     165           SUBQ.B #1,D5
00001186  E64B                     166           LSR #3,D3
00001188  E74C                     167           LSL #3,D4
0000118A  E369                     168           LSL D1,D1
0000118C  E66F                     169           LSR D3,D7
0000118E  E2F8 3563                170           LSR $3563
00001192  E3F9 00486412            171           LSL $486412
00001198  E643                     172           ASR #3,D3
0000119A  E744                     173           ASL #3,D4
0000119C  E361                     174           ASL D1,D1
0000119E  E667                     175           ASR D3,D7
000011A0  E0F8 3563                176           ASR $3563
000011A4  E1F9 00486412            177           ASL $486412
000011AA  E65B                     178           ROR #3,D3
000011AC  E75C                     179           ROL #3,D4
000011AE  E379                     180           ROL D1,D1
000011B0  E67F                     181           ROR D3,D7
000011B2  E6F8 3563                182           ROR $3563
000011B6  E7F9 00486412            183           ROL $486412
000011BC  C5FC 4562                184           MULS #$4562,D2
000011C0                           185  
000011C0                           186           
000011C0                           187  snippetEnd:
000011C0  FFFF FFFF                188           SIMHALT
000011C4                           189  
000011C4                           190  
000011C4= 00 10 18 20 38 39 ...    191  mulsEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,%111100,0
000011CC= 38 38 38 38 3F 3F ...    192  mulsEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,%111111,0
000011D4                           193          
000011D4                           194  MULS:
000011D4                           195  
000011D4  7000                     196          MOVEQ.L #0, D0 ;clear D0
000011D6                           197          
000011D6                           198  validMulsModes:
000011D6                           199          
000011D6  43F8 11CC                200          LEA mulsEAmasks,A1 ;load the list of masks
000011DA  D3C0                     201          ADDA.L D0,A1 ;displace to a specific mask
000011DC  1A11                     202          MOVE.B (A1),D5 ;move the mask to D5
000011DE                           203          
000011DE  0C05 0000                204          CMPI.B #0,D5 ;check if the mask is 0
000011E2  6700 FE8C                205          BEQ falsePositive ;branch if it is
000011E6                           206          
000011E6  1401                     207          MOVE.B D1,D2 ;copy instruction to D2
000011E8  C405                     208          AND.B D5,D2  ;mask D2
000011EA                           209          
000011EA  43F8 11C4                210          LEA mulsEA,A1 ;load the list of valid modes
000011EE  D3C0                     211          ADDA.L D0,A1 ;displace to a specific mode
000011F0  1811                     212          MOVE.B (A1),D4 ;move mode to D4
000011F2  B404                     213          CMP.B D4,D2 ;compare mode to masked value
000011F4  6700 0006                214          BEQ  mulsBody ;if its match, its a valid mode and we can procede
000011F8                           215          
000011F8  5280                     216          ADDQ.L #1,D0 ;add one to displacement
000011FA  60DA                     217          BRA validMulsModes ;check for next mode
000011FC                           218          
000011FC                           219  mulsBody:
000011FC                           220          
000011FC                           221  
000011FC                           222  
000011FC  43F9 00002287            223          LEA     mulsMessage,A1  ;move string for MOVE
00001202  103C 000E                224          MOVE.B  #14,D0        ;set for task to display null terminated 
00001206                           225                                ;string without CR, LF
00001206  4E4F                     226          TRAP    #15
00001208                           227  
00001208                           228          ;do source EA
00001208  3401                     229          MOVE.W  D1,D2 ;check mode
0000120A  C43C 003F                230          AND.B   #%00111111,D2
0000120E  1A02                     231          MOVE.B  D2,D5
00001210  48E7 4000                232          MOVEM.L D1,-(SP)
00001214  6100 0D1E                233          BSR     Get_Effective_Address
00001218  4CDF 0002                234          MOVEM.L (SP)+,D1
0000121C                           235  
0000121C                           236          ;print separator
0000121C                           237          
0000121C                           238          ;do dest data reg
0000121C  3401                     239          MOVE.W  D1,D2 ;check mode
0000121E  E04A                     240          LSR.W #8,D2 ;shift reg over
00001220  E20A                     241          LSR.B #1,D2
00001222  C43C 0007                242          AND.B   #%00000111,D2 ;force recognition as a Dn
00001226  1A02                     243          MOVE.B  D2,D5
00001228  48E7 4000                244          MOVEM.L D1,-(SP)
0000122C  6100 0D06                245          BSR     Get_Effective_Address
00001230  4CDF 0002                246          MOVEM.L (SP)+,D1
00001234                           247          
00001234  43F9 00002284            248          LEA     clearLine,A1  ;move string for a CR and LF
0000123A  103C 000E                249          MOVE.B  #14,D0        ;set for task to display null terminated 
0000123E                           250                                ;string without CR, LF
0000123E  4E4F                     251          TRAP    #15
00001240                           252  
00001240  7000                     253          MOVEQ.L #0,D0
00001242  4E75                     254          RTS
00001244                           255  
00001244                           256  
00001244                           257  
00001244                           258  RSRLWEA:
00001244                           259          
00001244                           260  
00001244                           261          
00001244  7000                     262          MOVEQ.L #0, D0 ;clear D0
00001246                           263          
00001246                           264  validRSRL:
00001246                           265          
00001246  43F9 00001396            266          LEA lsrlEAmasks,A1 ;load the list of masks
0000124C  D3C0                     267          ADDA.L D0,A1 ;displace to a specific mask
0000124E  1A11                     268          MOVE.B (A1),D5 ;move the mask to D5
00001250                           269          
00001250  0C05 0000                270          CMPI.B #0,D5 ;check if the mask is 0
00001254  6700 FE1A                271          BEQ falsePositive ;branch if it is
00001258                           272          
00001258  1401                     273          MOVE.B D1,D2 ;copy instruction to D2
0000125A  C405                     274          AND.B D5,D2  ;mask D2
0000125C                           275          
0000125C  43F9 00001390            276          LEA lsrlEA,A1 ;load the list of valid modes
00001262  D3C0                     277          ADDA.L D0,A1 ;displace to a specific mode
00001264  1811                     278          MOVE.B (A1),D4 ;move mode to D4
00001266  B404                     279          CMP.B D4,D2 ;compare mode to masked value
00001268  6700 0006                280          BEQ  rsrlweaCheckDirection ;if its match, its a valid mode and we can procede
0000126C                           281          
0000126C  5280                     282          ADDQ.L #1,D0 ;add one to displacement
0000126E  60D6                     283          BRA validRSRL ;check for next mode
00001270                           284  
00001270                           285  rsrlweaCheckDirection:
00001270                           286          ;Figure out which direction we are going
00001270  3401                     287          MOVE.W D1,D2 ;copy inst to D2
00001272  E04A                     288          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
00001274  0202 0001                289          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
00001278  0C02 0000                290          CMPI.B #0,D2 ;compare bit to zero
0000127C  6700 0006                291          BEQ RSREA ;if zero, right
00001280  6000 0012                292          BRA RSLEA ;else, its left
00001284                           293  
00001284                           294  RSREA:
00001284                           295  
00001284  43F9 00002292            296          LEA     rsrMessage,A1  ;move string for MOVE
0000128A  103C 000E                297          MOVE.B  #14,D0        ;set for task to display null terminated 
0000128E                           298                                ;string with CR, LF
0000128E  4E4F                     299          TRAP    #15
00001290  6000 0166                300          BRA lsrlweaBody
00001294                           301          
00001294                           302  RSLEA:
00001294                           303          
00001294  43F9 0000228D            304          LEA     rslMessage,A1  ;move string for MOVE
0000129A  103C 000E                305          MOVE.B  #14,D0        ;set for task to display null terminated 
0000129E                           306                                ;string with CR, LF
0000129E  4E4F                     307          TRAP    #15
000012A0  6000 0156                308          BRA lsrlweaBody        
000012A4                           309          
000012A4                           310  
000012A4                           311  
000012A4                           312  RSRLREG:
000012A4                           313          
000012A4                           314  
000012A4                           315          
000012A4  7000                     316          MOVEQ.L #0, D0 ;clear D0
000012A6                           317          
000012A6                           318          ;check valid size field
000012A6  3401                     319          MOVE.W D1,D2 ;copy inst to D2
000012A8  EC4A                     320          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
000012AA  0202 0003                321          ANDI.B #%00000011,D2 ;mask out rest of byte
000012AE  0C02 0003                322          CMPI.B #%11,D2 ;compare to 3
000012B2  6700 FDBC                323          BEQ falsePositive ;invalid size
000012B6                           324  
000012B6                           325          
000012B6                           326          ;Figure out which direction we are going
000012B6  3401                     327          MOVE.W D1,D2 ;copy inst to D2
000012B8  E04A                     328          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000012BA  0202 0001                329          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000012BE  0C02 0000                330          CMPI.B #0,D2 ;compare bit to zero
000012C2  6700 0006                331          BEQ RSRreg ;if zero, right
000012C6  6000 0012                332          BRA RSLreg ;else, its left        
000012CA                           333          
000012CA                           334  RSRreg:
000012CA                           335  
000012CA  43F9 00002292            336          LEA     rsrMessage,A1  ;move string for MOVE
000012D0  103C 000E                337          MOVE.B  #14,D0        ;set for task to display null terminated 
000012D4                           338                                ;string with CR, LF
000012D4  4E4F                     339          TRAP    #15
000012D6  6000 018A                340          BRA LSRLregBody
000012DA                           341          
000012DA                           342  RSLreg:
000012DA                           343          
000012DA  43F9 0000228D            344          LEA     rslMessage,A1  ;move string for MOVE
000012E0  103C 000E                345          MOVE.B  #14,D0        ;set for task to display null terminated 
000012E4                           346                                ;string with CR, LF
000012E4  4E4F                     347          TRAP    #15
000012E6  6000 017A                348          BRA LSRLregBody
000012EA                           349  
000012EA                           350       
000012EA                           351  
000012EA                           352  ASRLWEA:
000012EA                           353          
000012EA                           354  
000012EA                           355          
000012EA  7000                     356          MOVEQ.L #0, D0 ;clear D0
000012EC                           357          
000012EC                           358  validASRL:
000012EC                           359          
000012EC  43F9 00001396            360          LEA lsrlEAmasks,A1 ;load the list of masks
000012F2  D3C0                     361          ADDA.L D0,A1 ;displace to a specific mask
000012F4  1A11                     362          MOVE.B (A1),D5 ;move the mask to D5
000012F6                           363          
000012F6  0C05 0000                364          CMPI.B #0,D5 ;check if the mask is 0
000012FA  6700 FD74                365          BEQ falsePositive ;branch if it is
000012FE                           366          
000012FE  1401                     367          MOVE.B D1,D2 ;copy instruction to D2
00001300  C405                     368          AND.B D5,D2  ;mask D2
00001302                           369          
00001302  43F9 00001390            370          LEA lsrlEA,A1 ;load the list of valid modes
00001308  D3C0                     371          ADDA.L D0,A1 ;displace to a specific mode
0000130A  1811                     372          MOVE.B (A1),D4 ;move mode to D4
0000130C  B404                     373          CMP.B D4,D2 ;compare mode to masked value
0000130E  6700 0006                374          BEQ  asrlweaCheckDirection ;if its match, its a valid mode and we can procede
00001312                           375          
00001312  5280                     376          ADDQ.L #1,D0 ;add one to displacement
00001314  60D6                     377          BRA validASRL ;check for next mode
00001316                           378  
00001316                           379  asrlweaCheckDirection:
00001316                           380          ;Figure out which direction we are going
00001316  3401                     381          MOVE.W D1,D2 ;copy inst to D2
00001318  E04A                     382          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
0000131A  0202 0001                383          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
0000131E  0C02 0000                384          CMPI.B #0,D2 ;compare bit to zero
00001322  6700 0006                385          BEQ ASREA ;if zero, right
00001326  6000 0012                386          BRA ASLEA ;else, its left
0000132A                           387  
0000132A                           388  ASREA:
0000132A                           389  
0000132A  43F9 0000229C            390          LEA     asrMessage,A1  ;move string for MOVE
00001330  103C 000E                391          MOVE.B  #14,D0        ;set for task to display null terminated 
00001334                           392                                ;string with CR, LF
00001334  4E4F                     393          TRAP    #15
00001336  6000 00C0                394          BRA lsrlweaBody
0000133A                           395          
0000133A                           396  ASLEA:
0000133A                           397          
0000133A  43F9 00002297            398          LEA     aslMessage,A1  ;move string for MOVE
00001340  103C 000E                399          MOVE.B  #14,D0        ;set for task to display null terminated 
00001344                           400                                ;string with CR, LF
00001344  4E4F                     401          TRAP    #15
00001346  6000 00B0                402          BRA lsrlweaBody        
0000134A                           403          
0000134A                           404  
0000134A                           405  
0000134A                           406  ASRLREG:
0000134A                           407          
0000134A                           408  
0000134A                           409          
0000134A  7000                     410          MOVEQ.L #0, D0 ;clear D0
0000134C                           411          
0000134C                           412          ;check valid size field
0000134C  3401                     413          MOVE.W D1,D2 ;copy inst to D2
0000134E  EC4A                     414          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
00001350  0202 0003                415          ANDI.B #%00000011,D2 ;mask out rest of byte
00001354  0C02 0003                416          CMPI.B #%11,D2 ;compare to 3
00001358  6700 FD16                417          BEQ falsePositive ;invalid size
0000135C                           418  
0000135C                           419          
0000135C                           420          ;Figure out which direction we are going
0000135C  3401                     421          MOVE.W D1,D2 ;copy inst to D2
0000135E  E04A                     422          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
00001360  0202 0001                423          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
00001364  0C02 0000                424          CMPI.B #0,D2 ;compare bit to zero
00001368  6700 0006                425          BEQ ASRreg ;if zero, right
0000136C  6000 0012                426          BRA ASLreg ;else, its left        
00001370                           427          
00001370                           428  ASRreg:
00001370                           429  
00001370  43F9 0000229C            430          LEA     asrMessage,A1  ;move string for MOVE
00001376  103C 000E                431          MOVE.B  #14,D0        ;set for task to display null terminated 
0000137A                           432                                ;string with CR, LF
0000137A  4E4F                     433          TRAP    #15
0000137C  6000 00E4                434          BRA LSRLregBody
00001380                           435          
00001380                           436  ASLreg:
00001380                           437          
00001380  43F9 00002297            438          LEA     aslMessage,A1  ;move string for MOVE
00001386  103C 000E                439          MOVE.B  #14,D0        ;set for task to display null terminated 
0000138A                           440                                ;string with CR, LF
0000138A  4E4F                     441          TRAP    #15
0000138C  6000 00D4                442          BRA LSRLregBody
00001390                           443  
00001390                           444  
00001390= 10 18 20 38 39 00        445  lsrlEA        DC.B %010000,%011000,%100000,%111000,%111001,0
00001396= 38 38 38 3F 3F 00        446  lsrlEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0       
0000139C                           447  
0000139C                           448  LSRLWEA:
0000139C                           449          
0000139C                           450  
0000139C                           451          
0000139C  7000                     452          MOVEQ.L #0, D0 ;clear D0
0000139E                           453          
0000139E                           454  validLSRL:
0000139E                           455          
0000139E  43F8 1396                456          LEA lsrlEAmasks,A1 ;load the list of masks
000013A2  D3C0                     457          ADDA.L D0,A1 ;displace to a specific mask
000013A4  1A11                     458          MOVE.B (A1),D5 ;move the mask to D5
000013A6                           459          
000013A6  0C05 0000                460          CMPI.B #0,D5 ;check if the mask is 0
000013AA  6700 FCC4                461          BEQ falsePositive ;branch if it is
000013AE                           462          
000013AE  1401                     463          MOVE.B D1,D2 ;copy instruction to D2
000013B0  C405                     464          AND.B D5,D2  ;mask D2
000013B2                           465          
000013B2  43F8 1390                466          LEA lsrlEA,A1 ;load the list of valid modes
000013B6  D3C0                     467          ADDA.L D0,A1 ;displace to a specific mode
000013B8  1811                     468          MOVE.B (A1),D4 ;move mode to D4
000013BA  B404                     469          CMP.B D4,D2 ;compare mode to masked value
000013BC  6700 0006                470          BEQ  lsrlweaCheckDirection ;if its match, its a valid mode and we can procede
000013C0                           471          
000013C0  5280                     472          ADDQ.L #1,D0 ;add one to displacement
000013C2  60DA                     473          BRA validLSRL ;check for next mode
000013C4                           474  
000013C4                           475  lsrlweaCheckDirection:
000013C4                           476          ;Figure out which direction we are going
000013C4  3401                     477          MOVE.W D1,D2 ;copy inst to D2
000013C6  E04A                     478          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000013C8  0202 0001                479          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000013CC  0C02 0000                480          CMPI.B #0,D2 ;compare bit to zero
000013D0  6700 0006                481          BEQ LSREA ;if zero, right
000013D4  6000 0012                482          BRA LSLEA ;else, its left
000013D8                           483  
000013D8                           484  LSREA:
000013D8                           485  
000013D8  43F9 000022A6            486          LEA     lsrMessage,A1  ;move string for MOVE
000013DE  103C 000E                487          MOVE.B  #14,D0        ;set for task to display null terminated 
000013E2                           488                                ;string with CR, LF
000013E2  4E4F                     489          TRAP    #15
000013E4  6000 0012                490          BRA lsrlweaBody
000013E8                           491          
000013E8                           492  LSLEA:
000013E8                           493          
000013E8  43F9 000022A1            494          LEA     lslMessage,A1  ;move string for MOVE
000013EE  103C 000E                495          MOVE.B  #14,D0        ;set for task to display null terminated 
000013F2                           496                                ;string with CR, LF
000013F2  4E4F                     497          TRAP    #15
000013F4  6000 0002                498          BRA lsrlweaBody        
000013F8                           499          
000013F8                           500  lsrlweaBody:
000013F8                           501  
000013F8                           502          
000013F8  3401                     503          MOVE.W  D1,D2 ;check mode
000013FA  C43C 003F                504          AND.B   #%00111111,D2
000013FE  1A02                     505          MOVE.B  D2,D5
00001400  48E7 4000                506          MOVEM.L D1,-(SP)
00001404  6100 0B2E                507          BSR     Get_Effective_Address
00001408  4CDF 0002                508          MOVEM.L (SP)+,D1
0000140C                           509          
0000140C                           510          
0000140C  43F9 00002284            511          LEA     clearLine,A1  ;move string for a CR and LF
00001412  103C 000E                512          MOVE.B  #14,D0        ;set for task to display null terminated 
00001416                           513                                ;string without CR, LF
00001416  4E4F                     514          TRAP    #15
00001418                           515  
00001418  7000                     516          MOVEQ.L #0,D0
0000141A  4E75                     517          RTS
0000141C                           518  
0000141C                           519  
0000141C                           520  LSRLREG:
0000141C                           521          
0000141C                           522  
0000141C                           523          
0000141C  7000                     524          MOVEQ.L #0, D0 ;clear D0
0000141E                           525          
0000141E                           526          ;check valid size field
0000141E  3401                     527          MOVE.W D1,D2 ;copy inst to D2
00001420  EC4A                     528          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
00001422  0202 0003                529          ANDI.B #%00000011,D2 ;mask out rest of byte
00001426  0C02 0003                530          CMPI.B #%11,D2 ;compare to 3
0000142A  6700 FC44                531          BEQ falsePositive ;invalid size
0000142E                           532  
0000142E                           533          
0000142E                           534          ;Figure out which direction we are going
0000142E  3401                     535          MOVE.W D1,D2 ;copy inst to D2
00001430  E04A                     536          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
00001432  0202 0001                537          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
00001436  0C02 0000                538          CMPI.B #0,D2 ;compare bit to zero
0000143A  6700 0006                539          BEQ LSRreg ;if zero, right
0000143E  6000 0012                540          BRA LSLreg ;else, its left        
00001442                           541          
00001442                           542  LSRreg:
00001442                           543  
00001442  43F9 000022A6            544          LEA     lsrMessage,A1  ;move string for MOVE
00001448  103C 000E                545          MOVE.B  #14,D0        ;set for task to display null terminated 
0000144C                           546                                ;string with CR, LF
0000144C  4E4F                     547          TRAP    #15
0000144E  6000 0012                548          BRA LSRLregBody
00001452                           549          
00001452                           550  LSLreg:
00001452                           551          
00001452  43F9 000022A1            552          LEA     lslMessage,A1  ;move string for MOVE
00001458  103C 000E                553          MOVE.B  #14,D0        ;set for task to display null terminated 
0000145C                           554                                ;string with CR, LF
0000145C  4E4F                     555          TRAP    #15
0000145E  6000 0002                556          BRA LSRLregBody
00001462                           557          
00001462                           558  LSRLregBody:
00001462                           559                      
00001462                           560          ;check i/r
00001462  48E7 4000                561          MOVEM.L D1,-(SP)
00001466  6100 002A                562          BSR LSRLcheckIR
0000146A  4CDF 0002                563          MOVEM.L (SP)+,D1
0000146E                           564          
0000146E  3401                     565          MOVE.W  D1,D2 ;check mode
00001470  C43C 0007                566          AND.B   #%00000111,D2
00001474  1A02                     567          MOVE.B  D2,D5
00001476  48E7 4000                568          MOVEM.L D1,-(SP)
0000147A  6100 0AB8                569          BSR     Get_Effective_Address
0000147E  4CDF 0002                570          MOVEM.L (SP)+,D1
00001482                           571          
00001482                           572          
00001482  43F9 00002284            573          LEA     clearLine,A1  ;move string for a CR and LF
00001488  103C 000E                574          MOVE.B  #14,D0        ;set for task to display null terminated 
0000148C                           575                                ;string without CR, LF
0000148C  4E4F                     576          TRAP    #15
0000148E                           577  
0000148E  7000                     578          MOVEQ.L #0,D0
00001490  4E75                     579          RTS
00001492                           580  
00001492                           581  LSRLcheckIR:
00001492                           582  
00001492  1401                     583          MOVE.B D1,D2 ;move inst to D2
00001494  EA0A                     584          LSR.B  #5,D2
00001496  C43C 0001                585          AND.B  #%00000001,D2
0000149A  0C02 0000                586          CMPI.B #0,D2
0000149E  6700 0008                587          BEQ  LSRLcheckI
000014A2  6000 0038                588          BRA  LSRLcheckR
000014A6                           589  LSRLcheckIRreturn:
000014A6  4E75                     590          RTS
000014A8                           591          
000014A8                           592  LSRLcheckI:
000014A8                           593          ;print '#'
000014A8  48E7 4000                594          MOVEM.L D1,-(SP) ;save D1 to the stack
000014AC  123C 0023                595          MOVE.B #'#',D1 ;put ascii value of '#' in D1
000014B0  103C 0006                596          MOVE.B #6,D0 ;move task 6 into D0
000014B4  4E4F                     597          TRAP #15 ;prin char
000014B6  4CDF 0002                598          MOVEM.L (SP)+,D1 ;pull D1 off the stack
000014BA                           599          
000014BA                           600          ;print number
000014BA  48E7 4000                601          MOVEM.L D1,-(SP)
000014BE  3401                     602          MOVE.W D1,D2 ;copy inst to d2
000014C0  E04A                     603          LSR.W #8,D2 ;shift data section
000014C2  E20A                     604          LSR.B #1,D2
000014C4  C43C 0007                605          AND.B #%00000111,D2 ;mask out rest of data
000014C8  6100 00D6                606          BSR ZeroToEight ;handle zero
000014CC  7200                     607          MOVEQ.L #0,D1 ;clear D1
000014CE  1202                     608          MOVE.B D2,D1 ;move number to display into D1
000014D0  103C 0003                609          MOVE.B #3,D0 ;move task 3 to D0
000014D4  4E4F                     610          TRAP #15
000014D6  4CDF 0002                611          MOVEM.L (SP)+,D1
000014DA  60CA                     612          BRA LSRLcheckIRreturn
000014DC                           613          
000014DC                           614  LSRLcheckR:
000014DC  3401                     615          MOVE.W D1,D2 ;copy inst to d2
000014DE  E04A                     616          LSR.W #8,D2 ;shift data section
000014E0  E20A                     617          LSR.B #1,D2
000014E2  C43C 0007                618          AND.B #%00000111,D2 ;mask out rest of data
000014E6  1A02                     619          MOVE.B D2,D5 ;force Dn
000014E8  48E7 4000                620          MOVEM.L D1,-(SP)
000014EC  6100 0A46                621          BSR     Get_Effective_Address
000014F0  4CDF 0002                622          MOVEM.L (SP)+,D1
000014F4  60B0                     623          BRA LSRLcheckIRreturn
000014F6                           624          
000014F6= 00 08 10 18 20 38 ...    625  subqEA        DC.B %000000,%001000,%010000,%011000,%100000,%111000,%111001,0
000014FE= 38 38 38 38 38 3F ...    626  subqEAmasks   DC.B %111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001506                           627  
00001506                           628  SUBQ:
00001506                           629          
00001506                           630  
00001506                           631          
00001506  7000                     632          MOVEQ.L #0, D0 ;clear D0
00001508                           633          
00001508                           634          ;check valid size field
00001508  3401                     635          MOVE.W D1,D2 ;copy inst to D2
0000150A  EC4A                     636          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
0000150C  0202 0003                637          ANDI.B #%00000011,D2 ;mask out rest of byte
00001510  0C02 0003                638          CMPI.B #%11,D2 ;compare to 3
00001514  6700 FB5A                639          BEQ falsePositive ;invalid size
00001518                           640          
00001518                           641  validSubq:
00001518                           642          
00001518  43F8 14FE                643          LEA subqEAmasks,A1 ;load the list of masks
0000151C  D3C0                     644          ADDA.L D0,A1 ;displace to a specific mask
0000151E  1A11                     645          MOVE.B (A1),D5 ;move the mask to D5
00001520                           646          
00001520  0C05 0000                647          CMPI.B #0,D5 ;check if the mask is 0
00001524  6700 FB4A                648          BEQ falsePositive ;branch if it is
00001528                           649          
00001528  1401                     650          MOVE.B D1,D2 ;copy instruction to D2
0000152A  C405                     651          AND.B D5,D2  ;mask D2
0000152C                           652          
0000152C  43F8 14F6                653          LEA subqEA,A1 ;load the list of valid modes
00001530  D3C0                     654          ADDA.L D0,A1 ;displace to a specific mode
00001532  1811                     655          MOVE.B (A1),D4 ;move mode to D4
00001534  B404                     656          CMP.B D4,D2 ;compare mode to masked value
00001536  6700 0006                657          BEQ  subqBody ;if its match, its a valid mode and we can procede
0000153A                           658          
0000153A  5280                     659          ADDQ.L #1,D0 ;add one to displacement
0000153C  60DA                     660          BRA validSubq ;check for next mode
0000153E                           661          
0000153E                           662          
0000153E                           663  subqBody
0000153E                           664  
0000153E  43F9 000022AB            665          LEA     subqMessage,A1  ;move string for MOVE
00001544  103C 000E                666          MOVE.B  #14,D0        ;set for task to display null terminated 
00001548                           667                                ;string with CR, LF
00001548  4E4F                     668          TRAP    #15
0000154A                           669          
0000154A                           670          ;immediate data
0000154A                           671          
0000154A                           672          ;print '#'
0000154A  48E7 4000                673          MOVEM.L D1,-(SP) ;save D1 to the stack
0000154E  123C 0023                674          MOVE.B #'#',D1 ;put ascii value of '#' in D1
00001552  103C 0006                675          MOVE.B #6,D0 ;move task 6 into D0
00001556  4E4F                     676          TRAP #15 ;prin char
00001558  4CDF 0002                677          MOVEM.L (SP)+,D1 ;pull D1 off the stack
0000155C                           678          
0000155C                           679          ;print number
0000155C  48E7 4000                680          MOVEM.L D1,-(SP)
00001560  3401                     681          MOVE.W D1,D2 ;copy inst to d2
00001562  E04A                     682          LSR.W #8,D2 ;shift data section
00001564  E20A                     683          LSR.B #1,D2
00001566  C43C 0007                684          AND.B #%00000111,D2 ;mask out rest of data
0000156A  6100 0034                685          BSR ZeroToEight ;handle zero
0000156E  7200                     686          MOVEQ.L #0,D1 ;clear D1
00001570  1202                     687          MOVE.B D2,D1 ;move number to display into D1
00001572  103C 0003                688          MOVE.B #3,D0 ;move task 3 to D0
00001576  4E4F                     689          TRAP #15
00001578  4CDF 0002                690          MOVEM.L (SP)+,D1
0000157C                           691          
0000157C                           692          ;print separator
0000157C                           693          
0000157C                           694          ;Then do EA
0000157C                           695          
0000157C  3401                     696          MOVE.W  D1,D2 ;check mode
0000157E  C43C 003F                697          AND.B   #%00111111,D2
00001582  1A02                     698          MOVE.B  D2,D5
00001584  48E7 4000                699          MOVEM.L D1,-(SP)
00001588  6100 09AA                700          BSR     Get_Effective_Address
0000158C  4CDF 0002                701          MOVEM.L (SP)+,D1
00001590                           702          
00001590  43F9 00002284            703          LEA     clearLine,A1  ;move string for a CR and LF
00001596  103C 000E                704          MOVE.B  #14,D0        ;set for task to display null terminated 
0000159A                           705                                ;string without CR, LF
0000159A  4E4F                     706          TRAP    #15
0000159C                           707  
0000159C  7000                     708          MOVEQ.L #0,D0
0000159E  4E75                     709          RTS
000015A0                           710          
000015A0                           711  ZeroToEight:
000015A0                           712          
000015A0  0C02 0000                713          CMPI.B #0,D2
000015A4  6700 0004                714          BEQ toEight
000015A8                           715  ZeroToEightReturn:
000015A8                           716          
000015A8  4E75                     717          RTS
000015AA                           718  toEight:
000015AA                           719          
000015AA  5002                     720          ADDQ.B #8,D2
000015AC  60FA                     721          BRA ZeroToEightReturn
000015AE                           722  
000015AE                           723      
000015AE                           724  SUB:
000015AE                           725          
000015AE                           726  
000015AE                           727          
000015AE  7000                     728          MOVEQ.L #0, D0 ;clear D0
000015B0                           729          
000015B0                           730          ;Figure out if EA is source or destination
000015B0  3401                     731          MOVE.W D1,D2 ;copy inst to D2
000015B2  EC4A                     732          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
000015B4  0202 0007                733          ANDI.B #%00000111,D2 ;mask out rest of byte
000015B8  0C02 0002                734          CMPI.B #2,D2 ;compare to 2
000015BC  6F00 0016                735          BLE validSubSourceEA ;2 or less is EA is source
000015C0                           736          
000015C0  0C02 0007                737          CMPI.B #%111,D2 ;compare to 7
000015C4  6700 FAAA                738          BEQ falsePositive ;thats not valid
000015C8  0C02 0003                739          CMPI.B #%11,D2 ;compare to 3
000015CC  6700 FAA2                740          BEQ falsePositive ;also not valid
000015D0  6000 002C                741          BRA validSubDestEA ;all thats left is valid EA as Dest 
000015D4                           742          
000015D4                           743  validSubSourceEA:
000015D4                           744          
000015D4  43F9 00001B8F            745          LEA moveSourceEAmasks,A1 ;load the list of masks
000015DA  D3C0                     746          ADDA.L D0,A1 ;displace to a specific mask
000015DC  1A11                     747          MOVE.B (A1),D5 ;move the mask to D5
000015DE                           748          
000015DE  0C05 0000                749          CMPI.B #0,D5 ;check if the mask is 0
000015E2  6700 FA8C                750          BEQ falsePositive ;branch if it is
000015E6                           751          
000015E6  1401                     752          MOVE.B D1,D2 ;copy instruction to D2
000015E8  C405                     753          AND.B D5,D2  ;mask D2
000015EA                           754          
000015EA  43F9 00001B86            755          LEA moveSourceEA,A1 ;load the list of valid modes
000015F0  D3C0                     756          ADDA.L D0,A1 ;displace to a specific mode
000015F2  1811                     757          MOVE.B (A1),D4 ;move mode to D4
000015F4  B404                     758          CMP.B D4,D2 ;compare mode to masked value
000015F6  6700 0036                759          BEQ  subSource ;if its match, its a valid mode and we can procede
000015FA                           760          
000015FA  5280                     761          ADDQ.L #1,D0 ;add one to displacement
000015FC  60D6                     762          BRA validSubSourceEA ;check for next mode
000015FE                           763          
000015FE                           764          
000015FE                           765  validSubDestEA:
000015FE                           766          
000015FE  43F9 00001756            767          LEA addDestEAmasks,A1 ;load the list of masks
00001604  D3C0                     768          ADDA.L D0,A1 ;displace to a specific mask
00001606  1A11                     769          MOVE.B (A1),D5 ;move the mask to D5
00001608                           770          
00001608  0C05 0000                771          CMPI.B #0,D5 ;check if the mask is 0
0000160C  6700 FA62                772          BEQ falsePositive ;branch if it is
00001610                           773          
00001610  3401                     774          MOVE.W D1,D2 ;copy instruction to D2
00001612  EC4A                     775          LSR.W #6,D2  ;move mode
00001614  6100 0A92                776          BSR switchModeAndReg ;switch register and mode
00001618  C405                     777          AND.B D5,D2  ;mask D2
0000161A                           778          
0000161A  43F9 00001750            779          LEA addDestEA,A1 ;load the list of valid modes
00001620  D3C0                     780          ADDA.L D0,A1 ;displace to a specific mode
00001622  1811                     781          MOVE.B (A1),D4 ;move mode to D4
00001624  B404                     782          CMP.B D4,D2 ;compare mode to masked value
00001626  6700 004E                783          BEQ subDest ;if its match, its a valid mode and we can procede
0000162A                           784          
0000162A  5280                     785          ADDQ.L #1,D0 ;add one to displacement
0000162C  60D0                     786          BRA validSubDestEA ;check for next mode
0000162E                           787          
0000162E                           788  subSource
0000162E                           789  
0000162E  43F9 000022B1            790          LEA     subMessage,A1  ;move string for MOVE
00001634  103C 000E                791          MOVE.B  #14,D0        ;set for task to display null terminated 
00001638                           792                                ;string with CR, LF
00001638  4E4F                     793          TRAP    #15
0000163A                           794          
0000163A                           795          ;do EA
0000163A                           796          
0000163A  3401                     797          MOVE.W  D1,D2 ;check mode
0000163C  C43C 003F                798          AND.B   #%00111111,D2
00001640  1A02                     799          MOVE.B  D2,D5
00001642  48E7 4000                800          MOVEM.L D1,-(SP)
00001646  6100 08EC                801          BSR     Get_Effective_Address
0000164A  4CDF 0002                802          MOVEM.L (SP)+,D1
0000164E                           803          
0000164E                           804          ;print separator
0000164E                           805          
0000164E                           806          ;Then do Dn
0000164E                           807          
0000164E  3401                     808          MOVE.W  D1,D2
00001650  E04A                     809          LSR.W   #8,D2 ;move reg into first byte
00001652  E20A                     810          LSR.B   #1,D2 ;line it up to least sig bit
00001654  C43C 0007                811          AND.B   #%00000111,D2 ;force mode to Dn
00001658  1A02                     812          MOVE.B  D2,D5
0000165A  48E7 4000                813          MOVEM.L D1,-(SP)
0000165E  6100 08D4                814          BSR     Get_Effective_Address
00001662  4CDF 0002                815          MOVEM.L (SP)+,D1
00001666                           816          
00001666  43F9 00002284            817          LEA     clearLine,A1  ;move string for a CR and LF
0000166C  103C 000E                818          MOVE.B  #14,D0        ;set for task to display null terminated 
00001670                           819                                ;string without CR, LF
00001670  4E4F                     820          TRAP    #15
00001672                           821  
00001672  7000                     822          MOVEQ.L #0,D0
00001674  4E75                     823          RTS
00001676                           824  
00001676                           825  subDest
00001676                           826  
00001676  43F9 000022B1            827          LEA     subMessage,A1  ;move string for MOVE
0000167C  103C 000E                828          MOVE.B  #14,D0        ;set for task to display null terminated 
00001680                           829                                ;string with CR, LF
00001680  4E4F                     830          TRAP    #15
00001682                           831          
00001682                           832          ;Do Dn
00001682                           833          
00001682  3401                     834          MOVE.W  D1,D2
00001684  E04A                     835          LSR.W   #8,D2 ;move reg into first byte
00001686  E20A                     836          LSR.B   #1,D2 ;line it up to least sig bit
00001688  C43C 0007                837          AND.B   #%00000111,D2 ;force mode to Dn
0000168C  1A02                     838          MOVE.B  D2,D5
0000168E  48E7 4000                839          MOVEM.L D1,-(SP)
00001692  6100 08A0                840          BSR     Get_Effective_Address
00001696  4CDF 0002                841          MOVEM.L (SP)+,D1
0000169A                           842          
0000169A                           843          
0000169A                           844          ;print separator
0000169A                           845          
0000169A                           846          ;Then do EA
0000169A                           847          
0000169A  3401                     848          MOVE.W  D1,D2 ;check mode
0000169C  C43C 003F                849          AND.B   #%00111111,D2
000016A0  1A02                     850          MOVE.B  D2,D5
000016A2  48E7 4000                851          MOVEM.L D1,-(SP)
000016A6  6100 088C                852          BSR     Get_Effective_Address
000016AA  4CDF 0002                853          MOVEM.L (SP)+,D1
000016AE                           854          
000016AE                           855          
000016AE  43F9 00002284            856          LEA     clearLine,A1  ;move string for a CR and LF
000016B4  103C 000E                857          MOVE.B  #14,D0        ;set for task to display null terminated 
000016B8                           858                                ;string without CR, LF
000016B8  4E4F                     859          TRAP    #15
000016BA                           860  
000016BA  7000                     861          MOVEQ.L #0,D0
000016BC  4E75                     862          RTS
000016BE                           863  
000016BE                           864  
000016BE                           865  ADDA:
000016BE                           866          
000016BE                           867  
000016BE                           868          
000016BE  7000                     869          MOVEQ.L #0, D0 ;clear D0
000016C0                           870          
000016C0                           871          ;check opmode field
000016C0  3401                     872          MOVE.W D1,D2 ;copy inst to D2
000016C2  EC4A                     873          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
000016C4  0202 0007                874          ANDI.B #%00000111,D2 ;mask out rest of byte
000016C8  0C02 0007                875          CMPI.B #%111,D2 ;compare to 7
000016CC  6700 000E                876          BEQ validAdda ;thats valid
000016D0  0C02 0003                877          CMPI.B #%11,D2 ;compare to 3
000016D4  6700 0006                878          BEQ validAdda ;also valid
000016D8  6000 F996                879          BRA falsePositive ;all thats left is invalid 
000016DC                           880          
000016DC                           881  validAdda:
000016DC                           882          
000016DC  43F9 00001B8F            883          LEA moveSourceEAmasks,A1 ;load the list of masks
000016E2  D3C0                     884          ADDA.L D0,A1 ;displace to a specific mask
000016E4  1A11                     885          MOVE.B (A1),D5 ;move the mask to D5
000016E6                           886          
000016E6  0C05 0000                887          CMPI.B #0,D5 ;check if the mask is 0
000016EA  6700 F984                888          BEQ falsePositive ;branch if it is
000016EE                           889          
000016EE  1401                     890          MOVE.B D1,D2 ;copy instruction to D2
000016F0  C405                     891          AND.B D5,D2  ;mask D2
000016F2                           892          
000016F2  43F9 00001B86            893          LEA moveSourceEA,A1 ;load the list of valid modes
000016F8  D3C0                     894          ADDA.L D0,A1 ;displace to a specific mode
000016FA  1811                     895          MOVE.B (A1),D4 ;move mode to D4
000016FC  B404                     896          CMP.B D4,D2 ;compare mode to masked value
000016FE  6700 0006                897          BEQ  addaBody ;if its match, its a valid mode and we can procede
00001702                           898          
00001702  5280                     899          ADDQ.L #1,D0 ;add one to displacement
00001704  60D6                     900          BRA validAdda ;check for next mode
00001706                           901          
00001706                           902          
00001706                           903  addaBody
00001706                           904  
00001706  43F9 000022B6            905          LEA     addaMessage,A1  ;move string for MOVE
0000170C  103C 000E                906          MOVE.B  #14,D0        ;set for task to display null terminated 
00001710                           907                                ;string with CR, LF
00001710  4E4F                     908          TRAP    #15
00001712                           909          
00001712                           910          ;do EA
00001712                           911          
00001712  3401                     912          MOVE.W  D1,D2 ;check mode
00001714  C43C 003F                913          AND.B   #%00111111,D2
00001718  1A02                     914          MOVE.B  D2,D5
0000171A  48E7 4000                915          MOVEM.L D1,-(SP)
0000171E  6100 0814                916          BSR     Get_Effective_Address
00001722  4CDF 0002                917          MOVEM.L (SP)+,D1
00001726                           918          
00001726                           919          ;print separator
00001726                           920          
00001726                           921          ;Then do Dn
00001726                           922          
00001726  3401                     923          MOVE.W  D1,D2
00001728  E04A                     924          LSR.W   #8,D2 ;move reg into first byte
0000172A  E20A                     925          LSR.B   #1,D2 ;line it up to least sig bit
0000172C  C43C 0007                926          AND.B   #%00000111,D2 ;force mode to An
00001730  5002                     927          ADDI.B  #%00001000,D2 
00001732  1A02                     928          MOVE.B  D2,D5
00001734  48E7 4000                929          MOVEM.L D1,-(SP)
00001738  6100 07FA                930          BSR     Get_Effective_Address
0000173C  4CDF 0002                931          MOVEM.L (SP)+,D1
00001740                           932          
00001740  43F9 00002284            933          LEA     clearLine,A1  ;move string for a CR and LF
00001746  103C 000E                934          MOVE.B  #14,D0        ;set for task to display null terminated 
0000174A                           935                                ;string without CR, LF
0000174A  4E4F                     936          TRAP    #15
0000174C                           937  
0000174C  7000                     938          MOVEQ.L #0,D0
0000174E  4E75                     939          RTS
00001750                           940  
00001750                           941  
00001750                           942      
00001750= 10 18 20 38 39 00        943  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
00001756= 38 38 38 3F 3F 00        944  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
0000175C                           945  
0000175C                           946  ADD:
0000175C                           947          
0000175C                           948  
0000175C                           949          
0000175C  7000                     950          MOVEQ.L #0, D0 ;clear D0
0000175E                           951          
0000175E                           952          ;Figure out if EA is source or destination
0000175E  3401                     953          MOVE.W D1,D2 ;copy inst to D2
00001760  EC4A                     954          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
00001762  0202 0007                955          ANDI.B #%00000111,D2 ;mask out rest of byte
00001766  0C02 0002                956          CMPI.B #2,D2 ;compare to 2
0000176A  6F00 0016                957          BLE validAddSourceEA ;2 or less is EA is source
0000176E                           958          
0000176E  0C02 0007                959          CMPI.B #%111,D2 ;compare to 7
00001772  6700 F8FC                960          BEQ falsePositive ;thats not valid
00001776  0C02 0003                961          CMPI.B #%11,D2 ;compare to 3
0000177A  6700 F8F4                962          BEQ falsePositive ;also not valid
0000177E  6000 002C                963          BRA validAddDestEA ;all thats left is valid EA as Dest 
00001782                           964          
00001782                           965  validAddSourceEA:
00001782                           966          
00001782  43F9 00001B8F            967          LEA moveSourceEAmasks,A1 ;load the list of masks
00001788  D3C0                     968          ADDA.L D0,A1 ;displace to a specific mask
0000178A  1A11                     969          MOVE.B (A1),D5 ;move the mask to D5
0000178C                           970          
0000178C  0C05 0000                971          CMPI.B #0,D5 ;check if the mask is 0
00001790  6700 F8DE                972          BEQ falsePositive ;branch if it is
00001794                           973          
00001794  1401                     974          MOVE.B D1,D2 ;copy instruction to D2
00001796  C405                     975          AND.B D5,D2  ;mask D2
00001798                           976          
00001798  43F9 00001B86            977          LEA moveSourceEA,A1 ;load the list of valid modes
0000179E  D3C0                     978          ADDA.L D0,A1 ;displace to a specific mode
000017A0  1811                     979          MOVE.B (A1),D4 ;move mode to D4
000017A2  B404                     980          CMP.B D4,D2 ;compare mode to masked value
000017A4  6700 0032                981          BEQ  addSource ;if its match, its a valid mode and we can procede
000017A8                           982          
000017A8  5280                     983          ADDQ.L #1,D0 ;add one to displacement
000017AA  60D6                     984          BRA validAddSourceEA ;check for next mode
000017AC                           985          
000017AC                           986          
000017AC                           987  validAddDestEA:
000017AC                           988          
000017AC  43F8 1756                989          LEA addDestEAmasks,A1 ;load the list of masks
000017B0  D3C0                     990          ADDA.L D0,A1 ;displace to a specific mask
000017B2  1A11                     991          MOVE.B (A1),D5 ;move the mask to D5
000017B4                           992          
000017B4  0C05 0000                993          CMPI.B #0,D5 ;check if the mask is 0
000017B8  6700 F8B6                994          BEQ falsePositive ;branch if it is
000017BC                           995          
000017BC  3401                     996          MOVE.W D1,D2 ;copy instruction to D2
000017BE  EC4A                     997          LSR.W #6,D2  ;move mode
000017C0  6100 08E6                998          BSR switchModeAndReg ;switch register and mode
000017C4  C405                     999          AND.B D5,D2  ;mask D2
000017C6                          1000          
000017C6  43F8 1750               1001          LEA addDestEA,A1 ;load the list of valid modes
000017CA  D3C0                    1002          ADDA.L D0,A1 ;displace to a specific mode
000017CC  1811                    1003          MOVE.B (A1),D4 ;move mode to D4
000017CE  B404                    1004          CMP.B D4,D2 ;compare mode to masked value
000017D0  6700 004E               1005          BEQ addDest ;if its match, its a valid mode and we can procede
000017D4                          1006          
000017D4  5280                    1007          ADDQ.L #1,D0 ;add one to displacement
000017D6  60D4                    1008          BRA validAddDestEA ;check for next mode
000017D8                          1009          
000017D8                          1010  addSource
000017D8                          1011  
000017D8  43F9 000022BC           1012          LEA     addMessage,A1  ;move string for MOVE
000017DE  103C 000E               1013          MOVE.B  #14,D0        ;set for task to display null terminated 
000017E2                          1014                                ;string with CR, LF
000017E2  4E4F                    1015          TRAP    #15
000017E4                          1016          
000017E4                          1017          ;do EA
000017E4                          1018          
000017E4  3401                    1019          MOVE.W  D1,D2 ;check mode
000017E6  C43C 003F               1020          AND.B   #%00111111,D2
000017EA  1A02                    1021          MOVE.B  D2,D5
000017EC  48E7 4000               1022          MOVEM.L D1,-(SP)
000017F0  6100 0742               1023          BSR     Get_Effective_Address
000017F4  4CDF 0002               1024          MOVEM.L (SP)+,D1
000017F8                          1025          
000017F8                          1026          ;print separator
000017F8                          1027          
000017F8                          1028          ;Then do Dn
000017F8                          1029          
000017F8  3401                    1030          MOVE.W  D1,D2
000017FA  E04A                    1031          LSR.W   #8,D2 ;move reg into first byte
000017FC  E20A                    1032          LSR.B   #1,D2 ;line it up to least sig bit
000017FE  C43C 0007               1033          AND.B   #%00000111,D2 ;force mode to Dn
00001802  1A02                    1034          MOVE.B  D2,D5
00001804  48E7 4000               1035          MOVEM.L D1,-(SP)
00001808  6100 072A               1036          BSR     Get_Effective_Address
0000180C  4CDF 0002               1037          MOVEM.L (SP)+,D1
00001810                          1038          
00001810  43F9 00002284           1039          LEA     clearLine,A1  ;move string for a CR and LF
00001816  103C 000E               1040          MOVE.B  #14,D0        ;set for task to display null terminated 
0000181A                          1041                                ;string without CR, LF
0000181A  4E4F                    1042          TRAP    #15
0000181C                          1043  
0000181C  7000                    1044          MOVEQ.L #0,D0
0000181E  4E75                    1045          RTS
00001820                          1046  
00001820                          1047  addDest
00001820                          1048  
00001820  43F9 000022BC           1049          LEA     addMessage,A1  ;move string for MOVE
00001826  103C 000E               1050          MOVE.B  #14,D0        ;set for task to display null terminated 
0000182A                          1051                                ;string with CR, LF
0000182A  4E4F                    1052          TRAP    #15
0000182C                          1053          
0000182C                          1054          ;Do Dn
0000182C                          1055          
0000182C  3401                    1056          MOVE.W  D1,D2
0000182E  E04A                    1057          LSR.W   #8,D2 ;move reg into first byte
00001830  E20A                    1058          LSR.B   #1,D2 ;line it up to least sig bit
00001832  C43C 0007               1059          AND.B   #%00000111,D2 ;force mode to Dn
00001836  1A02                    1060          MOVE.B  D2,D5
00001838  48E7 4000               1061          MOVEM.L D1,-(SP)
0000183C  6100 06F6               1062          BSR     Get_Effective_Address
00001840  4CDF 0002               1063          MOVEM.L (SP)+,D1
00001844                          1064          
00001844                          1065          
00001844                          1066          ;print separator
00001844                          1067          
00001844                          1068          ;Then do EA
00001844                          1069          
00001844  3401                    1070          MOVE.W  D1,D2 ;check mode
00001846  C43C 003F               1071          AND.B   #%00111111,D2
0000184A  1A02                    1072          MOVE.B  D2,D5
0000184C  48E7 4000               1073          MOVEM.L D1,-(SP)
00001850  6100 06E2               1074          BSR     Get_Effective_Address
00001854  4CDF 0002               1075          MOVEM.L (SP)+,D1
00001858                          1076          
00001858                          1077          
00001858  43F9 00002284           1078          LEA     clearLine,A1  ;move string for a CR and LF
0000185E  103C 000E               1079          MOVE.B  #14,D0        ;set for task to display null terminated 
00001862                          1080                                ;string without CR, LF
00001862  4E4F                    1081          TRAP    #15
00001864                          1082  
00001864  7000                    1083          MOVEQ.L #0,D0
00001866  4E75                    1084          RTS
00001868                          1085  
00001868                          1086  
00001868= 10 20 38 39 00          1087  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
0000186D= 38 38 3F 3F 00          1088  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
00001872                          1089  
00001872= 10 18 38 39 00          1090  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
00001877= 38 38 3F 3F 00          1091  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
0000187C                          1092  
0000187C                          1093  MOVEM:
0000187C                          1094          
0000187C                          1095  
0000187C                          1096          
0000187C  7000                    1097          MOVEQ.L #0, D0 ;clear D0
0000187E                          1098          
0000187E                          1099          ;Figure out which direction we are going
0000187E  3401                    1100          MOVE.W D1,D2 ;copy inst to D2
00001880  E64A                    1101          LSR.W #3,D2 ;shift direction bit into most sig bit of first byte
00001882  0202 0080               1102          ANDI.B #%10000000,D2 ;mask out everything but direction bit in first byte
00001886  0C02 0000               1103          CMPI.B #0,D2 ;compare bit to zero
0000188A  6700 0006               1104          BEQ validRegToMem ;if zero, reg to mem
0000188E  6000 0028               1105          BRA validMemToReg ;else, its mem to reg
00001892                          1106          
00001892                          1107  validRegToMem:
00001892                          1108          
00001892  43F8 186D               1109          LEA movemRegToMemEAmasks,A1 ;load the list of masks
00001896  D3C0                    1110          ADDA.L D0,A1 ;displace to a specific mask
00001898  1A11                    1111          MOVE.B (A1),D5 ;move the mask to D5
0000189A                          1112          
0000189A  0C05 0000               1113          CMPI.B #0,D5 ;check if the mask is 0
0000189E  6700 F7D0               1114          BEQ falsePositive ;branch if it is
000018A2                          1115          
000018A2  1401                    1116          MOVE.B D1,D2 ;copy instruction to D2
000018A4  C405                    1117          AND.B D5,D2  ;mask D2
000018A6                          1118          
000018A6  43F8 1868               1119          LEA movemRegToMemEA,A1 ;load the list of valid modes
000018AA  D3C0                    1120          ADDA.L D0,A1 ;displace to a specific mode
000018AC  1811                    1121          MOVE.B (A1),D4 ;move mode to D4
000018AE  B404                    1122          CMP.B D4,D2 ;compare mode to masked value
000018B0  6700 0034               1123          BEQ  movemBody ;if its match, its a valid mode and we can procede
000018B4                          1124          
000018B4  5280                    1125          ADDQ.L #1,D0 ;add one to displacement
000018B6  60DA                    1126          BRA validRegToMem ;check for next mode
000018B8                          1127          
000018B8                          1128          
000018B8                          1129  validMemToReg:
000018B8                          1130          
000018B8  43F8 1877               1131          LEA movemMemToRegEAmasks,A1 ;load the list of masks
000018BC  D3C0                    1132          ADDA.L D0,A1 ;displace to a specific mask
000018BE  1A11                    1133          MOVE.B (A1),D5 ;move the mask to D5
000018C0                          1134          
000018C0  0C05 0000               1135          CMPI.B #0,D5 ;check if the mask is 0
000018C4  6700 F7AA               1136          BEQ falsePositive ;branch if it is
000018C8                          1137          
000018C8  3401                    1138          MOVE.W D1,D2 ;copy instruction to D2
000018CA  EC4A                    1139          LSR.W #6,D2  ;move mode
000018CC  6100 07DA               1140          BSR switchModeAndReg ;switch register and mode
000018D0  C405                    1141          AND.B D5,D2  ;mask D2
000018D2                          1142          
000018D2  43F8 1872               1143          LEA movemMemToRegEA,A1 ;load the list of valid modes
000018D6  D3C0                    1144          ADDA.L D0,A1 ;displace to a specific mode
000018D8  1811                    1145          MOVE.B (A1),D4 ;move mode to D4
000018DA  B404                    1146          CMP.B D4,D2 ;compare mode to masked value
000018DC  6700 0008               1147          BEQ movemBody ;if its match, its a valid mode and we can procede
000018E0                          1148          
000018E0  5280                    1149          ADDQ.L #1,D0 ;add one to displacement
000018E2  6000 02EC               1150          BRA validMoveDestModes ;check for next mode
000018E6                          1151          
000018E6                          1152  movemBody
000018E6                          1153  
000018E6  43F9 000022C1           1154          LEA     movemMessage,A1  ;move string for MOVE
000018EC  103C 000E               1155          MOVE.B  #14,D0        ;set for task to display null terminated 
000018F0                          1156                                ;string with CR, LF
000018F0  4E4F                    1157          TRAP    #15
000018F2                          1158          
000018F2                          1159          ;show list
000018F2                          1160          
000018F2  5487                    1161          ADDQ.L #word,D7 ;read past the register list mask(word) following
000018F4                          1162                          ;the instruction
000018F4                          1163          
000018F4                          1164          ;print separator
000018F4                          1165          
000018F4  3401                    1166          MOVE.W  D1,D2 ;check mode
000018F6  C43C 003F               1167          AND.B   #%00111111,D2
000018FA  1A02                    1168          MOVE.B  D2,D5
000018FC  48E7 4000               1169          MOVEM.L D1,-(SP)
00001900  6100 0632               1170          BSR     Get_Effective_Address
00001904  4CDF 0002               1171          MOVEM.L (SP)+,D1
00001908                          1172          
00001908                          1173          
00001908  43F9 00002284           1174          LEA     clearLine,A1  ;move string for a CR and LF
0000190E  103C 000E               1175          MOVE.B  #14,D0        ;set for task to display null terminated 
00001912                          1176                                ;string without CR, LF
00001912  4E4F                    1177          TRAP    #15
00001914                          1178  
00001914  7000                    1179          MOVEQ.L #0,D0
00001916  4E75                    1180          RTS
00001918                          1181  
00001918                          1182  
00001918                          1183      
00001918= 00 10 18 20 28 38 ...   1184  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
00001920= 38 38 38 38 38 3F ...   1185  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
00001928                          1186     
00001928                          1187  NEG:            
00001928                          1188       
00001928  7000                    1189          MOVEQ.L #0, D0 ;clear D0
0000192A                          1190          
0000192A                          1191  validNegModes:
0000192A                          1192          
0000192A  43F8 1920               1193          LEA NegEAmasks,A1 ;load the list of masks
0000192E  D3C0                    1194          ADDA.L D0,A1 ;displace to a specific mask
00001930  1A11                    1195          MOVE.B (A1),D5 ;move the mask to D5
00001932                          1196          
00001932  0C05 0000               1197          CMPI.B #0,D5 ;check if the mask is 0
00001936  6700 F738               1198          BEQ falsePositive ;branch if it is
0000193A                          1199          
0000193A  1401                    1200          MOVE.B D1,D2 ;copy instruction to D2
0000193C  C405                    1201          AND.B D5,D2  ;mask D2
0000193E  43F8 1918               1202          LEA NegEA,A1 ;load the list of valid modes
00001942  D3C0                    1203          ADDA.L D0,A1 ;displace to a specific mode
00001944  1811                    1204          MOVE.B (A1),D4 ;move mode to D4
00001946  B404                    1205          CMP.B D4,D2 ;compare mode to masked value
00001948  6700 0006               1206          BEQ NegBody ;if its match, its a valid mode and we can procede
0000194C                          1207          
0000194C  5280                    1208          ADDQ.L #1,D0 ;add one to displacement
0000194E  60DA                    1209          BRA validNegModes ;check for next mode
00001950                          1210          
00001950                          1211  NegBody:
00001950                          1212  
00001950                          1213  
00001950  3401                    1214          MOVE.W  D1,D2 ;copy inst to D2
00001952  C47C 0600               1215          AND.W  #%0011000000000,D2 ;mask word for size
00001956  0C42 0000               1216          CMPI.W #0,D2 ;0 is the only non valid size
0000195A  6700 F714               1217          BEQ falsePositive ; zero is not valid
0000195E                          1218  
0000195E  43F9 000022F0           1219          LEA     negMessage,A1  ;move string for NEG info
00001964  103C 000E               1220          MOVE.B  #14,D0        ;set for task to display null terminated 
00001968                          1221                                ;string without CR, LF
00001968  4E4F                    1222          TRAP    #15
0000196A                          1223          
0000196A  3401                    1224          MOVE.W D1,D2
0000196C  C47C 003F               1225          AND #%000000000111111,D2
00001970  1A02                    1226          MOVE.B D2,D5
00001972                          1227          
00001972  48E7 4000               1228          MOVEM.L D1,-(SP)
00001976  6100 05BC               1229          BSR     Get_Effective_Address
0000197A  4CDF 0002               1230          MOVEM.L (SP)+,D1
0000197E                          1231          
0000197E                          1232                
0000197E                          1233          
0000197E                          1234  NEGdone:
0000197E                          1235  
0000197E  43F9 00002284           1236          LEA     clearLine,A1  ;move string for a CR and LF
00001984  103C 000E               1237          MOVE.B  #14,D0        ;set for task to display null terminated 
00001988                          1238                                ;string without CR, LF
00001988  4E4F                    1239          TRAP    #15
0000198A  7000                    1240          MOVEQ.L #0,D0
0000198C  4E75                    1241          RTS
0000198E                          1242          
0000198E                          1243   ADDI:            
0000198E                          1244       
0000198E  7000                    1245          MOVEQ.L #0, D0 ;clear D0
00001990                          1246          
00001990                          1247  validAddiModes:
00001990                          1248          
00001990                          1249          
00001990  43F9 00001A89           1250          LEA cmpiEAmasks,A1 ;load the list of masks
00001996  D3C0                    1251          ADDA.L D0,A1 ;displace to a specific mask
00001998  1A11                    1252          MOVE.B (A1),D5 ;move the mask to D5
0000199A                          1253          
0000199A  0C05 0000               1254          CMPI.B #0,D5 ;check if the mask is 0
0000199E  6700 F6D0               1255          BEQ falsePositive ;branch if it is
000019A2                          1256          
000019A2  1401                    1257          MOVE.B D1,D2 ;copy instruction to D2
000019A4  C405                    1258          AND.B D5,D2  ;mask D2
000019A6  43F9 00001A82           1259          LEA cmpiEA,A1 ;load the list of valid modes
000019AC  D3C0                    1260          ADDA.L D0,A1 ;displace to a specific mode
000019AE  1811                    1261          MOVE.B (A1),D4 ;move mode to D4
000019B0  B404                    1262          CMP.B D4,D2 ;compare mode to masked value
000019B2  6700 0006               1263          BEQ addiBody ;if its match, its a valid mode and we can procede
000019B6                          1264          
000019B6  5280                    1265          ADDQ.L #1,D0 ;add one to displacement
000019B8  60D6                    1266          BRA validAddiModes ;check for next mode
000019BA                          1267          
000019BA                          1268  addiBody:
000019BA                          1269  
000019BA                          1270  
000019BA  3401                    1271          MOVE.W  D1,D2 ;copy inst to D2
000019BC  C47C 00C0               1272          AND.W  #%0000000011000000,D2 ;mask word for size
000019C0  0C42 00C0               1273          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
000019C4  6700 F6AA               1274          BEQ falsePositive
000019C8                          1275  
000019C8  43F9 000022C8           1276          LEA     addiMessage,A1  ;move string for NEG info
000019CE  103C 000E               1277          MOVE.B  #14,D0        ;set for task to display null terminated 
000019D2                          1278                                ;string without CR, LF
000019D2  4E4F                    1279          TRAP    #15
000019D4                          1280          
000019D4                          1281          ;go to Effective_Address for immediate data
000019D4  143C 003C               1282          MOVE.B #%00111100,D2
000019D8  48E7 4000               1283          MOVEM.L D1,-(SP)
000019DC  6100 0556               1284          BSR     Get_Effective_Address
000019E0  4CDF 0002               1285          MOVEM.L (SP)+,D1
000019E4                          1286          
000019E4  3401                    1287          MOVE.W D1,D2 ;copy inst to D2
000019E6  C47C 003F               1288          AND #%000000000111111,D2 ;and out everything but modes and regs
000019EA  1A02                    1289          MOVE.B D2,D5 ; copy to D5 for following BSR
000019EC                          1290          
000019EC  48E7 4000               1291          MOVEM.L D1,-(SP)
000019F0  6100 0542               1292          BSR     Get_Effective_Address
000019F4  4CDF 0002               1293          MOVEM.L (SP)+,D1
000019F8                          1294          
000019F8                          1295                
000019F8                          1296          
000019F8                          1297  addidone:
000019F8                          1298  
000019F8  43F9 00002284           1299          LEA     clearLine,A1  ;move string for a CR and LF
000019FE  103C 000E               1300          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A02                          1301                                ;string without CR, LF
00001A02  4E4F                    1302          TRAP    #15
00001A04  7000                    1303          MOVEQ.L #0,D0
00001A06  4E75                    1304          RTS
00001A08                          1305    
00001A08                          1306  ORI:            
00001A08                          1307       
00001A08  7000                    1308          MOVEQ.L #0, D0 ;clear D0
00001A0A                          1309          
00001A0A                          1310  validOriModes:
00001A0A                          1311          
00001A0A                          1312          
00001A0A  43F9 00001A89           1313          LEA cmpiEAmasks,A1 ;load the list of masks
00001A10  D3C0                    1314          ADDA.L D0,A1 ;displace to a specific mask
00001A12  1A11                    1315          MOVE.B (A1),D5 ;move the mask to D5
00001A14                          1316          
00001A14  0C05 0000               1317          CMPI.B #0,D5 ;check if the mask is 0
00001A18  6700 F656               1318          BEQ falsePositive ;branch if it is
00001A1C                          1319          
00001A1C  1401                    1320          MOVE.B D1,D2 ;copy instruction to D2
00001A1E  C405                    1321          AND.B D5,D2  ;mask D2
00001A20  43F9 00001A82           1322          LEA cmpiEA,A1 ;load the list of valid modes
00001A26  D3C0                    1323          ADDA.L D0,A1 ;displace to a specific mode
00001A28  1811                    1324          MOVE.B (A1),D4 ;move mode to D4
00001A2A  B404                    1325          CMP.B D4,D2 ;compare mode to masked value
00001A2C  6700 0006               1326          BEQ oriBody ;if its match, its a valid mode and we can procede
00001A30                          1327          
00001A30  5280                    1328          ADDQ.L #1,D0 ;add one to displacement
00001A32  60D6                    1329          BRA validOriModes ;check for next mode
00001A34                          1330          
00001A34                          1331  oriBody:
00001A34                          1332  
00001A34                          1333  
00001A34  3401                    1334          MOVE.W  D1,D2 ;copy inst to D2
00001A36  C47C 00C0               1335          AND.W  #%0000000011000000,D2 ;mask word for size
00001A3A  0C42 00C0               1336          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001A3E  6700 F630               1337          BEQ falsePositive
00001A42                          1338  
00001A42  43F9 000022CE           1339          LEA     oriMessage,A1  ;move string for NEG info
00001A48  103C 000E               1340          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A4C                          1341                                ;string without CR, LF
00001A4C  4E4F                    1342          TRAP    #15
00001A4E                          1343          
00001A4E                          1344          ;go to Effective_Address for immediate data
00001A4E  143C 003C               1345          MOVE.B #%00111100,D2
00001A52  48E7 4000               1346          MOVEM.L D1,-(SP)
00001A56  6100 04DC               1347          BSR     Get_Effective_Address
00001A5A  4CDF 0002               1348          MOVEM.L (SP)+,D1
00001A5E                          1349          
00001A5E  3401                    1350          MOVE.W D1,D2 ;copy inst to D2
00001A60  C47C 003F               1351          AND #%000000000111111,D2 ;and out everything but modes and regs
00001A64  1A02                    1352          MOVE.B D2,D5 ; copy to D5 for following BSR
00001A66                          1353          
00001A66  48E7 4000               1354          MOVEM.L D1,-(SP)
00001A6A  6100 04C8               1355          BSR     Get_Effective_Address
00001A6E  4CDF 0002               1356          MOVEM.L (SP)+,D1
00001A72                          1357          
00001A72                          1358                
00001A72                          1359          
00001A72                          1360  oridone:
00001A72                          1361  
00001A72  43F9 00002284           1362          LEA     clearLine,A1  ;move string for a CR and LF
00001A78  103C 000E               1363          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A7C                          1364                                ;string without CR, LF
00001A7C  4E4F                    1365          TRAP    #15
00001A7E  7000                    1366          MOVEQ.L #0,D0
00001A80  4E75                    1367          RTS
00001A82                          1368  
00001A82                          1369          
00001A82                          1370          
00001A82= 20 18 00 10 38 39 00    1371  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
00001A89= 38 38 38 38 3F 3F 00    1372  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
00001A90                          1373     
00001A90                          1374  CMPI:            
00001A90                          1375       
00001A90  7000                    1376          MOVEQ.L #0, D0 ;clear D0
00001A92                          1377          
00001A92                          1378  validCmpiModes:
00001A92                          1379          
00001A92                          1380          
00001A92  43F8 1A89               1381          LEA cmpiEAmasks,A1 ;load the list of masks
00001A96  D3C0                    1382          ADDA.L D0,A1 ;displace to a specific mask
00001A98  1A11                    1383          MOVE.B (A1),D5 ;move the mask to D5
00001A9A                          1384          
00001A9A  0C05 0000               1385          CMPI.B #0,D5 ;check if the mask is 0
00001A9E  6700 F5D0               1386          BEQ falsePositive ;branch if it is
00001AA2                          1387          
00001AA2  1401                    1388          MOVE.B D1,D2 ;copy instruction to D2
00001AA4  C405                    1389          AND.B D5,D2  ;mask D2
00001AA6  43F8 1A82               1390          LEA cmpiEA,A1 ;load the list of valid modes
00001AAA  D3C0                    1391          ADDA.L D0,A1 ;displace to a specific mode
00001AAC  1811                    1392          MOVE.B (A1),D4 ;move mode to D4
00001AAE  B404                    1393          CMP.B D4,D2 ;compare mode to masked value
00001AB0  6700 0006               1394          BEQ CMPIBody ;if its match, its a valid mode and we can procede
00001AB4                          1395          
00001AB4  5280                    1396          ADDQ.L #1,D0 ;add one to displacement
00001AB6  60DA                    1397          BRA validCmpiModes ;check for next mode
00001AB8                          1398          
00001AB8                          1399  CMPIBody:
00001AB8                          1400  
00001AB8                          1401  
00001AB8  3401                    1402          MOVE.W  D1,D2 ;copy inst to D2
00001ABA  C47C 00C0               1403          AND.W  #%0000000011000000,D2 ;mask word for size
00001ABE  0C42 00C0               1404          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001AC2  6700 F5AC               1405          BEQ falsePositive
00001AC6                          1406  
00001AC6  43F9 000022D3           1407          LEA     cmpiMessage,A1  ;move string for NEG info
00001ACC  103C 000E               1408          MOVE.B  #14,D0        ;set for task to display null terminated 
00001AD0                          1409                                ;string without CR, LF
00001AD0  4E4F                    1410          TRAP    #15
00001AD2                          1411          
00001AD2                          1412          ;go to Effective_Address for immediate data
00001AD2  143C 003C               1413          MOVE.B #%00111100,D2
00001AD6  48E7 4000               1414          MOVEM.L D1,-(SP)
00001ADA  6100 0458               1415          BSR     Get_Effective_Address
00001ADE  4CDF 0002               1416          MOVEM.L (SP)+,D1
00001AE2                          1417          
00001AE2  3401                    1418          MOVE.W D1,D2 ;copy inst to D2
00001AE4  C47C 003F               1419          AND #%000000000111111,D2 ;and out everything but modes and regs
00001AE8  1A02                    1420          MOVE.B D2,D5 ; copy to D5 for following BSR
00001AEA                          1421          
00001AEA  48E7 4000               1422          MOVEM.L D1,-(SP)
00001AEE  6100 0444               1423          BSR     Get_Effective_Address
00001AF2  4CDF 0002               1424          MOVEM.L (SP)+,D1
00001AF6                          1425          
00001AF6                          1426                
00001AF6                          1427          
00001AF6                          1428  CMPidone:
00001AF6                          1429  
00001AF6  43F9 00002284           1430          LEA     clearLine,A1  ;move string for a CR and LF
00001AFC  103C 000E               1431          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B00                          1432                                ;string without CR, LF
00001B00  4E4F                    1433          TRAP    #15
00001B02  7000                    1434          MOVEQ.L #0,D0
00001B04  4E75                    1435          RTS
00001B06                          1436  
00001B06                          1437          
00001B06= 10 38 39 00             1438  JsrEA        DC.B %010000, %111000, %111001,0
00001B0A= 38 3F 3F 00             1439  JsrEAmasks   DC.B %111000, %111111, %111111,0
00001B0E                          1440     
00001B0E                          1441  JSR:            
00001B0E                          1442       
00001B0E  7000                    1443          MOVEQ.L #0, D0 ;clear D0
00001B10                          1444          
00001B10                          1445  validJsrModes:
00001B10                          1446          
00001B10  43F8 1B0A               1447          LEA JsrEAmasks,A1 ;load the list of masks
00001B14  D3C0                    1448          ADDA.L D0,A1 ;displace to a specific mask
00001B16  1A11                    1449          MOVE.B (A1),D5 ;move the mask to D5
00001B18                          1450          
00001B18  0C05 0000               1451          CMPI.B #0,D5 ;check if the mask is 0
00001B1C  6700 F552               1452          BEQ falsePositive ;branch if it is
00001B20                          1453          
00001B20  1401                    1454          MOVE.B D1,D2 ;copy instruction to D2
00001B22  C405                    1455          AND.B D5,D2  ;mask D2
00001B24  43F8 1B06               1456          LEA JsrEA,A1 ;load the list of valid modes
00001B28  D3C0                    1457          ADDA.L D0,A1 ;displace to a specific mode
00001B2A  1811                    1458          MOVE.B (A1),D4 ;move mode to D4
00001B2C  B404                    1459          CMP.B D4,D2 ;compare mode to masked value
00001B2E  6700 0006               1460          BEQ JsrBody ;if its match, its a valid mode and we can procede
00001B32                          1461          
00001B32  5280                    1462          ADDQ.L #1,D0 ;add one to displacement
00001B34  60DA                    1463          BRA validJsrModes ;check for next mode
00001B36                          1464          
00001B36                          1465  JsrBody:
00001B36                          1466  
00001B36                          1467  
00001B36  43F9 000022D9           1468          LEA     jsrMessage,A1  ;move string for NEG info
00001B3C  103C 000E               1469          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B40                          1470                                ;string without CR, LF
00001B40  4E4F                    1471          TRAP    #15
00001B42                          1472          
00001B42  3401                    1473          MOVE.W D1,D2 ;copy inst to D2
00001B44  C47C 003F               1474          AND #%000000000111111,D2 ;and out everything but modes and regs
00001B48  1A02                    1475          MOVE.B D2,D5 ; copy to D5 for following BSR
00001B4A                          1476          
00001B4A  48E7 4000               1477          MOVEM.L D1,-(SP)
00001B4E  6100 03E4               1478          BSR     Get_Effective_Address
00001B52  4CDF 0002               1479          MOVEM.L (SP)+,D1
00001B56                          1480          
00001B56                          1481                
00001B56                          1482          
00001B56                          1483  Jsrdone:
00001B56                          1484  
00001B56  43F9 00002284           1485          LEA     clearLine,A1  ;move string for a CR and LF
00001B5C  103C 000E               1486          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B60                          1487                                ;string without CR, LF
00001B60  4E4F                    1488          TRAP    #15
00001B62  7000                    1489          MOVEQ.L #0,D0
00001B64  4E75                    1490          RTS
00001B66                          1491  
00001B66                          1492  
00001B66                          1493          
00001B66                          1494  NOP:
00001B66                          1495  
00001B66  43F9 000022E3           1496          LEA     nopMessage,A1 ;move string for NOP info
00001B6C  103C 000D               1497          MOVE.B  #13,D0        ;set for task to display null terminated 
00001B70                          1498                                ;string with CR, LF
00001B70  4E4F                    1499          TRAP    #15
00001B72                          1500          
00001B72  7000                    1501          MOVEQ.L #0,D0
00001B74  4E75                    1502          RTS
00001B76                          1503          
00001B76                          1504  RTS:
00001B76                          1505          
00001B76  43F9 000022DE           1506          LEA     rtsMessage,A1  ;move string for rts info
00001B7C  103C 000D               1507          MOVE.B  #13,D0        ;set for task to display null terminated 
00001B80                          1508                                ;string with CR, LF
00001B80  4E4F                    1509          TRAP    #15  
00001B82                          1510     
00001B82  7000                    1511          MOVEQ.L #0,D0
00001B84  4E75                    1512          RTS   
00001B86                          1513  
00001B86= 3C 08 00 10 18 20 ...   1514  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
00001B8F= 3F 38 38 38 38 38 ...   1515  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001B98                          1516  
00001B98= 00 10 18 20 38 39 00    1517  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
00001B9F= 38 38 38 38 3F 3F 00    1518  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
00001BA6                          1519  
00001BA6                          1520  MOVE:
00001BA6                          1521          
00001BA6                          1522  
00001BA6                          1523          
00001BA6  7000                    1524          MOVEQ.L #0, D0 ;clear D0
00001BA8                          1525          
00001BA8                          1526  validMoveSourceModes:
00001BA8                          1527          
00001BA8  43F8 1B8F               1528          LEA moveSourceEAmasks,A1 ;load the list of masks
00001BAC  D3C0                    1529          ADDA.L D0,A1 ;displace to a specific mask
00001BAE  1A11                    1530          MOVE.B (A1),D5 ;move the mask to D5
00001BB0                          1531          
00001BB0  0C05 0000               1532          CMPI.B #0,D5 ;check if the mask is 0
00001BB4  6700 F4BA               1533          BEQ falsePositive ;branch if it is
00001BB8                          1534          
00001BB8  1401                    1535          MOVE.B D1,D2 ;copy instruction to D2
00001BBA  C405                    1536          AND.B D5,D2  ;mask D2
00001BBC                          1537          
00001BBC  43F8 1B86               1538          LEA moveSourceEA,A1 ;load the list of valid modes
00001BC0  D3C0                    1539          ADDA.L D0,A1 ;displace to a specific mode
00001BC2  1811                    1540          MOVE.B (A1),D4 ;move mode to D4
00001BC4  B404                    1541          CMP.B D4,D2 ;compare mode to masked value
00001BC6  6700 0006               1542          BEQ  checkMoveDest ;if its match, its a valid mode and we can procede
00001BCA                          1543          
00001BCA  5280                    1544          ADDQ.L #1,D0 ;add one to displacement
00001BCC  60DA                    1545          BRA validMoveSourceModes ;check for next mode
00001BCE                          1546          
00001BCE                          1547  checkMoveDest:
00001BCE  7000                    1548          MOVEQ.L #0, D0 ;clear D0
00001BD0                          1549          
00001BD0                          1550  validMoveDestModes:
00001BD0                          1551          
00001BD0  43F8 1B9F               1552          LEA moveDestEAmasks,A1 ;load the list of masks
00001BD4  D3C0                    1553          ADDA.L D0,A1 ;displace to a specific mask
00001BD6  1A11                    1554          MOVE.B (A1),D5 ;move the mask to D5
00001BD8                          1555          
00001BD8  0C05 0000               1556          CMPI.B #0,D5 ;check if the mask is 0
00001BDC  6700 F492               1557          BEQ falsePositive ;branch if it is
00001BE0                          1558          
00001BE0  3401                    1559          MOVE.W D1,D2 ;copy instruction to D2
00001BE2  EC4A                    1560          LSR.W #6,D2  ;move mode
00001BE4  6100 04C2               1561          BSR switchModeAndReg ;switch register and mode
00001BE8  C405                    1562          AND.B D5,D2  ;mask D2
00001BEA                          1563          
00001BEA  43F8 1B98               1564          LEA moveDestEA,A1 ;load the list of valid modes
00001BEE  D3C0                    1565          ADDA.L D0,A1 ;displace to a specific mode
00001BF0  1811                    1566          MOVE.B (A1),D4 ;move mode to D4
00001BF2  B404                    1567          CMP.B D4,D2 ;compare mode to masked value
00001BF4  6700 0006               1568          BEQ moveBody ;if its match, its a valid mode and we can procede
00001BF8                          1569          
00001BF8  5280                    1570          ADDQ.L #1,D0 ;add one to displacement
00001BFA  60D4                    1571          BRA validMoveDestModes ;check for next mode
00001BFC                          1572          
00001BFC                          1573  moveBody
00001BFC  3401                    1574          MOVE.W  D1,D2 ;copy inst to D2
00001BFE  C47C 3000               1575          AND.W  #%0011000000000000,D2 ;mask word for size
00001C02  0C42 0000               1576          CMPI.W #0,D2 ;0 is the only non valid size
00001C06  6700 F468               1577          BEQ falsePositive ; if zero, this is not move
00001C0A                          1578  
00001C0A  43F9 000022E8           1579          LEA     moveMessage,A1  ;move string for MOVE
00001C10  103C 000E               1580          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C14                          1581                                ;string with CR, LF
00001C14  4E4F                    1582          TRAP    #15
00001C16                          1583          
00001C16                          1584          
00001C16  3401                    1585          MOVE.W  D1,D2 ;check source mode
00001C18  C43C 003F               1586          AND.B   #%00111111,D2
00001C1C  1A02                    1587          MOVE.B  D2,D5
00001C1E  48E7 4000               1588          MOVEM.L D1,-(SP)
00001C22  6100 0310               1589          BSR     Get_Effective_Address
00001C26  4CDF 0002               1590          MOVEM.L (SP)+,D1
00001C2A                          1591          
00001C2A                          1592          ;print separator
00001C2A                          1593          
00001C2A  3401                    1594          MOVE.W  D1,D2 ;check dest mode
00001C2C  EC4A                    1595          LSR.W   #6,D2
00001C2E  6100 0478               1596          BSR  switchModeAndReg
00001C32  C43C 003F               1597          AND.B   #%00111111,D2
00001C36  1A02                    1598          MOVE.B  D2,D5
00001C38  48E7 4000               1599          MOVEM.L D1,-(SP)
00001C3C  6100 02F6               1600          BSR     Get_Effective_Address
00001C40  4CDF 0002               1601          MOVEM.L (SP)+,D1
00001C44                          1602          
00001C44                          1603          
00001C44                          1604          
00001C44  43F9 00002284           1605          LEA     clearLine,A1  ;move string for a CR and LF
00001C4A  103C 000E               1606          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C4E                          1607                                ;string without CR, LF
00001C4E  4E4F                    1608          TRAP    #15
00001C50                          1609  
00001C50  7000                    1610          MOVEQ.L #0,D0
00001C52  4E75                    1611          RTS
00001C54                          1612          
00001C54= 08 00                   1613  moveADestEA        DC.B %001000,0
00001C56= 38 00                   1614  moveADestEAmasks   DC.B %111000,0
00001C58                          1615          
00001C58                          1616  MOVEA:
00001C58                          1617  
00001C58  7000                    1618          MOVEQ.L #0, D0 ;clear D0
00001C5A                          1619          
00001C5A                          1620  validMoveASourceModes:
00001C5A                          1621          
00001C5A  43F8 1B8F               1622          LEA moveSourceEAmasks,A1 ;load the list of masks
00001C5E  D3C0                    1623          ADDA.L D0,A1 ;displace to a specific mask
00001C60  1A11                    1624          MOVE.B (A1),D5 ;move the mask to D5
00001C62                          1625          
00001C62  0C05 0000               1626          CMPI.B #0,D5 ;check if the mask is 0
00001C66  6700 F408               1627          BEQ falsePositive ;branch if it is
00001C6A                          1628          
00001C6A  1401                    1629          MOVE.B D1,D2 ;copy instruction to D2
00001C6C  C405                    1630          AND.B D5,D2  ;mask D2
00001C6E                          1631          
00001C6E  43F8 1B86               1632          LEA moveSourceEA,A1 ;load the list of valid modes
00001C72  D3C0                    1633          ADDA.L D0,A1 ;displace to a specific mode
00001C74  1811                    1634          MOVE.B (A1),D4 ;move mode to D4
00001C76  B404                    1635          CMP.B D4,D2 ;compare mode to masked value
00001C78  6700 0006               1636          BEQ  checkMoveADest ;if its match, its a valid mode and we can procede
00001C7C                          1637          
00001C7C  5280                    1638          ADDQ.L #1,D0 ;add one to displacement
00001C7E  60DA                    1639          BRA validMoveASourceModes ;check for next mode
00001C80                          1640          
00001C80                          1641  checkMoveADest:
00001C80  7000                    1642          MOVEQ.L #0, D0 ;clear D0
00001C82                          1643  validMoveADestModes:
00001C82                          1644          
00001C82  43F8 1C56               1645          LEA moveADestEAmasks,A1 ;load the list of masks
00001C86  D3C0                    1646          ADDA.L D0,A1 ;displace to a specific mask
00001C88  1A11                    1647          MOVE.B (A1),D5 ;move the mask to D5
00001C8A                          1648          
00001C8A  0C05 0000               1649          CMPI.B #0,D5 ;check if the mask is 0
00001C8E  6700 F3E0               1650          BEQ falsePositive ;branch if it is
00001C92                          1651          
00001C92  3401                    1652          MOVE.W D1,D2 ;copy instruction to D2
00001C94  EA4A                    1653          LSR.W #5,D2  ;move mode
00001C96  6100 0410               1654          BSR switchModeAndReg ;switch register and mode
00001C9A  C405                    1655          AND.B D5,D2  ;mask D2
00001C9C                          1656          
00001C9C  43F8 1C54               1657          LEA moveADestEA,A1 ;load the list of valid modes
00001CA0  D3C0                    1658          ADDA.L D0,A1 ;displace to a specific mode
00001CA2  1811                    1659          MOVE.B (A1),D4 ;move mode to D4
00001CA4  B404                    1660          CMP.B D4,D2 ;compare mode to masked value
00001CA6  6700 0006               1661          BEQ moveABody ;if its match, its a valid mode and we can procede
00001CAA                          1662          
00001CAA  5280                    1663          ADDQ.L #1,D0 ;add one to displacement
00001CAC  60D4                    1664          BRA validMoveADestModes ;check for next mode
00001CAE                          1665  moveABody:
00001CAE  3401                    1666          MOVE.W  D1,D2 ;copy inst to D2
00001CB0  C47C 3000               1667          AND.W  #%0011000000000000,D2 ;mask word for size
00001CB4  0C42 0000               1668          CMPI.W #0,D2 ;0 is the non valid size
00001CB8  6700 F3B6               1669          BEQ falsePositive ; if zero, this is not move
00001CBC  0C42 1000               1670          CMPI.W #%0001000000000000,D2
00001CC0  6700 F3AE               1671          BEQ falsePositive ; if byte, this is not movea
00001CC4                          1672  
00001CC4                          1673  
00001CC4  43F9 000022FB           1674          LEA     moveAMessage,A1  ;move string for MOVE
00001CCA  103C 000D               1675          MOVE.B  #13,D0        ;set for task to display null terminated 
00001CCE                          1676                                ;string with CR, LF
00001CCE  4E4F                    1677          TRAP    #15
00001CD0                          1678  
00001CD0  7000                    1679          MOVEQ.L #0,D0
00001CD2  4E75                    1680          RTS
00001CD4                          1681  
00001CD4                          1682             
00001CD4                          1683  Bcc:
00001CD4                          1684  
00001CD4  43F9 000022EE           1685          LEA     bccMessage,A1  ;move string for BRA info
00001CDA  103C 000E               1686          MOVE.B  #14,D0        ;set for task to display null terminated 
00001CDE                          1687                                ;string without CR, LF
00001CDE  4E4F                    1688          TRAP    #15
00001CE0                          1689          
00001CE0  7000                    1690          MOVEQ.L #0,D0 ;clear D0
00001CE2  3401                    1691          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001CE4  E04A                    1692          LSR.W   #8,D2
00001CE6  C47C 000F               1693          AND.W   #$0F,D2 ;mask instruction
00001CEA                          1694          
00001CEA                          1695  checkCC:        
00001CEA  41F9 0000220B           1696          LEA     bccList,A0 ;get condition code signature list in A0
00001CF0  D1C0                    1697          ADDA.L  D0,A0 ;get correct sig         
00001CF2  B410                    1698          CMP.B   (A0),D2 ;compare to sig
00001CF4  6700 0006               1699          BEQ     foundCC ;if sig matches branch
00001CF8  5200                    1700          ADDQ.B  #byte,D0
00001CFA  60EE                    1701          BRA     checkCC
00001CFC                          1702  foundCC:
00001CFC  43F9 0000221C           1703          LEA     conditionCodeMessage,A1 ;get condition code message in A1
00001D02  C0FC 0004               1704          MULU.W  #long,D0 ;adjust size of D0 for a long
00001D06  D3C0                    1705          ADDA.L  D0,A1 ;get correct message location
00001D08  2251                    1706          MOVEA.L (A1),A1 ;get correct message
00001D0A                          1707          
00001D0A  103C 000E               1708          MOVE.B  #14,D0        ;set for task to display null terminated 
00001D0E                          1709                                ;string without CR, LF
00001D0E  4E4F                    1710          TRAP    #15
00001D10                          1711  
00001D10                          1712          
00001D10                          1713          
00001D10  548B                    1714          ADDQ.L  #word,A3 ;move past instruction in case long displacement
00001D12  C27C 00FF               1715          AND.W   #$00FF,D1   ;check for word sized displacement
00001D16                          1716          
00001D16  B23C 0000               1717          CMP.B   #$0,D1
00001D1A  6700 0010               1718          BEQ     BccWord
00001D1E                          1719          
00001D1E  B23C 00FF               1720          CMP.B   #$FF,D1 check for long sized displacement
00001D22  6700 0010               1721          BEQ     BccLong
00001D26                          1722          
00001D26                          1723  BccByte:
00001D26                          1724          
00001D26  7E00                    1725          MOVEQ.L #0,D7 ;pass back no extra data followed
00001D28  6000 0012               1726          BRA     BccDone
00001D2C                          1727  BccWord:
00001D2C  3213                    1728          MOVE.W  (A3),D1
00001D2E                          1729          
00001D2E  7E02                    1730          MOVEQ.L #word,D7 ;pass back an extra word followed
00001D30  6000 000A               1731          BRA     BccDone
00001D34                          1732  BccLong:
00001D34  2213                    1733          MOVE.L  (A3),D1
00001D36                          1734          
00001D36  7E04                    1735          MOVEQ.L #long,D7 ;pass back an extra long followed
00001D38  6000 0002               1736          BRA     BccDone
00001D3C                          1737  BccDone:
00001D3C                          1738  
00001D3C  343C 0010               1739          MOVE.W  #16,D2 ;put base in D2
00001D40  303C 000F               1740          MOVE.W  #15,D0  ;put task #15 in D0
00001D44  4E4F                    1741          TRAP    #15
00001D46                          1742          
00001D46  43F9 00002284           1743          LEA     clearLine,A1  ;move string for a CR and LF
00001D4C  103C 000E               1744          MOVE.B  #14,D0        ;set for task to display null terminated 
00001D50                          1745                                ;string without CR, LF
00001D50  4E4F                    1746          TRAP    #15
00001D52                          1747  
00001D52  7000                    1748          MOVEQ.L #0,D0
00001D54  4E75                    1749          RTS
00001D56                          1750          
00001D56                          1751          
00001D56                          1752  unknownOpCode:
00001D56  43F9 000022F5           1753          LEA     dataMessage,A1 ;move string for data info
00001D5C  103C 000E               1754          MOVE.B  #14,D0        ;set for task to display null terminated 
00001D60                          1755                                ;string without CR, LF
00001D60  4E4F                    1756          TRAP    #15
00001D62                          1757          
00001D62  143C 0010               1758          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001D66  103C 000F               1759          MOVE.B  #15,D0
00001D6A  4E4F                    1760          TRAP    #15
00001D6C                          1761          
00001D6C  43F9 00002284           1762          LEA     clearLine,A1  ;move string for a CR and LF
00001D72  103C 000E               1763          MOVE.B  #14,D0        ;set for task to display null terminated 
00001D76                          1764                                ;string without CR, LF
00001D76  4E4F                    1765          TRAP    #15
00001D78                          1766          
00001D78  7000                    1767          MOVEQ.L #0,D0
00001D7A  4E75                    1768          RTS
00001D7C                          1769          
00001D7C                          1770  handlebytedata:
00001D7C                          1771  
00001D7C  43F9 000022F5           1772          LEA     dataMessage,A1 ;move string for data info
00001D82  103C 000E               1773          MOVE.B  #14,D0        ;set for task to display null terminated 
00001D86                          1774                                ;string without CR, LF
00001D86  4E4F                    1775          TRAP    #15
00001D88                          1776          
00001D88  E049                    1777          LSR.W   #8,D1 ;shift the word read into D1 by a byte
00001D8A                          1778          
00001D8A  143C 0010               1779          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001D8E  103C 000F               1780          MOVE.B  #15,D0
00001D92  4E4F                    1781          TRAP    #15
00001D94                          1782          
00001D94  43F9 00002284           1783          LEA     clearLine,A1  ;move string for a CR and LF
00001D9A  103C 000E               1784          MOVE.B  #14,D0        ;set for task to display null terminated 
00001D9E                          1785                                ;string without CR, LF
00001D9E  4E4F                    1786          TRAP    #15
00001DA0                          1787          
00001DA0  7000                    1788          MOVEQ.L #0,D0
00001DA2                          1789          
00001DA2  528B                    1790          ADDQ.L  #byte,A3
00001DA4  6000 F280               1791          BRA main_Loop
00001DA8                          1792  
00001DA8                          1793          
00001DA8                          1794          
00001DA8                          1795  fin
00001DA8                          1796  
00001DA8                          1797          
00001DA8                          1798          
00001DA8  FFFF FFFF               1799          simhalt
00001DAC                          1800          
00001DAC                          1801  
00001DAC                          1802  *******************************************************************************
00001DAC                          1803  *                            SUB ROUTINES
00001DAC                          1804  *******************************************************************************
00001DAC                          1805  
00001DAC                          1806  *******************************************************************************
00001DAC                          1807  *                          IO ROLE ROUTINES
00001DAC                          1808  *******************************************************************************
00001DAC                          1809  
00001DAC                          1810  *==========================================================================
00001DAC                          1811  *                   Enter / Validate beginning address 
00001DAC                          1812  *==========================================================================
00001DAC                          1813   
00001DAC                          1814  begin_address:
00001DAC                          1815  
00001DAC                          1816         
00001DAC  43F9 000020BC           1817          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00001DB2  2239 000020BC           1818          MOVE.L      slPrompt,D1         ;Load display length to D1
00001DB8  700E                    1819          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001DBA  4E4F                    1820          TRAP        #15                 ;Perform task 14 (display)
00001DBC                          1821          
00001DBC  43F9 0000232C           1822          LEA         startLocation,A1    ;Load address to store user input
00001DC2  103C 0002               1823          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001DC6  4E4F                    1824          TRAP        #15                 ;Perform task 2 (input)
00001DC8                          1825          
00001DC8  0C11 001B               1826          CMP.B       #27,(A1)            ;Check for ESC entered
00001DCC  6700 004C               1827          BEQ         address_Exit        ;Exit condition 
00001DD0                          1828          
00001DD0  6100 0050               1829          BSR         enter_addr_edit_all
00001DD4  B67C FFFF               1830          CMP.W       #-1,D3              ;Did the edit pass?
00001DD8  67D2                    1831          BEQ         begin_address       ;No, loop and ask for correct input
00001DDA                          1832          
00001DDA  2643                    1833          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
00001DDC                          1834          
00001DDC  43F9 000021C9           1835          LEA         spc,A1              ;Load address for starting loaction prompt
00001DE2  1239 000021CA           1836          MOVE.B      spc_len,D1          ;Load empty line length
00001DE8  7000                    1837          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
00001DEA  4E4F                    1838          TRAP        #15                 ;Perform task 14 (display)
00001DEC  6000 0002               1839          BRA         end_address
00001DF0                          1840  
00001DF0                          1841  *===========================================================================
00001DF0                          1842  *                   Enter / Validate ending address 
00001DF0                          1843  *===========================================================================
00001DF0                          1844  
00001DF0                          1845  end_address:
00001DF0                          1846          
00001DF0  43F9 000020ED           1847          LEA         elPrompt,A1         ;Load address for ending loaction prompt
00001DF6                          1848          ;MOVE.L     elPrompt,D1         ;Load display length to D1
00001DF6  7250                    1849          MOVE.L      #80,D1       ;did not like previous command, do not know why, it should have worked
00001DF8  700E                    1850          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001DFA  4E4F                    1851          TRAP        #15                 ;Perform task 14 (display)
00001DFC                          1852          
00001DFC  103C 0002               1853          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001E00  4E4F                    1854          TRAP        #15                 ;Perform task 2 (input)
00001E02                          1855          
00001E02  0C11 001B               1856          CMP.B       #27,(A1)            ;Check for ESC entered
00001E06  6700 0012               1857          BEQ         address_Exit        ;Exit condition 
00001E0A                          1858          
00001E0A  6100 0016               1859          BSR         enter_addr_edit_all
00001E0E  B67C FFFF               1860          CMP.W       #-1,D3              ;Did the edit pass?
00001E12  67DC                    1861          BEQ         end_address         ;No, loop and ask for correct input
00001E14                          1862  
00001E14  2843                    1863          MOVEA.L     D3,A4               ;Ending address gets stored in A4
00001E16  6000 0008               1864          BRA         address_done
00001E1A                          1865  
00001E1A                          1866  address_Exit:
00001E1A                          1867  
00001E1A  76FF                    1868          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001E1C  6000 0002               1869          BRA         address_done
00001E20                          1870          
00001E20                          1871  address_done:
00001E20                          1872  
00001E20  4E75                    1873          RTS    
00001E22                          1874  
00001E22                          1875  *==============================================================================
00001E22                          1876  * enter_addr_edit_all - Enter address edit check to edit all errors  
00001E22                          1877  *                       using multiple different error checking routines.
00001E22                          1878  *
00001E22                          1879  * Parameters -
00001E22                          1880  *   Input   A1      The data that needs checked.
00001E22                          1881  *   Input   D1      The number of characters input     
00001E22                          1882  *   Output  D3      Returns '-1' when there is an error.
00001E22                          1883  *==============================================================================
00001E22                          1884  
00001E22                          1885  enter_addr_edit_all
00001E22                          1886  
00001E22                          1887  *------------------------------------------------------------------------------
00001E22                          1888  * Test for odd number of characters entered, not allowed
00001E22                          1889  *------------------------------------------------------------------------------
00001E22                          1890         
00001E22  6100 0024               1891          BSR         ck_boundry          ;check if the input is on a odd / even boundry
00001E26  B67C FFFF               1892          CMP.W       #-1,D3              ;Is the address odd?
00001E2A  6700 001A               1893          BEQ         enter_addr_edit_all_exit     ;No, return
00001E2E                          1894  
00001E2E                          1895  *------------------------------------------------------------------------------
00001E2E                          1896  * Ttest for character entered all being valid address characters
00001E2E                          1897  * Note: lower case a-f, gets converted to upper case A-F in D3
00001E2E                          1898  *------------------------------------------------------------------------------
00001E2E                          1899          
00001E2E  6100 0062               1900          BSR         parseHexString      ;check if the input contains valid Hex characters
00001E32  B67C FFFF               1901          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
00001E36  6700 000E               1902          BEQ         enter_addr_edit_all_exit     ;No, return
00001E3A                          1903  
00001E3A                          1904  *------------------------------------------------------------------------------
00001E3A                          1905  * Verify that the address entered is witin the range defined in the Equate
00001E3A                          1906  *------------------------------------------------------------------------------        
00001E3A                          1907          
00001E3A  6100 00C8               1908          BSR         ck_addr_range       ;is address entered witin the range 
00001E3E                          1909                                          ;   as defined in the Equate? 
00001E3E  B67C FFFF               1910          CMP.W       #-1,D3              ;is the address  valid?
00001E42  6700 0002               1911          BEQ         enter_addr_edit_all_exit     ;No, return
00001E46                          1912  
00001E46                          1913  enter_addr_edit_all_exit:
00001E46                          1914  
00001E46  4E75                    1915          RTS                             ;return
00001E48                          1916  
00001E48                          1917  *==============================================================================
00001E48                          1918  * ck_boundry - Check the size of the data characters input and determine
00001E48                          1919  *              if an odd number of characters was entered
00001E48                          1920  *
00001E48                          1921  * Parameters -
00001E48                          1922  *   Input   A1      The data that needs checked for odd length.
00001E48                          1923  *   Input   D1      The number of characters input     
00001E48                          1924  *   Output  D3      Returns '-1' when there is an odd length.
00001E48                          1925  *==============================================================================
00001E48                          1926  
00001E48                          1927  ck_boundry:
00001E48                          1928  
00001E48  4243                    1929          CLR.W       D3                  ;Clear the return
00001E4A                          1930  
00001E4A  B23C 0000               1931          CMP.B       #0,D1               ;Check for nothing entered
00001E4E  6700 002E               1932          BEQ         ck_size_error       ;Number of characters entered must be 
00001E52                          1933                                          ;greater than 0  
00001E52                          1934          
00001E52                          1935          
00001E52                          1936          * The program will branch to ck_size_error if D1 is greater than #8        
00001E52  B23C 0008               1937          CMP.B       #8,D1               ;Check for more than 8 characters entered
00001E56  6E00 0026               1938          BGT         ck_size_error       ;Number of characters entered must be less
00001E5A                          1939                                          ;than 9
00001E5A                          1940          
00001E5A  7402                    1941          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
00001E5C  82C2                    1942          DIVU        D2,D1               ;Divide address by 2
00001E5E  4841                    1943          SWAP        D1                  ;get remainder
00001E60  B23C 0001               1944          CMP.B       #$01,D1             ;Check for remainder of 1
00001E64  6700 0004               1945          BEQ         ck_boundry_error    ;Number of characters entered must be an 
00001E68                          1946                                          ;even number   
00001E68                          1947    
00001E68  4E75                    1948          RTS                             ;return
00001E6A                          1949  
00001E6A                          1950  *------------------------------------------------------------------------------
00001E6A                          1951  * ck_boundry_error - An odd number of characters was entered
00001E6A                          1952  *                  - Load error message and display it
00001E6A                          1953  *                  - Return error condition
00001E6A                          1954  *------------------------------------------------------------------------------
00001E6A                          1955          
00001E6A                          1956  ck_boundry_error:
00001E6A                          1957  
00001E6A  43F9 000021A9           1958          LEA         even_msg,A1         ;Load odd error message into A1
00001E70  2239 000021A9           1959          MOVE.L      even_msg,D1         ;Load error length to D1
00001E76                          1960          
00001E76  7000                    1961          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001E78                          1962                                          ; n is D1.W with CR, LF. 
00001E78  4E4F                    1963          TRAP #15                        ;Display the error message
00001E7A  76FF                    1964          MOVE.L #-1,D3                   ;Load -1 into return parameter
00001E7C  4E75                    1965          RTS                             ;Return
00001E7E                          1966          
00001E7E                          1967  *------------------------------------------------------------------------------
00001E7E                          1968  * ck_size_error -   The number of characters entered must be more than zero
00001E7E                          1969  *                  - Load error message and display it
00001E7E                          1970  *                  - Return error condition
00001E7E                          1971  *------------------------------------------------------------------------------
00001E7E                          1972          
00001E7E                          1973  ck_size_error:
00001E7E                          1974  
00001E7E  43F9 0000211C           1975          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001E84  2239 0000211C           1976          MOVE.L      invalidMsg,D1       ;Load error length to D1
00001E8A                          1977          
00001E8A  7000                    1978          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001E8C                          1979                                          ; n is D1.W with CR, LF. 
00001E8C  4E4F                    1980          TRAP        #15                 ;Display the error message
00001E8E  76FF                    1981          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001E90  4E75                    1982          RTS                             ;Return        
00001E92                          1983  
00001E92                          1984  
00001E92                          1985  *==============================================================================
00001E92                          1986  * parseHexString - Converts user input string into a valid memory address
00001E92                          1987  *                - Stores parsed address data into D3
00001E92                          1988  *                - Stores good/bad (1/0) data in D4 
00001E92                          1989  *
00001E92                          1990  * Hex values are stored as bytes in D2, the ASCII chart shows their value
00001E92                          1991  *   The ASCII chart values we care about are in the ranges of: 
00001E92                          1992  *                            Hex            Decimal
00001E92                          1993  *       No Value           NULL = 0         0
00001E92                          1994  *       Numeric Values:     0-9 = 30-39     48-57
00001E92                          1995  *       Upper Case letters: A-F = 41-46     65-70
00001E92                          1996  *       Lower Case letterc: a-f = 61-66     97-102
00001E92                          1997  
00001E92                          1998  * Parameters -
00001E92                          1999  *   Input   A1      The data that needs checked for valid input.
00001E92                          2000  *   Output  D3      The return value, '-1' for error
00001E92                          2001  *==============================================================================
00001E92                          2002  
00001E92                          2003  parseHexString:
00001E92                          2004  
00001E92                          2005  * setup any initializing item that do not get looped through
00001E92  4243                    2006          CLR.W       D3                  ;Clear the return
00001E94                          2007  
00001E94                          2008          
00001E94                          2009  *------------------------------------------------------------------------------
00001E94                          2010  * NextHex - Loop through all bytes and vaildate the input
00001E94                          2011  * Parameters -
00001E94                          2012  *   Input   A1      The data that needs checked for valid input.
00001E94                          2013  *   Output  D3      The return value, '-1' for error
00001E94                          2014  *------------------------------------------------------------------------------
00001E94                          2015          
00001E94                          2016  NextHex:
00001E94                          2017  
00001E94  1419                    2018          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00001E96  B43C 0000               2019          CMP.B       #0,D2               ;Check character for null 
00001E9A  6700 0066               2020          BEQ         NextHexReturn       ;Character is null (end of input)
00001E9E                          2021          
00001E9E                          2022  *................................................................................
00001E9E                          2023  *  Check decimal values 0-9 by testing hexadecimal values 30-39
00001E9E                          2024  *................................................................................
00001E9E                          2025                  
00001E9E                          2026          * The program will branch to hex_range_error if D2 is less than #30
00001E9E  B43C 0030               2027          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
00001EA2  6D00 0048               2028          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001EA6                          2029                                          ;processing
00001EA6                          2030          
00001EA6                          2031          * The program will branch to UcaseHex if D2 is greater than #39
00001EA6  B43C 0039               2032          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
00001EAA  6E00 000A               2033          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
00001EAE                          2034          
00001EAE                          2035          *a valid number was found within this range
00001EAE  0402 0030               2036          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
00001EB2  6000 0032               2037          BRA         NextHexDone         ;Done parsing this byte
00001EB6                          2038  
00001EB6                          2039  
00001EB6                          2040  *..............................................................................
00001EB6                          2041  *  Check upper case values A-F by testing hexadecimal values 41-46
00001EB6                          2042  *..............................................................................
00001EB6                          2043  
00001EB6                          2044  UcaseHex:
00001EB6                          2045  
00001EB6                          2046          * The program will branch to hex_range_error if D2 is less than #41
00001EB6  B43C 0041               2047          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
00001EBA  6D00 0030               2048          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001EBE                          2049                                          ;processing
00001EBE                          2050          
00001EBE  B43C 0046               2051          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
00001EC2  6E00 000A               2052          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
00001EC6                          2053                                          ;processing
00001EC6                          2054          
00001EC6                          2055          *a valid number was found within this range
00001EC6  0402 0037               2056          SUBI.B      #55,D2              ;Change uppercase character to actual value
00001ECA  6000 001A               2057          BRA         NextHexDone         ;Done parsing this byte
00001ECE                          2058  
00001ECE                          2059  
00001ECE                          2060  *..............................................................................
00001ECE                          2061  *  Check lower case values a-f by testing hexadecimal values 61-66
00001ECE                          2062  *..............................................................................
00001ECE                          2063  
00001ECE                          2064  LcaseHex
00001ECE                          2065          
00001ECE                          2066          * The program will branch to hex_range_error if D2 is less than #61
00001ECE  B43C 0061               2067          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
00001ED2  6D00 0018               2068          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
00001ED6                          2069                                          ;processing
00001ED6                          2070  
00001ED6  B43C 0066               2071          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
00001EDA  6E00 0010               2072          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
00001EDE                          2073                                          ;processing
00001EDE                          2074  
00001EDE                          2075          *a valid number was found within this range
00001EDE  0402 0057               2076          SUBI.B      #87,D2              ;Change lowercase character to actual value
00001EE2  6000 0002               2077          BRA         NextHexDone         ;Done parsing this byte
00001EE6                          2078  
00001EE6                          2079  NextHexDone:
00001EE6                          2080  
00001EE6  E983                    2081          ASL.L       #4,D3               ; Make rooom for new byte in the return register
00001EE8  D602                    2082          ADD.B       D2,D3               ; Move the new byte into the return register
00001EEA  60A8                    2083          BRA         NextHex             ; We're ready to parse the next byte
00001EEC                          2084          
00001EEC                          2085  *-------------------------------------------------------------------------------------
00001EEC                          2086  * hex_range_error -  A character entered was within the valid range for a hex address
00001EEC                          2087  *                 -  Load error message and display it
00001EEC                          2088  *                 -  Return error condition
00001EEC                          2089  *-------------------------------------------------------------------------------------
00001EEC                          2090          
00001EEC                          2091  hex_range_error:
00001EEC                          2092  
00001EEC  43F9 00002161           2093          LEA         invCharMsg,A1       ;Load invalid range message into A1
00001EF2  2239 00002161           2094          MOVE.L      invCharMsg,D1       ;Load error length to D1
00001EF8                          2095          
00001EF8  7000                    2096          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001EFA                          2097                                          ; n is D1.W with CR, LF. 
00001EFA  4E4F                    2098          TRAP        #15                 ;Display the error message
00001EFC  76FF                    2099          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001EFE  6000 0002               2100          BRA         NextHexReturn
00001F02                          2101          
00001F02                          2102  NextHexReturn:
00001F02                          2103          
00001F02  4E75                    2104          RTS                             ;Return      
00001F04                          2105  
00001F04                          2106  
00001F04                          2107  *===============================================================================
00001F04                          2108  * ck_addr_range - check the address input is within a valid memory address range
00001F04                          2109  *                - Parsed address data into D3
00001F04                          2110  *
00001F04                          2111  * Parameters -
00001F04                          2112  *   Input   A1      The data that needs checked for valid address.
00001F04                          2113  *   Output  D3      The return value, '-1' for error
00001F04                          2114  *===============================================================================
00001F04                          2115  
00001F04                          2116  
00001F04                          2117  ck_addr_range:   
00001F04                          2118  
00001F04                          2119  *------------------------------------------------------------------------------
00001F04                          2120  * Verify that the address entered is witin the 
00001F04                          2121  * beginning range ('begin') as defined in the Equate
00001F04                          2122  *------------------------------------------------------------------------------   
00001F04                          2123              
00001F04  2C3C 00005001           2124          MOVE.L      #begin,D6           * Load minimum starting address
00001F0A  B686                    2125          CMP.L       D6,D3               * Is input at or above minimum?
00001F0C  6D00 0012               2126          BLT         ck_addr_range_error 
00001F10                          2127          
00001F10                          2128  *------------------------------------------------------------------------------
00001F10                          2129  * Verify that the address entered is witin the 
00001F10                          2130  * ending range ('end') as defined in the Equate
00001F10                          2131  *------------------------------------------------------------------------------
00001F10                          2132          
00001F10  2C3C 00FFFFFE           2133          MOVE.L      #end,D6             * Load maximum starting address
00001F16  B686                    2134          CMP.L       D6,D3               * Is input at or below maximum?
00001F18  6E00 0006               2135          BGT         ck_addr_range_error 
00001F1C  6000 0012               2136          BRA         ck_addr_done        ;done checking
00001F20                          2137          
00001F20                          2138  *..............................................................................
00001F20                          2139  * ck_addr_range_error -  A address entered is not within the 
00001F20                          2140  *                        valid range for a hex address
00001F20                          2141  *..............................................................................
00001F20                          2142          
00001F20                          2143  ck_addr_range_error
00001F20                          2144  
00001F20  43F9 0000211C           2145          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001F26                          2146          
00001F26  700D                    2147          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
00001F28                          2148                                          ;with CR, LF. 
00001F28  4E4F                    2149          TRAP        #15                 ;Display the error message
00001F2A  76FF                    2150          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001F2C  6000 0002               2151          BRA         ck_addr_done 
00001F30                          2152  
00001F30                          2153  ck_addr_done:
00001F30                          2154  
00001F30  4E75                    2155          RTS                             ;Return
00001F32                          2156  
00001F32                          2157  *******************************************************************************
00001F32                          2158  *                          OP CODE ROLE ROUTINES
00001F32                          2159  *******************************************************************************
00001F32                          2160  
00001F32                          2161  process_op_codes:
00001F32                          2162  
00001F32                          2163  
00001F32                          2164  
00001F32                          2165  process_op_codes_exit:
00001F32                          2166  
00001F32  4E75                    2167          RTS
00001F34                          2168  
00001F34                          2169  
00001F34                          2170  *******************************************************************************
00001F34                          2171  *                    Effective Addressing ROLE ROUTINES
00001F34                          2172  *******************************************************************************
00001F34                          2173  
00001F34                          2174  Get_Effective_Address:
00001F34                          2175  
00001F34  1C05                    2176          MOVE.B      D5,D6
00001F36  E60E                    2177          LSR.B       #3,D6               ;mode
00001F38  CA3C 0007               2178          And.B       #%00000111,D5       ;register
00001F3C                          2179          
00001F3C  BC3C 0000               2180          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
00001F40  6700 004A               2181          BEQ         Data_Reg_Direct
00001F44                          2182          
00001F44  BC3C 0001               2183          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
00001F48  6700 005C               2184          BEQ         Addr_Reg_Direct
00001F4C                          2185          
00001F4C  BC3C 0002               2186          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
00001F50  6700 006E               2187          BEQ         Addr_Reg_Indirect
00001F54                          2188          
00001F54  BC3C 0003               2189          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
00001F58  6700 0098               2190          BEQ         Addr_Reg_Indirect_Inc
00001F5C                          2191          
00001F5C  BC3C 0004               2192          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
00001F60  6700 00CE               2193          BEQ         Addr_Reg_Indirect_Dec
00001F64                          2194          
00001F64  BC3C 0007               2195          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
00001F68  6700 0006               2196          BEQ         Get_Effective_Address_Other
00001F6C                          2197          
00001F6C  6000 0138               2198          BRA         invalidEA
00001F70                          2199          
00001F70                          2200  Get_Effective_Address_Other:        
00001F70                          2201          
00001F70  BA3C 0000               2202          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00001F74  6700 00F8               2203          BEQ Addr_Abs_Short
00001F78                          2204          
00001F78  BA3C 0001               2205          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
00001F7C  6700 0104               2206          BEQ Addr_Abs_Long
00001F80                          2207          
00001F80  BA3C 0004               2208          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
00001F84  6700 0110               2209          BEQ Addr_Immediate_Data
00001F88                          2210          
00001F88  6000 011C               2211          BRA         invalidEA
00001F8C                          2212          
00001F8C                          2213  Data_Reg_Direct:                        ;case 0(0000)
00001F8C                          2214  
00001F8C  43F9 00002322           2215          LEA         letterD,A1          ;output 'D' for data register
00001F92  103C 000E               2216          MOVE.B      #14,D0              ;set for task to display null terminated 
00001F96  4E4F                    2217          TRAP        #15                 ;string without CR, LF
00001F98                          2218                          
00001F98  4281                    2219          CLR.L       D1
00001F9A  1205                    2220          MOVE.B      D5,D1               ;move register number for display into D1
00001F9C  103C 0003               2221          MOVE.B      #3,D0               ;set for task to display null terminated 
00001FA0  4E4F                    2222          TRAP        #15                 ;string without CR, LF
00001FA2                          2223                 
00001FA2  6000 0102               2224          BRA         Get_Effective_Address_Exit  ;return
00001FA6                          2225          
00001FA6                          2226          
00001FA6                          2227  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
00001FA6                          2228        
00001FA6  43F9 00002320           2229          LEA         letterA,A1          ;output 'A' for address register
00001FAC  103C 000E               2230          MOVE.B      #14,D0              ;set for task to display null terminated 
00001FB0  4E4F                    2231          TRAP        #15                 ;string without CR, LF
00001FB2                          2232          
00001FB2  4281                    2233          CLR.L       D1
00001FB4  1205                    2234          MOVE.B      D5,D1               ;move register number for display into D1
00001FB6  103C 0003               2235          MOVE.B      #3,D0               ;set for task to display null terminated 
00001FBA  4E4F                    2236          TRAP        #15                 ;string without CR, LF
00001FBC                          2237          
00001FBC  6000 00E8               2238          BRA         Get_Effective_Address_Exit  ;return
00001FC0                          2239  
00001FC0                          2240  
00001FC0                          2241  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
00001FC0                          2242          
00001FC0  43F9 00002328           2243          LEA         lprn,A1             ;output 'D' for data register
00001FC6  103C 000E               2244          MOVE.B      #14,D0              ;set for task to display null terminated 
00001FCA  4E4F                    2245          TRAP        #15                 ;string without CR, LF
00001FCC                          2246  
00001FCC  43F9 00002320           2247          LEA         letterA,A1          ;output 'A' for address register
00001FD2  103C 000E               2248          MOVE.B      #14,D0              ;set for task to display null terminated 
00001FD6  4E4F                    2249          TRAP        #15                 ;string without CR, LF
00001FD8                          2250          
00001FD8  4281                    2251          CLR.L       D1
00001FDA  1205                    2252          MOVE.B      D5,D1               ;move register number for display into D1
00001FDC  103C 0003               2253          MOVE.B      #3,D0               ;set for task to display null terminated 
00001FE0  4E4F                    2254          TRAP        #15                 ;string without CR, LF
00001FE2                          2255  
00001FE2  43F9 0000232A           2256          LEA         rprn,A1             ;output 'D' for data register
00001FE8  103C 000E               2257          MOVE.B      #14,D0              ;set for task to display null terminated 
00001FEC  4E4F                    2258          TRAP        #15                 ;string without CR, LF
00001FEE                          2259          
00001FEE  6000 00B6               2260          BRA         Get_Effective_Address_Exit  ;return
00001FF2                          2261  
00001FF2                          2262                 
00001FF2                          2263  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
00001FF2                          2264  
00001FF2  43F9 00002328           2265          LEA         lprn,A1             ;output 'D' for data register
00001FF8  103C 000E               2266          MOVE.B      #14,D0              ;set for task to display null terminated 
00001FFC  4E4F                    2267          TRAP        #15                 ;string without CR, LF
00001FFE                          2268  
00001FFE  43F9 00002320           2269          LEA         letterA,A1          ;output 'A' for address register
00002004  103C 000E               2270          MOVE.B      #14,D0              ;set for task to display null terminated 
00002008  4E4F                    2271          TRAP        #15                 ;string without CR, LF
0000200A                          2272          
0000200A  4281                    2273          CLR.L       D1
0000200C  1205                    2274          MOVE.B      D5,D1               ;move register number for display into D1
0000200E  103C 0003               2275          MOVE.B      #3,D0               ;set for task to display null terminated 
00002012  4E4F                    2276          TRAP        #15                 ;string without CR, LF
00002014                          2277  
00002014  43F9 0000232A           2278          LEA         rprn,A1             ;output 'D' for data register
0000201A  103C 000E               2279          MOVE.B      #14,D0              ;set for task to display null terminated 
0000201E  4E4F                    2280          TRAP        #15                 ;string without CR, LF
00002020                          2281          
00002020  43F9 00002324           2282          LEA         plus,A1             ;output 'D' for data register
00002026  103C 000E               2283          MOVE.B      #14,D0              ;set for task to display null terminated 
0000202A  4E4F                    2284          TRAP        #15                 ;string without CR, LF
0000202C                          2285          
0000202C  6000 0078               2286          BRA         Get_Effective_Address_Exit  ;return
00002030                          2287  
00002030                          2288  Addr_Reg_Indirect_Dec                   ;4 = (An) - Address Register Indirect with Predecrement (100)
00002030                          2289  
00002030  43F9 00002326           2290          LEA         minus,A1            ;output '-' for Predecrement
00002036  103C 000E               2291          MOVE.B      #14,D0              ;set for task to display null terminated 
0000203A  4E4F                    2292          TRAP        #15                 ;string without CR, LF
0000203C                          2293  
0000203C  43F9 00002328           2294          LEA         lprn,A1             ;output 'D' for data register
00002042  103C 000E               2295          MOVE.B      #14,D0              ;set for task to display null terminated 
00002046  4E4F                    2296          TRAP        #15                 ;string without CR, LF
00002048                          2297  
00002048  43F9 00002320           2298          LEA         letterA,A1          ;output 'A' for address register
0000204E  103C 000E               2299          MOVE.B      #14,D0              ;set for task to display null terminated 
00002052  4E4F                    2300          TRAP        #15                 ;string without CR, LF
00002054                          2301          
00002054  4281                    2302          CLR.L       D1
00002056  1205                    2303          MOVE.B      D5,D1               ;move register number for display into D1
00002058  103C 0003               2304          MOVE.B      #3,D0               ;set for task to display null terminated 
0000205C  4E4F                    2305          TRAP        #15                 ;string without CR, LF
0000205E                          2306  
0000205E  43F9 0000232A           2307          LEA         rprn,A1             ;output 'D' for data register
00002064  103C 000E               2308          MOVE.B      #14,D0              ;set for task to display null terminated 
00002068  4E4F                    2309          TRAP        #15                 ;string without CR, LF
0000206A                          2310          
0000206A  6000 003A               2311          BRA         Get_Effective_Address_Exit  ;return
0000206E                          2312          
0000206E                          2313                         
0000206E                          2314  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
0000206E                          2315          
0000206E                          2316          
0000206E  43F9 00002302           2317          LEA         xxxW,A1             ;output 'D' for data register
00002074  103C 000E               2318          MOVE.B      #14,D0              ;set for task to display null terminated 
00002078  4E4F                    2319          TRAP        #15                 ;string without CR, LF
0000207A                          2320  
0000207A  548B                    2321          ADDA.L      #word,A3
0000207C                          2322          
0000207C                          2323          ;print word (A3)
0000207C                          2324          ;MOVE.W      A3,(A1)
0000207C                          2325          ;MOVE.B      #1,D0               ;set for task to display null terminated 
0000207C                          2326          ;TRAP        #15                 ;string without CR, LF
0000207C                          2327          
0000207C  5487                    2328          ADDI.L      #word,D7 
0000207E  6000 0026               2329          BRA         Get_Effective_Address_Exit  ;return
00002082                          2330                         
00002082                          2331  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
00002082                          2332          
00002082  43F9 0000230C           2333          LEA         xxxL,A1             ;output 'D' for data register
00002088  103C 000E               2334          MOVE.B      #14,D0              ;set for task to display null terminated 
0000208C  4E4F                    2335          TRAP        #15                 ;string without CR, LF
0000208E                          2336  
0000208E  548B                    2337          ADDA.L      #word,A3
00002090                          2338          
00002090                          2339          ;print long (A3)
00002090                          2340          ;MOVE.L      A3,(A1)
00002090                          2341          ;MOVE.B      #14,D0              ;set for task to display null terminated 
00002090                          2342          ;TRAP        #15                 ;string without CR, LF
00002090                          2343          
00002090  5887                    2344          ADDI.L      #long,D7
00002092  6000 0012               2345          BRA         Get_Effective_Address_Exit  ;return
00002096                          2346                         
00002096                          2347  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
00002096                          2348  
00002096  43F9 00002316           2349          LEA         iData,A1            ;output 'D' for data register
0000209C  103C 000E               2350          MOVE.B      #14,D0              ;set for task to display null terminated 
000020A0  4E4F                    2351          TRAP        #15                 ;string without CR, LF
000020A2                          2352          
000020A2                          2353          *need another input param for size
000020A2  6000 0002               2354          BRA         Get_Effective_Address_Exit  ;return
000020A6                          2355  
000020A6                          2356  invalidEA:
000020A6                          2357  
000020A6                          2358          ;do something
000020A6                          2359   
000020A6                          2360  Get_Effective_Address_Exit:     
000020A6                          2361  
000020A6  4E75                    2362          RTS                             ;return
000020A8                          2363  
000020A8                          2364  switchModeAndReg:
000020A8                          2365  ***
000020A8                          2366  * Assumed in D2
000020A8                          2367  *
000020A8                          2368  * Assumed that they are in least significant byte:
000020A8                          2369  *
000020A8                          2370  *            _this_
000020A8                          2371  *           /      \
000020A8                          2372  *  ........ ........
000020A8                          2373  *  \                /
000020A8                          2374  *   -----word-------
000020A8                          2375  *
000020A8                          2376  *  and that in that byte they are ordered:
000020A8                          2377  *
000020A8                          2378  *       ........   
000020A8                          2379  *       \/\_/\_/
000020A8                          2380  *      /  /    \
000020A8                          2381  *    /   /      \
000020A8                          2382  * dont  one    other
000020A8                          2383  * care
000020A8                          2384  *
000020A8                          2385  * after they will be
000020A8                          2386  *
000020A8                          2387  *       ........   
000020A8                          2388  *       \/\_/\_/
000020A8                          2389  *      /  /    \
000020A8                          2390  *    /   /      \
000020A8                          2391  * dont other    one
000020A8                          2392  * care
000020A8                          2393  *** 
000020A8  0202 003F               2394          AndI.B #%00111111,D2 ;remove unwanted bits from D2
000020AC  0283 00000000           2395          ANDI.L #0,D3 ;clear D3
000020B2  1602                    2396          MOVE.B D2,D3 ;copy to D3
000020B4  E70B                    2397          LSL.B  #3,D3 
000020B6  E60A                    2398          LSR.B  #3,D2
000020B8  D403                    2399          ADD.B  D3,D2
000020BA  4E75                    2400          RTS
000020BC                          2401  
000020BC                          2402          
000020BC                          2403  *==============================================================================
000020BC                          2404  *                            variables and constants
000020BC                          2405  *==============================================================================
000020BC                          2406  
000020BC                          2407  
000020BC                          2408  ***initial user prompt stuff        
000020BC= 45 6E 74 65 72 20 ...   2409  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE: $',0
000020ED= 45 6E 74 65 72 20 ...   2410  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE: $',0
0000211C                          2411  
0000211C= 20 41 64 64 72 65 ...   2412  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
00002161= 20 41 20 43 68 61 ...   2413  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
000021A9                          2414  
000021A9= 20 59 6F 75 20 6D ...   2415  even_msg        DC.B    ' You must enter an even address!'
000021C9                          2416  
000021C9= 20                      2417  spc             DC.B    ' '
000021CA= 01                      2418  spc_len         DC.B    spc_len-spc
000021CB                          2419  ***
000021CB                          2420  
000021CB                          2421  
000021CB                          2422  
000021CB                          2423  ***list of OP codes
000021CB                          2424  
000021CB  =0000C1C0               2425  mulsInstruction  EQU %1100000111000000
000021CB  =0000E6C0               2426  rsrlweaInstruction  EQU %1110011011000000
000021CB  =0000E018               2427  rsrlregInstruction  EQU %1110000000011000
000021CB  =0000E0C0               2428  asrlweaInstruction  EQU %1110000011000000
000021CB  =0000E000               2429  asrlregInstruction  EQU %1110000000000000
000021CB  =0000E2C0               2430  lsrlweaInstruction  EQU %1110001011000000
000021CB  =0000E008               2431  lsrlregInstruction  EQU %1110000000001000
000021CB  =00005100               2432  subqInstruction  EQU %0101000100000000
000021CB  =00009000               2433  subInstruction   EQU %1001000000000000
000021CB  =0000D000               2434  addaInstruction  EQU %1101000000000000
000021CB  =0000D000               2435  addInstruction   EQU %1101000000000000
000021CB  =00004880               2436  movemInstruction EQU %0100100010000000
000021CB  =00000600               2437  addiInstruction  EQU %0000011000000000
000021CB  =00000000               2438  oriInstruction   EQU 0
000021CB  =00000C00               2439  cmpiInstruction  EQU %0000110000000000
000021CB  =00004E80               2440  jsrInstruction   EQU %0100111010000000
000021CB  =00004E75               2441  rtsInstruction   EQU %0100111001110101
000021CB  =00004E71               2442  NoOpInstruction  EQU %0100111001110001
000021CB  =00000000               2443  moveInstruction  EQU 0
000021CB  =00006000               2444  bccInstruction   EQU %0110000000000000
000021CB  =00004400               2445  negInstruction   EQU %0100010000000000
000021CB  =00000000               2446  dataInstruction  EQU 0
000021CB                          2447  
000021CB                          2448  ***
000021CB                          2449  
000021CB                          2450  ***list of OP masks
000021CB                          2451  
000021CB  =0000F1C0               2452  mulsMask  EQU %1111000111000000
000021CB  =0000FEC0               2453  rsrlweaMask  EQU %1111111011000000
000021CB  =0000F018               2454  rsrlregMask  EQU %1111000000011000
000021CB  =0000FEC0               2455  asrlweaMask  EQU %1111111011000000
000021CB  =0000F018               2456  asrlregMask  EQU %1111000000011000
000021CB  =0000FEC0               2457  lsrlweaMask  EQU %1111111011000000
000021CB  =0000F018               2458  lsrlregMask  EQU %1111000000011000
000021CB  =0000F100               2459  subqMask  EQU %1111000100000000
000021CB  =0000F000               2460  subMask   EQU %1111000000000000
000021CB  =0000F000               2461  addaMask  EQU %1111000000000000
000021CB  =0000F000               2462  addMask   EQU %1111000000000000
000021CB  =0000FB80               2463  movemMask EQU %1111101110000000
000021CB  =0000FF00               2464  addiMask  EQU %1111111100000000
000021CB  =0000FF00               2465  oriMask   EQU %1111111100000000
000021CB  =0000FF00               2466  cmpiMask  EQU %1111111100000000
000021CB  =0000FFC0               2467  jsrMask   EQU %1111111111000000
000021CB  =0000FFFF               2468  rtsMask   EQU $FFFF
000021CB  =0000FFFF               2469  NoOpMask  EQU $FFFF
000021CB  =0000C000               2470  moveMask  EQU $C000
000021CB  =0000F000               2471  bccMask   EQU $F000
000021CB  =0000FF00               2472  negMask   EQU $FF00
000021CB  =00000000               2473  dataMask  EQU 0
000021CB                          2474  ***
000021CB                          2475  
000021CB                          2476  ***Bcc Codes***
000021CB  =00000004               2477  CC EQU $04
000021CB  =00000005               2478  CS EQU $05
000021CB  =00000007               2479  EQ EQU $07
000021CB  =0000000C               2480  GE EQU $0C
000021CB  =0000000E               2481  GT EQU $0E
000021CB  =00000002               2482  HI EQU $02
000021CB  =0000000F               2483  LE EQU $0F
000021CB  =00000003               2484  LS EQU $03
000021CB  =0000000D               2485  LT EQU $0D
000021CB  =0000000B               2486  MI EQU $0B
000021CB  =00000006               2487  NE EQU $06
000021CB  =0000000A               2488  PL EQU $0A
000021CB  =00000008               2489  VC EQU $08
000021CB  =00000009               2490  VS EQU $09
000021CB  =00000000               2491  RA EQU $00 ;not really a Condition Code
000021CB  =00000001               2492  SR EQU $01 ;not really a Condition Code
000021CB                          2493  
000021CB= 43 43 20 00             2494  CCm DC.B 'CC ',0
000021CF= 43 53 20 00             2495  CSm DC.B 'CS ',0
000021D3= 45 51 20 00             2496  EQm DC.B 'EQ ',0
000021D7= 47 45 20 00             2497  GEm DC.B 'GE ',0
000021DB= 47 54 20 00             2498  GTm DC.B 'GT ',0
000021DF= 48 49 20 00             2499  HIm DC.B 'HI ',0
000021E3= 4C 45 20 00             2500  LEm DC.B 'LE ',0
000021E7= 4C 53 20 00             2501  LSm DC.B 'LS ',0
000021EB= 4C 54 20 00             2502  LTm DC.B 'LT ',0
000021EF= 4D 49 20 00             2503  MIm DC.B 'MI ',0
000021F3= 4E 45 20 00             2504  NEm DC.B 'NE ',0
000021F7= 50 4C 20 00             2505  PLm DC.B 'PL ',0
000021FB= 56 43 20 00             2506  VCm DC.B 'VC ',0
000021FF= 56 53 20 00             2507  VSm DC.B 'VS ',0
00002203= 52 41 20 00             2508  RAm DC.B 'RA ',0
00002207= 53 52 20 00             2509  SRm DC.B 'SR ',0
0000220B                          2510  
0000220B= 01 04 05 07 0C 0E ...   2511  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
0000221C= 00002207 000021CB ...   2512  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
0000225C                          2513  ***
0000225C                          2514  
0000225C= 45 6E 74 65 72 20 ...   2515  startLocationPrompt DC.B    'Enter start location',0
00002271= 45 6E 74 65 72 20 ...   2516  endLocationPrompt   DC.B    'Enter end location',0
00002284                          2517  
00002284= 0D 0A 00                2518  clearLine  DC.B $0D,$0A,0
00002287                          2519  
00002287= 4D 55 4C 53 20 00       2520  mulsMessage     DC.B 'MULS ',0
0000228D= 52 4F 4C 20 00          2521  rslMessage      DC.B 'ROL ',0
00002292= 52 4F 52 20 00          2522  rsrMessage      DC.B 'ROR ',0
00002297= 41 53 4C 20 00          2523  aslMessage      DC.B 'ASL ',0
0000229C= 41 53 52 20 00          2524  asrMessage      DC.B 'ASR ',0
000022A1= 4C 53 4C 20 00          2525  lslMessage      DC.B 'LSL ',0
000022A6= 4C 53 52 20 00          2526  lsrMessage      DC.B 'LSR ',0
000022AB= 53 55 42 51 20 00       2527  subqMessage     DC.B 'SUBQ ',0
000022B1= 53 55 42 20 00          2528  subMessage      DC.B 'SUB ',0 
000022B6= 41 44 44 41 20 00       2529  addaMessage     DC.B 'ADDA ',0
000022BC= 41 44 44 20 00          2530  addMessage      DC.B 'ADD ',0
000022C1= 4D 4F 56 45 4D 20 00    2531  movemMessage    DC.B 'MOVEM ',0
000022C8= 41 44 44 49 20 00       2532  addiMessage     DC.B 'ADDI ',0
000022CE= 4F 52 49 20 00          2533  oriMessage      DC.B 'ORI ',0
000022D3= 43 4D 50 49 20 00       2534  cmpiMessage     DC.B 'CMPI ',0
000022D9= 4A 53 52 20 00          2535  jsrMessage      DC.B 'JSR ',0
000022DE= 52 54 53 20 00          2536  rtsMessage      DC.B 'RTS ',0
000022E3= 4E 4F 50 20 00          2537  nopMessage      DC.B 'NOP ',0 
000022E8= 4D 4F 56 45 20 00       2538  moveMessage     DC.B 'MOVE ',0
000022EE= 42 00                   2539  bccMessage      DC.B 'B',0
000022F0= 4E 45 47 20 00          2540  negMessage      DC.B 'NEG ',0
000022F5= 44 41 54 41 20 00       2541  dataMessage     DC.B 'DATA ',0
000022FB= 4D 4F 56 45 41 20 00    2542  moveaMessage    DC.B 'MOVEA ',0
00002302                          2543  
00002302= 28 78 78 78 29 2E ...   2544  xxxW            DC.B '(xxx).W: ',0
0000230C= 28 78 78 78 29 2E ...   2545  xxxL            DC.B '(xxx).L: ',0
00002316= 23 28 64 61 74 61 ...   2546  iData           DC.B '#(data): ',0
00002320                          2547  
00002320= 41 00                   2548  letterA         DC.B 'A', 0
00002322= 44 00                   2549  letterD         DC.B 'D', 0
00002324                          2550  
00002324= 2B 00                   2551  plus            DC.B '+', 0
00002326= 2D 00                   2552  minus           DC.B '-', 0
00002328= 28 00                   2553  lPrn            DC.B '(', 0
0000232A= 29 00                   2554  rPrn            DC.B ')', 0
0000232C                          2555  
0000232C                          2556  
0000232C= 00000000                2557  startLocation       DC.L    0
00002330= 00000000                2558  endLocation         DC.L    0
00002334                          2559  
00002334                          2560  
00002334                          2561     
00002334                          2562      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 175C
ADDA                16BE
ADDABODY            1706
ADDAINSTRUCTION     D000
ADDAMASK            F000
ADDAMESSAGE         22B6
ADDDEST             1820
ADDDESTEA           1750
ADDDESTEAMASKS      1756
ADDI                198E
ADDIBODY            19BA
ADDIDONE            19F8
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         22C8
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          22BC
ADDRESS_DONE        1E20
ADDRESS_EXIT        1E1A
ADDR_ABS_LONG       2082
ADDR_ABS_SHORT      206E
ADDR_IMMEDIATE_DATA  2096
ADDR_REG_DIRECT     1FA6
ADDR_REG_INDIRECT   1FC0
ADDR_REG_INDIRECT_DEC  2030
ADDR_REG_INDIRECT_INC  1FF2
ADDSOURCE           17D8
ASLEA               133A
ASLMESSAGE          2297
ASLREG              1380
ASREA               132A
ASRLREG             134A
ASRLREGINSTRUCTION  E000
ASRLREGMASK         F018
ASRLWEA             12EA
ASRLWEACHECKDIRECTION  1316
ASRLWEAINSTRUCTION  E0C0
ASRLWEAMASK         FEC0
ASRMESSAGE          229C
ASRREG              1370
BCC                 1CD4
BCCBYTE             1D26
BCCDONE             1D3C
BCCINSTRUCTION      6000
BCCLIST             220B
BCCLONG             1D34
BCCMASK             F000
BCCMESSAGE          22EE
BCCWORD             1D2C
BEGIN               5001
BEGIN_ADDRESS       1DAC
BYTE                1
CC                  4
CCM                 21CB
CHECKCC             1CEA
CHECKMOVEADEST      1C80
CHECKMOVEDEST       1BCE
CHECKOPCODE         1050
CK_ADDR_DONE        1F30
CK_ADDR_RANGE       1F04
CK_ADDR_RANGE_ERROR  1F20
CK_BOUNDRY          1E48
CK_BOUNDRY_ERROR    1E6A
CK_SIZE_ERROR       1E7E
CLEARLINE           2284
CMPI                1A90
CMPIBODY            1AB8
CMPIDONE            1AF6
CMPIEA              1A82
CMPIEAMASKS         1A89
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         22D3
CONDITIONCODEMESSAGE  221C
CS                  5
CSM                 21CF
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         22F5
DATA_REG_DIRECT     1F8C
ELPROMPT            20ED
END                 FFFFFE
ENDLOCATION         2330
ENDLOCATIONPROMPT   2271
END_ADDRESS         1DF0
ENTER_ADDR_EDIT_ALL  1E22
ENTER_ADDR_EDIT_ALL_EXIT  1E46
EQ                  7
EQM                 21D3
EVEN_MSG            21A9
FALSEPOSITIVE       1070
FARLABEL            FFE
FIN                 1DA8
FOUNDCC             1CFC
GE                  C
GEM                 21D7
GET_EFFECTIVE_ADDRESS  1F34
GET_EFFECTIVE_ADDRESS_EXIT  20A6
GET_EFFECTIVE_ADDRESS_OTHER  1F70
GT                  E
GTM                 21DB
HANDLEBYTEDATA      1D7C
HEX_RANGE_ERROR     1EEC
HI                  2
HIM                 21DF
IDATA               2316
INSTLABELLIST       10EE
INSTMASKLIST        10C2
INSTOPLIST          1096
INSTOPLIST2         10A4
INVALIDEA           20A6
INVALIDMSG          211C
INVCHARMSG          2161
JSR                 1B0E
JSRBODY             1B36
JSRDONE             1B56
JSREA               1B06
JSREAMASKS          1B0A
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          22D9
LCASEHEX            1ECE
LE                  F
LEM                 21E3
LETTERA             2320
LETTERD             2322
LONG                4
LPRN                2328
LS                  3
LSLEA               13E8
LSLMESSAGE          22A1
LSLREG              1452
LSM                 21E7
LSREA               13D8
LSRLCHECKI          14A8
LSRLCHECKIR         1492
LSRLCHECKIRRETURN   14A6
LSRLCHECKR          14DC
LSRLEA              1390
LSRLEAMASKS         1396
LSRLREG             141C
LSRLREGBODY         1462
LSRLREGINSTRUCTION  E008
LSRLREGMASK         F018
LSRLWEA             139C
LSRLWEABODY         13F8
LSRLWEACHECKDIRECTION  13C4
LSRLWEAINSTRUCTION  E2C0
LSRLWEAMASK         FEC0
LSRMESSAGE          22A6
LSRREG              1442
LT                  D
LTM                 21EB
MAIN_LOOP           1026
MATCH               1076
MI                  B
MIM                 21EF
MINUS               2326
MOVE                1BA6
MOVEA               1C58
MOVEABODY           1CAE
MOVEADESTEA         1C54
MOVEADESTEAMASKS    1C56
MOVEAMESSAGE        22FB
MOVEBODY            1BFC
MOVEDESTEA          1B98
MOVEDESTEAMASKS     1B9F
MOVEINSTRUCTION     0
MOVEM               187C
MOVEMASK            C000
MOVEMBODY           18E6
MOVEMESSAGE         22E8
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     1872
MOVEMMEMTOREGEAMASKS  1877
MOVEMMESSAGE        22C1
MOVEMREGTOMEMEA     1868
MOVEMREGTOMEMEAMASKS  186D
MOVESOURCEEA        1B86
MOVESOURCEEAMASKS   1B8F
MULS                11D4
MULSBODY            11FC
MULSEA              11C4
MULSEAMASKS         11CC
MULSINSTRUCTION     C1C0
MULSMASK            F1C0
MULSMESSAGE         2287
NE                  6
NEG                 1928
NEGBODY             1950
NEGDONE             197E
NEGEA               1918
NEGEAMASKS          1920
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          22F0
NEM                 21F3
NEXTHEX             1E94
NEXTHEXDONE         1EE6
NEXTHEXRETURN       1F02
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 1B66
NOPMESSAGE          22E3
ORI                 1A08
ORIBODY             1A34
ORIDONE             1A72
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          22CE
PARSEHEXSTRING      1E92
PL                  A
PLM                 21F7
PLUS                2324
PRGORG              1000
PROCESS_OP_CODES    1F32
PROCESS_OP_CODES_EXIT  1F32
PROMPT_USER         1014
RA                  0
RAM                 2203
RPRN                232A
RSLEA               1294
RSLMESSAGE          228D
RSLREG              12DA
RSREA               1284
RSRLREG             12A4
RSRLREGINSTRUCTION  E018
RSRLREGMASK         F018
RSRLWEA             1244
RSRLWEACHECKDIRECTION  1270
RSRLWEAINSTRUCTION  E6C0
RSRLWEAMASK         FEC0
RSRMESSAGE          2292
RSRREG              12CA
RTS                 1B76
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          22DE
SLPROMPT            20BC
SNIPPET             1146
SNIPPETEND          11C0
SPC                 21C9
SPC_LEN             21CA
SR                  1
SRM                 2207
STACK               5000
START               1000
STARTLOCATION       232C
STARTLOCATIONPROMPT  225C
SUB                 15AE
SUBDEST             1676
SUBINSTRUCTION      9000
SUBMASK             F000
SUBMESSAGE          22B1
SUBQ                1506
SUBQBODY            153E
SUBQEA              14F6
SUBQEAMASKS         14FE
SUBQINSTRUCTION     5100
SUBQMASK            F100
SUBQMESSAGE         22AB
SUBSOURCE           162E
SWITCHMODEANDREG    20A8
TOEIGHT             15AA
UCASEHEX            1EB6
UNKNOWNOPCODE       1D56
VALIDADDA           16DC
VALIDADDDESTEA      17AC
VALIDADDIMODES      1990
VALIDADDSOURCEEA    1782
VALIDASRL           12EC
VALIDCMPIMODES      1A92
VALIDJSRMODES       1B10
VALIDLSRL           139E
VALIDMEMTOREG       18B8
VALIDMOVEADESTMODES  1C82
VALIDMOVEASOURCEMODES  1C5A
VALIDMOVEDESTMODES  1BD0
VALIDMOVESOURCEMODES  1BA8
VALIDMULSMODES      11D6
VALIDNEGMODES       192A
VALIDORIMODES       1A0A
VALIDREGTOMEM       1892
VALIDRSRL           1246
VALIDSUBDESTEA      15FE
VALIDSUBQ           1518
VALIDSUBSOURCEEA    15D4
VC                  8
VCM                 21FB
VS                  9
VSM                 21FF
WORD                2
XXXL                230C
XXXW                2302
ZEROTOEIGHT         15A0
ZEROTOEIGHTRETURN   15A8

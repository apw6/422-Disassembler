00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/6/2014 2:26:25 PM

00000000                             1  *##########################################################################
00000000                             2  * Title      : 
00000000                             3  * Written by : Andrew Watson
00000000                             4  *            : Elaine Keller
00000000                             5  *            : Robert Anderson
00000000                             6  * Date       : 11/14/2014
00000000                             7  * Description: 
00000000                             8  *##########################################################################
00000000                             9  
00000000                            10  ***Possible Bug***
00000000                            11  *can not tell data from an
00000000                            12  *unidentified instruction from an actual
00000000                            13  *instruction therefore causing errors.
00000000                            14  *may not actually be a bug because data
00000000                            15  *is data to the machine, and if you modify
00000000                            16  *the instructions in memory for a program
00000000                            17  *by moivng data, you can modify the instuctions
00000000                            18  *executed.
00000000                            19  
00000000                            20  
00000000                            21  ***************************************************************************
00000000                            22  *                   Variable/Data Definitions
00000000                            23  ***************************************************************************
00000000                            24  
00000000  =00005000                 25  stack   EQU   $00005000
00000000  =00005001                 26  begin   EQU   $00005001
00000000  =00FFFFFE                 27  end     EQU   $00FFFFFE
00000000  =00000001                 28  byte    EQU   1
00000000  =00000002                 29  word    EQU   2
00000000  =00000004                 30  long    EQU   4
00000000  =00001000                 31  prgorg  EQU   $1000
00000000                            32  
00000FFE                            33      ORG $00000FFE
00000FFE                            34  FarLabel:
00001000                            35      ORG    prgorg
00001000                            36  start:
00001000  4FF8 5000                 37          LEA stack, SP ;initialize stack
00001004                            38  
00001000                            39      ORG    prgorg
00001000                            40  
00001000                            41  ******************************************************************************
00001000                            42  *                   Begin processing active code
00001000                            43  ******************************************************************************
00001000                            44      
00001000                            45  start:
00001000                            46  
00001000  4FF8 5000                 47          LEA         stack, SP           ;Initialize stack
00001004                            48          
00001004                            49  *.............................................................................
00001004                            50  * Debug Mode - Comment out when done
00001004  267C 000010F6             51          MOVE.L      #snippet,A3
0000100A  287C 0000112A             52          MOVE.L      #snippetEnd,A4
00001010  6000 0014                 53          BRA         main_Loop
00001014                            54  * Debug Mode - Comment out when done
00001014                            55  *.............................................................................        
00001014                            56          
00001014                            57  prompt_user:
00001014                            58  
00001014  6100 0774                 59          BSR         begin_address
00001018  B67C FFFF                 60          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000101C  6700 0768                 61          BEQ         fin                 ;Yes, then exit
00001020                            62          
00001020  6000 0004                 63          BRA         main_Loop
00001024                            64          ;BSR         process_op_codes
00001024  60EE                      65          BRA         prompt_user
00001026                            66                  
00001026                            67  ******************************************************************************
00001026                            68  *                   Begin processing OP Codes
00001026                            69  ******************************************************************************
00001026                            70   
00001026                            71  main_Loop:
00001026                            72  
00001026  B9CB                      73          CMPA.L A3,A4 ;check end of prog
00001028  6700 075C                 74          BEQ fin
0000102C                            75          
0000102C  3213                      76          MOVE.W (A3),D1 ;copy word from other prog to analyze as instruction
0000102E                            77          
0000102E                            78          ;handle an odd memory access(instructions will never be misaligned)
0000102E  240B                      79          MOVE.L A3,D2 ; copy address to D2
00001030  0202 0001                 80          ANDI.B #%00000001,D2 ;mask everything except the least significant bit
00001034  0C02 0001                 81          CMPI.B #1,D2 ;compare the least sig bit of the address to one
00001038  6700 0720                 82          BEQ handlebytedata ;the least sig bit will only be one if the insrtuction
0000103C                            83                             ;is odd(misaligned) and therefore not an instruction
0000103C                            84          
0000103C  7600                      85          MOVEQ.L #0,D3
0000103E                            86          
0000103E                            87          ***things to save A3,A4,D1(?)***
0000103E  48E7 0018                 88          MOVEM.L A3-A4,-(SP)
00001042  6100 000C                 89          BSR checkOPcode
00001046  4CDF 1800                 90          MOVEM.L (SP)+,A3-A4
0000104A  D7C7                      91          ADDA.L  D7,A3 ;look past data that was part of the instruction
0000104C                            92          
0000104C  548B                      93          ADDQ.L  #word,A3
0000104E  60D6                      94          BRA     main_Loop 
00001050                            95          
00001050                            96  checkOPcode:
00001050                            97  
00001050                            98  
00001050  7E00                      99          MOVEQ.L #0,D7
00001052                           100          
00001052  41F9 00001096            101          LEA     instOPList,A0 ;get instruction signitrue list in A0
00001058  D1C3                     102          ADDA.L  D3,A0 ;get correct sig         
0000105A                           103          
0000105A  43F9 000010AE            104          LEA     instMaskList,A1 ;get instruction mask in A1
00001060  D3C3                     105          ADDA.L  D3,A1  ;get correct mast
00001062                           106          
00001062  3401                     107          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001064                           108          
00001064  C451                     109          AND.W   (A1),D2 ;mask instruction
00001066                           110          
00001066                           111          
00001066                           112          
00001066                           113          
00001066  B450                     114          CMP.W   (A0),D2 ;compare to sig
00001068  6700 000C                115          BEQ     match ;if sig matches branch
0000106C  5483                     116          ADDQ.L  #word,D3 ;add to D3 to check for next instruction
0000106E  60E0                     117          BRA checkOPcode
00001070                           118          
00001070                           119  falsePositive:
00001070                           120          
00001070  103C 00FF                121          MOVE.B #-1,D0
00001074  4E75                     122          RTS
00001076                           123  
00001076                           124  match:
00001076                           125          
00001076  43F9 000010C6            126          LEA     instLabelList,A1 ;get instruction code label
0000107C  D3C3                     127          ADDA.L  D3,A1 ;get correct label
0000107E  D3C3                     128          ADDA.L  D3,A1
00001080  5483                     129          ADDQ.L  #word,D3 ;add to D3 incase false positive
00001082  2251                     130          MOVEA.L (A1),A1
00001084  48E7 1000                131          MOVEM.L D3,-(SP) ; save D3
00001088  4E91                     132          JSR     (A1)
0000108A  4CDF 0008                133          MOVEM.L (SP)+,D3 ;restore D3
0000108E  B03C 00FF                134          CMP.B   #-1,D0
00001092  67BC                     135          BEQ     checkOPcode
00001094  4E75                     136          RTS
00001096                           137          
00001096                           138  
00001096= D000 4880 0600 0...      139  instOPList DC.W addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruction         
000010AE= F000 FB80 FF00 F...      140  instMaskList DC.W addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
000010C6= 0000113A 0000125A ...    141  instLabelList DC.L ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
000010F6                           142  
000010F6                           143  snippet:
000010F6  4E71                     144           NOP
000010F8  60FC                     145           BRA snippet
000010FA  6000 FF02                146           BRA FarLabel
000010FE  67F6                     147           BEQ snippet
00001100  6E00 0204                148           BGT NEG
00001104  61F0                     149           BSR snippet
00001106  4441                     150           NEG D1
00001108  3239 00008500            151           MOVE.W $8500,D1
0000110E  0645 001E                152           ADDI.W #30,D5
00001112  4E75                     153           RTS
00001114  4EB8 0054                154           JSR $54
00001118  0C41 0003                155           CMPI #3,D1
0000111C  0041 0003                156           ORI  #3,D1
00001120  48E7 0018                157           MOVEM.L A3-A4,-(SP)
00001124  D401                     158           ADD.B D1,D2
00001126  0603 000A                159           ADD.B #10,D3
0000112A                           160  
0000112A                           161           
0000112A                           162  snippetEnd:
0000112A  FFFF FFFF                163           SIMHALT
0000112E                           164      
0000112E= 10 18 20 38 39 00        165  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
00001134= 38 38 38 3F 3F 00        166  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
0000113A                           167  
0000113A                           168  ADD:
0000113A                           169          
0000113A                           170  
0000113A                           171          
0000113A  7000                     172          MOVEQ.L #0, D0 ;clear D0
0000113C                           173          
0000113C                           174          ;Figure out if EA is source or destination
0000113C  3401                     175          MOVE.W D1,D2 ;copy inst to D2
0000113E  EC4A                     176          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
00001140  0202 0007                177          ANDI.B #%00000111,D2 ;mask out rest of byte
00001144  0C02 0002                178          CMPI.B #2,D2 ;compare to 2
00001148  6F00 0016                179          BLE validAddSourceEA ;2 or less is EA is source
0000114C                           180          
0000114C  0C02 0007                181          CMPI.B #%111,D2 ;compare to 7
00001150  6700 FF1E                182          BEQ falsePositive ;thats not valid
00001154  0C02 0003                183          CMPI.B #%11,D2 ;compare to 3
00001158  6700 FF16                184          BEQ falsePositive ;also not valid
0000115C  6000 002C                185          BRA validAddDestEA ;all thats left is valid EA as Dest 
00001160                           186          
00001160                           187  validAddSourceEA:
00001160                           188          
00001160  43F9 0000156D            189          LEA moveSourceEAmasks,A1 ;load the list of masks
00001166  D3C0                     190          ADDA.L D0,A1 ;displace to a specific mask
00001168  1A11                     191          MOVE.B (A1),D5 ;move the mask to D5
0000116A                           192          
0000116A  0C05 0000                193          CMPI.B #0,D5 ;check if the mask is 0
0000116E  6700 FF00                194          BEQ falsePositive ;branch if it is
00001172                           195          
00001172  1401                     196          MOVE.B D1,D2 ;copy instruction to D2
00001174  C405                     197          AND.B D5,D2  ;mask D2
00001176                           198          
00001176  43F9 00001564            199          LEA moveSourceEA,A1 ;load the list of valid modes
0000117C  D3C0                     200          ADDA.L D0,A1 ;displace to a specific mode
0000117E  1811                     201          MOVE.B (A1),D4 ;move mode to D4
00001180  B404                     202          CMP.B D4,D2 ;compare mode to masked value
00001182  6700 0032                203          BEQ  addSource ;if its match, its a valid mode and we can procede
00001186                           204          
00001186  5280                     205          ADDQ.L #1,D0 ;add one to displacement
00001188  60D6                     206          BRA validAddSourceEA ;check for next mode
0000118A                           207          
0000118A                           208          
0000118A                           209  validAddDestEA:
0000118A                           210          
0000118A  43F8 1134                211          LEA addDestEAmasks,A1 ;load the list of masks
0000118E  D3C0                     212          ADDA.L D0,A1 ;displace to a specific mask
00001190  1A11                     213          MOVE.B (A1),D5 ;move the mask to D5
00001192                           214          
00001192  0C05 0000                215          CMPI.B #0,D5 ;check if the mask is 0
00001196  6700 FED8                216          BEQ falsePositive ;branch if it is
0000119A                           217          
0000119A  3401                     218          MOVE.W D1,D2 ;copy instruction to D2
0000119C  EC4A                     219          LSR.W #6,D2  ;move mode
0000119E  6100 08E6                220          BSR switchModeAndReg ;switch register and mode
000011A2  C405                     221          AND.B D5,D2  ;mask D2
000011A4                           222          
000011A4  43F8 112E                223          LEA addDestEA,A1 ;load the list of valid modes
000011A8  D3C0                     224          ADDA.L D0,A1 ;displace to a specific mode
000011AA  1811                     225          MOVE.B (A1),D4 ;move mode to D4
000011AC  B404                     226          CMP.B D4,D2 ;compare mode to masked value
000011AE  6700 004E                227          BEQ addDest ;if its match, its a valid mode and we can procede
000011B2                           228          
000011B2  5280                     229          ADDQ.L #1,D0 ;add one to displacement
000011B4  60D4                     230          BRA validAddDestEA ;check for next mode
000011B6                           231          
000011B6                           232  addSource
000011B6                           233  
000011B6  43F9 00001C65            234          LEA     addMessage,A1  ;move string for MOVE
000011BC  103C 000E                235          MOVE.B  #14,D0        ;set for task to display null terminated 
000011C0                           236                                ;string with CR, LF
000011C0  4E4F                     237          TRAP    #15
000011C2                           238          
000011C2                           239          ;do EA
000011C2                           240          
000011C2  3401                     241          MOVE.W  D1,D2 ;check mode
000011C4  C43C 003F                242          AND.B   #%00111111,D2
000011C8  1A02                     243          MOVE.B  D2,D5
000011CA  48E7 4000                244          MOVEM.L D1,-(SP)
000011CE  6100 0742                245          BSR     Get_Effective_Address
000011D2  4CDF 0002                246          MOVEM.L (SP)+,D1
000011D6                           247          
000011D6                           248          ;print separator
000011D6                           249          
000011D6                           250          ;Then do Dn
000011D6                           251          
000011D6  3401                     252          MOVE.W  D1,D2
000011D8  E04A                     253          LSR.W   #8,D2 ;move reg into first byte
000011DA  E20A                     254          LSR.B   #1,D2 ;line it up to least sig bit
000011DC  C43C 0007                255          AND.B   #%00000111,D2 ;force mode to Dn
000011E0  1A02                     256          MOVE.B  D2,D5
000011E2  48E7 4000                257          MOVEM.L D1,-(SP)
000011E6  6100 072A                258          BSR     Get_Effective_Address
000011EA  4CDF 0002                259          MOVEM.L (SP)+,D1
000011EE                           260          
000011EE  43F9 00001C62            261          LEA     clearLine,A1  ;move string for a CR and LF
000011F4  103C 000E                262          MOVE.B  #14,D0        ;set for task to display null terminated 
000011F8                           263                                ;string without CR, LF
000011F8  4E4F                     264          TRAP    #15
000011FA                           265  
000011FA  7000                     266          MOVEQ.L #0,D0
000011FC  4E75                     267          RTS
000011FE                           268  
000011FE                           269  addDest
000011FE                           270  
000011FE  43F9 00001C65            271          LEA     addMessage,A1  ;move string for MOVE
00001204  103C 000E                272          MOVE.B  #14,D0        ;set for task to display null terminated 
00001208                           273                                ;string with CR, LF
00001208  4E4F                     274          TRAP    #15
0000120A                           275          
0000120A                           276          ;Do Dn
0000120A                           277          
0000120A  3401                     278          MOVE.W  D1,D2
0000120C  E04A                     279          LSR.W   #8,D2 ;move reg into first byte
0000120E  E20A                     280          LSR.B   #1,D2 ;line it up to least sig bit
00001210  C43C 0007                281          AND.B   #%00000111,D2 ;force mode to Dn
00001214  1A02                     282          MOVE.B  D2,D5
00001216  48E7 4000                283          MOVEM.L D1,-(SP)
0000121A  6100 06F6                284          BSR     Get_Effective_Address
0000121E  4CDF 0002                285          MOVEM.L (SP)+,D1
00001222                           286          
00001222                           287          
00001222                           288          ;print separator
00001222                           289          
00001222                           290          ;Then do EA
00001222                           291          
00001222  3401                     292          MOVE.W  D1,D2 ;check mode
00001224  C43C 003F                293          AND.B   #%00111111,D2
00001228  1A02                     294          MOVE.B  D2,D5
0000122A  48E7 4000                295          MOVEM.L D1,-(SP)
0000122E  6100 06E2                296          BSR     Get_Effective_Address
00001232  4CDF 0002                297          MOVEM.L (SP)+,D1
00001236                           298          
00001236                           299          
00001236  43F9 00001C62            300          LEA     clearLine,A1  ;move string for a CR and LF
0000123C  103C 000E                301          MOVE.B  #14,D0        ;set for task to display null terminated 
00001240                           302                                ;string without CR, LF
00001240  4E4F                     303          TRAP    #15
00001242                           304  
00001242  7000                     305          MOVEQ.L #0,D0
00001244  4E75                     306          RTS
00001246                           307  
00001246                           308  
00001246= 10 20 38 39 00           309  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
0000124B= 38 38 3F 3F 00           310  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
00001250                           311  
00001250= 10 18 38 39 00           312  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
00001255= 38 38 3F 3F 00           313  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
0000125A                           314  
0000125A                           315  MOVEM:
0000125A                           316          
0000125A                           317  
0000125A                           318          
0000125A  7000                     319          MOVEQ.L #0, D0 ;clear D0
0000125C                           320          
0000125C                           321          ;Figure out which direction we are going
0000125C  3401                     322          MOVE.W D1,D2 ;copy inst to D2
0000125E  E64A                     323          LSR.W #3,D2 ;shift direction bit into most sig bit of first byte
00001260  0202 0080                324          ANDI.B #%10000000,D2 ;mask out everything but direction bit in first byte
00001264  0C02 0000                325          CMPI.B #0,D2 ;compare bit to zero
00001268  6700 0006                326          BEQ validRegToMem ;if zero, reg to mem
0000126C  6000 0028                327          BRA validMemToReg ;else, its mem to reg
00001270                           328          
00001270                           329  validRegToMem:
00001270                           330          
00001270  43F8 124B                331          LEA movemRegToMemEAmasks,A1 ;load the list of masks
00001274  D3C0                     332          ADDA.L D0,A1 ;displace to a specific mask
00001276  1A11                     333          MOVE.B (A1),D5 ;move the mask to D5
00001278                           334          
00001278  0C05 0000                335          CMPI.B #0,D5 ;check if the mask is 0
0000127C  6700 FDF2                336          BEQ falsePositive ;branch if it is
00001280                           337          
00001280  1401                     338          MOVE.B D1,D2 ;copy instruction to D2
00001282  C405                     339          AND.B D5,D2  ;mask D2
00001284                           340          
00001284  43F8 1246                341          LEA movemRegToMemEA,A1 ;load the list of valid modes
00001288  D3C0                     342          ADDA.L D0,A1 ;displace to a specific mode
0000128A  1811                     343          MOVE.B (A1),D4 ;move mode to D4
0000128C  B404                     344          CMP.B D4,D2 ;compare mode to masked value
0000128E  6700 0034                345          BEQ  movemBody ;if its match, its a valid mode and we can procede
00001292                           346          
00001292  5280                     347          ADDQ.L #1,D0 ;add one to displacement
00001294  60DA                     348          BRA validRegToMem ;check for next mode
00001296                           349          
00001296                           350          
00001296                           351  validMemToReg:
00001296                           352          
00001296  43F8 1255                353          LEA movemMemToRegEAmasks,A1 ;load the list of masks
0000129A  D3C0                     354          ADDA.L D0,A1 ;displace to a specific mask
0000129C  1A11                     355          MOVE.B (A1),D5 ;move the mask to D5
0000129E                           356          
0000129E  0C05 0000                357          CMPI.B #0,D5 ;check if the mask is 0
000012A2  6700 FDCC                358          BEQ falsePositive ;branch if it is
000012A6                           359          
000012A6  3401                     360          MOVE.W D1,D2 ;copy instruction to D2
000012A8  EC4A                     361          LSR.W #6,D2  ;move mode
000012AA  6100 07DA                362          BSR switchModeAndReg ;switch register and mode
000012AE  C405                     363          AND.B D5,D2  ;mask D2
000012B0                           364          
000012B0  43F8 1250                365          LEA movemMemToRegEA,A1 ;load the list of valid modes
000012B4  D3C0                     366          ADDA.L D0,A1 ;displace to a specific mode
000012B6  1811                     367          MOVE.B (A1),D4 ;move mode to D4
000012B8  B404                     368          CMP.B D4,D2 ;compare mode to masked value
000012BA  6700 0008                369          BEQ movemBody ;if its match, its a valid mode and we can procede
000012BE                           370          
000012BE  5280                     371          ADDQ.L #1,D0 ;add one to displacement
000012C0  6000 02EC                372          BRA validMoveDestModes ;check for next mode
000012C4                           373          
000012C4                           374  movemBody
000012C4                           375  
000012C4  43F9 00001C6B            376          LEA     movemMessage,A1  ;move string for MOVE
000012CA  103C 000E                377          MOVE.B  #14,D0        ;set for task to display null terminated 
000012CE                           378                                ;string with CR, LF
000012CE  4E4F                     379          TRAP    #15
000012D0                           380          
000012D0                           381          ;show list
000012D0                           382          
000012D0  5487                     383          ADDQ.L #word,D7 ;read past the register list mask(word) following
000012D2                           384                          ;the instruction
000012D2                           385          
000012D2                           386          ;print separator
000012D2                           387          
000012D2  3401                     388          MOVE.W  D1,D2 ;check mode
000012D4  C43C 003F                389          AND.B   #%00111111,D2
000012D8  1A02                     390          MOVE.B  D2,D5
000012DA  48E7 4000                391          MOVEM.L D1,-(SP)
000012DE  6100 0632                392          BSR     Get_Effective_Address
000012E2  4CDF 0002                393          MOVEM.L (SP)+,D1
000012E6                           394          
000012E6                           395          
000012E6  43F9 00001C62            396          LEA     clearLine,A1  ;move string for a CR and LF
000012EC  103C 000E                397          MOVE.B  #14,D0        ;set for task to display null terminated 
000012F0                           398                                ;string without CR, LF
000012F0  4E4F                     399          TRAP    #15
000012F2                           400  
000012F2  7000                     401          MOVEQ.L #0,D0
000012F4  4E75                     402          RTS
000012F6                           403  
000012F6                           404  
000012F6                           405      
000012F6= 00 10 18 20 28 38 ...    406  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
000012FE= 38 38 38 38 38 3F ...    407  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
00001306                           408     
00001306                           409  NEG:            
00001306                           410       
00001306  7000                     411          MOVEQ.L #0, D0 ;clear D0
00001308                           412          
00001308                           413  validNegModes:
00001308                           414          
00001308  43F8 12FE                415          LEA NegEAmasks,A1 ;load the list of masks
0000130C  D3C0                     416          ADDA.L D0,A1 ;displace to a specific mask
0000130E  1A11                     417          MOVE.B (A1),D5 ;move the mask to D5
00001310                           418          
00001310  0C05 0000                419          CMPI.B #0,D5 ;check if the mask is 0
00001314  6700 FD5A                420          BEQ falsePositive ;branch if it is
00001318                           421          
00001318  1401                     422          MOVE.B D1,D2 ;copy instruction to D2
0000131A  C405                     423          AND.B D5,D2  ;mask D2
0000131C  43F8 12F6                424          LEA NegEA,A1 ;load the list of valid modes
00001320  D3C0                     425          ADDA.L D0,A1 ;displace to a specific mode
00001322  1811                     426          MOVE.B (A1),D4 ;move mode to D4
00001324  B404                     427          CMP.B D4,D2 ;compare mode to masked value
00001326  6700 0006                428          BEQ NegBody ;if its match, its a valid mode and we can procede
0000132A                           429          
0000132A  5280                     430          ADDQ.L #1,D0 ;add one to displacement
0000132C  60DA                     431          BRA validNegModes ;check for next mode
0000132E                           432          
0000132E                           433  NegBody:
0000132E                           434  
0000132E                           435  
0000132E  3401                     436          MOVE.W  D1,D2 ;copy inst to D2
00001330  C47C 0600                437          AND.W  #%0011000000000,D2 ;mask word for size
00001334  0C42 0000                438          CMPI.W #0,D2 ;0 is the only non valid size
00001338  6700 FD36                439          BEQ falsePositive ; zero is not valid
0000133C                           440  
0000133C  43F9 00001CA1            441          LEA     negMessage,A1  ;move string for NEG info
00001342  103C 000E                442          MOVE.B  #14,D0        ;set for task to display null terminated 
00001346                           443                                ;string without CR, LF
00001346  4E4F                     444          TRAP    #15
00001348                           445          
00001348  3401                     446          MOVE.W D1,D2
0000134A  C47C 003F                447          AND #%000000000111111,D2
0000134E  1A02                     448          MOVE.B D2,D5
00001350                           449          
00001350  48E7 4000                450          MOVEM.L D1,-(SP)
00001354  6100 05BC                451          BSR     Get_Effective_Address
00001358  4CDF 0002                452          MOVEM.L (SP)+,D1
0000135C                           453          
0000135C                           454                
0000135C                           455          
0000135C                           456  NEGdone:
0000135C                           457  
0000135C  43F9 00001C62            458          LEA     clearLine,A1  ;move string for a CR and LF
00001362  103C 000E                459          MOVE.B  #14,D0        ;set for task to display null terminated 
00001366                           460                                ;string without CR, LF
00001366  4E4F                     461          TRAP    #15
00001368  7000                     462          MOVEQ.L #0,D0
0000136A  4E75                     463          RTS
0000136C                           464          
0000136C                           465   ADDI:            
0000136C                           466       
0000136C  7000                     467          MOVEQ.L #0, D0 ;clear D0
0000136E                           468          
0000136E                           469  validAddiModes:
0000136E                           470          
0000136E                           471          
0000136E  43F9 00001467            472          LEA cmpiEAmasks,A1 ;load the list of masks
00001374  D3C0                     473          ADDA.L D0,A1 ;displace to a specific mask
00001376  1A11                     474          MOVE.B (A1),D5 ;move the mask to D5
00001378                           475          
00001378  0C05 0000                476          CMPI.B #0,D5 ;check if the mask is 0
0000137C  6700 FCF2                477          BEQ falsePositive ;branch if it is
00001380                           478          
00001380  1401                     479          MOVE.B D1,D2 ;copy instruction to D2
00001382  C405                     480          AND.B D5,D2  ;mask D2
00001384  43F9 00001460            481          LEA cmpiEA,A1 ;load the list of valid modes
0000138A  D3C0                     482          ADDA.L D0,A1 ;displace to a specific mode
0000138C  1811                     483          MOVE.B (A1),D4 ;move mode to D4
0000138E  B404                     484          CMP.B D4,D2 ;compare mode to masked value
00001390  6700 0006                485          BEQ addiBody ;if its match, its a valid mode and we can procede
00001394                           486          
00001394  5280                     487          ADDQ.L #1,D0 ;add one to displacement
00001396  60D6                     488          BRA validAddiModes ;check for next mode
00001398                           489          
00001398                           490  addiBody:
00001398                           491  
00001398                           492  
00001398  3401                     493          MOVE.W  D1,D2 ;copy inst to D2
0000139A  C47C 00C0                494          AND.W  #%0000000011000000,D2 ;mask word for size
0000139E  0C42 00C0                495          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
000013A2  6700 FCCC                496          BEQ falsePositive
000013A6                           497  
000013A6  43F9 00001C73            498          LEA     addiMessage,A1  ;move string for NEG info
000013AC  103C 000E                499          MOVE.B  #14,D0        ;set for task to display null terminated 
000013B0                           500                                ;string without CR, LF
000013B0  4E4F                     501          TRAP    #15
000013B2                           502          
000013B2                           503          ;go to Effective_Address for immediate data
000013B2  143C 003C                504          MOVE.B #%00111100,D2
000013B6  48E7 4000                505          MOVEM.L D1,-(SP)
000013BA  6100 0556                506          BSR     Get_Effective_Address
000013BE  4CDF 0002                507          MOVEM.L (SP)+,D1
000013C2                           508          
000013C2  3401                     509          MOVE.W D1,D2 ;copy inst to D2
000013C4  C47C 003F                510          AND #%000000000111111,D2 ;and out everything but modes and regs
000013C8  1A02                     511          MOVE.B D2,D5 ; copy to D5 for following BSR
000013CA                           512          
000013CA  48E7 4000                513          MOVEM.L D1,-(SP)
000013CE  6100 0542                514          BSR     Get_Effective_Address
000013D2  4CDF 0002                515          MOVEM.L (SP)+,D1
000013D6                           516          
000013D6                           517                
000013D6                           518          
000013D6                           519  addidone:
000013D6                           520  
000013D6  43F9 00001C62            521          LEA     clearLine,A1  ;move string for a CR and LF
000013DC  103C 000E                522          MOVE.B  #14,D0        ;set for task to display null terminated 
000013E0                           523                                ;string without CR, LF
000013E0  4E4F                     524          TRAP    #15
000013E2  7000                     525          MOVEQ.L #0,D0
000013E4  4E75                     526          RTS
000013E6                           527    
000013E6                           528  ORI:            
000013E6                           529       
000013E6  7000                     530          MOVEQ.L #0, D0 ;clear D0
000013E8                           531          
000013E8                           532  validOriModes:
000013E8                           533          
000013E8                           534          
000013E8  43F9 00001467            535          LEA cmpiEAmasks,A1 ;load the list of masks
000013EE  D3C0                     536          ADDA.L D0,A1 ;displace to a specific mask
000013F0  1A11                     537          MOVE.B (A1),D5 ;move the mask to D5
000013F2                           538          
000013F2  0C05 0000                539          CMPI.B #0,D5 ;check if the mask is 0
000013F6  6700 FC78                540          BEQ falsePositive ;branch if it is
000013FA                           541          
000013FA  1401                     542          MOVE.B D1,D2 ;copy instruction to D2
000013FC  C405                     543          AND.B D5,D2  ;mask D2
000013FE  43F9 00001460            544          LEA cmpiEA,A1 ;load the list of valid modes
00001404  D3C0                     545          ADDA.L D0,A1 ;displace to a specific mode
00001406  1811                     546          MOVE.B (A1),D4 ;move mode to D4
00001408  B404                     547          CMP.B D4,D2 ;compare mode to masked value
0000140A  6700 0006                548          BEQ oriBody ;if its match, its a valid mode and we can procede
0000140E                           549          
0000140E  5280                     550          ADDQ.L #1,D0 ;add one to displacement
00001410  60D6                     551          BRA validOriModes ;check for next mode
00001412                           552          
00001412                           553  oriBody:
00001412                           554  
00001412                           555  
00001412  3401                     556          MOVE.W  D1,D2 ;copy inst to D2
00001414  C47C 00C0                557          AND.W  #%0000000011000000,D2 ;mask word for size
00001418  0C42 00C0                558          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
0000141C  6700 FC52                559          BEQ falsePositive
00001420                           560  
00001420  43F9 00001C7A            561          LEA     oriMessage,A1  ;move string for NEG info
00001426  103C 000E                562          MOVE.B  #14,D0        ;set for task to display null terminated 
0000142A                           563                                ;string without CR, LF
0000142A  4E4F                     564          TRAP    #15
0000142C                           565          
0000142C                           566          ;go to Effective_Address for immediate data
0000142C  143C 003C                567          MOVE.B #%00111100,D2
00001430  48E7 4000                568          MOVEM.L D1,-(SP)
00001434  6100 04DC                569          BSR     Get_Effective_Address
00001438  4CDF 0002                570          MOVEM.L (SP)+,D1
0000143C                           571          
0000143C  3401                     572          MOVE.W D1,D2 ;copy inst to D2
0000143E  C47C 003F                573          AND #%000000000111111,D2 ;and out everything but modes and regs
00001442  1A02                     574          MOVE.B D2,D5 ; copy to D5 for following BSR
00001444                           575          
00001444  48E7 4000                576          MOVEM.L D1,-(SP)
00001448  6100 04C8                577          BSR     Get_Effective_Address
0000144C  4CDF 0002                578          MOVEM.L (SP)+,D1
00001450                           579          
00001450                           580                
00001450                           581          
00001450                           582  oridone:
00001450                           583  
00001450  43F9 00001C62            584          LEA     clearLine,A1  ;move string for a CR and LF
00001456  103C 000E                585          MOVE.B  #14,D0        ;set for task to display null terminated 
0000145A                           586                                ;string without CR, LF
0000145A  4E4F                     587          TRAP    #15
0000145C  7000                     588          MOVEQ.L #0,D0
0000145E  4E75                     589          RTS
00001460                           590  
00001460                           591          
00001460                           592          
00001460= 20 18 00 10 38 39 00     593  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
00001467= 38 38 38 38 3F 3F 00     594  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
0000146E                           595     
0000146E                           596  CMPI:            
0000146E                           597       
0000146E  7000                     598          MOVEQ.L #0, D0 ;clear D0
00001470                           599          
00001470                           600  validCmpiModes:
00001470                           601          
00001470                           602          
00001470  43F8 1467                603          LEA cmpiEAmasks,A1 ;load the list of masks
00001474  D3C0                     604          ADDA.L D0,A1 ;displace to a specific mask
00001476  1A11                     605          MOVE.B (A1),D5 ;move the mask to D5
00001478                           606          
00001478  0C05 0000                607          CMPI.B #0,D5 ;check if the mask is 0
0000147C  6700 FBF2                608          BEQ falsePositive ;branch if it is
00001480                           609          
00001480  1401                     610          MOVE.B D1,D2 ;copy instruction to D2
00001482  C405                     611          AND.B D5,D2  ;mask D2
00001484  43F8 1460                612          LEA cmpiEA,A1 ;load the list of valid modes
00001488  D3C0                     613          ADDA.L D0,A1 ;displace to a specific mode
0000148A  1811                     614          MOVE.B (A1),D4 ;move mode to D4
0000148C  B404                     615          CMP.B D4,D2 ;compare mode to masked value
0000148E  6700 0006                616          BEQ CMPIBody ;if its match, its a valid mode and we can procede
00001492                           617          
00001492  5280                     618          ADDQ.L #1,D0 ;add one to displacement
00001494  60DA                     619          BRA validCmpiModes ;check for next mode
00001496                           620          
00001496                           621  CMPIBody:
00001496                           622  
00001496                           623  
00001496  3401                     624          MOVE.W  D1,D2 ;copy inst to D2
00001498  C47C 00C0                625          AND.W  #%0000000011000000,D2 ;mask word for size
0000149C  0C42 00C0                626          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
000014A0  6700 FBCE                627          BEQ falsePositive
000014A4                           628  
000014A4  43F9 00001C80            629          LEA     cmpiMessage,A1  ;move string for NEG info
000014AA  103C 000E                630          MOVE.B  #14,D0        ;set for task to display null terminated 
000014AE                           631                                ;string without CR, LF
000014AE  4E4F                     632          TRAP    #15
000014B0                           633          
000014B0                           634          ;go to Effective_Address for immediate data
000014B0  143C 003C                635          MOVE.B #%00111100,D2
000014B4  48E7 4000                636          MOVEM.L D1,-(SP)
000014B8  6100 0458                637          BSR     Get_Effective_Address
000014BC  4CDF 0002                638          MOVEM.L (SP)+,D1
000014C0                           639          
000014C0  3401                     640          MOVE.W D1,D2 ;copy inst to D2
000014C2  C47C 003F                641          AND #%000000000111111,D2 ;and out everything but modes and regs
000014C6  1A02                     642          MOVE.B D2,D5 ; copy to D5 for following BSR
000014C8                           643          
000014C8  48E7 4000                644          MOVEM.L D1,-(SP)
000014CC  6100 0444                645          BSR     Get_Effective_Address
000014D0  4CDF 0002                646          MOVEM.L (SP)+,D1
000014D4                           647          
000014D4                           648                
000014D4                           649          
000014D4                           650  CMPidone:
000014D4                           651  
000014D4  43F9 00001C62            652          LEA     clearLine,A1  ;move string for a CR and LF
000014DA  103C 000E                653          MOVE.B  #14,D0        ;set for task to display null terminated 
000014DE                           654                                ;string without CR, LF
000014DE  4E4F                     655          TRAP    #15
000014E0  7000                     656          MOVEQ.L #0,D0
000014E2  4E75                     657          RTS
000014E4                           658  
000014E4                           659          
000014E4= 10 38 39 00              660  JsrEA        DC.B %010000, %111000, %111001,0
000014E8= 38 3F 3F 00              661  JsrEAmasks   DC.B %111000, %111111, %111111,0
000014EC                           662     
000014EC                           663  JSR:            
000014EC                           664       
000014EC  7000                     665          MOVEQ.L #0, D0 ;clear D0
000014EE                           666          
000014EE                           667  validJsrModes:
000014EE                           668          
000014EE  43F8 14E8                669          LEA JsrEAmasks,A1 ;load the list of masks
000014F2  D3C0                     670          ADDA.L D0,A1 ;displace to a specific mask
000014F4  1A11                     671          MOVE.B (A1),D5 ;move the mask to D5
000014F6                           672          
000014F6  0C05 0000                673          CMPI.B #0,D5 ;check if the mask is 0
000014FA  6700 FB74                674          BEQ falsePositive ;branch if it is
000014FE                           675          
000014FE  1401                     676          MOVE.B D1,D2 ;copy instruction to D2
00001500  C405                     677          AND.B D5,D2  ;mask D2
00001502  43F8 14E4                678          LEA JsrEA,A1 ;load the list of valid modes
00001506  D3C0                     679          ADDA.L D0,A1 ;displace to a specific mode
00001508  1811                     680          MOVE.B (A1),D4 ;move mode to D4
0000150A  B404                     681          CMP.B D4,D2 ;compare mode to masked value
0000150C  6700 0006                682          BEQ JsrBody ;if its match, its a valid mode and we can procede
00001510                           683          
00001510  5280                     684          ADDQ.L #1,D0 ;add one to displacement
00001512  60DA                     685          BRA validJsrModes ;check for next mode
00001514                           686          
00001514                           687  JsrBody:
00001514                           688  
00001514                           689  
00001514  43F9 00001C87            690          LEA     jsrMessage,A1  ;move string for NEG info
0000151A  103C 000E                691          MOVE.B  #14,D0        ;set for task to display null terminated 
0000151E                           692                                ;string without CR, LF
0000151E  4E4F                     693          TRAP    #15
00001520                           694          
00001520  3401                     695          MOVE.W D1,D2 ;copy inst to D2
00001522  C47C 003F                696          AND #%000000000111111,D2 ;and out everything but modes and regs
00001526  1A02                     697          MOVE.B D2,D5 ; copy to D5 for following BSR
00001528                           698          
00001528  48E7 4000                699          MOVEM.L D1,-(SP)
0000152C  6100 03E4                700          BSR     Get_Effective_Address
00001530  4CDF 0002                701          MOVEM.L (SP)+,D1
00001534                           702          
00001534                           703                
00001534                           704          
00001534                           705  Jsrdone:
00001534                           706  
00001534  43F9 00001C62            707          LEA     clearLine,A1  ;move string for a CR and LF
0000153A  103C 000E                708          MOVE.B  #14,D0        ;set for task to display null terminated 
0000153E                           709                                ;string without CR, LF
0000153E  4E4F                     710          TRAP    #15
00001540  7000                     711          MOVEQ.L #0,D0
00001542  4E75                     712          RTS
00001544                           713  
00001544                           714  
00001544                           715          
00001544                           716  NOP:
00001544                           717  
00001544  43F9 00001C92            718          LEA     nopMessage,A1 ;move string for NOP info
0000154A  103C 000D                719          MOVE.B  #13,D0        ;set for task to display null terminated 
0000154E                           720                                ;string with CR, LF
0000154E  4E4F                     721          TRAP    #15
00001550                           722          
00001550  7000                     723          MOVEQ.L #0,D0
00001552  4E75                     724          RTS
00001554                           725          
00001554                           726  RTS:
00001554                           727          
00001554  43F9 00001C8D            728          LEA     rtsMessage,A1  ;move string for rts info
0000155A  103C 000D                729          MOVE.B  #13,D0        ;set for task to display null terminated 
0000155E                           730                                ;string with CR, LF
0000155E  4E4F                     731          TRAP    #15  
00001560                           732     
00001560  7000                     733          MOVEQ.L #0,D0
00001562  4E75                     734          RTS   
00001564                           735  
00001564= 3C 08 00 10 18 20 ...    736  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
0000156D= 3F 38 38 38 38 38 ...    737  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001576                           738  
00001576= 00 10 18 20 38 39 00     739  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
0000157D= 38 38 38 38 3F 3F 00     740  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
00001584                           741  
00001584                           742  MOVE:
00001584                           743          
00001584                           744  
00001584                           745          
00001584  7000                     746          MOVEQ.L #0, D0 ;clear D0
00001586                           747          
00001586                           748  validMoveSourceModes:
00001586                           749          
00001586  43F8 156D                750          LEA moveSourceEAmasks,A1 ;load the list of masks
0000158A  D3C0                     751          ADDA.L D0,A1 ;displace to a specific mask
0000158C  1A11                     752          MOVE.B (A1),D5 ;move the mask to D5
0000158E                           753          
0000158E  0C05 0000                754          CMPI.B #0,D5 ;check if the mask is 0
00001592  6700 FADC                755          BEQ falsePositive ;branch if it is
00001596                           756          
00001596  1401                     757          MOVE.B D1,D2 ;copy instruction to D2
00001598  C405                     758          AND.B D5,D2  ;mask D2
0000159A                           759          
0000159A  43F8 1564                760          LEA moveSourceEA,A1 ;load the list of valid modes
0000159E  D3C0                     761          ADDA.L D0,A1 ;displace to a specific mode
000015A0  1811                     762          MOVE.B (A1),D4 ;move mode to D4
000015A2  B404                     763          CMP.B D4,D2 ;compare mode to masked value
000015A4  6700 0006                764          BEQ  checkMoveDest ;if its match, its a valid mode and we can procede
000015A8                           765          
000015A8  5280                     766          ADDQ.L #1,D0 ;add one to displacement
000015AA  60DA                     767          BRA validMoveSourceModes ;check for next mode
000015AC                           768          
000015AC                           769  checkMoveDest:
000015AC  7000                     770          MOVEQ.L #0, D0 ;clear D0
000015AE                           771          
000015AE                           772  validMoveDestModes:
000015AE                           773          
000015AE  43F8 157D                774          LEA moveDestEAmasks,A1 ;load the list of masks
000015B2  D3C0                     775          ADDA.L D0,A1 ;displace to a specific mask
000015B4  1A11                     776          MOVE.B (A1),D5 ;move the mask to D5
000015B6                           777          
000015B6  0C05 0000                778          CMPI.B #0,D5 ;check if the mask is 0
000015BA  6700 FAB4                779          BEQ falsePositive ;branch if it is
000015BE                           780          
000015BE  3401                     781          MOVE.W D1,D2 ;copy instruction to D2
000015C0  EC4A                     782          LSR.W #6,D2  ;move mode
000015C2  6100 04C2                783          BSR switchModeAndReg ;switch register and mode
000015C6  C405                     784          AND.B D5,D2  ;mask D2
000015C8                           785          
000015C8  43F8 1576                786          LEA moveDestEA,A1 ;load the list of valid modes
000015CC  D3C0                     787          ADDA.L D0,A1 ;displace to a specific mode
000015CE  1811                     788          MOVE.B (A1),D4 ;move mode to D4
000015D0  B404                     789          CMP.B D4,D2 ;compare mode to masked value
000015D2  6700 0006                790          BEQ moveBody ;if its match, its a valid mode and we can procede
000015D6                           791          
000015D6  5280                     792          ADDQ.L #1,D0 ;add one to displacement
000015D8  60D4                     793          BRA validMoveDestModes ;check for next mode
000015DA                           794          
000015DA                           795  moveBody
000015DA  3401                     796          MOVE.W  D1,D2 ;copy inst to D2
000015DC  C47C 3000                797          AND.W  #%0011000000000000,D2 ;mask word for size
000015E0  0C42 0000                798          CMPI.W #0,D2 ;0 is the only non valid size
000015E4  6700 FA8A                799          BEQ falsePositive ; if zero, this is not move
000015E8                           800  
000015E8  43F9 00001C98            801          LEA     moveMessage,A1  ;move string for MOVE
000015EE  103C 000E                802          MOVE.B  #14,D0        ;set for task to display null terminated 
000015F2                           803                                ;string with CR, LF
000015F2  4E4F                     804          TRAP    #15
000015F4                           805          
000015F4                           806          
000015F4  3401                     807          MOVE.W  D1,D2 ;check source mode
000015F6  C43C 003F                808          AND.B   #%00111111,D2
000015FA  1A02                     809          MOVE.B  D2,D5
000015FC  48E7 4000                810          MOVEM.L D1,-(SP)
00001600  6100 0310                811          BSR     Get_Effective_Address
00001604  4CDF 0002                812          MOVEM.L (SP)+,D1
00001608                           813          
00001608                           814          ;print separator
00001608                           815          
00001608  3401                     816          MOVE.W  D1,D2 ;check dest mode
0000160A  EC4A                     817          LSR.W   #6,D2
0000160C  6100 0478                818          BSR  switchModeAndReg
00001610  C43C 003F                819          AND.B   #%00111111,D2
00001614  1A02                     820          MOVE.B  D2,D5
00001616  48E7 4000                821          MOVEM.L D1,-(SP)
0000161A  6100 02F6                822          BSR     Get_Effective_Address
0000161E  4CDF 0002                823          MOVEM.L (SP)+,D1
00001622                           824          
00001622                           825          
00001622                           826          
00001622  43F9 00001C62            827          LEA     clearLine,A1  ;move string for a CR and LF
00001628  103C 000E                828          MOVE.B  #14,D0        ;set for task to display null terminated 
0000162C                           829                                ;string without CR, LF
0000162C  4E4F                     830          TRAP    #15
0000162E                           831  
0000162E  7000                     832          MOVEQ.L #0,D0
00001630  4E75                     833          RTS
00001632                           834          
00001632= 08 00                    835  moveADestEA        DC.B %001000,0
00001634= 38 00                    836  moveADestEAmasks   DC.B %111000,0
00001636                           837          
00001636                           838  MOVEA:
00001636                           839  
00001636  7000                     840          MOVEQ.L #0, D0 ;clear D0
00001638                           841          
00001638                           842  validMoveASourceModes:
00001638                           843          
00001638  43F8 156D                844          LEA moveSourceEAmasks,A1 ;load the list of masks
0000163C  D3C0                     845          ADDA.L D0,A1 ;displace to a specific mask
0000163E  1A11                     846          MOVE.B (A1),D5 ;move the mask to D5
00001640                           847          
00001640  0C05 0000                848          CMPI.B #0,D5 ;check if the mask is 0
00001644  6700 FA2A                849          BEQ falsePositive ;branch if it is
00001648                           850          
00001648  1401                     851          MOVE.B D1,D2 ;copy instruction to D2
0000164A  C405                     852          AND.B D5,D2  ;mask D2
0000164C                           853          
0000164C  43F8 1564                854          LEA moveSourceEA,A1 ;load the list of valid modes
00001650  D3C0                     855          ADDA.L D0,A1 ;displace to a specific mode
00001652  1811                     856          MOVE.B (A1),D4 ;move mode to D4
00001654  B404                     857          CMP.B D4,D2 ;compare mode to masked value
00001656  6700 0006                858          BEQ  checkMoveADest ;if its match, its a valid mode and we can procede
0000165A                           859          
0000165A  5280                     860          ADDQ.L #1,D0 ;add one to displacement
0000165C  60DA                     861          BRA validMoveASourceModes ;check for next mode
0000165E                           862          
0000165E                           863  checkMoveADest:
0000165E  7000                     864          MOVEQ.L #0, D0 ;clear D0
00001660                           865  validMoveADestModes:
00001660                           866          
00001660  43F8 1634                867          LEA moveADestEAmasks,A1 ;load the list of masks
00001664  D3C0                     868          ADDA.L D0,A1 ;displace to a specific mask
00001666  1A11                     869          MOVE.B (A1),D5 ;move the mask to D5
00001668                           870          
00001668  0C05 0000                871          CMPI.B #0,D5 ;check if the mask is 0
0000166C  6700 FA02                872          BEQ falsePositive ;branch if it is
00001670                           873          
00001670  3401                     874          MOVE.W D1,D2 ;copy instruction to D2
00001672  EA4A                     875          LSR.W #5,D2  ;move mode
00001674  6100 0410                876          BSR switchModeAndReg ;switch register and mode
00001678  C405                     877          AND.B D5,D2  ;mask D2
0000167A                           878          
0000167A  43F8 1632                879          LEA moveADestEA,A1 ;load the list of valid modes
0000167E  D3C0                     880          ADDA.L D0,A1 ;displace to a specific mode
00001680  1811                     881          MOVE.B (A1),D4 ;move mode to D4
00001682  B404                     882          CMP.B D4,D2 ;compare mode to masked value
00001684  6700 0006                883          BEQ moveABody ;if its match, its a valid mode and we can procede
00001688                           884          
00001688  5280                     885          ADDQ.L #1,D0 ;add one to displacement
0000168A  60D4                     886          BRA validMoveADestModes ;check for next mode
0000168C                           887  moveABody:
0000168C  3401                     888          MOVE.W  D1,D2 ;copy inst to D2
0000168E  C47C 3000                889          AND.W  #%0011000000000000,D2 ;mask word for size
00001692  0C42 0000                890          CMPI.W #0,D2 ;0 is the non valid size
00001696  6700 F9D8                891          BEQ falsePositive ; if zero, this is not move
0000169A  0C42 1000                892          CMPI.W #%0001000000000000,D2
0000169E  6700 F9D0                893          BEQ falsePositive ; if byte, this is not movea
000016A2                           894  
000016A2                           895  
000016A2  43F9 00001CAE            896          LEA     moveAMessage,A1  ;move string for MOVE
000016A8  103C 000D                897          MOVE.B  #13,D0        ;set for task to display null terminated 
000016AC                           898                                ;string with CR, LF
000016AC  4E4F                     899          TRAP    #15
000016AE                           900  
000016AE  7000                     901          MOVEQ.L #0,D0
000016B0  4E75                     902          RTS
000016B2                           903  
000016B2                           904             
000016B2                           905  Bcc:
000016B2                           906  
000016B2  43F9 00001C9F            907          LEA     bccMessage,A1  ;move string for BRA info
000016B8  103C 000E                908          MOVE.B  #14,D0        ;set for task to display null terminated 
000016BC                           909                                ;string without CR, LF
000016BC  4E4F                     910          TRAP    #15
000016BE                           911          
000016BE  7000                     912          MOVEQ.L #0,D0 ;clear D0
000016C0  3401                     913          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
000016C2  E04A                     914          LSR.W   #8,D2
000016C4  C47C 000F                915          AND.W   #$0F,D2 ;mask instruction
000016C8                           916          
000016C8                           917  checkCC:        
000016C8  41F9 00001BE9            918          LEA     bccList,A0 ;get condition code signature list in A0
000016CE  D1C0                     919          ADDA.L  D0,A0 ;get correct sig         
000016D0  B410                     920          CMP.B   (A0),D2 ;compare to sig
000016D2  6700 0006                921          BEQ     foundCC ;if sig matches branch
000016D6  5200                     922          ADDQ.B  #byte,D0
000016D8  60EE                     923          BRA     checkCC
000016DA                           924  foundCC:
000016DA  43F9 00001BFA            925          LEA     conditionCodeMessage,A1 ;get condition code message in A1
000016E0  C0FC 0004                926          MULU.W  #long,D0 ;adjust size of D0 for a long
000016E4  D3C0                     927          ADDA.L  D0,A1 ;get correct message location
000016E6  2251                     928          MOVEA.L (A1),A1 ;get correct message
000016E8                           929          
000016E8  103C 000E                930          MOVE.B  #14,D0        ;set for task to display null terminated 
000016EC                           931                                ;string without CR, LF
000016EC  4E4F                     932          TRAP    #15
000016EE                           933  
000016EE                           934          
000016EE                           935          
000016EE  548B                     936          ADDQ.L  #word,A3 ;move past instruction in case long displacement
000016F0  C27C 00FF                937          AND.W   #$00FF,D1   ;check for word sized displacement
000016F4                           938          
000016F4  B23C 0000                939          CMP.B   #$0,D1
000016F8  6700 0010                940          BEQ     BccWord
000016FC                           941          
000016FC  B23C 00FF                942          CMP.B   #$FF,D1 check for long sized displacement
00001700  6700 0010                943          BEQ     BccLong
00001704                           944          
00001704                           945  BccByte:
00001704                           946          
00001704  7E00                     947          MOVEQ.L #0,D7 ;pass back no extra data followed
00001706  6000 0012                948          BRA     BccDone
0000170A                           949  BccWord:
0000170A  3213                     950          MOVE.W  (A3),D1
0000170C                           951          
0000170C  7E02                     952          MOVEQ.L #word,D7 ;pass back an extra word followed
0000170E  6000 000A                953          BRA     BccDone
00001712                           954  BccLong:
00001712  2213                     955          MOVE.L  (A3),D1
00001714                           956          
00001714  7E04                     957          MOVEQ.L #long,D7 ;pass back an extra long followed
00001716  6000 0002                958          BRA     BccDone
0000171A                           959  BccDone:
0000171A                           960  
0000171A  343C 0010                961          MOVE.W  #16,D2 ;put base in D2
0000171E  303C 000F                962          MOVE.W  #15,D0  ;put task #15 in D0
00001722  4E4F                     963          TRAP    #15
00001724                           964          
00001724  43F9 00001C62            965          LEA     clearLine,A1  ;move string for a CR and LF
0000172A  103C 000E                966          MOVE.B  #14,D0        ;set for task to display null terminated 
0000172E                           967                                ;string without CR, LF
0000172E  4E4F                     968          TRAP    #15
00001730                           969  
00001730  7000                     970          MOVEQ.L #0,D0
00001732  4E75                     971          RTS
00001734                           972          
00001734                           973          
00001734                           974  unknownOpCode:
00001734  43F9 00001CA7            975          LEA     dataMessage,A1 ;move string for data info
0000173A  103C 000E                976          MOVE.B  #14,D0        ;set for task to display null terminated 
0000173E                           977                                ;string without CR, LF
0000173E  4E4F                     978          TRAP    #15
00001740                           979          
00001740  143C 0010                980          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001744  103C 000F                981          MOVE.B  #15,D0
00001748  4E4F                     982          TRAP    #15
0000174A                           983          
0000174A  43F9 00001C62            984          LEA     clearLine,A1  ;move string for a CR and LF
00001750  103C 000E                985          MOVE.B  #14,D0        ;set for task to display null terminated 
00001754                           986                                ;string without CR, LF
00001754  4E4F                     987          TRAP    #15
00001756                           988          
00001756  7000                     989          MOVEQ.L #0,D0
00001758  4E75                     990          RTS
0000175A                           991          
0000175A                           992  handlebytedata:
0000175A                           993  
0000175A  43F9 00001CA7            994          LEA     dataMessage,A1 ;move string for data info
00001760  103C 000E                995          MOVE.B  #14,D0        ;set for task to display null terminated 
00001764                           996                                ;string without CR, LF
00001764  4E4F                     997          TRAP    #15
00001766                           998          
00001766  E049                     999          LSR.W   #8,D1 ;shift the word read into D1 by a byte
00001768                          1000          
00001768  143C 0010               1001          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
0000176C  103C 000F               1002          MOVE.B  #15,D0
00001770  4E4F                    1003          TRAP    #15
00001772                          1004          
00001772  43F9 00001C62           1005          LEA     clearLine,A1  ;move string for a CR and LF
00001778  103C 000E               1006          MOVE.B  #14,D0        ;set for task to display null terminated 
0000177C                          1007                                ;string without CR, LF
0000177C  4E4F                    1008          TRAP    #15
0000177E                          1009          
0000177E  7000                    1010          MOVEQ.L #0,D0
00001780                          1011          
00001780  528B                    1012          ADDQ.L  #byte,A3
00001782  6000 F8A2               1013          BRA main_Loop
00001786                          1014  
00001786                          1015          
00001786                          1016          
00001786                          1017  fin
00001786                          1018  
00001786                          1019          
00001786                          1020          
00001786  FFFF FFFF               1021          simhalt
0000178A                          1022          
0000178A                          1023  
0000178A                          1024  *******************************************************************************
0000178A                          1025  *                            SUB ROUTINES
0000178A                          1026  *******************************************************************************
0000178A                          1027  
0000178A                          1028  *******************************************************************************
0000178A                          1029  *                          IO ROLE ROUTINES
0000178A                          1030  *******************************************************************************
0000178A                          1031  
0000178A                          1032  *==========================================================================
0000178A                          1033  *                   Enter / Validate beginning address 
0000178A                          1034  *==========================================================================
0000178A                          1035   
0000178A                          1036  begin_address:
0000178A                          1037  
0000178A                          1038         
0000178A  43F9 00001A9A           1039          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00001790  2239 00001A9A           1040          MOVE.L      slPrompt,D1         ;Load display length to D1
00001796  700E                    1041          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001798  4E4F                    1042          TRAP        #15                 ;Perform task 14 (display)
0000179A                          1043          
0000179A  43F9 00001CE0           1044          LEA         startLocation,A1    ;Load address to store user input
000017A0  103C 0002               1045          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
000017A4  4E4F                    1046          TRAP        #15                 ;Perform task 2 (input)
000017A6                          1047          
000017A6  0C11 001B               1048          CMP.B       #27,(A1)            ;Check for ESC entered
000017AA  6700 004C               1049          BEQ         address_Exit        ;Exit condition 
000017AE                          1050          
000017AE  6100 0050               1051          BSR         enter_addr_edit_all
000017B2  B67C FFFF               1052          CMP.W       #-1,D3              ;Did the edit pass?
000017B6  67D2                    1053          BEQ         begin_address       ;No, loop and ask for correct input
000017B8                          1054          
000017B8  2643                    1055          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
000017BA                          1056          
000017BA  43F9 00001BA7           1057          LEA         spc,A1              ;Load address for starting loaction prompt
000017C0  1239 00001BA8           1058          MOVE.B      spc_len,D1          ;Load empty line length
000017C6  7000                    1059          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
000017C8  4E4F                    1060          TRAP        #15                 ;Perform task 14 (display)
000017CA  6000 0002               1061          BRA         end_address
000017CE                          1062  
000017CE                          1063  *===========================================================================
000017CE                          1064  *                   Enter / Validate ending address 
000017CE                          1065  *===========================================================================
000017CE                          1066  
000017CE                          1067  end_address:
000017CE                          1068          
000017CE  43F9 00001ACB           1069          LEA         elPrompt,A1         ;Load address for ending loaction prompt
000017D4                          1070          ;MOVE.L     elPrompt,D1         ;Load display length to D1
000017D4  7250                    1071          MOVE.L      #80,D1       ;did not like previous command, do not know why, it should have worked
000017D6  700E                    1072          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
000017D8  4E4F                    1073          TRAP        #15                 ;Perform task 14 (display)
000017DA                          1074          
000017DA  103C 0002               1075          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
000017DE  4E4F                    1076          TRAP        #15                 ;Perform task 2 (input)
000017E0                          1077          
000017E0  0C11 001B               1078          CMP.B       #27,(A1)            ;Check for ESC entered
000017E4  6700 0012               1079          BEQ         address_Exit        ;Exit condition 
000017E8                          1080          
000017E8  6100 0016               1081          BSR         enter_addr_edit_all
000017EC  B67C FFFF               1082          CMP.W       #-1,D3              ;Did the edit pass?
000017F0  67DC                    1083          BEQ         end_address         ;No, loop and ask for correct input
000017F2                          1084  
000017F2  2843                    1085          MOVEA.L     D3,A4               ;Ending address gets stored in A4
000017F4  6000 0008               1086          BRA         address_done
000017F8                          1087  
000017F8                          1088  address_Exit:
000017F8                          1089  
000017F8  76FF                    1090          MOVE.L      #-1,D3              ;Load -1 into return parameter
000017FA  6000 0002               1091          BRA         address_done
000017FE                          1092          
000017FE                          1093  address_done:
000017FE                          1094  
000017FE  4E75                    1095          RTS    
00001800                          1096  
00001800                          1097  *==============================================================================
00001800                          1098  * enter_addr_edit_all - Enter address edit check to edit all errors  
00001800                          1099  *                       using multiple different error checking routines.
00001800                          1100  *
00001800                          1101  * Parameters -
00001800                          1102  *   Input   A1      The data that needs checked.
00001800                          1103  *   Input   D1      The number of characters input     
00001800                          1104  *   Output  D3      Returns '-1' when there is an error.
00001800                          1105  *==============================================================================
00001800                          1106  
00001800                          1107  enter_addr_edit_all
00001800                          1108  
00001800                          1109  *------------------------------------------------------------------------------
00001800                          1110  * Test for odd number of characters entered, not allowed
00001800                          1111  *------------------------------------------------------------------------------
00001800                          1112         
00001800  6100 0024               1113          BSR         ck_boundry          ;check if the input is on a odd / even boundry
00001804  B67C FFFF               1114          CMP.W       #-1,D3              ;Is the address odd?
00001808  6700 001A               1115          BEQ         enter_addr_edit_all_exit     ;No, return
0000180C                          1116  
0000180C                          1117  *------------------------------------------------------------------------------
0000180C                          1118  * Ttest for character entered all being valid address characters
0000180C                          1119  * Note: lower case a-f, gets converted to upper case A-F in D3
0000180C                          1120  *------------------------------------------------------------------------------
0000180C                          1121          
0000180C  6100 0062               1122          BSR         parseHexString      ;check if the input contains valid Hex characters
00001810  B67C FFFF               1123          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
00001814  6700 000E               1124          BEQ         enter_addr_edit_all_exit     ;No, return
00001818                          1125  
00001818                          1126  *------------------------------------------------------------------------------
00001818                          1127  * Verify that the address entered is witin the range defined in the Equate
00001818                          1128  *------------------------------------------------------------------------------        
00001818                          1129          
00001818  6100 00C8               1130          BSR         ck_addr_range       ;is address entered witin the range 
0000181C                          1131                                          ;   as defined in the Equate? 
0000181C  B67C FFFF               1132          CMP.W       #-1,D3              ;is the address  valid?
00001820  6700 0002               1133          BEQ         enter_addr_edit_all_exit     ;No, return
00001824                          1134  
00001824                          1135  enter_addr_edit_all_exit:
00001824                          1136  
00001824  4E75                    1137          RTS                             ;return
00001826                          1138  
00001826                          1139  *==============================================================================
00001826                          1140  * ck_boundry - Check the size of the data characters input and determine
00001826                          1141  *              if an odd number of characters was entered
00001826                          1142  *
00001826                          1143  * Parameters -
00001826                          1144  *   Input   A1      The data that needs checked for odd length.
00001826                          1145  *   Input   D1      The number of characters input     
00001826                          1146  *   Output  D3      Returns '-1' when there is an odd length.
00001826                          1147  *==============================================================================
00001826                          1148  
00001826                          1149  ck_boundry:
00001826                          1150  
00001826  4243                    1151          CLR.W       D3                  ;Clear the return
00001828                          1152  
00001828  B23C 0000               1153          CMP.B       #0,D1               ;Check for nothing entered
0000182C  6700 002E               1154          BEQ         ck_size_error       ;Number of characters entered must be 
00001830                          1155                                          ;greater than 0  
00001830                          1156          
00001830                          1157          
00001830                          1158          * The program will branch to ck_size_error if D1 is greater than #8        
00001830  B23C 0008               1159          CMP.B       #8,D1               ;Check for more than 8 characters entered
00001834  6E00 0026               1160          BGT         ck_size_error       ;Number of characters entered must be less
00001838                          1161                                          ;than 9
00001838                          1162          
00001838  7402                    1163          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
0000183A  82C2                    1164          DIVU        D2,D1               ;Divide address by 2
0000183C  4841                    1165          SWAP        D1                  ;get remainder
0000183E  B23C 0001               1166          CMP.B       #$01,D1             ;Check for remainder of 1
00001842  6700 0004               1167          BEQ         ck_boundry_error    ;Number of characters entered must be an 
00001846                          1168                                          ;even number   
00001846                          1169    
00001846  4E75                    1170          RTS                             ;return
00001848                          1171  
00001848                          1172  *------------------------------------------------------------------------------
00001848                          1173  * ck_boundry_error - An odd number of characters was entered
00001848                          1174  *                  - Load error message and display it
00001848                          1175  *                  - Return error condition
00001848                          1176  *------------------------------------------------------------------------------
00001848                          1177          
00001848                          1178  ck_boundry_error:
00001848                          1179  
00001848  43F9 00001B87           1180          LEA         even_msg,A1         ;Load odd error message into A1
0000184E  2239 00001B87           1181          MOVE.L      even_msg,D1         ;Load error length to D1
00001854                          1182          
00001854  7000                    1183          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001856                          1184                                          ; n is D1.W with CR, LF. 
00001856  4E4F                    1185          TRAP #15                        ;Display the error message
00001858  76FF                    1186          MOVE.L #-1,D3                   ;Load -1 into return parameter
0000185A  4E75                    1187          RTS                             ;Return
0000185C                          1188          
0000185C                          1189  *------------------------------------------------------------------------------
0000185C                          1190  * ck_size_error -   The number of characters entered must be more than zero
0000185C                          1191  *                  - Load error message and display it
0000185C                          1192  *                  - Return error condition
0000185C                          1193  *------------------------------------------------------------------------------
0000185C                          1194          
0000185C                          1195  ck_size_error:
0000185C                          1196  
0000185C  43F9 00001AFA           1197          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001862  2239 00001AFA           1198          MOVE.L      invalidMsg,D1       ;Load error length to D1
00001868                          1199          
00001868  7000                    1200          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
0000186A                          1201                                          ; n is D1.W with CR, LF. 
0000186A  4E4F                    1202          TRAP        #15                 ;Display the error message
0000186C  76FF                    1203          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000186E  4E75                    1204          RTS                             ;Return        
00001870                          1205  
00001870                          1206  
00001870                          1207  *==============================================================================
00001870                          1208  * parseHexString - Converts user input string into a valid memory address
00001870                          1209  *                - Stores parsed address data into D3
00001870                          1210  *                - Stores good/bad (1/0) data in D4 
00001870                          1211  *
00001870                          1212  * Hex values are stored as bytes in D2, the ASCII chart shows their value
00001870                          1213  *   The ASCII chart values we care about are in the ranges of: 
00001870                          1214  *                            Hex            Decimal
00001870                          1215  *       No Value           NULL = 0         0
00001870                          1216  *       Numeric Values:     0-9 = 30-39     48-57
00001870                          1217  *       Upper Case letters: A-F = 41-46     65-70
00001870                          1218  *       Lower Case letterc: a-f = 61-66     97-102
00001870                          1219  
00001870                          1220  * Parameters -
00001870                          1221  *   Input   A1      The data that needs checked for valid input.
00001870                          1222  *   Output  D3      The return value, '-1' for error
00001870                          1223  *==============================================================================
00001870                          1224  
00001870                          1225  parseHexString:
00001870                          1226  
00001870                          1227  * setup any initializing item that do not get looped through
00001870  4243                    1228          CLR.W       D3                  ;Clear the return
00001872                          1229  
00001872                          1230          
00001872                          1231  *------------------------------------------------------------------------------
00001872                          1232  * NextHex - Loop through all bytes and vaildate the input
00001872                          1233  * Parameters -
00001872                          1234  *   Input   A1      The data that needs checked for valid input.
00001872                          1235  *   Output  D3      The return value, '-1' for error
00001872                          1236  *------------------------------------------------------------------------------
00001872                          1237          
00001872                          1238  NextHex:
00001872                          1239  
00001872  1419                    1240          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00001874  B43C 0000               1241          CMP.B       #0,D2               ;Check character for null 
00001878  6700 0066               1242          BEQ         NextHexReturn       ;Character is null (end of input)
0000187C                          1243          
0000187C                          1244  *................................................................................
0000187C                          1245  *  Check decimal values 0-9 by testing hexadecimal values 30-39
0000187C                          1246  *................................................................................
0000187C                          1247                  
0000187C                          1248          * The program will branch to hex_range_error if D2 is less than #30
0000187C  B43C 0030               1249          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
00001880  6D00 0048               1250          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001884                          1251                                          ;processing
00001884                          1252          
00001884                          1253          * The program will branch to UcaseHex if D2 is greater than #39
00001884  B43C 0039               1254          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
00001888  6E00 000A               1255          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
0000188C                          1256          
0000188C                          1257          *a valid number was found within this range
0000188C  0402 0030               1258          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
00001890  6000 0032               1259          BRA         NextHexDone         ;Done parsing this byte
00001894                          1260  
00001894                          1261  
00001894                          1262  *..............................................................................
00001894                          1263  *  Check upper case values A-F by testing hexadecimal values 41-46
00001894                          1264  *..............................................................................
00001894                          1265  
00001894                          1266  UcaseHex:
00001894                          1267  
00001894                          1268          * The program will branch to hex_range_error if D2 is less than #41
00001894  B43C 0041               1269          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
00001898  6D00 0030               1270          BLT         hex_range_error     ;Branch to handle range error hexidecimal
0000189C                          1271                                          ;processing
0000189C                          1272          
0000189C  B43C 0046               1273          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
000018A0  6E00 000A               1274          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
000018A4                          1275                                          ;processing
000018A4                          1276          
000018A4                          1277          *a valid number was found within this range
000018A4  0402 0037               1278          SUBI.B      #55,D2              ;Change uppercase character to actual value
000018A8  6000 001A               1279          BRA         NextHexDone         ;Done parsing this byte
000018AC                          1280  
000018AC                          1281  
000018AC                          1282  *..............................................................................
000018AC                          1283  *  Check lower case values a-f by testing hexadecimal values 61-66
000018AC                          1284  *..............................................................................
000018AC                          1285  
000018AC                          1286  LcaseHex
000018AC                          1287          
000018AC                          1288          * The program will branch to hex_range_error if D2 is less than #61
000018AC  B43C 0061               1289          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
000018B0  6D00 0018               1290          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
000018B4                          1291                                          ;processing
000018B4                          1292  
000018B4  B43C 0066               1293          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
000018B8  6E00 0010               1294          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
000018BC                          1295                                          ;processing
000018BC                          1296  
000018BC                          1297          *a valid number was found within this range
000018BC  0402 0057               1298          SUBI.B      #87,D2              ;Change lowercase character to actual value
000018C0  6000 0002               1299          BRA         NextHexDone         ;Done parsing this byte
000018C4                          1300  
000018C4                          1301  NextHexDone:
000018C4                          1302  
000018C4  E983                    1303          ASL.L       #4,D3               ; Make rooom for new byte in the return register
000018C6  D602                    1304          ADD.B       D2,D3               ; Move the new byte into the return register
000018C8  60A8                    1305          BRA         NextHex             ; We're ready to parse the next byte
000018CA                          1306          
000018CA                          1307  *-------------------------------------------------------------------------------------
000018CA                          1308  * hex_range_error -  A character entered was within the valid range for a hex address
000018CA                          1309  *                 -  Load error message and display it
000018CA                          1310  *                 -  Return error condition
000018CA                          1311  *-------------------------------------------------------------------------------------
000018CA                          1312          
000018CA                          1313  hex_range_error:
000018CA                          1314  
000018CA  43F9 00001B3F           1315          LEA         invCharMsg,A1       ;Load invalid range message into A1
000018D0  2239 00001B3F           1316          MOVE.L      invCharMsg,D1       ;Load error length to D1
000018D6                          1317          
000018D6  7000                    1318          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
000018D8                          1319                                          ; n is D1.W with CR, LF. 
000018D8  4E4F                    1320          TRAP        #15                 ;Display the error message
000018DA  76FF                    1321          MOVE.L      #-1,D3              ;Load -1 into return parameter
000018DC  6000 0002               1322          BRA         NextHexReturn
000018E0                          1323          
000018E0                          1324  NextHexReturn:
000018E0                          1325          
000018E0  4E75                    1326          RTS                             ;Return      
000018E2                          1327  
000018E2                          1328  
000018E2                          1329  *===============================================================================
000018E2                          1330  * ck_addr_range - check the address input is within a valid memory address range
000018E2                          1331  *                - Parsed address data into D3
000018E2                          1332  *
000018E2                          1333  * Parameters -
000018E2                          1334  *   Input   A1      The data that needs checked for valid address.
000018E2                          1335  *   Output  D3      The return value, '-1' for error
000018E2                          1336  *===============================================================================
000018E2                          1337  
000018E2                          1338  
000018E2                          1339  ck_addr_range:   
000018E2                          1340  
000018E2                          1341  *------------------------------------------------------------------------------
000018E2                          1342  * Verify that the address entered is witin the 
000018E2                          1343  * beginning range ('begin') as defined in the Equate
000018E2                          1344  *------------------------------------------------------------------------------   
000018E2                          1345              
000018E2  2C3C 00005001           1346          MOVE.L      #begin,D6           * Load minimum starting address
000018E8  B686                    1347          CMP.L       D6,D3               * Is input at or above minimum?
000018EA  6D00 0012               1348          BLT         ck_addr_range_error 
000018EE                          1349          
000018EE                          1350  *------------------------------------------------------------------------------
000018EE                          1351  * Verify that the address entered is witin the 
000018EE                          1352  * ending range ('end') as defined in the Equate
000018EE                          1353  *------------------------------------------------------------------------------
000018EE                          1354          
000018EE  2C3C 00FFFFFE           1355          MOVE.L      #end,D6             * Load maximum starting address
000018F4  B686                    1356          CMP.L       D6,D3               * Is input at or below maximum?
000018F6  6E00 0006               1357          BGT         ck_addr_range_error 
000018FA  6000 0012               1358          BRA         ck_addr_done        ;done checking
000018FE                          1359          
000018FE                          1360  *..............................................................................
000018FE                          1361  * ck_addr_range_error -  A address entered is not within the 
000018FE                          1362  *                        valid range for a hex address
000018FE                          1363  *..............................................................................
000018FE                          1364          
000018FE                          1365  ck_addr_range_error
000018FE                          1366  
000018FE  43F9 00001AFA           1367          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001904                          1368          
00001904  700D                    1369          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
00001906                          1370                                          ;with CR, LF. 
00001906  4E4F                    1371          TRAP        #15                 ;Display the error message
00001908  76FF                    1372          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000190A  6000 0002               1373          BRA         ck_addr_done 
0000190E                          1374  
0000190E                          1375  ck_addr_done:
0000190E                          1376  
0000190E  4E75                    1377          RTS                             ;Return
00001910                          1378  
00001910                          1379  *******************************************************************************
00001910                          1380  *                          OP CODE ROLE ROUTINES
00001910                          1381  *******************************************************************************
00001910                          1382  
00001910                          1383  process_op_codes:
00001910                          1384  
00001910                          1385  
00001910                          1386  
00001910                          1387  process_op_codes_exit:
00001910                          1388  
00001910  4E75                    1389          RTS
00001912                          1390  
00001912                          1391  
00001912                          1392  *******************************************************************************
00001912                          1393  *                    Effective Addressing ROLE ROUTINES
00001912                          1394  *******************************************************************************
00001912                          1395  
00001912                          1396  Get_Effective_Address:
00001912                          1397  
00001912  1C05                    1398          MOVE.B      D5,D6
00001914  E60E                    1399          LSR.B       #3,D6               ;mode
00001916  CA3C 0007               1400          And.B       #%00000111,D5       ;register
0000191A                          1401          
0000191A  BC3C 0000               1402          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
0000191E  6700 004A               1403          BEQ         Data_Reg_Direct
00001922                          1404          
00001922  BC3C 0001               1405          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
00001926  6700 0076               1406          BEQ         Addr_Reg_Indirect
0000192A                          1407          
0000192A  BC3C 0002               1408          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
0000192E  6700 006E               1409          BEQ         Addr_Reg_Indirect
00001932                          1410          
00001932  BC3C 0003               1411          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
00001936  6700 0098               1412          BEQ         Addr_Reg_Indirect_Inc
0000193A                          1413          
0000193A  BC3C 0004               1414          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
0000193E  6700 00CE               1415          BEQ         Addr_Reg_Indirect_Dec
00001942                          1416          
00001942  BC3C 0007               1417          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
00001946  6700 0006               1418          BEQ         Get_Effective_Address_Other
0000194A                          1419          
0000194A  6000 0138               1420          BRA         invalidEA
0000194E                          1421          
0000194E                          1422  Get_Effective_Address_Other:        
0000194E                          1423          
0000194E  BA3C 0000               1424          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00001952  6700 00F8               1425          BEQ Addr_Abs_Short
00001956                          1426          
00001956  BA3C 0001               1427          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
0000195A  6700 0104               1428          BEQ Addr_Abs_Long
0000195E                          1429          
0000195E  BA3C 0004               1430          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
00001962  6700 0110               1431          BEQ Addr_Immediate_Data
00001966                          1432          
00001966  6000 011C               1433          BRA         invalidEA
0000196A                          1434          
0000196A                          1435  Data_Reg_Direct:                        ;case 0(0000)
0000196A                          1436  
0000196A  43F9 00001CD6           1437          LEA         letterD,A1          ;output 'D' for data register
00001970  103C 000E               1438          MOVE.B      #14,D0              ;set for task to display null terminated 
00001974  4E4F                    1439          TRAP        #15                 ;string without CR, LF
00001976                          1440                          
00001976  4281                    1441          CLR.L       D1
00001978  1205                    1442          MOVE.B      D5,D1               ;move register number for display into D1
0000197A  103C 0003               1443          MOVE.B      #3,D0               ;set for task to display null terminated 
0000197E  4E4F                    1444          TRAP        #15                 ;string without CR, LF
00001980                          1445                 
00001980  6000 0102               1446          BRA         Get_Effective_Address_Exit  ;return
00001984                          1447          
00001984                          1448          
00001984                          1449  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
00001984                          1450        
00001984  43F9 00001CD4           1451          LEA         letterA,A1          ;output 'A' for address register
0000198A  103C 000E               1452          MOVE.B      #14,D0              ;set for task to display null terminated 
0000198E  4E4F                    1453          TRAP        #15                 ;string without CR, LF
00001990                          1454          
00001990  4281                    1455          CLR.L       D1
00001992  1205                    1456          MOVE.B      D5,D1               ;move register number for display into D1
00001994  103C 0003               1457          MOVE.B      #3,D0               ;set for task to display null terminated 
00001998  4E4F                    1458          TRAP        #15                 ;string without CR, LF
0000199A                          1459          
0000199A  6000 00E8               1460          BRA         Get_Effective_Address_Exit  ;return
0000199E                          1461  
0000199E                          1462  
0000199E                          1463  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
0000199E                          1464          
0000199E  43F9 00001CDC           1465          LEA         lprn,A1             ;output 'D' for data register
000019A4  103C 000E               1466          MOVE.B      #14,D0              ;set for task to display null terminated 
000019A8  4E4F                    1467          TRAP        #15                 ;string without CR, LF
000019AA                          1468  
000019AA  43F9 00001CD4           1469          LEA         letterA,A1          ;output 'A' for address register
000019B0  103C 000E               1470          MOVE.B      #14,D0              ;set for task to display null terminated 
000019B4  4E4F                    1471          TRAP        #15                 ;string without CR, LF
000019B6                          1472          
000019B6  4281                    1473          CLR.L       D1
000019B8  1205                    1474          MOVE.B      D5,D1               ;move register number for display into D1
000019BA  103C 0003               1475          MOVE.B      #3,D0               ;set for task to display null terminated 
000019BE  4E4F                    1476          TRAP        #15                 ;string without CR, LF
000019C0                          1477  
000019C0  43F9 00001CDE           1478          LEA         rprn,A1             ;output 'D' for data register
000019C6  103C 000E               1479          MOVE.B      #14,D0              ;set for task to display null terminated 
000019CA  4E4F                    1480          TRAP        #15                 ;string without CR, LF
000019CC                          1481          
000019CC  6000 00B6               1482          BRA         Get_Effective_Address_Exit  ;return
000019D0                          1483  
000019D0                          1484                 
000019D0                          1485  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
000019D0                          1486  
000019D0  43F9 00001CDC           1487          LEA         lprn,A1             ;output 'D' for data register
000019D6  103C 000E               1488          MOVE.B      #14,D0              ;set for task to display null terminated 
000019DA  4E4F                    1489          TRAP        #15                 ;string without CR, LF
000019DC                          1490  
000019DC  43F9 00001CD4           1491          LEA         letterA,A1          ;output 'A' for address register
000019E2  103C 000E               1492          MOVE.B      #14,D0              ;set for task to display null terminated 
000019E6  4E4F                    1493          TRAP        #15                 ;string without CR, LF
000019E8                          1494          
000019E8  4281                    1495          CLR.L       D1
000019EA  1205                    1496          MOVE.B      D5,D1               ;move register number for display into D1
000019EC  103C 0003               1497          MOVE.B      #3,D0               ;set for task to display null terminated 
000019F0  4E4F                    1498          TRAP        #15                 ;string without CR, LF
000019F2                          1499  
000019F2  43F9 00001CDE           1500          LEA         rprn,A1             ;output 'D' for data register
000019F8  103C 000E               1501          MOVE.B      #14,D0              ;set for task to display null terminated 
000019FC  4E4F                    1502          TRAP        #15                 ;string without CR, LF
000019FE                          1503          
000019FE  43F9 00001CD8           1504          LEA         plus,A1             ;output 'D' for data register
00001A04  103C 000E               1505          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A08  4E4F                    1506          TRAP        #15                 ;string without CR, LF
00001A0A                          1507          
00001A0A  6000 0078               1508          BRA         Get_Effective_Address_Exit  ;return
00001A0E                          1509  
00001A0E                          1510  Addr_Reg_Indirect_Dec                   ;4 = (An) - Address Register Indirect with Predecrement (100)
00001A0E                          1511  
00001A0E  43F9 00001CDA           1512          LEA         minus,A1            ;output '-' for Predecrement
00001A14  103C 000E               1513          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A18  4E4F                    1514          TRAP        #15                 ;string without CR, LF
00001A1A                          1515  
00001A1A  43F9 00001CDC           1516          LEA         lprn,A1             ;output 'D' for data register
00001A20  103C 000E               1517          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A24  4E4F                    1518          TRAP        #15                 ;string without CR, LF
00001A26                          1519  
00001A26  43F9 00001CD4           1520          LEA         letterA,A1          ;output 'A' for address register
00001A2C  103C 000E               1521          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A30  4E4F                    1522          TRAP        #15                 ;string without CR, LF
00001A32                          1523          
00001A32  4281                    1524          CLR.L       D1
00001A34  1205                    1525          MOVE.B      D5,D1               ;move register number for display into D1
00001A36  103C 0003               1526          MOVE.B      #3,D0               ;set for task to display null terminated 
00001A3A  4E4F                    1527          TRAP        #15                 ;string without CR, LF
00001A3C                          1528  
00001A3C  43F9 00001CDE           1529          LEA         rprn,A1             ;output 'D' for data register
00001A42  103C 000E               1530          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A46  4E4F                    1531          TRAP        #15                 ;string without CR, LF
00001A48                          1532          
00001A48  6000 003A               1533          BRA         Get_Effective_Address_Exit  ;return
00001A4C                          1534          
00001A4C                          1535                         
00001A4C                          1536  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00001A4C                          1537          
00001A4C                          1538          
00001A4C  43F9 00001CB6           1539          LEA         xxxW,A1             ;output 'D' for data register
00001A52  103C 000E               1540          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A56  4E4F                    1541          TRAP        #15                 ;string without CR, LF
00001A58                          1542  
00001A58  548B                    1543          ADDA.L      #word,A3
00001A5A                          1544          
00001A5A                          1545          ;print word (A3)
00001A5A                          1546          ;MOVE.W      A3,(A1)
00001A5A                          1547          ;MOVE.B      #14,D0              ;set for task to display null terminated 
00001A5A                          1548          ;TRAP        #15                 ;string without CR, LF
00001A5A                          1549          
00001A5A  5487                    1550          ADDI.L      #word,D7 
00001A5C  6000 0026               1551          BRA         Get_Effective_Address_Exit  ;return
00001A60                          1552                         
00001A60                          1553  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
00001A60                          1554          
00001A60  43F9 00001CC0           1555          LEA         xxxL,A1             ;output 'D' for data register
00001A66  103C 000E               1556          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A6A  4E4F                    1557          TRAP        #15                 ;string without CR, LF
00001A6C                          1558  
00001A6C  548B                    1559          ADDA.L      #word,A3
00001A6E                          1560          
00001A6E                          1561          ;print long (A3)
00001A6E                          1562          ;MOVE.L      A3,(A1)
00001A6E                          1563          ;MOVE.B      #14,D0              ;set for task to display null terminated 
00001A6E                          1564          ;TRAP        #15                 ;string without CR, LF
00001A6E                          1565          
00001A6E  5887                    1566          ADDI.L      #long,D7
00001A70  6000 0012               1567          BRA         Get_Effective_Address_Exit  ;return
00001A74                          1568                         
00001A74                          1569  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
00001A74                          1570  
00001A74  43F9 00001CCA           1571          LEA         iData,A1            ;output 'D' for data register
00001A7A  103C 000E               1572          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A7E  4E4F                    1573          TRAP        #15                 ;string without CR, LF
00001A80                          1574          
00001A80                          1575          *need another input param for size
00001A80  6000 0002               1576          BRA         Get_Effective_Address_Exit  ;return
00001A84                          1577  
00001A84                          1578  invalidEA:
00001A84                          1579  
00001A84                          1580          ;do something
00001A84                          1581   
00001A84                          1582  Get_Effective_Address_Exit:     
00001A84                          1583  
00001A84  4E75                    1584          RTS                             ;return
00001A86                          1585  
00001A86                          1586  switchModeAndReg:
00001A86                          1587  ***
00001A86                          1588  * Assumed in D2
00001A86                          1589  *
00001A86                          1590  * Assumed that they are in least significant byte:
00001A86                          1591  *
00001A86                          1592  *            _this_
00001A86                          1593  *           /      \
00001A86                          1594  *  ........ ........
00001A86                          1595  *  \                /
00001A86                          1596  *   -----word-------
00001A86                          1597  *
00001A86                          1598  *  and that in that byte they are ordered:
00001A86                          1599  *
00001A86                          1600  *       ........   
00001A86                          1601  *       \/\_/\_/
00001A86                          1602  *      /  /    \
00001A86                          1603  *    /   /      \
00001A86                          1604  * dont  one    other
00001A86                          1605  * care
00001A86                          1606  *
00001A86                          1607  * after they will be
00001A86                          1608  *
00001A86                          1609  *       ........   
00001A86                          1610  *       \/\_/\_/
00001A86                          1611  *      /  /    \
00001A86                          1612  *    /   /      \
00001A86                          1613  * dont other    one
00001A86                          1614  * care
00001A86                          1615  *** 
00001A86  0202 003F               1616          AndI.B #%00111111,D2 ;remove unwanted bits from D2
00001A8A  0283 00000000           1617          ANDI.L #0,D3 ;clear D3
00001A90  1602                    1618          MOVE.B D2,D3 ;copy to D3
00001A92  E70B                    1619          LSL.B  #3,D3 
00001A94  E60A                    1620          LSR.B  #3,D2
00001A96  D403                    1621          ADD.B  D3,D2
00001A98  4E75                    1622          RTS
00001A9A                          1623  
00001A9A                          1624          
00001A9A                          1625  *==============================================================================
00001A9A                          1626  *                            variables and constants
00001A9A                          1627  *==============================================================================
00001A9A                          1628  
00001A9A                          1629  
00001A9A                          1630  ***initial user prompt stuff        
00001A9A= 45 6E 74 65 72 20 ...   1631  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE: $',0
00001ACB= 45 6E 74 65 72 20 ...   1632  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE: $',0
00001AFA                          1633  
00001AFA= 20 41 64 64 72 65 ...   1634  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
00001B3F= 20 41 20 43 68 61 ...   1635  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
00001B87                          1636  
00001B87= 20 59 6F 75 20 6D ...   1637  even_msg        DC.B    ' You must enter an even address!'
00001BA7                          1638  
00001BA7= 20                      1639  spc             DC.B    ' '
00001BA8= 01                      1640  spc_len         DC.B    spc_len-spc
00001BA9                          1641  ***
00001BA9                          1642  
00001BA9                          1643  
00001BA9                          1644  
00001BA9                          1645  ***list of OP codes
00001BA9                          1646  
00001BA9  =0000D000               1647  addInstruction   EQU %1101000000000000
00001BA9  =00004880               1648  movemInstruction EQU %0100100010000000
00001BA9  =00000600               1649  addiInstruction  EQU %0000011000000000
00001BA9  =00000000               1650  oriInstruction   EQU 0
00001BA9  =00000C00               1651  cmpiInstruction  EQU %0000110000000000
00001BA9  =00004E80               1652  jsrInstruction   EQU %0100111010000000
00001BA9  =00004E75               1653  rtsInstruction   EQU %0100111001110101
00001BA9  =00004E71               1654  NoOpInstruction  EQU %0100111001110001
00001BA9  =00000000               1655  moveInstruction  EQU 0
00001BA9  =00006000               1656  bccInstruction   EQU %0110000000000000
00001BA9  =00004400               1657  negInstruction   EQU %0100010000000000
00001BA9  =00000000               1658  dataInstruction  EQU 0
00001BA9                          1659  
00001BA9                          1660  ***
00001BA9                          1661  
00001BA9                          1662  ***list of OP masks
00001BA9                          1663  
00001BA9  =0000F000               1664  addMask   EQU %1111000000000000
00001BA9  =0000FB80               1665  movemMask EQU %1111101110000000
00001BA9  =0000FF00               1666  addiMask  EQU %1111111100000000
00001BA9  =0000FF00               1667  oriMask   EQU %1111111100000000
00001BA9  =0000FF00               1668  cmpiMask  EQU %1111111100000000
00001BA9  =0000FFC0               1669  jsrMask   EQU %1111111111000000
00001BA9  =0000FFFF               1670  rtsMask   EQU $FFFF
00001BA9  =0000FFFF               1671  NoOpMask  EQU $FFFF
00001BA9  =0000C000               1672  moveMask  EQU $C000
00001BA9  =0000F000               1673  bccMask   EQU $F000
00001BA9  =0000FF00               1674  negMask   EQU $FF00
00001BA9  =00000000               1675  dataMask  EQU 0
00001BA9                          1676  ***
00001BA9                          1677  
00001BA9                          1678  ***Bcc Codes***
00001BA9  =00000004               1679  CC EQU $04
00001BA9  =00000005               1680  CS EQU $05
00001BA9  =00000007               1681  EQ EQU $07
00001BA9  =0000000C               1682  GE EQU $0C
00001BA9  =0000000E               1683  GT EQU $0E
00001BA9  =00000002               1684  HI EQU $02
00001BA9  =0000000F               1685  LE EQU $0F
00001BA9  =00000003               1686  LS EQU $03
00001BA9  =0000000D               1687  LT EQU $0D
00001BA9  =0000000B               1688  MI EQU $0B
00001BA9  =00000006               1689  NE EQU $06
00001BA9  =0000000A               1690  PL EQU $0A
00001BA9  =00000008               1691  VC EQU $08
00001BA9  =00000009               1692  VS EQU $09
00001BA9  =00000000               1693  RA EQU $00 ;not really a Condition Code
00001BA9  =00000001               1694  SR EQU $01 ;not really a Condition Code
00001BA9                          1695  
00001BA9= 43 43 20 00             1696  CCm DC.B 'CC ',0
00001BAD= 43 53 20 00             1697  CSm DC.B 'CS ',0
00001BB1= 45 51 20 00             1698  EQm DC.B 'EQ ',0
00001BB5= 47 45 20 00             1699  GEm DC.B 'GE ',0
00001BB9= 47 54 20 00             1700  GTm DC.B 'GT ',0
00001BBD= 48 49 20 00             1701  HIm DC.B 'HI ',0
00001BC1= 4C 45 20 00             1702  LEm DC.B 'LE ',0
00001BC5= 4C 53 20 00             1703  LSm DC.B 'LS ',0
00001BC9= 4C 54 20 00             1704  LTm DC.B 'LT ',0
00001BCD= 4D 49 20 00             1705  MIm DC.B 'MI ',0
00001BD1= 4E 45 20 00             1706  NEm DC.B 'NE ',0
00001BD5= 50 4C 20 00             1707  PLm DC.B 'PL ',0
00001BD9= 56 43 20 00             1708  VCm DC.B 'VC ',0
00001BDD= 56 53 20 00             1709  VSm DC.B 'VS ',0
00001BE1= 52 41 20 00             1710  RAm DC.B 'RA ',0
00001BE5= 53 52 20 00             1711  SRm DC.B 'SR ',0
00001BE9                          1712  
00001BE9= 01 04 05 07 0C 0E ...   1713  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
00001BFA= 00001BE5 00001BA9 ...   1714  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
00001C3A                          1715  ***
00001C3A                          1716  
00001C3A= 45 6E 74 65 72 20 ...   1717  startLocationPrompt DC.B    'Enter start location',0
00001C4F= 45 6E 74 65 72 20 ...   1718  endLocationPrompt   DC.B    'Enter end location',0
00001C62                          1719  
00001C62= 0D 0A 00                1720  clearLine  DC.B $0D,$0A,0
00001C65                          1721  
00001C65= 41 44 44 3A 20 00       1722  addMessage      DC.B 'ADD: ',0
00001C6B= 4D 4F 56 45 4D 3A ...   1723  movemMessage    DC.B 'MOVEM: ',0
00001C73= 41 44 44 49 3A 20 00    1724  addiMessage     DC.B 'ADDI: ',0
00001C7A= 4F 52 49 3A 20 00       1725  oriMessage      DC.B 'ORI: ',0
00001C80= 43 4D 50 49 3A 20 00    1726  cmpiMessage     DC.B 'CMPI: ',0
00001C87= 4A 53 52 3A 20 00       1727  jsrMessage      DC.B 'JSR: ',0
00001C8D= 52 54 53 20 00          1728  rtsMessage      DC.B 'RTS ',0
00001C92= 4E 4F 50 3A 20 00       1729  nopMessage      DC.B 'NOP: ',0 
00001C98= 4D 4F 56 45 3A 20 00    1730  moveMessage     DC.B 'MOVE: ',0
00001C9F= 42 00                   1731  bccMessage      DC.B 'B',0
00001CA1= 4E 45 47 3A 20 00       1732  negMessage      DC.B 'NEG: ',0
00001CA7= 44 41 54 41 3A 20 00    1733  dataMessage     DC.B 'DATA: ',0
00001CAE                          1734  
00001CAE= 4D 4F 56 45 41 3A ...   1735  moveaMessage    DC.B 'MOVEA: ',0
00001CB6                          1736  
00001CB6= 28 78 78 78 29 2E ...   1737  xxxW            DC.B '(xxx).W: ',0
00001CC0= 28 78 78 78 29 2E ...   1738  xxxL            DC.B '(xxx).L: ',0
00001CCA= 23 28 64 61 74 61 ...   1739  iData           DC.B '#(data): ',0
00001CD4                          1740  
00001CD4= 41 00                   1741  letterA         DC.B 'A', 0
00001CD6= 44 00                   1742  letterD         DC.B 'D', 0
00001CD8                          1743  
00001CD8= 2B 00                   1744  plus            DC.B '+', 0
00001CDA= 2D 00                   1745  minus           DC.B '-', 0
00001CDC= 28 00                   1746  lPrn            DC.B '(', 0
00001CDE= 29 00                   1747  rPrn            DC.B ')', 0
00001CE0                          1748  
00001CE0                          1749  
00001CE0= 00000000                1750  startLocation       DC.L    0
00001CE4= 00000000                1751  endLocation         DC.L    0
00001CE8                          1752  
00001CE8                          1753  
00001CE8                          1754     
00001CE8                          1755      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 113A
ADDDEST             11FE
ADDDESTEA           112E
ADDDESTEAMASKS      1134
ADDI                136C
ADDIBODY            1398
ADDIDONE            13D6
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         1C73
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          1C65
ADDRESS_DONE        17FE
ADDRESS_EXIT        17F8
ADDR_ABS_LONG       1A60
ADDR_ABS_SHORT      1A4C
ADDR_IMMEDIATE_DATA  1A74
ADDR_REG_DIRECT     1984
ADDR_REG_INDIRECT   199E
ADDR_REG_INDIRECT_DEC  1A0E
ADDR_REG_INDIRECT_INC  19D0
ADDSOURCE           11B6
BCC                 16B2
BCCBYTE             1704
BCCDONE             171A
BCCINSTRUCTION      6000
BCCLIST             1BE9
BCCLONG             1712
BCCMASK             F000
BCCMESSAGE          1C9F
BCCWORD             170A
BEGIN               5001
BEGIN_ADDRESS       178A
BYTE                1
CC                  4
CCM                 1BA9
CHECKCC             16C8
CHECKMOVEADEST      165E
CHECKMOVEDEST       15AC
CHECKOPCODE         1050
CK_ADDR_DONE        190E
CK_ADDR_RANGE       18E2
CK_ADDR_RANGE_ERROR  18FE
CK_BOUNDRY          1826
CK_BOUNDRY_ERROR    1848
CK_SIZE_ERROR       185C
CLEARLINE           1C62
CMPI                146E
CMPIBODY            1496
CMPIDONE            14D4
CMPIEA              1460
CMPIEAMASKS         1467
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         1C80
CONDITIONCODEMESSAGE  1BFA
CS                  5
CSM                 1BAD
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         1CA7
DATA_REG_DIRECT     196A
ELPROMPT            1ACB
END                 FFFFFE
ENDLOCATION         1CE4
ENDLOCATIONPROMPT   1C4F
END_ADDRESS         17CE
ENTER_ADDR_EDIT_ALL  1800
ENTER_ADDR_EDIT_ALL_EXIT  1824
EQ                  7
EQM                 1BB1
EVEN_MSG            1B87
FALSEPOSITIVE       1070
FARLABEL            FFE
FIN                 1786
FOUNDCC             16DA
GE                  C
GEM                 1BB5
GET_EFFECTIVE_ADDRESS  1912
GET_EFFECTIVE_ADDRESS_EXIT  1A84
GET_EFFECTIVE_ADDRESS_OTHER  194E
GT                  E
GTM                 1BB9
HANDLEBYTEDATA      175A
HEX_RANGE_ERROR     18CA
HI                  2
HIM                 1BBD
IDATA               1CCA
INSTLABELLIST       10C6
INSTMASKLIST        10AE
INSTOPLIST          1096
INVALIDEA           1A84
INVALIDMSG          1AFA
INVCHARMSG          1B3F
JSR                 14EC
JSRBODY             1514
JSRDONE             1534
JSREA               14E4
JSREAMASKS          14E8
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          1C87
LCASEHEX            18AC
LE                  F
LEM                 1BC1
LETTERA             1CD4
LETTERD             1CD6
LONG                4
LPRN                1CDC
LS                  3
LSM                 1BC5
LT                  D
LTM                 1BC9
MAIN_LOOP           1026
MATCH               1076
MI                  B
MIM                 1BCD
MINUS               1CDA
MOVE                1584
MOVEA               1636
MOVEABODY           168C
MOVEADESTEA         1632
MOVEADESTEAMASKS    1634
MOVEAMESSAGE        1CAE
MOVEBODY            15DA
MOVEDESTEA          1576
MOVEDESTEAMASKS     157D
MOVEINSTRUCTION     0
MOVEM               125A
MOVEMASK            C000
MOVEMBODY           12C4
MOVEMESSAGE         1C98
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     1250
MOVEMMEMTOREGEAMASKS  1255
MOVEMMESSAGE        1C6B
MOVEMREGTOMEMEA     1246
MOVEMREGTOMEMEAMASKS  124B
MOVESOURCEEA        1564
MOVESOURCEEAMASKS   156D
NE                  6
NEG                 1306
NEGBODY             132E
NEGDONE             135C
NEGEA               12F6
NEGEAMASKS          12FE
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          1CA1
NEM                 1BD1
NEXTHEX             1872
NEXTHEXDONE         18C4
NEXTHEXRETURN       18E0
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 1544
NOPMESSAGE          1C92
ORI                 13E6
ORIBODY             1412
ORIDONE             1450
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          1C7A
PARSEHEXSTRING      1870
PL                  A
PLM                 1BD5
PLUS                1CD8
PRGORG              1000
PROCESS_OP_CODES    1910
PROCESS_OP_CODES_EXIT  1910
PROMPT_USER         1014
RA                  0
RAM                 1BE1
RPRN                1CDE
RTS                 1554
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          1C8D
SLPROMPT            1A9A
SNIPPET             10F6
SNIPPETEND          112A
SPC                 1BA7
SPC_LEN             1BA8
SR                  1
SRM                 1BE5
STACK               5000
START               1000
STARTLOCATION       1CE0
STARTLOCATIONPROMPT  1C3A
SWITCHMODEANDREG    1A86
UCASEHEX            1894
UNKNOWNOPCODE       1734
VALIDADDDESTEA      118A
VALIDADDIMODES      136E
VALIDADDSOURCEEA    1160
VALIDCMPIMODES      1470
VALIDJSRMODES       14EE
VALIDMEMTOREG       1296
VALIDMOVEADESTMODES  1660
VALIDMOVEASOURCEMODES  1638
VALIDMOVEDESTMODES  15AE
VALIDMOVESOURCEMODES  1586
VALIDNEGMODES       1308
VALIDORIMODES       13E8
VALIDREGTOMEM       1270
VC                  8
VCM                 1BD9
VS                  9
VSM                 1BDD
WORD                2
XXXL                1CC0
XXXW                1CB6

00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/10/2014 3:20:28 PM

00000000                             1  *##########################################################################
00000000                             2  * Title      : 
00000000                             3  * Written by : Andrew Watson
00000000                             4  *            : Elaine Keller
00000000                             5  *            : Robert Anderson
00000000                             6  * Date       : 11/14/2014
00000000                             7  * Description: 
00000000                             8  *##########################################################################
00000000                             9  
00000000                            10  ***Possible Bug***
00000000                            11  *can not tell data from an
00000000                            12  *unidentified instruction from an actual
00000000                            13  *instruction therefore causing errors.
00000000                            14  *may not actually be a bug because data
00000000                            15  *is data to the machine, and if you modify
00000000                            16  *the instructions in memory for a program
00000000                            17  *by moivng data, you can modify the instuctions
00000000                            18  *executed.
00000000                            19  
00000000                            20  
00000000                            21  ***************************************************************************
00000000                            22  *                   Variable/Data Definitions
00000000                            23  ***************************************************************************
00000000                            24  
00000000  =00005000                 25  stack   EQU   $00005000
00000000  =00005001                 26  begin   EQU   $00005001
00000000  =00FFFFFE                 27  end     EQU   $00FFFFFE
00000000  =00000001                 28  byte    EQU   1
00000000  =00000002                 29  word    EQU   2
00000000  =00000004                 30  long    EQU   4
00000000  =00001000                 31  prgorg  EQU   $1000
00000000                            32  
00000FFE                            33      ORG $00000FFE
00000FFE                            34  FarLabel:
00001000                            35      ORG    prgorg
00001000                            36  start:
00001000  4FF8 5000                 37          LEA stack, SP ;initialize stack
00001004                            38  
00001000                            39      ORG    prgorg
00001000                            40  
00001000                            41  ******************************************************************************
00001000                            42  *                   Begin processing active code
00001000                            43  ******************************************************************************
00001000                            44      
00001000                            45  start:
00001000                            46  
00001000  4FF8 5000                 47          LEA         stack, SP           ;Initialize stack
00001004                            48          
00001004                            49  *.............................................................................
00001004                            50  * Debug Mode - Comment out when done
00001004  267C 00001178             51          MOVE.L      #snippet,A3
0000100A  287C 000011FC             52          MOVE.L      #snippetEnd,A4
00001010  6000 0014                 53          BRA         main_Loop
00001014                            54  * Debug Mode - Comment out when done
00001014                            55  *.............................................................................        
00001014                            56          
00001014                            57  prompt_user:
00001014                            58  
00001014  6100 0ED2                 59          BSR         begin_address
00001018  B67C FFFF                 60          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000101C  6700 0EC6                 61          BEQ         fin                 ;Yes, then exit
00001020                            62          
00001020  6000 0004                 63          BRA         main_Loop
00001024                            64          ;BSR         process_op_codes
00001024  60EE                      65          BRA         prompt_user
00001026                            66                  
00001026                            67  ******************************************************************************
00001026                            68  *                   Begin processing OP Codes
00001026                            69  ******************************************************************************
00001026                            70   
00001026                            71  main_Loop:
00001026                            72  
00001026  B9CB                      73          CMPA.L A3,A4 ;check end of prog
00001028  6700 0EBA                 74          BEQ fin
0000102C                            75          
0000102C                            76          ;print memory location
0000102C  48E7 1200                 77          MOVEM.L D3/D6,-(SP)
00001030  7C02                      78          MOVEQ.L #2,D6 ;set as long hex string
00001032  260B                      79          MOVE.L  A3,D3 ;put hex in D3
00001034  6100 11C0                 80          BSR outputHex
00001038  48E7 1200                 81          MOVEM.L D3/D6,-(SP)
0000103C                            82          
0000103C                            83          ;print ' '
0000103C  48E7 4000                 84          MOVEM.L D1,-(SP) ;save D1 to the stack
00001040  123C 0020                 85          MOVE.B #' ',D1 ;put ascii value of char in D1
00001044  103C 0006                 86          MOVE.B #6,D0 ;move task 6 into D0
00001048  4E4F                      87          TRAP #15 ;prin char
0000104A  4CDF 0002                 88          MOVEM.L (SP)+,D1 ;pull D1 off the stack
0000104E                            89          
0000104E  3213                      90          MOVE.W (A3),D1 ;copy word from other prog to analyze as instruction
00001050                            91          
00001050                            92          ;handle an odd memory access(instructions will never be misaligned)
00001050  240B                      93          MOVE.L A3,D2 ; copy address to D2
00001052  0202 0001                 94          ANDI.B #%00000001,D2 ;mask everything except the least significant bit
00001056  0C02 0001                 95          CMPI.B #1,D2 ;compare the least sig bit of the address to one
0000105A  6700 0E5C                 96          BEQ handlebytedata ;the least sig bit will only be one if the insrtuction
0000105E                            97                             ;is odd(misaligned) and therefore not an instruction
0000105E                            98          
0000105E  7600                      99          MOVEQ.L #0,D3
00001060                           100          
00001060                           101          ***things to save A3,A4,D1(?)***
00001060  48E7 0018                102          MOVEM.L A3-A4,-(SP)
00001064  6100 000C                103          BSR checkOPcode
00001068  4CDF 1800                104          MOVEM.L (SP)+,A3-A4
0000106C  D7C7                     105          ADDA.L  D7,A3 ;look past data that was part of the instruction
0000106E                           106          
0000106E  548B                     107          ADDQ.L  #word,A3
00001070  60B4                     108          BRA     main_Loop 
00001072                           109          
00001072                           110  checkOPcode:
00001072                           111  
00001072                           112  
00001072  7E00                     113          MOVEQ.L #0,D7
00001074                           114          
00001074  41F9 000010B8            115          LEA     instOPList,A0 ;get instruction signitrue list in A0
0000107A  D1C3                     116          ADDA.L  D3,A0 ;get correct sig         
0000107C                           117          
0000107C  43F9 000010E8            118          LEA     instMaskList,A1 ;get instruction mask in A1
00001082  D3C3                     119          ADDA.L  D3,A1  ;get correct mast
00001084                           120          
00001084  3401                     121          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001086                           122          
00001086  C451                     123          AND.W   (A1),D2 ;mask instruction
00001088                           124          
00001088                           125          
00001088                           126          
00001088                           127          
00001088  B450                     128          CMP.W   (A0),D2 ;compare to sig
0000108A  6700 000C                129          BEQ     match ;if sig matches branch
0000108E  5483                     130          ADDQ.L  #word,D3 ;add to D3 to check for next instruction
00001090  60E0                     131          BRA checkOPcode
00001092                           132          
00001092                           133  falsePositive:
00001092                           134          
00001092  103C 00FF                135          MOVE.B #-1,D0
00001096  4E75                     136          RTS
00001098                           137  
00001098                           138  match:
00001098                           139          
00001098  43F9 00001118            140          LEA     instLabelList,A1 ;get instruction code label
0000109E  D3C3                     141          ADDA.L  D3,A1 ;get correct label
000010A0  D3C3                     142          ADDA.L  D3,A1
000010A2  5483                     143          ADDQ.L  #word,D3 ;add to D3 incase false positive
000010A4  2251                     144          MOVEA.L (A1),A1
000010A6  48E7 1000                145          MOVEM.L D3,-(SP) ; save D3
000010AA  4E91                     146          JSR     (A1)
000010AC  4CDF 0008                147          MOVEM.L (SP)+,D3 ;restore D3
000010B0  B03C 00FF                148          CMP.B   #-1,D0
000010B4  67BC                     149          BEQ     checkOPcode
000010B6  4E75                     150          RTS
000010B8                           151          
000010B8                           152  
000010B8= 41C0 81C0 C1C0 E...      153  instOPList  DC.W leaInstruction,divsInstruction,mulsInstruction,rsrlweaInstruction,rsrlregInstruction,asrlweaInstruction,asrlregInstruction,lsrlweaInstruction,lsrlregInstruction
000010CA= 5100 9000 D000 D...      154  instOPList2 DC.W subqInstruction,subInstruction,addaInstruction,addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruct
000010E8                           155      
000010E8= F1C0 F1C0 F1C0 F...      156  instMaskList DC.W leaMask,divsMask,mulsMask,rsrlweaMask,rsrlregMask,asrlweaMask,asrlregMask,lsrlweaMask,lsrlregMask,subqMask,subMask,addaMask,addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask   
00001118= 00001208 0000127A        157  instLabelList  DC.L LEA,DIVS
00001120= 000012FE 0000136E ...    158  instLabelList2 DC.L MULS,RSRLWEA,RSRLREG,ASRLWEA,ASRLREG,LSRLWEA,LSRLREG,SUBQ,SUB,ADDA,ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
00001178                           159  
00001178                           160  snippet:
00001178  4E71                     161           NOP
0000117A  60FC                     162           BRA snippet
0000117C  6000 FE80                163           BRA FarLabel
00001180  67F6                     164           BEQ snippet
00001182  6E00 08E0                165           BGT NEG
00001186  61F0                     166           BSR snippet
00001188  4441                     167           NEG D1
0000118A  3239 00008500            168           MOVE.W $8500,D1
00001190  0645 001E                169           ADDI.W #30,D5
00001194  4E75                     170           RTS
00001196  4EB8 0054                171           JSR $54
0000119A  0C41 0003                172           CMPI #3,D1
0000119E  0041 0003                173           ORI  #3,D1
000011A2  48E7 0018                174           MOVEM.L A3-A4,-(SP)
000011A6  D401                     175           ADD.B D1,D2
000011A8  0603 000A                176           ADD.B #10,D3
000011AC  D7FC 00000463            177           ADDA.L #1123,A3
000011B2  9A43                     178           SUB.W D3,D5
000011B4  5105                     179           SUBQ.B #8,D5
000011B6  5305                     180           SUBQ.B #1,D5
000011B8  E64B                     181           LSR #3,D3
000011BA  E74C                     182           LSL #3,D4
000011BC  E369                     183           LSL D1,D1
000011BE  E66F                     184           LSR D3,D7
000011C0  E2F8 3563                185           LSR $3563
000011C4  E3F9 00486412            186           LSL $486412
000011CA  E643                     187           ASR #3,D3
000011CC  E744                     188           ASL #3,D4
000011CE  E361                     189           ASL D1,D1
000011D0  E667                     190           ASR D3,D7
000011D2  E0F8 3563                191           ASR $3563
000011D6  E1F9 00486412            192           ASL $486412
000011DC  E65B                     193           ROR #3,D3
000011DE  E75C                     194           ROL #3,D4
000011E0  E379                     195           ROL D1,D1
000011E2  E67F                     196           ROR D3,D7
000011E4  E6F8 3563                197           ROR $3563
000011E8  E7F9 00486412            198           ROL $486412
000011EE  C5FC 4562                199           MULS #$4562,D2
000011F2  85FC 4562                200           DIVS #$4562,D2
000011F6  43F9 00001204            201           LEA leaEAmasks,A1
000011FC                           202  
000011FC                           203           
000011FC                           204  snippetEnd:
000011FC  FFFF FFFF                205           SIMHALT
00001200                           206  
00001200= 10 38 39 00              207  leaEA        DC.B %010000,%111000,%111001,0
00001204= 38 3F 3F 00              208  leaEAmasks   DC.B %111000,%111111,%111111,0
00001208                           209          
00001208                           210  LEA:
00001208                           211  
00001208  7000                     212          MOVEQ.L #0, D0 ;clear D0
0000120A                           213          
0000120A                           214  validLeaModes:
0000120A                           215          
0000120A  43F8 1204                216          LEA leaEAmasks,A1 ;load the list of masks
0000120E  D3C0                     217          ADDA.L D0,A1 ;displace to a specific mask
00001210  1A11                     218          MOVE.B (A1),D5 ;move the mask to D5
00001212                           219          
00001212  0C05 0000                220          CMPI.B #0,D5 ;check if the mask is 0
00001216  6700 FE7A                221          BEQ falsePositive ;branch if it is
0000121A                           222          
0000121A  1401                     223          MOVE.B D1,D2 ;copy instruction to D2
0000121C  C405                     224          AND.B D5,D2  ;mask D2
0000121E                           225          
0000121E  43F8 1200                226          LEA leaEA,A1 ;load the list of valid modes
00001222  D3C0                     227          ADDA.L D0,A1 ;displace to a specific mode
00001224  1811                     228          MOVE.B (A1),D4 ;move mode to D4
00001226  B404                     229          CMP.B D4,D2 ;compare mode to masked value
00001228  6700 0006                230          BEQ  leaBody ;if its match, its a valid mode and we can procede
0000122C                           231          
0000122C  5280                     232          ADDQ.L #1,D0 ;add one to displacement
0000122E  60DA                     233          BRA validLeaModes ;check for next mode
00001230                           234          
00001230                           235  leaBody:
00001230                           236          
00001230                           237  
00001230                           238  
00001230  43F9 00002481            239          LEA     leaMessage,A1  ;move string for MOVE
00001236  103C 000E                240          MOVE.B  #14,D0        ;set for task to display null terminated 
0000123A                           241                                ;string without CR, LF
0000123A  4E4F                     242          TRAP    #15
0000123C                           243  
0000123C                           244          ;do source EA
0000123C  3401                     245          MOVE.W  D1,D2 ;check mode
0000123E  C43C 003F                246          AND.B   #%00111111,D2
00001242  1A02                     247          MOVE.B  D2,D5
00001244  48E7 4000                248          MOVEM.L D1,-(SP)
00001248  6100 0E26                249          BSR     Get_Effective_Address
0000124C  4CDF 0002                250          MOVEM.L (SP)+,D1
00001250                           251  
00001250                           252          ;print separator
00001250                           253          
00001250                           254          ;do dest addr reg
00001250  3401                     255          MOVE.W  D1,D2 ;check mode
00001252  E04A                     256          LSR.W #8,D2 ;shift reg over
00001254  E20A                     257          LSR.B #1,D2
00001256  C43C 0007                258          AND.B   #%00000111,D2 ;force recognition as a An
0000125A  5002                     259          ADDQ.B #%1000,D2
0000125C  1A02                     260          MOVE.B  D2,D5
0000125E  48E7 4000                261          MOVEM.L D1,-(SP)
00001262  6100 0E0C                262          BSR     Get_Effective_Address
00001266  4CDF 0002                263          MOVEM.L (SP)+,D1
0000126A                           264          
0000126A  43F9 0000247E            265          LEA     clearLine,A1  ;move string for a CR and LF
00001270  103C 000E                266          MOVE.B  #14,D0        ;set for task to display null terminated 
00001274                           267                                ;string without CR, LF
00001274  4E4F                     268          TRAP    #15
00001276                           269  
00001276  7000                     270          MOVEQ.L #0,D0
00001278  4E75                     271          RTS
0000127A                           272  
0000127A                           273  
0000127A                           274  
0000127A                           275  DIVS:
0000127A                           276  
0000127A  7000                     277          MOVEQ.L #0, D0 ;clear D0
0000127C                           278          
0000127C                           279  validDivsModes:
0000127C                           280          
0000127C  43F9 000012F6            281          LEA mulsEAmasks,A1 ;load the list of masks
00001282  D3C0                     282          ADDA.L D0,A1 ;displace to a specific mask
00001284  1A11                     283          MOVE.B (A1),D5 ;move the mask to D5
00001286                           284          
00001286  0C05 0000                285          CMPI.B #0,D5 ;check if the mask is 0
0000128A  6700 FE06                286          BEQ falsePositive ;branch if it is
0000128E                           287          
0000128E  1401                     288          MOVE.B D1,D2 ;copy instruction to D2
00001290  C405                     289          AND.B D5,D2  ;mask D2
00001292                           290          
00001292  43F9 000012EE            291          LEA mulsEA,A1 ;load the list of valid modes
00001298  D3C0                     292          ADDA.L D0,A1 ;displace to a specific mode
0000129A  1811                     293          MOVE.B (A1),D4 ;move mode to D4
0000129C  B404                     294          CMP.B D4,D2 ;compare mode to masked value
0000129E  6700 0006                295          BEQ  divsBody ;if its match, its a valid mode and we can procede
000012A2                           296          
000012A2  5280                     297          ADDQ.L #1,D0 ;add one to displacement
000012A4  60D6                     298          BRA validDivsModes ;check for next mode
000012A6                           299          
000012A6                           300  divsBody:
000012A6                           301          
000012A6                           302  
000012A6                           303  
000012A6  43F9 00002486            304          LEA     divsMessage,A1  ;move string for MOVE
000012AC  103C 000E                305          MOVE.B  #14,D0        ;set for task to display null terminated 
000012B0                           306                                ;string without CR, LF
000012B0  4E4F                     307          TRAP    #15
000012B2                           308  
000012B2                           309          ;do source EA
000012B2  3401                     310          MOVE.W  D1,D2 ;check mode
000012B4  C43C 003F                311          AND.B   #%00111111,D2
000012B8  1A02                     312          MOVE.B  D2,D5
000012BA  48E7 4000                313          MOVEM.L D1,-(SP)
000012BE  6100 0DB0                314          BSR     Get_Effective_Address
000012C2  4CDF 0002                315          MOVEM.L (SP)+,D1
000012C6                           316  
000012C6                           317          ;print separator
000012C6                           318          
000012C6                           319          ;do dest data reg
000012C6  3401                     320          MOVE.W  D1,D2 ;check mode
000012C8  E04A                     321          LSR.W #8,D2 ;shift reg over
000012CA  E20A                     322          LSR.B #1,D2
000012CC  C43C 0007                323          AND.B   #%00000111,D2 ;force recognition as a Dn
000012D0  1A02                     324          MOVE.B  D2,D5
000012D2  48E7 4000                325          MOVEM.L D1,-(SP)
000012D6  6100 0D98                326          BSR     Get_Effective_Address
000012DA  4CDF 0002                327          MOVEM.L (SP)+,D1
000012DE                           328          
000012DE  43F9 0000247E            329          LEA     clearLine,A1  ;move string for a CR and LF
000012E4  103C 000E                330          MOVE.B  #14,D0        ;set for task to display null terminated 
000012E8                           331                                ;string without CR, LF
000012E8  4E4F                     332          TRAP    #15
000012EA                           333  
000012EA  7000                     334          MOVEQ.L #0,D0
000012EC  4E75                     335          RTS
000012EE                           336  
000012EE                           337  
000012EE                           338  
000012EE                           339  
000012EE= 00 10 18 20 38 39 ...    340  mulsEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,%111100,0
000012F6= 38 38 38 38 3F 3F ...    341  mulsEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,%111111,0
000012FE                           342          
000012FE                           343  MULS:
000012FE                           344  
000012FE  7000                     345          MOVEQ.L #0, D0 ;clear D0
00001300                           346          
00001300                           347  validMulsModes:
00001300                           348          
00001300  43F8 12F6                349          LEA mulsEAmasks,A1 ;load the list of masks
00001304  D3C0                     350          ADDA.L D0,A1 ;displace to a specific mask
00001306  1A11                     351          MOVE.B (A1),D5 ;move the mask to D5
00001308                           352          
00001308  0C05 0000                353          CMPI.B #0,D5 ;check if the mask is 0
0000130C  6700 FD84                354          BEQ falsePositive ;branch if it is
00001310                           355          
00001310  1401                     356          MOVE.B D1,D2 ;copy instruction to D2
00001312  C405                     357          AND.B D5,D2  ;mask D2
00001314                           358          
00001314  43F8 12EE                359          LEA mulsEA,A1 ;load the list of valid modes
00001318  D3C0                     360          ADDA.L D0,A1 ;displace to a specific mode
0000131A  1811                     361          MOVE.B (A1),D4 ;move mode to D4
0000131C  B404                     362          CMP.B D4,D2 ;compare mode to masked value
0000131E  6700 0006                363          BEQ  mulsBody ;if its match, its a valid mode and we can procede
00001322                           364          
00001322  5280                     365          ADDQ.L #1,D0 ;add one to displacement
00001324  60DA                     366          BRA validMulsModes ;check for next mode
00001326                           367          
00001326                           368  mulsBody:
00001326                           369          
00001326                           370  
00001326                           371  
00001326  43F9 0000248C            372          LEA     mulsMessage,A1  ;move string for MOVE
0000132C  103C 000E                373          MOVE.B  #14,D0        ;set for task to display null terminated 
00001330                           374                                ;string without CR, LF
00001330  4E4F                     375          TRAP    #15
00001332                           376  
00001332                           377          ;do source EA
00001332  3401                     378          MOVE.W  D1,D2 ;check mode
00001334  C43C 003F                379          AND.B   #%00111111,D2
00001338  1A02                     380          MOVE.B  D2,D5
0000133A  48E7 4000                381          MOVEM.L D1,-(SP)
0000133E  6100 0D30                382          BSR     Get_Effective_Address
00001342  4CDF 0002                383          MOVEM.L (SP)+,D1
00001346                           384  
00001346                           385          ;print separator
00001346                           386          
00001346                           387          ;do dest data reg
00001346  3401                     388          MOVE.W  D1,D2 ;check mode
00001348  E04A                     389          LSR.W #8,D2 ;shift reg over
0000134A  E20A                     390          LSR.B #1,D2
0000134C  C43C 0007                391          AND.B   #%00000111,D2 ;force recognition as a Dn
00001350  1A02                     392          MOVE.B  D2,D5
00001352  48E7 4000                393          MOVEM.L D1,-(SP)
00001356  6100 0D18                394          BSR     Get_Effective_Address
0000135A  4CDF 0002                395          MOVEM.L (SP)+,D1
0000135E                           396          
0000135E  43F9 0000247E            397          LEA     clearLine,A1  ;move string for a CR and LF
00001364  103C 000E                398          MOVE.B  #14,D0        ;set for task to display null terminated 
00001368                           399                                ;string without CR, LF
00001368  4E4F                     400          TRAP    #15
0000136A                           401  
0000136A  7000                     402          MOVEQ.L #0,D0
0000136C  4E75                     403          RTS
0000136E                           404  
0000136E                           405  
0000136E                           406  
0000136E                           407  RSRLWEA:
0000136E                           408          
0000136E                           409  
0000136E                           410          
0000136E  7000                     411          MOVEQ.L #0, D0 ;clear D0
00001370                           412          
00001370                           413  validRSRL:
00001370                           414          
00001370  43F9 000014C0            415          LEA lsrlEAmasks,A1 ;load the list of masks
00001376  D3C0                     416          ADDA.L D0,A1 ;displace to a specific mask
00001378  1A11                     417          MOVE.B (A1),D5 ;move the mask to D5
0000137A                           418          
0000137A  0C05 0000                419          CMPI.B #0,D5 ;check if the mask is 0
0000137E  6700 FD12                420          BEQ falsePositive ;branch if it is
00001382                           421          
00001382  1401                     422          MOVE.B D1,D2 ;copy instruction to D2
00001384  C405                     423          AND.B D5,D2  ;mask D2
00001386                           424          
00001386  43F9 000014BA            425          LEA lsrlEA,A1 ;load the list of valid modes
0000138C  D3C0                     426          ADDA.L D0,A1 ;displace to a specific mode
0000138E  1811                     427          MOVE.B (A1),D4 ;move mode to D4
00001390  B404                     428          CMP.B D4,D2 ;compare mode to masked value
00001392  6700 0006                429          BEQ  rsrlweaCheckDirection ;if its match, its a valid mode and we can procede
00001396                           430          
00001396  5280                     431          ADDQ.L #1,D0 ;add one to displacement
00001398  60D6                     432          BRA validRSRL ;check for next mode
0000139A                           433  
0000139A                           434  rsrlweaCheckDirection:
0000139A                           435          ;Figure out which direction we are going
0000139A  3401                     436          MOVE.W D1,D2 ;copy inst to D2
0000139C  E04A                     437          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
0000139E  0202 0001                438          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000013A2  0C02 0000                439          CMPI.B #0,D2 ;compare bit to zero
000013A6  6700 0006                440          BEQ RSREA ;if zero, right
000013AA  6000 0012                441          BRA RSLEA ;else, its left
000013AE                           442  
000013AE                           443  RSREA:
000013AE                           444  
000013AE  43F9 00002497            445          LEA     rsrMessage,A1  ;move string for MOVE
000013B4  103C 000E                446          MOVE.B  #14,D0        ;set for task to display null terminated 
000013B8                           447                                ;string with CR, LF
000013B8  4E4F                     448          TRAP    #15
000013BA  6000 0166                449          BRA lsrlweaBody
000013BE                           450          
000013BE                           451  RSLEA:
000013BE                           452          
000013BE  43F9 00002492            453          LEA     rslMessage,A1  ;move string for MOVE
000013C4  103C 000E                454          MOVE.B  #14,D0        ;set for task to display null terminated 
000013C8                           455                                ;string with CR, LF
000013C8  4E4F                     456          TRAP    #15
000013CA  6000 0156                457          BRA lsrlweaBody        
000013CE                           458          
000013CE                           459  
000013CE                           460  
000013CE                           461  RSRLREG:
000013CE                           462          
000013CE                           463  
000013CE                           464          
000013CE  7000                     465          MOVEQ.L #0, D0 ;clear D0
000013D0                           466          
000013D0                           467          ;check valid size field
000013D0  3401                     468          MOVE.W D1,D2 ;copy inst to D2
000013D2  EC4A                     469          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
000013D4  0202 0003                470          ANDI.B #%00000011,D2 ;mask out rest of byte
000013D8  0C02 0003                471          CMPI.B #%11,D2 ;compare to 3
000013DC  6700 FCB4                472          BEQ falsePositive ;invalid size
000013E0                           473  
000013E0                           474          
000013E0                           475          ;Figure out which direction we are going
000013E0  3401                     476          MOVE.W D1,D2 ;copy inst to D2
000013E2  E04A                     477          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000013E4  0202 0001                478          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000013E8  0C02 0000                479          CMPI.B #0,D2 ;compare bit to zero
000013EC  6700 0006                480          BEQ RSRreg ;if zero, right
000013F0  6000 0012                481          BRA RSLreg ;else, its left        
000013F4                           482          
000013F4                           483  RSRreg:
000013F4                           484  
000013F4  43F9 00002497            485          LEA     rsrMessage,A1  ;move string for MOVE
000013FA  103C 000E                486          MOVE.B  #14,D0        ;set for task to display null terminated 
000013FE                           487                                ;string with CR, LF
000013FE  4E4F                     488          TRAP    #15
00001400  6000 018A                489          BRA LSRLregBody
00001404                           490          
00001404                           491  RSLreg:
00001404                           492          
00001404  43F9 00002492            493          LEA     rslMessage,A1  ;move string for MOVE
0000140A  103C 000E                494          MOVE.B  #14,D0        ;set for task to display null terminated 
0000140E                           495                                ;string with CR, LF
0000140E  4E4F                     496          TRAP    #15
00001410  6000 017A                497          BRA LSRLregBody
00001414                           498  
00001414                           499       
00001414                           500  
00001414                           501  ASRLWEA:
00001414                           502          
00001414                           503  
00001414                           504          
00001414  7000                     505          MOVEQ.L #0, D0 ;clear D0
00001416                           506          
00001416                           507  validASRL:
00001416                           508          
00001416  43F9 000014C0            509          LEA lsrlEAmasks,A1 ;load the list of masks
0000141C  D3C0                     510          ADDA.L D0,A1 ;displace to a specific mask
0000141E  1A11                     511          MOVE.B (A1),D5 ;move the mask to D5
00001420                           512          
00001420  0C05 0000                513          CMPI.B #0,D5 ;check if the mask is 0
00001424  6700 FC6C                514          BEQ falsePositive ;branch if it is
00001428                           515          
00001428  1401                     516          MOVE.B D1,D2 ;copy instruction to D2
0000142A  C405                     517          AND.B D5,D2  ;mask D2
0000142C                           518          
0000142C  43F9 000014BA            519          LEA lsrlEA,A1 ;load the list of valid modes
00001432  D3C0                     520          ADDA.L D0,A1 ;displace to a specific mode
00001434  1811                     521          MOVE.B (A1),D4 ;move mode to D4
00001436  B404                     522          CMP.B D4,D2 ;compare mode to masked value
00001438  6700 0006                523          BEQ  asrlweaCheckDirection ;if its match, its a valid mode and we can procede
0000143C                           524          
0000143C  5280                     525          ADDQ.L #1,D0 ;add one to displacement
0000143E  60D6                     526          BRA validASRL ;check for next mode
00001440                           527  
00001440                           528  asrlweaCheckDirection:
00001440                           529          ;Figure out which direction we are going
00001440  3401                     530          MOVE.W D1,D2 ;copy inst to D2
00001442  E04A                     531          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
00001444  0202 0001                532          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
00001448  0C02 0000                533          CMPI.B #0,D2 ;compare bit to zero
0000144C  6700 0006                534          BEQ ASREA ;if zero, right
00001450  6000 0012                535          BRA ASLEA ;else, its left
00001454                           536  
00001454                           537  ASREA:
00001454                           538  
00001454  43F9 000024A1            539          LEA     asrMessage,A1  ;move string for MOVE
0000145A  103C 000E                540          MOVE.B  #14,D0        ;set for task to display null terminated 
0000145E                           541                                ;string with CR, LF
0000145E  4E4F                     542          TRAP    #15
00001460  6000 00C0                543          BRA lsrlweaBody
00001464                           544          
00001464                           545  ASLEA:
00001464                           546          
00001464  43F9 0000249C            547          LEA     aslMessage,A1  ;move string for MOVE
0000146A  103C 000E                548          MOVE.B  #14,D0        ;set for task to display null terminated 
0000146E                           549                                ;string with CR, LF
0000146E  4E4F                     550          TRAP    #15
00001470  6000 00B0                551          BRA lsrlweaBody        
00001474                           552          
00001474                           553  
00001474                           554  
00001474                           555  ASRLREG:
00001474                           556          
00001474                           557  
00001474                           558          
00001474  7000                     559          MOVEQ.L #0, D0 ;clear D0
00001476                           560          
00001476                           561          ;check valid size field
00001476  3401                     562          MOVE.W D1,D2 ;copy inst to D2
00001478  EC4A                     563          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
0000147A  0202 0003                564          ANDI.B #%00000011,D2 ;mask out rest of byte
0000147E  0C02 0003                565          CMPI.B #%11,D2 ;compare to 3
00001482  6700 FC0E                566          BEQ falsePositive ;invalid size
00001486                           567  
00001486                           568          
00001486                           569          ;Figure out which direction we are going
00001486  3401                     570          MOVE.W D1,D2 ;copy inst to D2
00001488  E04A                     571          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
0000148A  0202 0001                572          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
0000148E  0C02 0000                573          CMPI.B #0,D2 ;compare bit to zero
00001492  6700 0006                574          BEQ ASRreg ;if zero, right
00001496  6000 0012                575          BRA ASLreg ;else, its left        
0000149A                           576          
0000149A                           577  ASRreg:
0000149A                           578  
0000149A  43F9 000024A1            579          LEA     asrMessage,A1  ;move string for MOVE
000014A0  103C 000E                580          MOVE.B  #14,D0        ;set for task to display null terminated 
000014A4                           581                                ;string with CR, LF
000014A4  4E4F                     582          TRAP    #15
000014A6  6000 00E4                583          BRA LSRLregBody
000014AA                           584          
000014AA                           585  ASLreg:
000014AA                           586          
000014AA  43F9 0000249C            587          LEA     aslMessage,A1  ;move string for MOVE
000014B0  103C 000E                588          MOVE.B  #14,D0        ;set for task to display null terminated 
000014B4                           589                                ;string with CR, LF
000014B4  4E4F                     590          TRAP    #15
000014B6  6000 00D4                591          BRA LSRLregBody
000014BA                           592  
000014BA                           593  
000014BA= 10 18 20 38 39 00        594  lsrlEA        DC.B %010000,%011000,%100000,%111000,%111001,0
000014C0= 38 38 38 3F 3F 00        595  lsrlEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0       
000014C6                           596  
000014C6                           597  LSRLWEA:
000014C6                           598          
000014C6                           599  
000014C6                           600          
000014C6  7000                     601          MOVEQ.L #0, D0 ;clear D0
000014C8                           602          
000014C8                           603  validLSRL:
000014C8                           604          
000014C8  43F8 14C0                605          LEA lsrlEAmasks,A1 ;load the list of masks
000014CC  D3C0                     606          ADDA.L D0,A1 ;displace to a specific mask
000014CE  1A11                     607          MOVE.B (A1),D5 ;move the mask to D5
000014D0                           608          
000014D0  0C05 0000                609          CMPI.B #0,D5 ;check if the mask is 0
000014D4  6700 FBBC                610          BEQ falsePositive ;branch if it is
000014D8                           611          
000014D8  1401                     612          MOVE.B D1,D2 ;copy instruction to D2
000014DA  C405                     613          AND.B D5,D2  ;mask D2
000014DC                           614          
000014DC  43F8 14BA                615          LEA lsrlEA,A1 ;load the list of valid modes
000014E0  D3C0                     616          ADDA.L D0,A1 ;displace to a specific mode
000014E2  1811                     617          MOVE.B (A1),D4 ;move mode to D4
000014E4  B404                     618          CMP.B D4,D2 ;compare mode to masked value
000014E6  6700 0006                619          BEQ  lsrlweaCheckDirection ;if its match, its a valid mode and we can procede
000014EA                           620          
000014EA  5280                     621          ADDQ.L #1,D0 ;add one to displacement
000014EC  60DA                     622          BRA validLSRL ;check for next mode
000014EE                           623  
000014EE                           624  lsrlweaCheckDirection:
000014EE                           625          ;Figure out which direction we are going
000014EE  3401                     626          MOVE.W D1,D2 ;copy inst to D2
000014F0  E04A                     627          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000014F2  0202 0001                628          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000014F6  0C02 0000                629          CMPI.B #0,D2 ;compare bit to zero
000014FA  6700 0006                630          BEQ LSREA ;if zero, right
000014FE  6000 0012                631          BRA LSLEA ;else, its left
00001502                           632  
00001502                           633  LSREA:
00001502                           634  
00001502  43F9 000024AB            635          LEA     lsrMessage,A1  ;move string for MOVE
00001508  103C 000E                636          MOVE.B  #14,D0        ;set for task to display null terminated 
0000150C                           637                                ;string with CR, LF
0000150C  4E4F                     638          TRAP    #15
0000150E  6000 0012                639          BRA lsrlweaBody
00001512                           640          
00001512                           641  LSLEA:
00001512                           642          
00001512  43F9 000024A6            643          LEA     lslMessage,A1  ;move string for MOVE
00001518  103C 000E                644          MOVE.B  #14,D0        ;set for task to display null terminated 
0000151C                           645                                ;string with CR, LF
0000151C  4E4F                     646          TRAP    #15
0000151E  6000 0002                647          BRA lsrlweaBody        
00001522                           648          
00001522                           649  lsrlweaBody:
00001522                           650  
00001522                           651          
00001522  3401                     652          MOVE.W  D1,D2 ;check mode
00001524  C43C 003F                653          AND.B   #%00111111,D2
00001528  1A02                     654          MOVE.B  D2,D5
0000152A  48E7 4000                655          MOVEM.L D1,-(SP)
0000152E  6100 0B40                656          BSR     Get_Effective_Address
00001532  4CDF 0002                657          MOVEM.L (SP)+,D1
00001536                           658          
00001536                           659          
00001536  43F9 0000247E            660          LEA     clearLine,A1  ;move string for a CR and LF
0000153C  103C 000E                661          MOVE.B  #14,D0        ;set for task to display null terminated 
00001540                           662                                ;string without CR, LF
00001540  4E4F                     663          TRAP    #15
00001542                           664  
00001542  7000                     665          MOVEQ.L #0,D0
00001544  4E75                     666          RTS
00001546                           667  
00001546                           668  
00001546                           669  LSRLREG:
00001546                           670          
00001546                           671  
00001546                           672          
00001546  7000                     673          MOVEQ.L #0, D0 ;clear D0
00001548                           674          
00001548                           675          ;check valid size field
00001548  3401                     676          MOVE.W D1,D2 ;copy inst to D2
0000154A  EC4A                     677          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
0000154C  0202 0003                678          ANDI.B #%00000011,D2 ;mask out rest of byte
00001550  0C02 0003                679          CMPI.B #%11,D2 ;compare to 3
00001554  6700 FB3C                680          BEQ falsePositive ;invalid size
00001558                           681  
00001558                           682          
00001558                           683          ;Figure out which direction we are going
00001558  3401                     684          MOVE.W D1,D2 ;copy inst to D2
0000155A  E04A                     685          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
0000155C  0202 0001                686          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
00001560  0C02 0000                687          CMPI.B #0,D2 ;compare bit to zero
00001564  6700 0006                688          BEQ LSRreg ;if zero, right
00001568  6000 0012                689          BRA LSLreg ;else, its left        
0000156C                           690          
0000156C                           691  LSRreg:
0000156C                           692  
0000156C  43F9 000024AB            693          LEA     lsrMessage,A1  ;move string for MOVE
00001572  103C 000E                694          MOVE.B  #14,D0        ;set for task to display null terminated 
00001576                           695                                ;string with CR, LF
00001576  4E4F                     696          TRAP    #15
00001578  6000 0012                697          BRA LSRLregBody
0000157C                           698          
0000157C                           699  LSLreg:
0000157C                           700          
0000157C  43F9 000024A6            701          LEA     lslMessage,A1  ;move string for MOVE
00001582  103C 000E                702          MOVE.B  #14,D0        ;set for task to display null terminated 
00001586                           703                                ;string with CR, LF
00001586  4E4F                     704          TRAP    #15
00001588  6000 0002                705          BRA LSRLregBody
0000158C                           706          
0000158C                           707  LSRLregBody:
0000158C                           708                      
0000158C                           709          ;check i/r
0000158C  48E7 4000                710          MOVEM.L D1,-(SP)
00001590  6100 003C                711          BSR LSRLcheckIR
00001594  4CDF 0002                712          MOVEM.L (SP)+,D1
00001598                           713          
00001598                           714          ;print ','
00001598  48E7 4000                715          MOVEM.L D1,-(SP) ;save D1 to the stack
0000159C  123C 002C                716          MOVE.B #',',D1 ;put ascii value of char in D1
000015A0  103C 0006                717          MOVE.B #6,D0 ;move task 6 into D0
000015A4  4E4F                     718          TRAP #15 ;prin char
000015A6  4CDF 0002                719          MOVEM.L (SP)+,D1 ;pull D1 off the stack
000015AA                           720          
000015AA  3401                     721          MOVE.W  D1,D2 ;check mode
000015AC  C43C 0007                722          AND.B   #%00000111,D2
000015B0  1A02                     723          MOVE.B  D2,D5
000015B2  48E7 4000                724          MOVEM.L D1,-(SP)
000015B6  6100 0AB8                725          BSR     Get_Effective_Address
000015BA  4CDF 0002                726          MOVEM.L (SP)+,D1
000015BE                           727          
000015BE                           728          
000015BE  43F9 0000247E            729          LEA     clearLine,A1  ;move string for a CR and LF
000015C4  103C 000E                730          MOVE.B  #14,D0        ;set for task to display null terminated 
000015C8                           731                                ;string without CR, LF
000015C8  4E4F                     732          TRAP    #15
000015CA                           733  
000015CA  7000                     734          MOVEQ.L #0,D0
000015CC  4E75                     735          RTS
000015CE                           736  
000015CE                           737  LSRLcheckIR:
000015CE                           738  
000015CE  1401                     739          MOVE.B D1,D2 ;move inst to D2
000015D0  EA0A                     740          LSR.B  #5,D2
000015D2  C43C 0001                741          AND.B  #%00000001,D2
000015D6  0C02 0000                742          CMPI.B #0,D2
000015DA  6700 0008                743          BEQ  LSRLcheckI
000015DE  6000 0038                744          BRA  LSRLcheckR
000015E2                           745  LSRLcheckIRreturn:
000015E2  4E75                     746          RTS
000015E4                           747          
000015E4                           748  LSRLcheckI:
000015E4                           749          ;print '#'
000015E4  48E7 4000                750          MOVEM.L D1,-(SP) ;save D1 to the stack
000015E8  123C 0023                751          MOVE.B #'#',D1 ;put ascii value of '#' in D1
000015EC  103C 0006                752          MOVE.B #6,D0 ;move task 6 into D0
000015F0  4E4F                     753          TRAP #15 ;prin char
000015F2  4CDF 0002                754          MOVEM.L (SP)+,D1 ;pull D1 off the stack
000015F6                           755          
000015F6                           756          
000015F6                           757          ;print number
000015F6  48E7 4000                758          MOVEM.L D1,-(SP)
000015FA  3401                     759          MOVE.W D1,D2 ;copy inst to d2
000015FC  E04A                     760          LSR.W #8,D2 ;shift data section
000015FE  E20A                     761          LSR.B #1,D2
00001600  C43C 0007                762          AND.B #%00000111,D2 ;mask out rest of data
00001604  6100 00D6                763          BSR ZeroToEight ;handle zero
00001608  7200                     764          MOVEQ.L #0,D1 ;clear D1
0000160A  1202                     765          MOVE.B D2,D1 ;move number to display into D1
0000160C  103C 0003                766          MOVE.B #3,D0 ;move task 3 to D0
00001610  4E4F                     767          TRAP #15
00001612  4CDF 0002                768          MOVEM.L (SP)+,D1
00001616  60CA                     769          BRA LSRLcheckIRreturn
00001618                           770          
00001618                           771  LSRLcheckR:
00001618  3401                     772          MOVE.W D1,D2 ;copy inst to d2
0000161A  E04A                     773          LSR.W #8,D2 ;shift data section
0000161C  E20A                     774          LSR.B #1,D2
0000161E  C43C 0007                775          AND.B #%00000111,D2 ;mask out rest of data
00001622  1A02                     776          MOVE.B D2,D5 ;force Dn
00001624  48E7 4000                777          MOVEM.L D1,-(SP)
00001628  6100 0A46                778          BSR     Get_Effective_Address
0000162C  4CDF 0002                779          MOVEM.L (SP)+,D1
00001630  60B0                     780          BRA LSRLcheckIRreturn
00001632                           781          
00001632= 00 08 10 18 20 38 ...    782  subqEA        DC.B %000000,%001000,%010000,%011000,%100000,%111000,%111001,0
0000163A= 38 38 38 38 38 3F ...    783  subqEAmasks   DC.B %111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001642                           784  
00001642                           785  SUBQ:
00001642                           786          
00001642                           787  
00001642                           788          
00001642  7000                     789          MOVEQ.L #0, D0 ;clear D0
00001644                           790          
00001644                           791          ;check valid size field
00001644  3401                     792          MOVE.W D1,D2 ;copy inst to D2
00001646  EC4A                     793          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
00001648  0202 0003                794          ANDI.B #%00000011,D2 ;mask out rest of byte
0000164C  0C02 0003                795          CMPI.B #%11,D2 ;compare to 3
00001650  6700 FA40                796          BEQ falsePositive ;invalid size
00001654                           797          
00001654                           798  validSubq:
00001654                           799          
00001654  43F8 163A                800          LEA subqEAmasks,A1 ;load the list of masks
00001658  D3C0                     801          ADDA.L D0,A1 ;displace to a specific mask
0000165A  1A11                     802          MOVE.B (A1),D5 ;move the mask to D5
0000165C                           803          
0000165C  0C05 0000                804          CMPI.B #0,D5 ;check if the mask is 0
00001660  6700 FA30                805          BEQ falsePositive ;branch if it is
00001664                           806          
00001664  1401                     807          MOVE.B D1,D2 ;copy instruction to D2
00001666  C405                     808          AND.B D5,D2  ;mask D2
00001668                           809          
00001668  43F8 1632                810          LEA subqEA,A1 ;load the list of valid modes
0000166C  D3C0                     811          ADDA.L D0,A1 ;displace to a specific mode
0000166E  1811                     812          MOVE.B (A1),D4 ;move mode to D4
00001670  B404                     813          CMP.B D4,D2 ;compare mode to masked value
00001672  6700 0006                814          BEQ  subqBody ;if its match, its a valid mode and we can procede
00001676                           815          
00001676  5280                     816          ADDQ.L #1,D0 ;add one to displacement
00001678  60DA                     817          BRA validSubq ;check for next mode
0000167A                           818          
0000167A                           819          
0000167A                           820  subqBody
0000167A                           821  
0000167A  43F9 000024B0            822          LEA     subqMessage,A1  ;move string for MOVE
00001680  103C 000E                823          MOVE.B  #14,D0        ;set for task to display null terminated 
00001684                           824                                ;string with CR, LF
00001684  4E4F                     825          TRAP    #15
00001686                           826          
00001686                           827          ;immediate data
00001686                           828          
00001686                           829          ;print '#'
00001686  48E7 4000                830          MOVEM.L D1,-(SP) ;save D1 to the stack
0000168A  123C 0023                831          MOVE.B #'#',D1 ;put ascii value of '#' in D1
0000168E  103C 0006                832          MOVE.B #6,D0 ;move task 6 into D0
00001692  4E4F                     833          TRAP #15 ;prin char
00001694  4CDF 0002                834          MOVEM.L (SP)+,D1 ;pull D1 off the stack
00001698                           835          
00001698                           836          ;print number
00001698  48E7 4000                837          MOVEM.L D1,-(SP)
0000169C  3401                     838          MOVE.W D1,D2 ;copy inst to d2
0000169E  E04A                     839          LSR.W #8,D2 ;shift data section
000016A0  E20A                     840          LSR.B #1,D2
000016A2  C43C 0007                841          AND.B #%00000111,D2 ;mask out rest of data
000016A6  6100 0034                842          BSR ZeroToEight ;handle zero
000016AA  7200                     843          MOVEQ.L #0,D1 ;clear D1
000016AC  1202                     844          MOVE.B D2,D1 ;move number to display into D1
000016AE  103C 0003                845          MOVE.B #3,D0 ;move task 3 to D0
000016B2  4E4F                     846          TRAP #15
000016B4  4CDF 0002                847          MOVEM.L (SP)+,D1
000016B8                           848          
000016B8                           849          ;print separator
000016B8                           850          
000016B8                           851          ;Then do EA
000016B8                           852          
000016B8  3401                     853          MOVE.W  D1,D2 ;check mode
000016BA  C43C 003F                854          AND.B   #%00111111,D2
000016BE  1A02                     855          MOVE.B  D2,D5
000016C0  48E7 4000                856          MOVEM.L D1,-(SP)
000016C4  6100 09AA                857          BSR     Get_Effective_Address
000016C8  4CDF 0002                858          MOVEM.L (SP)+,D1
000016CC                           859          
000016CC  43F9 0000247E            860          LEA     clearLine,A1  ;move string for a CR and LF
000016D2  103C 000E                861          MOVE.B  #14,D0        ;set for task to display null terminated 
000016D6                           862                                ;string without CR, LF
000016D6  4E4F                     863          TRAP    #15
000016D8                           864  
000016D8  7000                     865          MOVEQ.L #0,D0
000016DA  4E75                     866          RTS
000016DC                           867          
000016DC                           868  ZeroToEight:
000016DC                           869          
000016DC  0C02 0000                870          CMPI.B #0,D2
000016E0  6700 0004                871          BEQ toEight
000016E4                           872  ZeroToEightReturn:
000016E4                           873          
000016E4  4E75                     874          RTS
000016E6                           875  toEight:
000016E6                           876          
000016E6  5002                     877          ADDQ.B #8,D2
000016E8  60FA                     878          BRA ZeroToEightReturn
000016EA                           879  
000016EA                           880      
000016EA                           881  SUB:
000016EA                           882          
000016EA                           883  
000016EA                           884          
000016EA  7000                     885          MOVEQ.L #0, D0 ;clear D0
000016EC                           886          
000016EC                           887          ;Figure out if EA is source or destination
000016EC  3401                     888          MOVE.W D1,D2 ;copy inst to D2
000016EE  EC4A                     889          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
000016F0  0202 0007                890          ANDI.B #%00000111,D2 ;mask out rest of byte
000016F4  0C02 0002                891          CMPI.B #2,D2 ;compare to 2
000016F8  6F00 0016                892          BLE validSubSourceEA ;2 or less is EA is source
000016FC                           893          
000016FC  0C02 0007                894          CMPI.B #%111,D2 ;compare to 7
00001700  6700 F990                895          BEQ falsePositive ;thats not valid
00001704  0C02 0003                896          CMPI.B #%11,D2 ;compare to 3
00001708  6700 F988                897          BEQ falsePositive ;also not valid
0000170C  6000 002C                898          BRA validSubDestEA ;all thats left is valid EA as Dest 
00001710                           899          
00001710                           900  validSubSourceEA:
00001710                           901          
00001710  43F9 00001CCB            902          LEA moveSourceEAmasks,A1 ;load the list of masks
00001716  D3C0                     903          ADDA.L D0,A1 ;displace to a specific mask
00001718  1A11                     904          MOVE.B (A1),D5 ;move the mask to D5
0000171A                           905          
0000171A  0C05 0000                906          CMPI.B #0,D5 ;check if the mask is 0
0000171E  6700 F972                907          BEQ falsePositive ;branch if it is
00001722                           908          
00001722  1401                     909          MOVE.B D1,D2 ;copy instruction to D2
00001724  C405                     910          AND.B D5,D2  ;mask D2
00001726                           911          
00001726  43F9 00001CC2            912          LEA moveSourceEA,A1 ;load the list of valid modes
0000172C  D3C0                     913          ADDA.L D0,A1 ;displace to a specific mode
0000172E  1811                     914          MOVE.B (A1),D4 ;move mode to D4
00001730  B404                     915          CMP.B D4,D2 ;compare mode to masked value
00001732  6700 0036                916          BEQ  subSource ;if its match, its a valid mode and we can procede
00001736                           917          
00001736  5280                     918          ADDQ.L #1,D0 ;add one to displacement
00001738  60D6                     919          BRA validSubSourceEA ;check for next mode
0000173A                           920          
0000173A                           921          
0000173A                           922  validSubDestEA:
0000173A                           923          
0000173A  43F9 00001892            924          LEA addDestEAmasks,A1 ;load the list of masks
00001740  D3C0                     925          ADDA.L D0,A1 ;displace to a specific mask
00001742  1A11                     926          MOVE.B (A1),D5 ;move the mask to D5
00001744                           927          
00001744  0C05 0000                928          CMPI.B #0,D5 ;check if the mask is 0
00001748  6700 F948                929          BEQ falsePositive ;branch if it is
0000174C                           930          
0000174C  3401                     931          MOVE.W D1,D2 ;copy instruction to D2
0000174E  EC4A                     932          LSR.W #6,D2  ;move mode
00001750  6100 0B50                933          BSR switchModeAndReg ;switch register and mode
00001754  C405                     934          AND.B D5,D2  ;mask D2
00001756                           935          
00001756  43F9 0000188C            936          LEA addDestEA,A1 ;load the list of valid modes
0000175C  D3C0                     937          ADDA.L D0,A1 ;displace to a specific mode
0000175E  1811                     938          MOVE.B (A1),D4 ;move mode to D4
00001760  B404                     939          CMP.B D4,D2 ;compare mode to masked value
00001762  6700 004E                940          BEQ subDest ;if its match, its a valid mode and we can procede
00001766                           941          
00001766  5280                     942          ADDQ.L #1,D0 ;add one to displacement
00001768  60D0                     943          BRA validSubDestEA ;check for next mode
0000176A                           944          
0000176A                           945  subSource
0000176A                           946  
0000176A  43F9 000024B6            947          LEA     subMessage,A1  ;move string for MOVE
00001770  103C 000E                948          MOVE.B  #14,D0        ;set for task to display null terminated 
00001774                           949                                ;string with CR, LF
00001774  4E4F                     950          TRAP    #15
00001776                           951          
00001776                           952          ;do EA
00001776                           953          
00001776  3401                     954          MOVE.W  D1,D2 ;check mode
00001778  C43C 003F                955          AND.B   #%00111111,D2
0000177C  1A02                     956          MOVE.B  D2,D5
0000177E  48E7 4000                957          MOVEM.L D1,-(SP)
00001782  6100 08EC                958          BSR     Get_Effective_Address
00001786  4CDF 0002                959          MOVEM.L (SP)+,D1
0000178A                           960          
0000178A                           961          ;print separator
0000178A                           962          
0000178A                           963          ;Then do Dn
0000178A                           964          
0000178A  3401                     965          MOVE.W  D1,D2
0000178C  E04A                     966          LSR.W   #8,D2 ;move reg into first byte
0000178E  E20A                     967          LSR.B   #1,D2 ;line it up to least sig bit
00001790  C43C 0007                968          AND.B   #%00000111,D2 ;force mode to Dn
00001794  1A02                     969          MOVE.B  D2,D5
00001796  48E7 4000                970          MOVEM.L D1,-(SP)
0000179A  6100 08D4                971          BSR     Get_Effective_Address
0000179E  4CDF 0002                972          MOVEM.L (SP)+,D1
000017A2                           973          
000017A2  43F9 0000247E            974          LEA     clearLine,A1  ;move string for a CR and LF
000017A8  103C 000E                975          MOVE.B  #14,D0        ;set for task to display null terminated 
000017AC                           976                                ;string without CR, LF
000017AC  4E4F                     977          TRAP    #15
000017AE                           978  
000017AE  7000                     979          MOVEQ.L #0,D0
000017B0  4E75                     980          RTS
000017B2                           981  
000017B2                           982  subDest
000017B2                           983  
000017B2  43F9 000024B6            984          LEA     subMessage,A1  ;move string for MOVE
000017B8  103C 000E                985          MOVE.B  #14,D0        ;set for task to display null terminated 
000017BC                           986                                ;string with CR, LF
000017BC  4E4F                     987          TRAP    #15
000017BE                           988          
000017BE                           989          ;Do Dn
000017BE                           990          
000017BE  3401                     991          MOVE.W  D1,D2
000017C0  E04A                     992          LSR.W   #8,D2 ;move reg into first byte
000017C2  E20A                     993          LSR.B   #1,D2 ;line it up to least sig bit
000017C4  C43C 0007                994          AND.B   #%00000111,D2 ;force mode to Dn
000017C8  1A02                     995          MOVE.B  D2,D5
000017CA  48E7 4000                996          MOVEM.L D1,-(SP)
000017CE  6100 08A0                997          BSR     Get_Effective_Address
000017D2  4CDF 0002                998          MOVEM.L (SP)+,D1
000017D6                           999          
000017D6                          1000          
000017D6                          1001          ;print separator
000017D6                          1002          
000017D6                          1003          ;Then do EA
000017D6                          1004          
000017D6  3401                    1005          MOVE.W  D1,D2 ;check mode
000017D8  C43C 003F               1006          AND.B   #%00111111,D2
000017DC  1A02                    1007          MOVE.B  D2,D5
000017DE  48E7 4000               1008          MOVEM.L D1,-(SP)
000017E2  6100 088C               1009          BSR     Get_Effective_Address
000017E6  4CDF 0002               1010          MOVEM.L (SP)+,D1
000017EA                          1011          
000017EA                          1012          
000017EA  43F9 0000247E           1013          LEA     clearLine,A1  ;move string for a CR and LF
000017F0  103C 000E               1014          MOVE.B  #14,D0        ;set for task to display null terminated 
000017F4                          1015                                ;string without CR, LF
000017F4  4E4F                    1016          TRAP    #15
000017F6                          1017  
000017F6  7000                    1018          MOVEQ.L #0,D0
000017F8  4E75                    1019          RTS
000017FA                          1020  
000017FA                          1021  
000017FA                          1022  ADDA:
000017FA                          1023          
000017FA                          1024  
000017FA                          1025          
000017FA  7000                    1026          MOVEQ.L #0, D0 ;clear D0
000017FC                          1027          
000017FC                          1028          ;check opmode field
000017FC  3401                    1029          MOVE.W D1,D2 ;copy inst to D2
000017FE  EC4A                    1030          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
00001800  0202 0007               1031          ANDI.B #%00000111,D2 ;mask out rest of byte
00001804  0C02 0007               1032          CMPI.B #%111,D2 ;compare to 7
00001808  6700 000E               1033          BEQ validAdda ;thats valid
0000180C  0C02 0003               1034          CMPI.B #%11,D2 ;compare to 3
00001810  6700 0006               1035          BEQ validAdda ;also valid
00001814  6000 F87C               1036          BRA falsePositive ;all thats left is invalid 
00001818                          1037          
00001818                          1038  validAdda:
00001818                          1039          
00001818  43F9 00001CCB           1040          LEA moveSourceEAmasks,A1 ;load the list of masks
0000181E  D3C0                    1041          ADDA.L D0,A1 ;displace to a specific mask
00001820  1A11                    1042          MOVE.B (A1),D5 ;move the mask to D5
00001822                          1043          
00001822  0C05 0000               1044          CMPI.B #0,D5 ;check if the mask is 0
00001826  6700 F86A               1045          BEQ falsePositive ;branch if it is
0000182A                          1046          
0000182A  1401                    1047          MOVE.B D1,D2 ;copy instruction to D2
0000182C  C405                    1048          AND.B D5,D2  ;mask D2
0000182E                          1049          
0000182E  43F9 00001CC2           1050          LEA moveSourceEA,A1 ;load the list of valid modes
00001834  D3C0                    1051          ADDA.L D0,A1 ;displace to a specific mode
00001836  1811                    1052          MOVE.B (A1),D4 ;move mode to D4
00001838  B404                    1053          CMP.B D4,D2 ;compare mode to masked value
0000183A  6700 0006               1054          BEQ  addaBody ;if its match, its a valid mode and we can procede
0000183E                          1055          
0000183E  5280                    1056          ADDQ.L #1,D0 ;add one to displacement
00001840  60D6                    1057          BRA validAdda ;check for next mode
00001842                          1058          
00001842                          1059          
00001842                          1060  addaBody
00001842                          1061  
00001842  43F9 000024BB           1062          LEA     addaMessage,A1  ;move string for MOVE
00001848  103C 000E               1063          MOVE.B  #14,D0        ;set for task to display null terminated 
0000184C                          1064                                ;string with CR, LF
0000184C  4E4F                    1065          TRAP    #15
0000184E                          1066          
0000184E                          1067          ;do EA
0000184E                          1068          
0000184E  3401                    1069          MOVE.W  D1,D2 ;check mode
00001850  C43C 003F               1070          AND.B   #%00111111,D2
00001854  1A02                    1071          MOVE.B  D2,D5
00001856  48E7 4000               1072          MOVEM.L D1,-(SP)
0000185A  6100 0814               1073          BSR     Get_Effective_Address
0000185E  4CDF 0002               1074          MOVEM.L (SP)+,D1
00001862                          1075          
00001862                          1076          ;print separator
00001862                          1077          
00001862                          1078          ;Then do Dn
00001862                          1079          
00001862  3401                    1080          MOVE.W  D1,D2
00001864  E04A                    1081          LSR.W   #8,D2 ;move reg into first byte
00001866  E20A                    1082          LSR.B   #1,D2 ;line it up to least sig bit
00001868  C43C 0007               1083          AND.B   #%00000111,D2 ;force mode to An
0000186C  5002                    1084          ADDI.B  #%00001000,D2 
0000186E  1A02                    1085          MOVE.B  D2,D5
00001870  48E7 4000               1086          MOVEM.L D1,-(SP)
00001874  6100 07FA               1087          BSR     Get_Effective_Address
00001878  4CDF 0002               1088          MOVEM.L (SP)+,D1
0000187C                          1089          
0000187C  43F9 0000247E           1090          LEA     clearLine,A1  ;move string for a CR and LF
00001882  103C 000E               1091          MOVE.B  #14,D0        ;set for task to display null terminated 
00001886                          1092                                ;string without CR, LF
00001886  4E4F                    1093          TRAP    #15
00001888                          1094  
00001888  7000                    1095          MOVEQ.L #0,D0
0000188A  4E75                    1096          RTS
0000188C                          1097  
0000188C                          1098  
0000188C                          1099      
0000188C= 10 18 20 38 39 00       1100  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
00001892= 38 38 38 3F 3F 00       1101  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
00001898                          1102  
00001898                          1103  ADD:
00001898                          1104          
00001898                          1105  
00001898                          1106          
00001898  7000                    1107          MOVEQ.L #0, D0 ;clear D0
0000189A                          1108          
0000189A                          1109          ;Figure out if EA is source or destination
0000189A  3401                    1110          MOVE.W D1,D2 ;copy inst to D2
0000189C  EC4A                    1111          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
0000189E  0202 0007               1112          ANDI.B #%00000111,D2 ;mask out rest of byte
000018A2  0C02 0002               1113          CMPI.B #2,D2 ;compare to 2
000018A6  6F00 0016               1114          BLE validAddSourceEA ;2 or less is EA is source
000018AA                          1115          
000018AA  0C02 0007               1116          CMPI.B #%111,D2 ;compare to 7
000018AE  6700 F7E2               1117          BEQ falsePositive ;thats not valid
000018B2  0C02 0003               1118          CMPI.B #%11,D2 ;compare to 3
000018B6  6700 F7DA               1119          BEQ falsePositive ;also not valid
000018BA  6000 002C               1120          BRA validAddDestEA ;all thats left is valid EA as Dest 
000018BE                          1121          
000018BE                          1122  validAddSourceEA:
000018BE                          1123          
000018BE  43F9 00001CCB           1124          LEA moveSourceEAmasks,A1 ;load the list of masks
000018C4  D3C0                    1125          ADDA.L D0,A1 ;displace to a specific mask
000018C6  1A11                    1126          MOVE.B (A1),D5 ;move the mask to D5
000018C8                          1127          
000018C8  0C05 0000               1128          CMPI.B #0,D5 ;check if the mask is 0
000018CC  6700 F7C4               1129          BEQ falsePositive ;branch if it is
000018D0                          1130          
000018D0  1401                    1131          MOVE.B D1,D2 ;copy instruction to D2
000018D2  C405                    1132          AND.B D5,D2  ;mask D2
000018D4                          1133          
000018D4  43F9 00001CC2           1134          LEA moveSourceEA,A1 ;load the list of valid modes
000018DA  D3C0                    1135          ADDA.L D0,A1 ;displace to a specific mode
000018DC  1811                    1136          MOVE.B (A1),D4 ;move mode to D4
000018DE  B404                    1137          CMP.B D4,D2 ;compare mode to masked value
000018E0  6700 0032               1138          BEQ  addSource ;if its match, its a valid mode and we can procede
000018E4                          1139          
000018E4  5280                    1140          ADDQ.L #1,D0 ;add one to displacement
000018E6  60D6                    1141          BRA validAddSourceEA ;check for next mode
000018E8                          1142          
000018E8                          1143          
000018E8                          1144  validAddDestEA:
000018E8                          1145          
000018E8  43F8 1892               1146          LEA addDestEAmasks,A1 ;load the list of masks
000018EC  D3C0                    1147          ADDA.L D0,A1 ;displace to a specific mask
000018EE  1A11                    1148          MOVE.B (A1),D5 ;move the mask to D5
000018F0                          1149          
000018F0  0C05 0000               1150          CMPI.B #0,D5 ;check if the mask is 0
000018F4  6700 F79C               1151          BEQ falsePositive ;branch if it is
000018F8                          1152          
000018F8  3401                    1153          MOVE.W D1,D2 ;copy instruction to D2
000018FA  EC4A                    1154          LSR.W #6,D2  ;move mode
000018FC  6100 09A4               1155          BSR switchModeAndReg ;switch register and mode
00001900  C405                    1156          AND.B D5,D2  ;mask D2
00001902                          1157          
00001902  43F8 188C               1158          LEA addDestEA,A1 ;load the list of valid modes
00001906  D3C0                    1159          ADDA.L D0,A1 ;displace to a specific mode
00001908  1811                    1160          MOVE.B (A1),D4 ;move mode to D4
0000190A  B404                    1161          CMP.B D4,D2 ;compare mode to masked value
0000190C  6700 004E               1162          BEQ addDest ;if its match, its a valid mode and we can procede
00001910                          1163          
00001910  5280                    1164          ADDQ.L #1,D0 ;add one to displacement
00001912  60D4                    1165          BRA validAddDestEA ;check for next mode
00001914                          1166          
00001914                          1167  addSource
00001914                          1168  
00001914  43F9 000024C1           1169          LEA     addMessage,A1  ;move string for MOVE
0000191A  103C 000E               1170          MOVE.B  #14,D0        ;set for task to display null terminated 
0000191E                          1171                                ;string with CR, LF
0000191E  4E4F                    1172          TRAP    #15
00001920                          1173          
00001920                          1174          ;do EA
00001920                          1175          
00001920  3401                    1176          MOVE.W  D1,D2 ;check mode
00001922  C43C 003F               1177          AND.B   #%00111111,D2
00001926  1A02                    1178          MOVE.B  D2,D5
00001928  48E7 4000               1179          MOVEM.L D1,-(SP)
0000192C  6100 0742               1180          BSR     Get_Effective_Address
00001930  4CDF 0002               1181          MOVEM.L (SP)+,D1
00001934                          1182          
00001934                          1183          ;print separator
00001934                          1184          
00001934                          1185          ;Then do Dn
00001934                          1186          
00001934  3401                    1187          MOVE.W  D1,D2
00001936  E04A                    1188          LSR.W   #8,D2 ;move reg into first byte
00001938  E20A                    1189          LSR.B   #1,D2 ;line it up to least sig bit
0000193A  C43C 0007               1190          AND.B   #%00000111,D2 ;force mode to Dn
0000193E  1A02                    1191          MOVE.B  D2,D5
00001940  48E7 4000               1192          MOVEM.L D1,-(SP)
00001944  6100 072A               1193          BSR     Get_Effective_Address
00001948  4CDF 0002               1194          MOVEM.L (SP)+,D1
0000194C                          1195          
0000194C  43F9 0000247E           1196          LEA     clearLine,A1  ;move string for a CR and LF
00001952  103C 000E               1197          MOVE.B  #14,D0        ;set for task to display null terminated 
00001956                          1198                                ;string without CR, LF
00001956  4E4F                    1199          TRAP    #15
00001958                          1200  
00001958  7000                    1201          MOVEQ.L #0,D0
0000195A  4E75                    1202          RTS
0000195C                          1203  
0000195C                          1204  addDest
0000195C                          1205  
0000195C  43F9 000024C1           1206          LEA     addMessage,A1  ;move string for MOVE
00001962  103C 000E               1207          MOVE.B  #14,D0        ;set for task to display null terminated 
00001966                          1208                                ;string with CR, LF
00001966  4E4F                    1209          TRAP    #15
00001968                          1210          
00001968                          1211          ;Do Dn
00001968                          1212          
00001968  3401                    1213          MOVE.W  D1,D2
0000196A  E04A                    1214          LSR.W   #8,D2 ;move reg into first byte
0000196C  E20A                    1215          LSR.B   #1,D2 ;line it up to least sig bit
0000196E  C43C 0007               1216          AND.B   #%00000111,D2 ;force mode to Dn
00001972  1A02                    1217          MOVE.B  D2,D5
00001974  48E7 4000               1218          MOVEM.L D1,-(SP)
00001978  6100 06F6               1219          BSR     Get_Effective_Address
0000197C  4CDF 0002               1220          MOVEM.L (SP)+,D1
00001980                          1221          
00001980                          1222          
00001980                          1223          ;print separator
00001980                          1224          
00001980                          1225          ;Then do EA
00001980                          1226          
00001980  3401                    1227          MOVE.W  D1,D2 ;check mode
00001982  C43C 003F               1228          AND.B   #%00111111,D2
00001986  1A02                    1229          MOVE.B  D2,D5
00001988  48E7 4000               1230          MOVEM.L D1,-(SP)
0000198C  6100 06E2               1231          BSR     Get_Effective_Address
00001990  4CDF 0002               1232          MOVEM.L (SP)+,D1
00001994                          1233          
00001994                          1234          
00001994  43F9 0000247E           1235          LEA     clearLine,A1  ;move string for a CR and LF
0000199A  103C 000E               1236          MOVE.B  #14,D0        ;set for task to display null terminated 
0000199E                          1237                                ;string without CR, LF
0000199E  4E4F                    1238          TRAP    #15
000019A0                          1239  
000019A0  7000                    1240          MOVEQ.L #0,D0
000019A2  4E75                    1241          RTS
000019A4                          1242  
000019A4                          1243  
000019A4= 10 20 38 39 00          1244  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
000019A9= 38 38 3F 3F 00          1245  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
000019AE                          1246  
000019AE= 10 18 38 39 00          1247  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
000019B3= 38 38 3F 3F 00          1248  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
000019B8                          1249  
000019B8                          1250  MOVEM:
000019B8                          1251          
000019B8                          1252  
000019B8                          1253          
000019B8  7000                    1254          MOVEQ.L #0, D0 ;clear D0
000019BA                          1255          
000019BA                          1256          ;Figure out which direction we are going
000019BA  3401                    1257          MOVE.W D1,D2 ;copy inst to D2
000019BC  E64A                    1258          LSR.W #3,D2 ;shift direction bit into most sig bit of first byte
000019BE  0202 0080               1259          ANDI.B #%10000000,D2 ;mask out everything but direction bit in first byte
000019C2  0C02 0000               1260          CMPI.B #0,D2 ;compare bit to zero
000019C6  6700 0006               1261          BEQ validRegToMem ;if zero, reg to mem
000019CA  6000 0028               1262          BRA validMemToReg ;else, its mem to reg
000019CE                          1263          
000019CE                          1264  validRegToMem:
000019CE                          1265          
000019CE  43F8 19A9               1266          LEA movemRegToMemEAmasks,A1 ;load the list of masks
000019D2  D3C0                    1267          ADDA.L D0,A1 ;displace to a specific mask
000019D4  1A11                    1268          MOVE.B (A1),D5 ;move the mask to D5
000019D6                          1269          
000019D6  0C05 0000               1270          CMPI.B #0,D5 ;check if the mask is 0
000019DA  6700 F6B6               1271          BEQ falsePositive ;branch if it is
000019DE                          1272          
000019DE  1401                    1273          MOVE.B D1,D2 ;copy instruction to D2
000019E0  C405                    1274          AND.B D5,D2  ;mask D2
000019E2                          1275          
000019E2  43F8 19A4               1276          LEA movemRegToMemEA,A1 ;load the list of valid modes
000019E6  D3C0                    1277          ADDA.L D0,A1 ;displace to a specific mode
000019E8  1811                    1278          MOVE.B (A1),D4 ;move mode to D4
000019EA  B404                    1279          CMP.B D4,D2 ;compare mode to masked value
000019EC  6700 0034               1280          BEQ  movemBody ;if its match, its a valid mode and we can procede
000019F0                          1281          
000019F0  5280                    1282          ADDQ.L #1,D0 ;add one to displacement
000019F2  60DA                    1283          BRA validRegToMem ;check for next mode
000019F4                          1284          
000019F4                          1285          
000019F4                          1286  validMemToReg:
000019F4                          1287          
000019F4  43F8 19B3               1288          LEA movemMemToRegEAmasks,A1 ;load the list of masks
000019F8  D3C0                    1289          ADDA.L D0,A1 ;displace to a specific mask
000019FA  1A11                    1290          MOVE.B (A1),D5 ;move the mask to D5
000019FC                          1291          
000019FC  0C05 0000               1292          CMPI.B #0,D5 ;check if the mask is 0
00001A00  6700 F690               1293          BEQ falsePositive ;branch if it is
00001A04                          1294          
00001A04  3401                    1295          MOVE.W D1,D2 ;copy instruction to D2
00001A06  EC4A                    1296          LSR.W #6,D2  ;move mode
00001A08  6100 0898               1297          BSR switchModeAndReg ;switch register and mode
00001A0C  C405                    1298          AND.B D5,D2  ;mask D2
00001A0E                          1299          
00001A0E  43F8 19AE               1300          LEA movemMemToRegEA,A1 ;load the list of valid modes
00001A12  D3C0                    1301          ADDA.L D0,A1 ;displace to a specific mode
00001A14  1811                    1302          MOVE.B (A1),D4 ;move mode to D4
00001A16  B404                    1303          CMP.B D4,D2 ;compare mode to masked value
00001A18  6700 0008               1304          BEQ movemBody ;if its match, its a valid mode and we can procede
00001A1C                          1305          
00001A1C  5280                    1306          ADDQ.L #1,D0 ;add one to displacement
00001A1E  6000 02EC               1307          BRA validMoveDestModes ;check for next mode
00001A22                          1308          
00001A22                          1309  movemBody
00001A22                          1310  
00001A22  43F9 000024C6           1311          LEA     movemMessage,A1  ;move string for MOVE
00001A28  103C 000E               1312          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A2C                          1313                                ;string with CR, LF
00001A2C  4E4F                    1314          TRAP    #15
00001A2E                          1315          
00001A2E                          1316          ;show list
00001A2E                          1317          
00001A2E  5487                    1318          ADDQ.L #word,D7 ;read past the register list mask(word) following
00001A30                          1319                          ;the instruction
00001A30                          1320          
00001A30                          1321          ;print separator
00001A30                          1322          
00001A30  3401                    1323          MOVE.W  D1,D2 ;check mode
00001A32  C43C 003F               1324          AND.B   #%00111111,D2
00001A36  1A02                    1325          MOVE.B  D2,D5
00001A38  48E7 4000               1326          MOVEM.L D1,-(SP)
00001A3C  6100 0632               1327          BSR     Get_Effective_Address
00001A40  4CDF 0002               1328          MOVEM.L (SP)+,D1
00001A44                          1329          
00001A44                          1330          
00001A44  43F9 0000247E           1331          LEA     clearLine,A1  ;move string for a CR and LF
00001A4A  103C 000E               1332          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A4E                          1333                                ;string without CR, LF
00001A4E  4E4F                    1334          TRAP    #15
00001A50                          1335  
00001A50  7000                    1336          MOVEQ.L #0,D0
00001A52  4E75                    1337          RTS
00001A54                          1338  
00001A54                          1339  
00001A54                          1340      
00001A54= 00 10 18 20 28 38 ...   1341  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
00001A5C= 38 38 38 38 38 3F ...   1342  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
00001A64                          1343     
00001A64                          1344  NEG:            
00001A64                          1345       
00001A64  7000                    1346          MOVEQ.L #0, D0 ;clear D0
00001A66                          1347          
00001A66                          1348  validNegModes:
00001A66                          1349          
00001A66  43F8 1A5C               1350          LEA NegEAmasks,A1 ;load the list of masks
00001A6A  D3C0                    1351          ADDA.L D0,A1 ;displace to a specific mask
00001A6C  1A11                    1352          MOVE.B (A1),D5 ;move the mask to D5
00001A6E                          1353          
00001A6E  0C05 0000               1354          CMPI.B #0,D5 ;check if the mask is 0
00001A72  6700 F61E               1355          BEQ falsePositive ;branch if it is
00001A76                          1356          
00001A76  1401                    1357          MOVE.B D1,D2 ;copy instruction to D2
00001A78  C405                    1358          AND.B D5,D2  ;mask D2
00001A7A  43F8 1A54               1359          LEA NegEA,A1 ;load the list of valid modes
00001A7E  D3C0                    1360          ADDA.L D0,A1 ;displace to a specific mode
00001A80  1811                    1361          MOVE.B (A1),D4 ;move mode to D4
00001A82  B404                    1362          CMP.B D4,D2 ;compare mode to masked value
00001A84  6700 0006               1363          BEQ NegBody ;if its match, its a valid mode and we can procede
00001A88                          1364          
00001A88  5280                    1365          ADDQ.L #1,D0 ;add one to displacement
00001A8A  60DA                    1366          BRA validNegModes ;check for next mode
00001A8C                          1367          
00001A8C                          1368  NegBody:
00001A8C                          1369  
00001A8C                          1370  
00001A8C  3401                    1371          MOVE.W  D1,D2 ;copy inst to D2
00001A8E  C47C 0600               1372          AND.W  #%0011000000000,D2 ;mask word for size
00001A92  0C42 0000               1373          CMPI.W #0,D2 ;0 is the only non valid size
00001A96  6700 F5FA               1374          BEQ falsePositive ; zero is not valid
00001A9A                          1375  
00001A9A  43F9 000024F5           1376          LEA     negMessage,A1  ;move string for NEG info
00001AA0  103C 000E               1377          MOVE.B  #14,D0        ;set for task to display null terminated 
00001AA4                          1378                                ;string without CR, LF
00001AA4  4E4F                    1379          TRAP    #15
00001AA6                          1380          
00001AA6  3401                    1381          MOVE.W D1,D2
00001AA8  C47C 003F               1382          AND #%000000000111111,D2
00001AAC  1A02                    1383          MOVE.B D2,D5
00001AAE                          1384          
00001AAE  48E7 4000               1385          MOVEM.L D1,-(SP)
00001AB2  6100 05BC               1386          BSR     Get_Effective_Address
00001AB6  4CDF 0002               1387          MOVEM.L (SP)+,D1
00001ABA                          1388          
00001ABA                          1389                
00001ABA                          1390          
00001ABA                          1391  NEGdone:
00001ABA                          1392  
00001ABA  43F9 0000247E           1393          LEA     clearLine,A1  ;move string for a CR and LF
00001AC0  103C 000E               1394          MOVE.B  #14,D0        ;set for task to display null terminated 
00001AC4                          1395                                ;string without CR, LF
00001AC4  4E4F                    1396          TRAP    #15
00001AC6  7000                    1397          MOVEQ.L #0,D0
00001AC8  4E75                    1398          RTS
00001ACA                          1399          
00001ACA                          1400   ADDI:            
00001ACA                          1401       
00001ACA  7000                    1402          MOVEQ.L #0, D0 ;clear D0
00001ACC                          1403          
00001ACC                          1404  validAddiModes:
00001ACC                          1405          
00001ACC                          1406          
00001ACC  43F9 00001BC5           1407          LEA cmpiEAmasks,A1 ;load the list of masks
00001AD2  D3C0                    1408          ADDA.L D0,A1 ;displace to a specific mask
00001AD4  1A11                    1409          MOVE.B (A1),D5 ;move the mask to D5
00001AD6                          1410          
00001AD6  0C05 0000               1411          CMPI.B #0,D5 ;check if the mask is 0
00001ADA  6700 F5B6               1412          BEQ falsePositive ;branch if it is
00001ADE                          1413          
00001ADE  1401                    1414          MOVE.B D1,D2 ;copy instruction to D2
00001AE0  C405                    1415          AND.B D5,D2  ;mask D2
00001AE2  43F9 00001BBE           1416          LEA cmpiEA,A1 ;load the list of valid modes
00001AE8  D3C0                    1417          ADDA.L D0,A1 ;displace to a specific mode
00001AEA  1811                    1418          MOVE.B (A1),D4 ;move mode to D4
00001AEC  B404                    1419          CMP.B D4,D2 ;compare mode to masked value
00001AEE  6700 0006               1420          BEQ addiBody ;if its match, its a valid mode and we can procede
00001AF2                          1421          
00001AF2  5280                    1422          ADDQ.L #1,D0 ;add one to displacement
00001AF4  60D6                    1423          BRA validAddiModes ;check for next mode
00001AF6                          1424          
00001AF6                          1425  addiBody:
00001AF6                          1426  
00001AF6                          1427  
00001AF6  3401                    1428          MOVE.W  D1,D2 ;copy inst to D2
00001AF8  C47C 00C0               1429          AND.W  #%0000000011000000,D2 ;mask word for size
00001AFC  0C42 00C0               1430          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001B00  6700 F590               1431          BEQ falsePositive
00001B04                          1432  
00001B04  43F9 000024CD           1433          LEA     addiMessage,A1  ;move string for NEG info
00001B0A  103C 000E               1434          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B0E                          1435                                ;string without CR, LF
00001B0E  4E4F                    1436          TRAP    #15
00001B10                          1437          
00001B10                          1438          ;go to Effective_Address for immediate data
00001B10  143C 003C               1439          MOVE.B #%00111100,D2
00001B14  48E7 4000               1440          MOVEM.L D1,-(SP)
00001B18  6100 0556               1441          BSR     Get_Effective_Address
00001B1C  4CDF 0002               1442          MOVEM.L (SP)+,D1
00001B20                          1443          
00001B20  3401                    1444          MOVE.W D1,D2 ;copy inst to D2
00001B22  C47C 003F               1445          AND #%000000000111111,D2 ;and out everything but modes and regs
00001B26  1A02                    1446          MOVE.B D2,D5 ; copy to D5 for following BSR
00001B28                          1447          
00001B28  48E7 4000               1448          MOVEM.L D1,-(SP)
00001B2C  6100 0542               1449          BSR     Get_Effective_Address
00001B30  4CDF 0002               1450          MOVEM.L (SP)+,D1
00001B34                          1451          
00001B34                          1452                
00001B34                          1453          
00001B34                          1454  addidone:
00001B34                          1455  
00001B34  43F9 0000247E           1456          LEA     clearLine,A1  ;move string for a CR and LF
00001B3A  103C 000E               1457          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B3E                          1458                                ;string without CR, LF
00001B3E  4E4F                    1459          TRAP    #15
00001B40  7000                    1460          MOVEQ.L #0,D0
00001B42  4E75                    1461          RTS
00001B44                          1462    
00001B44                          1463  ORI:            
00001B44                          1464       
00001B44  7000                    1465          MOVEQ.L #0, D0 ;clear D0
00001B46                          1466          
00001B46                          1467  validOriModes:
00001B46                          1468          
00001B46                          1469          
00001B46  43F9 00001BC5           1470          LEA cmpiEAmasks,A1 ;load the list of masks
00001B4C  D3C0                    1471          ADDA.L D0,A1 ;displace to a specific mask
00001B4E  1A11                    1472          MOVE.B (A1),D5 ;move the mask to D5
00001B50                          1473          
00001B50  0C05 0000               1474          CMPI.B #0,D5 ;check if the mask is 0
00001B54  6700 F53C               1475          BEQ falsePositive ;branch if it is
00001B58                          1476          
00001B58  1401                    1477          MOVE.B D1,D2 ;copy instruction to D2
00001B5A  C405                    1478          AND.B D5,D2  ;mask D2
00001B5C  43F9 00001BBE           1479          LEA cmpiEA,A1 ;load the list of valid modes
00001B62  D3C0                    1480          ADDA.L D0,A1 ;displace to a specific mode
00001B64  1811                    1481          MOVE.B (A1),D4 ;move mode to D4
00001B66  B404                    1482          CMP.B D4,D2 ;compare mode to masked value
00001B68  6700 0006               1483          BEQ oriBody ;if its match, its a valid mode and we can procede
00001B6C                          1484          
00001B6C  5280                    1485          ADDQ.L #1,D0 ;add one to displacement
00001B6E  60D6                    1486          BRA validOriModes ;check for next mode
00001B70                          1487          
00001B70                          1488  oriBody:
00001B70                          1489  
00001B70                          1490  
00001B70  3401                    1491          MOVE.W  D1,D2 ;copy inst to D2
00001B72  C47C 00C0               1492          AND.W  #%0000000011000000,D2 ;mask word for size
00001B76  0C42 00C0               1493          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001B7A  6700 F516               1494          BEQ falsePositive
00001B7E                          1495  
00001B7E  43F9 000024D3           1496          LEA     oriMessage,A1  ;move string for NEG info
00001B84  103C 000E               1497          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B88                          1498                                ;string without CR, LF
00001B88  4E4F                    1499          TRAP    #15
00001B8A                          1500          
00001B8A                          1501          ;go to Effective_Address for immediate data
00001B8A  143C 003C               1502          MOVE.B #%00111100,D2
00001B8E  48E7 4000               1503          MOVEM.L D1,-(SP)
00001B92  6100 04DC               1504          BSR     Get_Effective_Address
00001B96  4CDF 0002               1505          MOVEM.L (SP)+,D1
00001B9A                          1506          
00001B9A  3401                    1507          MOVE.W D1,D2 ;copy inst to D2
00001B9C  C47C 003F               1508          AND #%000000000111111,D2 ;and out everything but modes and regs
00001BA0  1A02                    1509          MOVE.B D2,D5 ; copy to D5 for following BSR
00001BA2                          1510          
00001BA2  48E7 4000               1511          MOVEM.L D1,-(SP)
00001BA6  6100 04C8               1512          BSR     Get_Effective_Address
00001BAA  4CDF 0002               1513          MOVEM.L (SP)+,D1
00001BAE                          1514          
00001BAE                          1515                
00001BAE                          1516          
00001BAE                          1517  oridone:
00001BAE                          1518  
00001BAE  43F9 0000247E           1519          LEA     clearLine,A1  ;move string for a CR and LF
00001BB4  103C 000E               1520          MOVE.B  #14,D0        ;set for task to display null terminated 
00001BB8                          1521                                ;string without CR, LF
00001BB8  4E4F                    1522          TRAP    #15
00001BBA  7000                    1523          MOVEQ.L #0,D0
00001BBC  4E75                    1524          RTS
00001BBE                          1525  
00001BBE                          1526          
00001BBE                          1527          
00001BBE= 20 18 00 10 38 39 00    1528  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
00001BC5= 38 38 38 38 3F 3F 00    1529  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
00001BCC                          1530     
00001BCC                          1531  CMPI:            
00001BCC                          1532       
00001BCC  7000                    1533          MOVEQ.L #0, D0 ;clear D0
00001BCE                          1534          
00001BCE                          1535  validCmpiModes:
00001BCE                          1536          
00001BCE                          1537          
00001BCE  43F8 1BC5               1538          LEA cmpiEAmasks,A1 ;load the list of masks
00001BD2  D3C0                    1539          ADDA.L D0,A1 ;displace to a specific mask
00001BD4  1A11                    1540          MOVE.B (A1),D5 ;move the mask to D5
00001BD6                          1541          
00001BD6  0C05 0000               1542          CMPI.B #0,D5 ;check if the mask is 0
00001BDA  6700 F4B6               1543          BEQ falsePositive ;branch if it is
00001BDE                          1544          
00001BDE  1401                    1545          MOVE.B D1,D2 ;copy instruction to D2
00001BE0  C405                    1546          AND.B D5,D2  ;mask D2
00001BE2  43F8 1BBE               1547          LEA cmpiEA,A1 ;load the list of valid modes
00001BE6  D3C0                    1548          ADDA.L D0,A1 ;displace to a specific mode
00001BE8  1811                    1549          MOVE.B (A1),D4 ;move mode to D4
00001BEA  B404                    1550          CMP.B D4,D2 ;compare mode to masked value
00001BEC  6700 0006               1551          BEQ CMPIBody ;if its match, its a valid mode and we can procede
00001BF0                          1552          
00001BF0  5280                    1553          ADDQ.L #1,D0 ;add one to displacement
00001BF2  60DA                    1554          BRA validCmpiModes ;check for next mode
00001BF4                          1555          
00001BF4                          1556  CMPIBody:
00001BF4                          1557  
00001BF4                          1558  
00001BF4  3401                    1559          MOVE.W  D1,D2 ;copy inst to D2
00001BF6  C47C 00C0               1560          AND.W  #%0000000011000000,D2 ;mask word for size
00001BFA  0C42 00C0               1561          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001BFE  6700 F492               1562          BEQ falsePositive
00001C02                          1563  
00001C02  43F9 000024D8           1564          LEA     cmpiMessage,A1  ;move string for NEG info
00001C08  103C 000E               1565          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C0C                          1566                                ;string without CR, LF
00001C0C  4E4F                    1567          TRAP    #15
00001C0E                          1568          
00001C0E                          1569          ;go to Effective_Address for immediate data
00001C0E  143C 003C               1570          MOVE.B #%00111100,D2
00001C12  48E7 4000               1571          MOVEM.L D1,-(SP)
00001C16  6100 0458               1572          BSR     Get_Effective_Address
00001C1A  4CDF 0002               1573          MOVEM.L (SP)+,D1
00001C1E                          1574          
00001C1E  3401                    1575          MOVE.W D1,D2 ;copy inst to D2
00001C20  C47C 003F               1576          AND #%000000000111111,D2 ;and out everything but modes and regs
00001C24  1A02                    1577          MOVE.B D2,D5 ; copy to D5 for following BSR
00001C26                          1578          
00001C26  48E7 4000               1579          MOVEM.L D1,-(SP)
00001C2A  6100 0444               1580          BSR     Get_Effective_Address
00001C2E  4CDF 0002               1581          MOVEM.L (SP)+,D1
00001C32                          1582          
00001C32                          1583                
00001C32                          1584          
00001C32                          1585  CMPidone:
00001C32                          1586  
00001C32  43F9 0000247E           1587          LEA     clearLine,A1  ;move string for a CR and LF
00001C38  103C 000E               1588          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C3C                          1589                                ;string without CR, LF
00001C3C  4E4F                    1590          TRAP    #15
00001C3E  7000                    1591          MOVEQ.L #0,D0
00001C40  4E75                    1592          RTS
00001C42                          1593  
00001C42                          1594          
00001C42= 10 38 39 00             1595  JsrEA        DC.B %010000, %111000, %111001,0
00001C46= 38 3F 3F 00             1596  JsrEAmasks   DC.B %111000, %111111, %111111,0
00001C4A                          1597     
00001C4A                          1598  JSR:            
00001C4A                          1599       
00001C4A  7000                    1600          MOVEQ.L #0, D0 ;clear D0
00001C4C                          1601          
00001C4C                          1602  validJsrModes:
00001C4C                          1603          
00001C4C  43F8 1C46               1604          LEA JsrEAmasks,A1 ;load the list of masks
00001C50  D3C0                    1605          ADDA.L D0,A1 ;displace to a specific mask
00001C52  1A11                    1606          MOVE.B (A1),D5 ;move the mask to D5
00001C54                          1607          
00001C54  0C05 0000               1608          CMPI.B #0,D5 ;check if the mask is 0
00001C58  6700 F438               1609          BEQ falsePositive ;branch if it is
00001C5C                          1610          
00001C5C  1401                    1611          MOVE.B D1,D2 ;copy instruction to D2
00001C5E  C405                    1612          AND.B D5,D2  ;mask D2
00001C60  43F8 1C42               1613          LEA JsrEA,A1 ;load the list of valid modes
00001C64  D3C0                    1614          ADDA.L D0,A1 ;displace to a specific mode
00001C66  1811                    1615          MOVE.B (A1),D4 ;move mode to D4
00001C68  B404                    1616          CMP.B D4,D2 ;compare mode to masked value
00001C6A  6700 0006               1617          BEQ JsrBody ;if its match, its a valid mode and we can procede
00001C6E                          1618          
00001C6E  5280                    1619          ADDQ.L #1,D0 ;add one to displacement
00001C70  60DA                    1620          BRA validJsrModes ;check for next mode
00001C72                          1621          
00001C72                          1622  JsrBody:
00001C72                          1623  
00001C72                          1624  
00001C72  43F9 000024DE           1625          LEA     jsrMessage,A1  ;move string for NEG info
00001C78  103C 000E               1626          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C7C                          1627                                ;string without CR, LF
00001C7C  4E4F                    1628          TRAP    #15
00001C7E                          1629          
00001C7E  3401                    1630          MOVE.W D1,D2 ;copy inst to D2
00001C80  C47C 003F               1631          AND #%000000000111111,D2 ;and out everything but modes and regs
00001C84  1A02                    1632          MOVE.B D2,D5 ; copy to D5 for following BSR
00001C86                          1633          
00001C86  48E7 4000               1634          MOVEM.L D1,-(SP)
00001C8A  6100 03E4               1635          BSR     Get_Effective_Address
00001C8E  4CDF 0002               1636          MOVEM.L (SP)+,D1
00001C92                          1637          
00001C92                          1638                
00001C92                          1639          
00001C92                          1640  Jsrdone:
00001C92                          1641  
00001C92  43F9 0000247E           1642          LEA     clearLine,A1  ;move string for a CR and LF
00001C98  103C 000E               1643          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C9C                          1644                                ;string without CR, LF
00001C9C  4E4F                    1645          TRAP    #15
00001C9E  7000                    1646          MOVEQ.L #0,D0
00001CA0  4E75                    1647          RTS
00001CA2                          1648  
00001CA2                          1649  
00001CA2                          1650          
00001CA2                          1651  NOP:
00001CA2                          1652  
00001CA2  43F9 000024E8           1653          LEA     nopMessage,A1 ;move string for NOP info
00001CA8  103C 000D               1654          MOVE.B  #13,D0        ;set for task to display null terminated 
00001CAC                          1655                                ;string with CR, LF
00001CAC  4E4F                    1656          TRAP    #15
00001CAE                          1657          
00001CAE  7000                    1658          MOVEQ.L #0,D0
00001CB0  4E75                    1659          RTS
00001CB2                          1660          
00001CB2                          1661  RTS:
00001CB2                          1662          
00001CB2  43F9 000024E3           1663          LEA     rtsMessage,A1  ;move string for rts info
00001CB8  103C 000D               1664          MOVE.B  #13,D0        ;set for task to display null terminated 
00001CBC                          1665                                ;string with CR, LF
00001CBC  4E4F                    1666          TRAP    #15  
00001CBE                          1667     
00001CBE  7000                    1668          MOVEQ.L #0,D0
00001CC0  4E75                    1669          RTS   
00001CC2                          1670  
00001CC2= 3C 08 00 10 18 20 ...   1671  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
00001CCB= 3F 38 38 38 38 38 ...   1672  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001CD4                          1673  
00001CD4= 00 10 18 20 38 39 00    1674  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
00001CDB= 38 38 38 38 3F 3F 00    1675  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
00001CE2                          1676  
00001CE2                          1677  MOVE:
00001CE2                          1678          
00001CE2                          1679  
00001CE2                          1680          
00001CE2  7000                    1681          MOVEQ.L #0, D0 ;clear D0
00001CE4                          1682          
00001CE4                          1683  validMoveSourceModes:
00001CE4                          1684          
00001CE4  43F8 1CCB               1685          LEA moveSourceEAmasks,A1 ;load the list of masks
00001CE8  D3C0                    1686          ADDA.L D0,A1 ;displace to a specific mask
00001CEA  1A11                    1687          MOVE.B (A1),D5 ;move the mask to D5
00001CEC                          1688          
00001CEC  0C05 0000               1689          CMPI.B #0,D5 ;check if the mask is 0
00001CF0  6700 F3A0               1690          BEQ falsePositive ;branch if it is
00001CF4                          1691          
00001CF4  1401                    1692          MOVE.B D1,D2 ;copy instruction to D2
00001CF6  C405                    1693          AND.B D5,D2  ;mask D2
00001CF8                          1694          
00001CF8  43F8 1CC2               1695          LEA moveSourceEA,A1 ;load the list of valid modes
00001CFC  D3C0                    1696          ADDA.L D0,A1 ;displace to a specific mode
00001CFE  1811                    1697          MOVE.B (A1),D4 ;move mode to D4
00001D00  B404                    1698          CMP.B D4,D2 ;compare mode to masked value
00001D02  6700 0006               1699          BEQ  checkMoveDest ;if its match, its a valid mode and we can procede
00001D06                          1700          
00001D06  5280                    1701          ADDQ.L #1,D0 ;add one to displacement
00001D08  60DA                    1702          BRA validMoveSourceModes ;check for next mode
00001D0A                          1703          
00001D0A                          1704  checkMoveDest:
00001D0A  7000                    1705          MOVEQ.L #0, D0 ;clear D0
00001D0C                          1706          
00001D0C                          1707  validMoveDestModes:
00001D0C                          1708          
00001D0C  43F8 1CDB               1709          LEA moveDestEAmasks,A1 ;load the list of masks
00001D10  D3C0                    1710          ADDA.L D0,A1 ;displace to a specific mask
00001D12  1A11                    1711          MOVE.B (A1),D5 ;move the mask to D5
00001D14                          1712          
00001D14  0C05 0000               1713          CMPI.B #0,D5 ;check if the mask is 0
00001D18  6700 F378               1714          BEQ falsePositive ;branch if it is
00001D1C                          1715          
00001D1C  3401                    1716          MOVE.W D1,D2 ;copy instruction to D2
00001D1E  EC4A                    1717          LSR.W #6,D2  ;move mode
00001D20  6100 0580               1718          BSR switchModeAndReg ;switch register and mode
00001D24  C405                    1719          AND.B D5,D2  ;mask D2
00001D26                          1720          
00001D26  43F8 1CD4               1721          LEA moveDestEA,A1 ;load the list of valid modes
00001D2A  D3C0                    1722          ADDA.L D0,A1 ;displace to a specific mode
00001D2C  1811                    1723          MOVE.B (A1),D4 ;move mode to D4
00001D2E  B404                    1724          CMP.B D4,D2 ;compare mode to masked value
00001D30  6700 0006               1725          BEQ moveBody ;if its match, its a valid mode and we can procede
00001D34                          1726          
00001D34  5280                    1727          ADDQ.L #1,D0 ;add one to displacement
00001D36  60D4                    1728          BRA validMoveDestModes ;check for next mode
00001D38                          1729          
00001D38                          1730  moveBody
00001D38  3401                    1731          MOVE.W  D1,D2 ;copy inst to D2
00001D3A  C47C 3000               1732          AND.W  #%0011000000000000,D2 ;mask word for size
00001D3E  0C42 0000               1733          CMPI.W #0,D2 ;0 is the only non valid size
00001D42  6700 F34E               1734          BEQ falsePositive ; if zero, this is not move
00001D46                          1735  
00001D46  43F9 000024ED           1736          LEA     moveMessage,A1  ;move string for MOVE
00001D4C  103C 000E               1737          MOVE.B  #14,D0        ;set for task to display null terminated 
00001D50                          1738                                ;string with CR, LF
00001D50  4E4F                    1739          TRAP    #15
00001D52                          1740          
00001D52                          1741          
00001D52  3401                    1742          MOVE.W  D1,D2 ;check source mode
00001D54  C43C 003F               1743          AND.B   #%00111111,D2
00001D58  1A02                    1744          MOVE.B  D2,D5
00001D5A  48E7 4000               1745          MOVEM.L D1,-(SP)
00001D5E  6100 0310               1746          BSR     Get_Effective_Address
00001D62  4CDF 0002               1747          MOVEM.L (SP)+,D1
00001D66                          1748          
00001D66                          1749          ;print separator
00001D66                          1750          
00001D66  3401                    1751          MOVE.W  D1,D2 ;check dest mode
00001D68  EC4A                    1752          LSR.W   #6,D2
00001D6A  6100 0536               1753          BSR  switchModeAndReg
00001D6E  C43C 003F               1754          AND.B   #%00111111,D2
00001D72  1A02                    1755          MOVE.B  D2,D5
00001D74  48E7 4000               1756          MOVEM.L D1,-(SP)
00001D78  6100 02F6               1757          BSR     Get_Effective_Address
00001D7C  4CDF 0002               1758          MOVEM.L (SP)+,D1
00001D80                          1759          
00001D80                          1760          
00001D80                          1761          
00001D80  43F9 0000247E           1762          LEA     clearLine,A1  ;move string for a CR and LF
00001D86  103C 000E               1763          MOVE.B  #14,D0        ;set for task to display null terminated 
00001D8A                          1764                                ;string without CR, LF
00001D8A  4E4F                    1765          TRAP    #15
00001D8C                          1766  
00001D8C  7000                    1767          MOVEQ.L #0,D0
00001D8E  4E75                    1768          RTS
00001D90                          1769          
00001D90= 08 00                   1770  moveADestEA        DC.B %001000,0
00001D92= 38 00                   1771  moveADestEAmasks   DC.B %111000,0
00001D94                          1772          
00001D94                          1773  MOVEA:
00001D94                          1774  
00001D94  7000                    1775          MOVEQ.L #0, D0 ;clear D0
00001D96                          1776          
00001D96                          1777  validMoveASourceModes:
00001D96                          1778          
00001D96  43F8 1CCB               1779          LEA moveSourceEAmasks,A1 ;load the list of masks
00001D9A  D3C0                    1780          ADDA.L D0,A1 ;displace to a specific mask
00001D9C  1A11                    1781          MOVE.B (A1),D5 ;move the mask to D5
00001D9E                          1782          
00001D9E  0C05 0000               1783          CMPI.B #0,D5 ;check if the mask is 0
00001DA2  6700 F2EE               1784          BEQ falsePositive ;branch if it is
00001DA6                          1785          
00001DA6  1401                    1786          MOVE.B D1,D2 ;copy instruction to D2
00001DA8  C405                    1787          AND.B D5,D2  ;mask D2
00001DAA                          1788          
00001DAA  43F8 1CC2               1789          LEA moveSourceEA,A1 ;load the list of valid modes
00001DAE  D3C0                    1790          ADDA.L D0,A1 ;displace to a specific mode
00001DB0  1811                    1791          MOVE.B (A1),D4 ;move mode to D4
00001DB2  B404                    1792          CMP.B D4,D2 ;compare mode to masked value
00001DB4  6700 0006               1793          BEQ  checkMoveADest ;if its match, its a valid mode and we can procede
00001DB8                          1794          
00001DB8  5280                    1795          ADDQ.L #1,D0 ;add one to displacement
00001DBA  60DA                    1796          BRA validMoveASourceModes ;check for next mode
00001DBC                          1797          
00001DBC                          1798  checkMoveADest:
00001DBC  7000                    1799          MOVEQ.L #0, D0 ;clear D0
00001DBE                          1800  validMoveADestModes:
00001DBE                          1801          
00001DBE  43F8 1D92               1802          LEA moveADestEAmasks,A1 ;load the list of masks
00001DC2  D3C0                    1803          ADDA.L D0,A1 ;displace to a specific mask
00001DC4  1A11                    1804          MOVE.B (A1),D5 ;move the mask to D5
00001DC6                          1805          
00001DC6  0C05 0000               1806          CMPI.B #0,D5 ;check if the mask is 0
00001DCA  6700 F2C6               1807          BEQ falsePositive ;branch if it is
00001DCE                          1808          
00001DCE  3401                    1809          MOVE.W D1,D2 ;copy instruction to D2
00001DD0  EA4A                    1810          LSR.W #5,D2  ;move mode
00001DD2  6100 04CE               1811          BSR switchModeAndReg ;switch register and mode
00001DD6  C405                    1812          AND.B D5,D2  ;mask D2
00001DD8                          1813          
00001DD8  43F8 1D90               1814          LEA moveADestEA,A1 ;load the list of valid modes
00001DDC  D3C0                    1815          ADDA.L D0,A1 ;displace to a specific mode
00001DDE  1811                    1816          MOVE.B (A1),D4 ;move mode to D4
00001DE0  B404                    1817          CMP.B D4,D2 ;compare mode to masked value
00001DE2  6700 0006               1818          BEQ moveABody ;if its match, its a valid mode and we can procede
00001DE6                          1819          
00001DE6  5280                    1820          ADDQ.L #1,D0 ;add one to displacement
00001DE8  60D4                    1821          BRA validMoveADestModes ;check for next mode
00001DEA                          1822  moveABody:
00001DEA  3401                    1823          MOVE.W  D1,D2 ;copy inst to D2
00001DEC  C47C 3000               1824          AND.W  #%0011000000000000,D2 ;mask word for size
00001DF0  0C42 0000               1825          CMPI.W #0,D2 ;0 is the non valid size
00001DF4  6700 F29C               1826          BEQ falsePositive ; if zero, this is not move
00001DF8  0C42 1000               1827          CMPI.W #%0001000000000000,D2
00001DFC  6700 F294               1828          BEQ falsePositive ; if byte, this is not movea
00001E00                          1829  
00001E00                          1830  
00001E00  43F9 00002500           1831          LEA     moveAMessage,A1  ;move string for MOVE
00001E06  103C 000D               1832          MOVE.B  #13,D0        ;set for task to display null terminated 
00001E0A                          1833                                ;string with CR, LF
00001E0A  4E4F                    1834          TRAP    #15
00001E0C                          1835  
00001E0C  7000                    1836          MOVEQ.L #0,D0
00001E0E  4E75                    1837          RTS
00001E10                          1838  
00001E10                          1839             
00001E10                          1840  Bcc:
00001E10                          1841  
00001E10  43F9 000024F3           1842          LEA     bccMessage,A1  ;move string for BRA info
00001E16  103C 000E               1843          MOVE.B  #14,D0        ;set for task to display null terminated 
00001E1A                          1844                                ;string without CR, LF
00001E1A  4E4F                    1845          TRAP    #15
00001E1C                          1846          
00001E1C  7000                    1847          MOVEQ.L #0,D0 ;clear D0
00001E1E  3401                    1848          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001E20  E04A                    1849          LSR.W   #8,D2
00001E22  C47C 000F               1850          AND.W   #$0F,D2 ;mask instruction
00001E26                          1851          
00001E26                          1852  checkCC:        
00001E26  41F9 00002405           1853          LEA     bccList,A0 ;get condition code signature list in A0
00001E2C  D1C0                    1854          ADDA.L  D0,A0 ;get correct sig         
00001E2E  B410                    1855          CMP.B   (A0),D2 ;compare to sig
00001E30  6700 0006               1856          BEQ     foundCC ;if sig matches branch
00001E34  5200                    1857          ADDQ.B  #byte,D0
00001E36  60EE                    1858          BRA     checkCC
00001E38                          1859  foundCC:
00001E38  43F9 00002416           1860          LEA     conditionCodeMessage,A1 ;get condition code message in A1
00001E3E  C0FC 0004               1861          MULU.W  #long,D0 ;adjust size of D0 for a long
00001E42  D3C0                    1862          ADDA.L  D0,A1 ;get correct message location
00001E44  2251                    1863          MOVEA.L (A1),A1 ;get correct message
00001E46                          1864          
00001E46  103C 000E               1865          MOVE.B  #14,D0        ;set for task to display null terminated 
00001E4A                          1866                                ;string without CR, LF
00001E4A  4E4F                    1867          TRAP    #15
00001E4C                          1868  
00001E4C                          1869          
00001E4C                          1870          
00001E4C  548B                    1871          ADDQ.L  #word,A3 ;move past instruction in case long displacement
00001E4E  C27C 00FF               1872          AND.W   #$00FF,D1   ;check for word sized displacement
00001E52                          1873          
00001E52  B23C 0000               1874          CMP.B   #$0,D1
00001E56  6700 0010               1875          BEQ     BccWord
00001E5A                          1876          
00001E5A  B23C 00FF               1877          CMP.B   #$FF,D1 check for long sized displacement
00001E5E  6700 0010               1878          BEQ     BccLong
00001E62                          1879          
00001E62                          1880  BccByte:
00001E62                          1881          
00001E62  7E00                    1882          MOVEQ.L #0,D7 ;pass back no extra data followed
00001E64  6000 0012               1883          BRA     BccDone
00001E68                          1884  BccWord:
00001E68  3213                    1885          MOVE.W  (A3),D1
00001E6A                          1886          
00001E6A  7E02                    1887          MOVEQ.L #word,D7 ;pass back an extra word followed
00001E6C  6000 000A               1888          BRA     BccDone
00001E70                          1889  BccLong:
00001E70  2213                    1890          MOVE.L  (A3),D1
00001E72                          1891          
00001E72  7E04                    1892          MOVEQ.L #long,D7 ;pass back an extra long followed
00001E74  6000 0002               1893          BRA     BccDone
00001E78                          1894  BccDone:
00001E78                          1895  
00001E78  343C 0010               1896          MOVE.W  #16,D2 ;put base in D2
00001E7C  303C 000F               1897          MOVE.W  #15,D0  ;put task #15 in D0
00001E80  4E4F                    1898          TRAP    #15
00001E82                          1899          
00001E82  43F9 0000247E           1900          LEA     clearLine,A1  ;move string for a CR and LF
00001E88  103C 000E               1901          MOVE.B  #14,D0        ;set for task to display null terminated 
00001E8C                          1902                                ;string without CR, LF
00001E8C  4E4F                    1903          TRAP    #15
00001E8E                          1904  
00001E8E  7000                    1905          MOVEQ.L #0,D0
00001E90  4E75                    1906          RTS
00001E92                          1907          
00001E92                          1908          
00001E92                          1909  unknownOpCode:
00001E92  43F9 000024FA           1910          LEA     dataMessage,A1 ;move string for data info
00001E98  103C 000E               1911          MOVE.B  #14,D0        ;set for task to display null terminated 
00001E9C                          1912                                ;string without CR, LF
00001E9C  4E4F                    1913          TRAP    #15
00001E9E                          1914          
00001E9E  143C 0010               1915          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001EA2  103C 000F               1916          MOVE.B  #15,D0
00001EA6  4E4F                    1917          TRAP    #15
00001EA8                          1918          
00001EA8  43F9 0000247E           1919          LEA     clearLine,A1  ;move string for a CR and LF
00001EAE  103C 000E               1920          MOVE.B  #14,D0        ;set for task to display null terminated 
00001EB2                          1921                                ;string without CR, LF
00001EB2  4E4F                    1922          TRAP    #15
00001EB4                          1923          
00001EB4  7000                    1924          MOVEQ.L #0,D0
00001EB6  4E75                    1925          RTS
00001EB8                          1926          
00001EB8                          1927  handlebytedata:
00001EB8                          1928  
00001EB8  43F9 000024FA           1929          LEA     dataMessage,A1 ;move string for data info
00001EBE  103C 000E               1930          MOVE.B  #14,D0        ;set for task to display null terminated 
00001EC2                          1931                                ;string without CR, LF
00001EC2  4E4F                    1932          TRAP    #15
00001EC4                          1933          
00001EC4  E049                    1934          LSR.W   #8,D1 ;shift the word read into D1 by a byte
00001EC6                          1935          
00001EC6  143C 0010               1936          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001ECA  103C 000F               1937          MOVE.B  #15,D0
00001ECE  4E4F                    1938          TRAP    #15
00001ED0                          1939          
00001ED0  43F9 0000247E           1940          LEA     clearLine,A1  ;move string for a CR and LF
00001ED6  103C 000E               1941          MOVE.B  #14,D0        ;set for task to display null terminated 
00001EDA                          1942                                ;string without CR, LF
00001EDA  4E4F                    1943          TRAP    #15
00001EDC                          1944          
00001EDC  7000                    1945          MOVEQ.L #0,D0
00001EDE                          1946          
00001EDE  528B                    1947          ADDQ.L  #byte,A3
00001EE0  6000 F144               1948          BRA main_Loop
00001EE4                          1949  
00001EE4                          1950          
00001EE4                          1951          
00001EE4                          1952  fin
00001EE4                          1953  
00001EE4                          1954          
00001EE4                          1955          
00001EE4  FFFF FFFF               1956          simhalt
00001EE8                          1957          
00001EE8                          1958  
00001EE8                          1959  *******************************************************************************
00001EE8                          1960  *                            SUB ROUTINES
00001EE8                          1961  *******************************************************************************
00001EE8                          1962  
00001EE8                          1963  *******************************************************************************
00001EE8                          1964  *                          IO ROLE ROUTINES
00001EE8                          1965  *******************************************************************************
00001EE8                          1966  
00001EE8                          1967  *==========================================================================
00001EE8                          1968  *                   Enter / Validate beginning address 
00001EE8                          1969  *==========================================================================
00001EE8                          1970   
00001EE8                          1971  begin_address:
00001EE8                          1972  
00001EE8                          1973         
00001EE8  43F9 000022B6           1974          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00001EEE  2239 000022B6           1975          MOVE.L      slPrompt,D1         ;Load display length to D1
00001EF4  700E                    1976          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001EF6  4E4F                    1977          TRAP        #15                 ;Perform task 14 (display)
00001EF8                          1978          
00001EF8  43F9 00002532           1979          LEA         startLocation,A1    ;Load address to store user input
00001EFE  103C 0002               1980          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001F02  4E4F                    1981          TRAP        #15                 ;Perform task 2 (input)
00001F04                          1982          
00001F04  0C11 001B               1983          CMP.B       #27,(A1)            ;Check for ESC entered
00001F08  6700 004C               1984          BEQ         address_Exit        ;Exit condition 
00001F0C                          1985          
00001F0C  6100 0050               1986          BSR         enter_addr_edit_all
00001F10  B67C FFFF               1987          CMP.W       #-1,D3              ;Did the edit pass?
00001F14  67D2                    1988          BEQ         begin_address       ;No, loop and ask for correct input
00001F16                          1989          
00001F16  2643                    1990          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
00001F18                          1991          
00001F18  43F9 000023C3           1992          LEA         spc,A1              ;Load address for starting loaction prompt
00001F1E  1239 000023C4           1993          MOVE.B      spc_len,D1          ;Load empty line length
00001F24  7000                    1994          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
00001F26  4E4F                    1995          TRAP        #15                 ;Perform task 14 (display)
00001F28  6000 0002               1996          BRA         end_address
00001F2C                          1997  
00001F2C                          1998  *===========================================================================
00001F2C                          1999  *                   Enter / Validate ending address 
00001F2C                          2000  *===========================================================================
00001F2C                          2001  
00001F2C                          2002  end_address:
00001F2C                          2003          
00001F2C  43F9 000022E7           2004          LEA         elPrompt,A1         ;Load address for ending loaction prompt
00001F32                          2005          ;MOVE.L     elPrompt,D1         ;Load display length to D1
00001F32  7250                    2006          MOVE.L      #80,D1       ;did not like previous command, do not know why, it should have worked
00001F34  700E                    2007          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001F36  4E4F                    2008          TRAP        #15                 ;Perform task 14 (display)
00001F38                          2009          
00001F38  103C 0002               2010          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001F3C  4E4F                    2011          TRAP        #15                 ;Perform task 2 (input)
00001F3E                          2012          
00001F3E  0C11 001B               2013          CMP.B       #27,(A1)            ;Check for ESC entered
00001F42  6700 0012               2014          BEQ         address_Exit        ;Exit condition 
00001F46                          2015          
00001F46  6100 0016               2016          BSR         enter_addr_edit_all
00001F4A  B67C FFFF               2017          CMP.W       #-1,D3              ;Did the edit pass?
00001F4E  67DC                    2018          BEQ         end_address         ;No, loop and ask for correct input
00001F50                          2019  
00001F50  2843                    2020          MOVEA.L     D3,A4               ;Ending address gets stored in A4
00001F52  6000 0008               2021          BRA         address_done
00001F56                          2022  
00001F56                          2023  address_Exit:
00001F56                          2024  
00001F56  76FF                    2025          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001F58  6000 0002               2026          BRA         address_done
00001F5C                          2027          
00001F5C                          2028  address_done:
00001F5C                          2029  
00001F5C  4E75                    2030          RTS    
00001F5E                          2031  
00001F5E                          2032  *==============================================================================
00001F5E                          2033  * enter_addr_edit_all - Enter address edit check to edit all errors  
00001F5E                          2034  *                       using multiple different error checking routines.
00001F5E                          2035  *
00001F5E                          2036  * Parameters -
00001F5E                          2037  *   Input   A1      The data that needs checked.
00001F5E                          2038  *   Input   D1      The number of characters input     
00001F5E                          2039  *   Output  D3      Returns '-1' when there is an error.
00001F5E                          2040  *==============================================================================
00001F5E                          2041  
00001F5E                          2042  enter_addr_edit_all
00001F5E                          2043  
00001F5E                          2044  *------------------------------------------------------------------------------
00001F5E                          2045  * Test for odd number of characters entered, not allowed
00001F5E                          2046  *------------------------------------------------------------------------------
00001F5E                          2047         
00001F5E  6100 0024               2048          BSR         ck_boundry          ;check if the input is on a odd / even boundry
00001F62  B67C FFFF               2049          CMP.W       #-1,D3              ;Is the address odd?
00001F66  6700 001A               2050          BEQ         enter_addr_edit_all_exit     ;No, return
00001F6A                          2051  
00001F6A                          2052  *------------------------------------------------------------------------------
00001F6A                          2053  * Ttest for character entered all being valid address characters
00001F6A                          2054  * Note: lower case a-f, gets converted to upper case A-F in D3
00001F6A                          2055  *------------------------------------------------------------------------------
00001F6A                          2056          
00001F6A  6100 0062               2057          BSR         parseHexString      ;check if the input contains valid Hex characters
00001F6E  B67C FFFF               2058          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
00001F72  6700 000E               2059          BEQ         enter_addr_edit_all_exit     ;No, return
00001F76                          2060  
00001F76                          2061  *------------------------------------------------------------------------------
00001F76                          2062  * Verify that the address entered is witin the range defined in the Equate
00001F76                          2063  *------------------------------------------------------------------------------        
00001F76                          2064          
00001F76  6100 00C8               2065          BSR         ck_addr_range       ;is address entered witin the range 
00001F7A                          2066                                          ;   as defined in the Equate? 
00001F7A  B67C FFFF               2067          CMP.W       #-1,D3              ;is the address  valid?
00001F7E  6700 0002               2068          BEQ         enter_addr_edit_all_exit     ;No, return
00001F82                          2069  
00001F82                          2070  enter_addr_edit_all_exit:
00001F82                          2071  
00001F82  4E75                    2072          RTS                             ;return
00001F84                          2073  
00001F84                          2074  *==============================================================================
00001F84                          2075  * ck_boundry - Check the size of the data characters input and determine
00001F84                          2076  *              if an odd number of characters was entered
00001F84                          2077  *
00001F84                          2078  * Parameters -
00001F84                          2079  *   Input   A1      The data that needs checked for odd length.
00001F84                          2080  *   Input   D1      The number of characters input     
00001F84                          2081  *   Output  D3      Returns '-1' when there is an odd length.
00001F84                          2082  *==============================================================================
00001F84                          2083  
00001F84                          2084  ck_boundry:
00001F84                          2085  
00001F84  4243                    2086          CLR.W       D3                  ;Clear the return
00001F86                          2087  
00001F86  B23C 0000               2088          CMP.B       #0,D1               ;Check for nothing entered
00001F8A  6700 002E               2089          BEQ         ck_size_error       ;Number of characters entered must be 
00001F8E                          2090                                          ;greater than 0  
00001F8E                          2091          
00001F8E                          2092          
00001F8E                          2093          * The program will branch to ck_size_error if D1 is greater than #8        
00001F8E  B23C 0008               2094          CMP.B       #8,D1               ;Check for more than 8 characters entered
00001F92  6E00 0026               2095          BGT         ck_size_error       ;Number of characters entered must be less
00001F96                          2096                                          ;than 9
00001F96                          2097          
00001F96  7402                    2098          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
00001F98  82C2                    2099          DIVU        D2,D1               ;Divide address by 2
00001F9A  4841                    2100          SWAP        D1                  ;get remainder
00001F9C  B23C 0001               2101          CMP.B       #$01,D1             ;Check for remainder of 1
00001FA0  6700 0004               2102          BEQ         ck_boundry_error    ;Number of characters entered must be an 
00001FA4                          2103                                          ;even number   
00001FA4                          2104    
00001FA4  4E75                    2105          RTS                             ;return
00001FA6                          2106  
00001FA6                          2107  *------------------------------------------------------------------------------
00001FA6                          2108  * ck_boundry_error - An odd number of characters was entered
00001FA6                          2109  *                  - Load error message and display it
00001FA6                          2110  *                  - Return error condition
00001FA6                          2111  *------------------------------------------------------------------------------
00001FA6                          2112          
00001FA6                          2113  ck_boundry_error:
00001FA6                          2114  
00001FA6  43F9 000023A3           2115          LEA         even_msg,A1         ;Load odd error message into A1
00001FAC  2239 000023A3           2116          MOVE.L      even_msg,D1         ;Load error length to D1
00001FB2                          2117          
00001FB2  7000                    2118          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001FB4                          2119                                          ; n is D1.W with CR, LF. 
00001FB4  4E4F                    2120          TRAP #15                        ;Display the error message
00001FB6  76FF                    2121          MOVE.L #-1,D3                   ;Load -1 into return parameter
00001FB8  4E75                    2122          RTS                             ;Return
00001FBA                          2123          
00001FBA                          2124  *------------------------------------------------------------------------------
00001FBA                          2125  * ck_size_error -   The number of characters entered must be more than zero
00001FBA                          2126  *                  - Load error message and display it
00001FBA                          2127  *                  - Return error condition
00001FBA                          2128  *------------------------------------------------------------------------------
00001FBA                          2129          
00001FBA                          2130  ck_size_error:
00001FBA                          2131  
00001FBA  43F9 00002316           2132          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001FC0  2239 00002316           2133          MOVE.L      invalidMsg,D1       ;Load error length to D1
00001FC6                          2134          
00001FC6  7000                    2135          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001FC8                          2136                                          ; n is D1.W with CR, LF. 
00001FC8  4E4F                    2137          TRAP        #15                 ;Display the error message
00001FCA  76FF                    2138          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001FCC  4E75                    2139          RTS                             ;Return        
00001FCE                          2140  
00001FCE                          2141  
00001FCE                          2142  *==============================================================================
00001FCE                          2143  * parseHexString - Converts user input string into a valid memory address
00001FCE                          2144  *                - Stores parsed address data into D3
00001FCE                          2145  *                - Stores good/bad (1/0) data in D4 
00001FCE                          2146  *
00001FCE                          2147  * Hex values are stored as bytes in D2, the ASCII chart shows their value
00001FCE                          2148  *   The ASCII chart values we care about are in the ranges of: 
00001FCE                          2149  *                            Hex            Decimal
00001FCE                          2150  *       No Value           NULL = 0         0
00001FCE                          2151  *       Numeric Values:     0-9 = 30-39     48-57
00001FCE                          2152  *       Upper Case letters: A-F = 41-46     65-70
00001FCE                          2153  *       Lower Case letterc: a-f = 61-66     97-102
00001FCE                          2154  
00001FCE                          2155  * Parameters -
00001FCE                          2156  *   Input   A1      The data that needs checked for valid input.
00001FCE                          2157  *   Output  D3      The return value, '-1' for error
00001FCE                          2158  *==============================================================================
00001FCE                          2159  
00001FCE                          2160  parseHexString:
00001FCE                          2161  
00001FCE                          2162  * setup any initializing item that do not get looped through
00001FCE  4243                    2163          CLR.W       D3                  ;Clear the return
00001FD0                          2164  
00001FD0                          2165          
00001FD0                          2166  *------------------------------------------------------------------------------
00001FD0                          2167  * NextHex - Loop through all bytes and vaildate the input
00001FD0                          2168  * Parameters -
00001FD0                          2169  *   Input   A1      The data that needs checked for valid input.
00001FD0                          2170  *   Output  D3      The return value, '-1' for error
00001FD0                          2171  *------------------------------------------------------------------------------
00001FD0                          2172          
00001FD0                          2173  NextHex:
00001FD0                          2174  
00001FD0  1419                    2175          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00001FD2  B43C 0000               2176          CMP.B       #0,D2               ;Check character for null 
00001FD6  6700 0066               2177          BEQ         NextHexReturn       ;Character is null (end of input)
00001FDA                          2178          
00001FDA                          2179  *................................................................................
00001FDA                          2180  *  Check decimal values 0-9 by testing hexadecimal values 30-39
00001FDA                          2181  *................................................................................
00001FDA                          2182                  
00001FDA                          2183          * The program will branch to hex_range_error if D2 is less than #30
00001FDA  B43C 0030               2184          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
00001FDE  6D00 0048               2185          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001FE2                          2186                                          ;processing
00001FE2                          2187          
00001FE2                          2188          * The program will branch to UcaseHex if D2 is greater than #39
00001FE2  B43C 0039               2189          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
00001FE6  6E00 000A               2190          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
00001FEA                          2191          
00001FEA                          2192          *a valid number was found within this range
00001FEA  0402 0030               2193          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
00001FEE  6000 0032               2194          BRA         NextHexDone         ;Done parsing this byte
00001FF2                          2195  
00001FF2                          2196  
00001FF2                          2197  *..............................................................................
00001FF2                          2198  *  Check upper case values A-F by testing hexadecimal values 41-46
00001FF2                          2199  *..............................................................................
00001FF2                          2200  
00001FF2                          2201  UcaseHex:
00001FF2                          2202  
00001FF2                          2203          * The program will branch to hex_range_error if D2 is less than #41
00001FF2  B43C 0041               2204          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
00001FF6  6D00 0030               2205          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001FFA                          2206                                          ;processing
00001FFA                          2207          
00001FFA  B43C 0046               2208          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
00001FFE  6E00 000A               2209          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
00002002                          2210                                          ;processing
00002002                          2211          
00002002                          2212          *a valid number was found within this range
00002002  0402 0037               2213          SUBI.B      #55,D2              ;Change uppercase character to actual value
00002006  6000 001A               2214          BRA         NextHexDone         ;Done parsing this byte
0000200A                          2215  
0000200A                          2216  
0000200A                          2217  *..............................................................................
0000200A                          2218  *  Check lower case values a-f by testing hexadecimal values 61-66
0000200A                          2219  *..............................................................................
0000200A                          2220  
0000200A                          2221  LcaseHex
0000200A                          2222          
0000200A                          2223          * The program will branch to hex_range_error if D2 is less than #61
0000200A  B43C 0061               2224          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
0000200E  6D00 0018               2225          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
00002012                          2226                                          ;processing
00002012                          2227  
00002012  B43C 0066               2228          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
00002016  6E00 0010               2229          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
0000201A                          2230                                          ;processing
0000201A                          2231  
0000201A                          2232          *a valid number was found within this range
0000201A  0402 0057               2233          SUBI.B      #87,D2              ;Change lowercase character to actual value
0000201E  6000 0002               2234          BRA         NextHexDone         ;Done parsing this byte
00002022                          2235  
00002022                          2236  NextHexDone:
00002022                          2237  
00002022  E983                    2238          ASL.L       #4,D3               ; Make rooom for new byte in the return register
00002024  D602                    2239          ADD.B       D2,D3               ; Move the new byte into the return register
00002026  60A8                    2240          BRA         NextHex             ; We're ready to parse the next byte
00002028                          2241          
00002028                          2242  *-------------------------------------------------------------------------------------
00002028                          2243  * hex_range_error -  A character entered was within the valid range for a hex address
00002028                          2244  *                 -  Load error message and display it
00002028                          2245  *                 -  Return error condition
00002028                          2246  *-------------------------------------------------------------------------------------
00002028                          2247          
00002028                          2248  hex_range_error:
00002028                          2249  
00002028  43F9 0000235B           2250          LEA         invCharMsg,A1       ;Load invalid range message into A1
0000202E  2239 0000235B           2251          MOVE.L      invCharMsg,D1       ;Load error length to D1
00002034                          2252          
00002034  7000                    2253          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00002036                          2254                                          ; n is D1.W with CR, LF. 
00002036  4E4F                    2255          TRAP        #15                 ;Display the error message
00002038  76FF                    2256          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000203A  6000 0002               2257          BRA         NextHexReturn
0000203E                          2258          
0000203E                          2259  NextHexReturn:
0000203E                          2260          
0000203E  4E75                    2261          RTS                             ;Return      
00002040                          2262  
00002040                          2263  
00002040                          2264  *===============================================================================
00002040                          2265  * ck_addr_range - check the address input is within a valid memory address range
00002040                          2266  *                - Parsed address data into D3
00002040                          2267  *
00002040                          2268  * Parameters -
00002040                          2269  *   Input   A1      The data that needs checked for valid address.
00002040                          2270  *   Output  D3      The return value, '-1' for error
00002040                          2271  *===============================================================================
00002040                          2272  
00002040                          2273  
00002040                          2274  ck_addr_range:   
00002040                          2275  
00002040                          2276  *------------------------------------------------------------------------------
00002040                          2277  * Verify that the address entered is witin the 
00002040                          2278  * beginning range ('begin') as defined in the Equate
00002040                          2279  *------------------------------------------------------------------------------   
00002040                          2280              
00002040  2C3C 00005001           2281          MOVE.L      #begin,D6           * Load minimum starting address
00002046  B686                    2282          CMP.L       D6,D3               * Is input at or above minimum?
00002048  6D00 0012               2283          BLT         ck_addr_range_error 
0000204C                          2284          
0000204C                          2285  *------------------------------------------------------------------------------
0000204C                          2286  * Verify that the address entered is witin the 
0000204C                          2287  * ending range ('end') as defined in the Equate
0000204C                          2288  *------------------------------------------------------------------------------
0000204C                          2289          
0000204C  2C3C 00FFFFFE           2290          MOVE.L      #end,D6             * Load maximum starting address
00002052  B686                    2291          CMP.L       D6,D3               * Is input at or below maximum?
00002054  6E00 0006               2292          BGT         ck_addr_range_error 
00002058  6000 0012               2293          BRA         ck_addr_done        ;done checking
0000205C                          2294          
0000205C                          2295  *..............................................................................
0000205C                          2296  * ck_addr_range_error -  A address entered is not within the 
0000205C                          2297  *                        valid range for a hex address
0000205C                          2298  *..............................................................................
0000205C                          2299          
0000205C                          2300  ck_addr_range_error
0000205C                          2301  
0000205C  43F9 00002316           2302          LEA         invalidMsg,A1       ;Load invalid range message into A1
00002062                          2303          
00002062  700D                    2304          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
00002064                          2305                                          ;with CR, LF. 
00002064  4E4F                    2306          TRAP        #15                 ;Display the error message
00002066  76FF                    2307          MOVE.L      #-1,D3              ;Load -1 into return parameter
00002068  6000 0002               2308          BRA         ck_addr_done 
0000206C                          2309  
0000206C                          2310  ck_addr_done:
0000206C                          2311  
0000206C  4E75                    2312          RTS                             ;Return
0000206E                          2313  
0000206E                          2314  *******************************************************************************
0000206E                          2315  *                          OP CODE ROLE ROUTINES
0000206E                          2316  *******************************************************************************
0000206E                          2317  
0000206E                          2318  process_op_codes:
0000206E                          2319  
0000206E                          2320  
0000206E                          2321  
0000206E                          2322  process_op_codes_exit:
0000206E                          2323  
0000206E  4E75                    2324          RTS
00002070                          2325  
00002070                          2326  
00002070                          2327  *******************************************************************************
00002070                          2328  *                    Effective Addressing ROLE ROUTINES
00002070                          2329  *******************************************************************************
00002070                          2330  
00002070                          2331  Get_Effective_Address:
00002070                          2332  
00002070  1C05                    2333          MOVE.B      D5,D6
00002072  E60E                    2334          LSR.B       #3,D6               ;mode
00002074  CA3C 0007               2335          And.B       #%00000111,D5       ;register
00002078                          2336          
00002078  BC3C 0000               2337          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
0000207C  6700 004A               2338          BEQ         Data_Reg_Direct
00002080                          2339          
00002080  BC3C 0001               2340          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
00002084  6700 005C               2341          BEQ         Addr_Reg_Direct
00002088                          2342          
00002088  BC3C 0002               2343          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
0000208C  6700 006E               2344          BEQ         Addr_Reg_Indirect
00002090                          2345          
00002090  BC3C 0003               2346          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
00002094  6700 0098               2347          BEQ         Addr_Reg_Indirect_Inc
00002098                          2348          
00002098  BC3C 0004               2349          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
0000209C  6700 00CE               2350          BEQ         Addr_Reg_Indirect_Dec
000020A0                          2351          
000020A0  BC3C 0007               2352          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
000020A4  6700 0006               2353          BEQ         Get_Effective_Address_Other
000020A8                          2354          
000020A8  6000 013E               2355          BRA         invalidEA
000020AC                          2356          
000020AC                          2357  Get_Effective_Address_Other:        
000020AC                          2358          
000020AC  BA3C 0000               2359          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
000020B0  6700 00F8               2360          BEQ Addr_Abs_Short
000020B4                          2361          
000020B4  BA3C 0001               2362          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
000020B8  6700 010A               2363          BEQ Addr_Abs_Long
000020BC                          2364          
000020BC  BA3C 0004               2365          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
000020C0  6700 0116               2366          BEQ Addr_Immediate_Data
000020C4                          2367          
000020C4  6000 0122               2368          BRA         invalidEA
000020C8                          2369          
000020C8                          2370  Data_Reg_Direct:                        ;case 0(0000)
000020C8                          2371  
000020C8  43F9 00002527           2372          LEA         letterD,A1          ;output 'D' for data register
000020CE  103C 000E               2373          MOVE.B      #14,D0              ;set for task to display null terminated 
000020D2  4E4F                    2374          TRAP        #15                 ;string without CR, LF
000020D4                          2375                          
000020D4  4281                    2376          CLR.L       D1
000020D6  1205                    2377          MOVE.B      D5,D1               ;move register number for display into D1
000020D8  103C 0003               2378          MOVE.B      #3,D0               ;set for task to display null terminated 
000020DC  4E4F                    2379          TRAP        #15                 ;string without CR, LF
000020DE                          2380                 
000020DE  6000 0108               2381          BRA         Get_Effective_Address_Exit  ;return
000020E2                          2382          
000020E2                          2383          
000020E2                          2384  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
000020E2                          2385        
000020E2  43F9 00002525           2386          LEA         letterA,A1          ;output 'A' for address register
000020E8  103C 000E               2387          MOVE.B      #14,D0              ;set for task to display null terminated 
000020EC  4E4F                    2388          TRAP        #15                 ;string without CR, LF
000020EE                          2389          
000020EE  4281                    2390          CLR.L       D1
000020F0  1205                    2391          MOVE.B      D5,D1               ;move register number for display into D1
000020F2  103C 0003               2392          MOVE.B      #3,D0               ;set for task to display null terminated 
000020F6  4E4F                    2393          TRAP        #15                 ;string without CR, LF
000020F8                          2394          
000020F8  6000 00EE               2395          BRA         Get_Effective_Address_Exit  ;return
000020FC                          2396  
000020FC                          2397  
000020FC                          2398  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
000020FC                          2399          
000020FC  43F9 0000252D           2400          LEA         lprn,A1             ;output 'D' for data register
00002102  103C 000E               2401          MOVE.B      #14,D0              ;set for task to display null terminated 
00002106  4E4F                    2402          TRAP        #15                 ;string without CR, LF
00002108                          2403  
00002108  43F9 00002525           2404          LEA         letterA,A1          ;output 'A' for address register
0000210E  103C 000E               2405          MOVE.B      #14,D0              ;set for task to display null terminated 
00002112  4E4F                    2406          TRAP        #15                 ;string without CR, LF
00002114                          2407          
00002114  4281                    2408          CLR.L       D1
00002116  1205                    2409          MOVE.B      D5,D1               ;move register number for display into D1
00002118  103C 0003               2410          MOVE.B      #3,D0               ;set for task to display null terminated 
0000211C  4E4F                    2411          TRAP        #15                 ;string without CR, LF
0000211E                          2412  
0000211E  43F9 0000252F           2413          LEA         rprn,A1             ;output 'D' for data register
00002124  103C 000E               2414          MOVE.B      #14,D0              ;set for task to display null terminated 
00002128  4E4F                    2415          TRAP        #15                 ;string without CR, LF
0000212A                          2416          
0000212A  6000 00BC               2417          BRA         Get_Effective_Address_Exit  ;return
0000212E                          2418  
0000212E                          2419                 
0000212E                          2420  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
0000212E                          2421  
0000212E  43F9 0000252D           2422          LEA         lprn,A1             ;output 'D' for data register
00002134  103C 000E               2423          MOVE.B      #14,D0              ;set for task to display null terminated 
00002138  4E4F                    2424          TRAP        #15                 ;string without CR, LF
0000213A                          2425  
0000213A  43F9 00002525           2426          LEA         letterA,A1          ;output 'A' for address register
00002140  103C 000E               2427          MOVE.B      #14,D0              ;set for task to display null terminated 
00002144  4E4F                    2428          TRAP        #15                 ;string without CR, LF
00002146                          2429          
00002146  4281                    2430          CLR.L       D1
00002148  1205                    2431          MOVE.B      D5,D1               ;move register number for display into D1
0000214A  103C 0003               2432          MOVE.B      #3,D0               ;set for task to display null terminated 
0000214E  4E4F                    2433          TRAP        #15                 ;string without CR, LF
00002150                          2434  
00002150  43F9 0000252F           2435          LEA         rprn,A1             ;output 'D' for data register
00002156  103C 000E               2436          MOVE.B      #14,D0              ;set for task to display null terminated 
0000215A  4E4F                    2437          TRAP        #15                 ;string without CR, LF
0000215C                          2438          
0000215C  43F9 00002529           2439          LEA         plus,A1             ;output 'D' for data register
00002162  103C 000E               2440          MOVE.B      #14,D0              ;set for task to display null terminated 
00002166  4E4F                    2441          TRAP        #15                 ;string without CR, LF
00002168                          2442          
00002168  6000 007E               2443          BRA         Get_Effective_Address_Exit  ;return
0000216C                          2444  
0000216C                          2445  Addr_Reg_Indirect_Dec                   ;4 = (An) - Address Register Indirect with Predecrement (100)
0000216C                          2446  
0000216C  43F9 0000252B           2447          LEA         minus,A1            ;output '-' for Predecrement
00002172  103C 000E               2448          MOVE.B      #14,D0              ;set for task to display null terminated 
00002176  4E4F                    2449          TRAP        #15                 ;string without CR, LF
00002178                          2450  
00002178  43F9 0000252D           2451          LEA         lprn,A1             ;output 'D' for data register
0000217E  103C 000E               2452          MOVE.B      #14,D0              ;set for task to display null terminated 
00002182  4E4F                    2453          TRAP        #15                 ;string without CR, LF
00002184                          2454  
00002184  43F9 00002525           2455          LEA         letterA,A1          ;output 'A' for address register
0000218A  103C 000E               2456          MOVE.B      #14,D0              ;set for task to display null terminated 
0000218E  4E4F                    2457          TRAP        #15                 ;string without CR, LF
00002190                          2458          
00002190  4281                    2459          CLR.L       D1
00002192  1205                    2460          MOVE.B      D5,D1               ;move register number for display into D1
00002194  103C 0003               2461          MOVE.B      #3,D0               ;set for task to display null terminated 
00002198  4E4F                    2462          TRAP        #15                 ;string without CR, LF
0000219A                          2463  
0000219A  43F9 0000252F           2464          LEA         rprn,A1             ;output 'D' for data register
000021A0  103C 000E               2465          MOVE.B      #14,D0              ;set for task to display null terminated 
000021A4  4E4F                    2466          TRAP        #15                 ;string without CR, LF
000021A6                          2467          
000021A6  6000 0040               2468          BRA         Get_Effective_Address_Exit  ;return
000021AA                          2469          
000021AA                          2470                         
000021AA                          2471  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
000021AA                          2472          
000021AA                          2473          
000021AA  548B                    2474          ADDA.L      #word,A3 ;move past instruction
000021AC                          2475          
000021AC                          2476          ;print word (A3)
000021AC  48E7 1200               2477          MOVEM.L D6/D3,-(SP)
000021B0  1C3C 0001               2478          MOVE.B #1,D6 ;put size of word in D6
000021B4  3613                    2479          MOVE.W (A3),D3 ;move data at (A3) to D3
000021B6  6100 003E               2480          BSR outputHex
000021BA  4CDF 0048               2481          MOVEM.L (SP)+,D6/D3
000021BE                          2482          
000021BE  5487                    2483          ADDI.L      #word,D7 
000021C0  6000 0026               2484          BRA         Get_Effective_Address_Exit  ;return
000021C4                          2485                         
000021C4                          2486  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
000021C4                          2487          
000021C4  43F9 00002511           2488          LEA         xxxL,A1             ;output 'D' for data register
000021CA  103C 000E               2489          MOVE.B      #14,D0              ;set for task to display null terminated 
000021CE  4E4F                    2490          TRAP        #15                 ;string without CR, LF
000021D0                          2491  
000021D0  548B                    2492          ADDA.L      #word,A3
000021D2                          2493          
000021D2                          2494          ;print long (A3)
000021D2                          2495          ;MOVE.L      A3,(A1)
000021D2                          2496          ;MOVE.B      #14,D0              ;set for task to display null terminated 
000021D2                          2497          ;TRAP        #15                 ;string without CR, LF
000021D2                          2498          
000021D2  5887                    2499          ADDI.L      #long,D7
000021D4  6000 0012               2500          BRA         Get_Effective_Address_Exit  ;return
000021D8                          2501                         
000021D8                          2502  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
000021D8                          2503  
000021D8  43F9 0000251B           2504          LEA         iData,A1            ;output 'D' for data register
000021DE  103C 000E               2505          MOVE.B      #14,D0              ;set for task to display null terminated 
000021E2  4E4F                    2506          TRAP        #15                 ;string without CR, LF
000021E4                          2507          
000021E4                          2508          *need another input param for size
000021E4  6000 0002               2509          BRA         Get_Effective_Address_Exit  ;return
000021E8                          2510  
000021E8                          2511  invalidEA:
000021E8                          2512  
000021E8                          2513          ;do something
000021E8                          2514   
000021E8                          2515  Get_Effective_Address_Exit:     
000021E8                          2516  
000021E8  4E75                    2517          RTS                             ;return
000021EA                          2518  
000021EA                          2519  
000021EA                          2520  ***assume hex to print is in D3***
000021EA                          2521  ***assume size in D6. 00 = byte, 01 = word, 10 = long
000021EA                          2522  
000021EA= 00000000 00000000 ...   2523  hexoutputbuffer DC.L 0,0,0
000021F6                          2524  
000021F6                          2525  outputHex:
000021F6  48E7 B248               2526          MOVEM.L D0/D2/D3/D6/A1/A4,-(SP)
000021FA  49F8 21EA               2527          LEA hexoutputbuffer,A4
000021FE  0C06 0001               2528          CMPI.B #1,D6
00002202  6D00 006A               2529          BLT hexByte
00002206  6700 004C               2530          BEQ hexWord
0000220A  6E00 0016               2531          BGT hexLong
0000220E                          2532  outputHexDone:
0000220E  18BC 0000               2533          MOVE.B #0,(A4)
00002212                          2534          
00002212                          2535          ;output string of hex
00002212  103C 000E               2536          MOVE.B #14,D0
00002216  43F8 21EA               2537          LEA hexoutputbuffer,A1
0000221A  4E4F                    2538          TRAP #15
0000221C  4CDF 124D               2539          MOVEM.L (SP)+ ,D0/D2/D3/D6/A1/A4
00002220  4E75                    2540          RTS
00002222                          2541          
00002222                          2542  hexLong:
00002222  E99B                    2543          ROL.L #4,D3
00002224  6100 0056               2544          BSR convertHexToASCII
00002228  E99B                    2545          ROL.L #4,D3
0000222A  6100 0050               2546          BSR convertHexToASCII
0000222E  E99B                    2547          ROL.L #4,D3
00002230  6100 004A               2548          BSR convertHexToASCII
00002234  E99B                    2549          ROL.L #4,D3
00002236  6100 0044               2550          BSR convertHexToASCII
0000223A  E99B                    2551          ROL.L #4,D3
0000223C  6100 003E               2552          BSR convertHexToASCII
00002240  E99B                    2553          ROL.L #4,D3
00002242  6100 0038               2554          BSR convertHexToASCII
00002246  E99B                    2555          ROL.L #4,D3
00002248  6100 0032               2556          BSR convertHexToASCII
0000224C  E99B                    2557          ROL.L #4,D3
0000224E  6100 002C               2558          BSR convertHexToASCII
00002252                          2559          
00002252  60BA                    2560          BRA outputHexDone
00002254                          2561          
00002254                          2562  hexWord:
00002254  E95B                    2563          ROL.W #4,D3
00002256  6100 0024               2564          BSR convertHexToASCII
0000225A  E95B                    2565          ROL.W #4,D3
0000225C  6100 001E               2566          BSR convertHexToASCII
00002260  E95B                    2567          ROL.W #4,D3
00002262  6100 0018               2568          BSR convertHexToASCII
00002266  E95B                    2569          ROL.W #4,D3
00002268  6100 0012               2570          BSR convertHexToASCII
0000226C                          2571  
0000226C  60A0                    2572          BRA outputHexDone
0000226E                          2573          
0000226E                          2574  hexByte:
0000226E  E91B                    2575          ROL.B #4,D3
00002270  6100 000A               2576          BSR convertHexToASCII
00002274  E91B                    2577          ROL.B #4,D3
00002276  6100 0004               2578          BSR convertHexToASCII
0000227A                          2579          
0000227A  6092                    2580          BRA outputHexDone
0000227C                          2581          
0000227C                          2582  convertHexToASCII:
0000227C  1403                    2583          MOVE.B D3,D2
0000227E  0202 000F               2584          ANDI.B #%00001111,D2 ;mask out all but hex at least significant nyb
00002282  0C02 0009               2585          CMPI.B #9,D2
00002286  6F00 0006               2586          BLE Number
0000228A  6000 000A               2587          BRA Letter       
0000228E                          2588  
0000228E                          2589  Number:
0000228E  0602 0030               2590          ADDI.B #'0',D2
00002292  18C2                    2591          MOVE.B D2,(A4)+
00002294  4E75                    2592          RTS
00002296                          2593          
00002296                          2594  Letter:
00002296  0402 000A               2595          SUBI.B #$A,D2
0000229A  0602 0041               2596          ADDI.B #'A',D2
0000229E  18C2                    2597          MOVE.B D2,(A4)+
000022A0  4E75                    2598          RTS
000022A2                          2599  
000022A2                          2600  
000022A2                          2601  
000022A2                          2602  switchModeAndReg:
000022A2                          2603  ***
000022A2                          2604  * Assumed in D2
000022A2                          2605  *
000022A2                          2606  * Assumed that they are in least significant byte:
000022A2                          2607  *
000022A2                          2608  *            _this_
000022A2                          2609  *           /      \
000022A2                          2610  *  ........ ........
000022A2                          2611  *  \                /
000022A2                          2612  *   -----word-------
000022A2                          2613  *
000022A2                          2614  *  and that in that byte they are ordered:
000022A2                          2615  *
000022A2                          2616  *       ........   
000022A2                          2617  *       \/\_/\_/
000022A2                          2618  *      /  /    \
000022A2                          2619  *    /   /      \
000022A2                          2620  * dont  one    other
000022A2                          2621  * care
000022A2                          2622  *
000022A2                          2623  * after they will be
000022A2                          2624  *
000022A2                          2625  *       ........   
000022A2                          2626  *       \/\_/\_/
000022A2                          2627  *      /  /    \
000022A2                          2628  *    /   /      \
000022A2                          2629  * dont other    one
000022A2                          2630  * care
000022A2                          2631  *** 
000022A2  0202 003F               2632          AndI.B #%00111111,D2 ;remove unwanted bits from D2
000022A6  0283 00000000           2633          ANDI.L #0,D3 ;clear D3
000022AC  1602                    2634          MOVE.B D2,D3 ;copy to D3
000022AE  E70B                    2635          LSL.B  #3,D3 
000022B0  E60A                    2636          LSR.B  #3,D2
000022B2  D403                    2637          ADD.B  D3,D2
000022B4  4E75                    2638          RTS
000022B6                          2639  
000022B6                          2640          
000022B6                          2641  *==============================================================================
000022B6                          2642  *                            variables and constants
000022B6                          2643  *==============================================================================
000022B6                          2644  
000022B6                          2645  
000022B6                          2646  ***initial user prompt stuff        
000022B6= 45 6E 74 65 72 20 ...   2647  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE: $',0
000022E7= 45 6E 74 65 72 20 ...   2648  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE: $',0
00002316                          2649  
00002316= 20 41 64 64 72 65 ...   2650  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
0000235B= 20 41 20 43 68 61 ...   2651  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
000023A3                          2652  
000023A3= 20 59 6F 75 20 6D ...   2653  even_msg        DC.B    ' You must enter an even address!'
000023C3                          2654  
000023C3= 20                      2655  spc             DC.B    ' '
000023C4= 01                      2656  spc_len         DC.B    spc_len-spc
000023C5                          2657  ***
000023C5                          2658  
000023C5                          2659  
000023C5                          2660  
000023C5                          2661  ***list of OP codes
000023C5                          2662  
000023C5  =000041C0               2663  leaInstruction   EQU %0100000111000000
000023C5  =000081C0               2664  divsInstruction  EQU %1000000111000000
000023C5  =0000C1C0               2665  mulsInstruction  EQU %1100000111000000
000023C5  =0000E6C0               2666  rsrlweaInstruction  EQU %1110011011000000
000023C5  =0000E018               2667  rsrlregInstruction  EQU %1110000000011000
000023C5  =0000E0C0               2668  asrlweaInstruction  EQU %1110000011000000
000023C5  =0000E000               2669  asrlregInstruction  EQU %1110000000000000
000023C5  =0000E2C0               2670  lsrlweaInstruction  EQU %1110001011000000
000023C5  =0000E008               2671  lsrlregInstruction  EQU %1110000000001000
000023C5  =00005100               2672  subqInstruction  EQU %0101000100000000
000023C5  =00009000               2673  subInstruction   EQU %1001000000000000
000023C5  =0000D000               2674  addaInstruction  EQU %1101000000000000
000023C5  =0000D000               2675  addInstruction   EQU %1101000000000000
000023C5  =00004880               2676  movemInstruction EQU %0100100010000000
000023C5  =00000600               2677  addiInstruction  EQU %0000011000000000
000023C5  =00000000               2678  oriInstruction   EQU 0
000023C5  =00000C00               2679  cmpiInstruction  EQU %0000110000000000
000023C5  =00004E80               2680  jsrInstruction   EQU %0100111010000000
000023C5  =00004E75               2681  rtsInstruction   EQU %0100111001110101
000023C5  =00004E71               2682  NoOpInstruction  EQU %0100111001110001
000023C5  =00000000               2683  moveInstruction  EQU 0
000023C5  =00006000               2684  bccInstruction   EQU %0110000000000000
000023C5  =00004400               2685  negInstruction   EQU %0100010000000000
000023C5  =00000000               2686  dataInstruction  EQU 0
000023C5                          2687  
000023C5                          2688  ***
000023C5                          2689  
000023C5                          2690  ***list of OP masks
000023C5                          2691  
000023C5  =0000F1C0               2692  leaMask   EQU %1111000111000000
000023C5  =0000F1C0               2693  divsMask  EQU %1111000111000000
000023C5  =0000F1C0               2694  mulsMask  EQU %1111000111000000
000023C5  =0000FEC0               2695  rsrlweaMask  EQU %1111111011000000
000023C5  =0000F018               2696  rsrlregMask  EQU %1111000000011000
000023C5  =0000FEC0               2697  asrlweaMask  EQU %1111111011000000
000023C5  =0000F018               2698  asrlregMask  EQU %1111000000011000
000023C5  =0000FEC0               2699  lsrlweaMask  EQU %1111111011000000
000023C5  =0000F018               2700  lsrlregMask  EQU %1111000000011000
000023C5  =0000F100               2701  subqMask  EQU %1111000100000000
000023C5  =0000F000               2702  subMask   EQU %1111000000000000
000023C5  =0000F000               2703  addaMask  EQU %1111000000000000
000023C5  =0000F000               2704  addMask   EQU %1111000000000000
000023C5  =0000FB80               2705  movemMask EQU %1111101110000000
000023C5  =0000FF00               2706  addiMask  EQU %1111111100000000
000023C5  =0000FF00               2707  oriMask   EQU %1111111100000000
000023C5  =0000FF00               2708  cmpiMask  EQU %1111111100000000
000023C5  =0000FFC0               2709  jsrMask   EQU %1111111111000000
000023C5  =0000FFFF               2710  rtsMask   EQU $FFFF
000023C5  =0000FFFF               2711  NoOpMask  EQU $FFFF
000023C5  =0000C000               2712  moveMask  EQU $C000
000023C5  =0000F000               2713  bccMask   EQU $F000
000023C5  =0000FF00               2714  negMask   EQU $FF00
000023C5  =00000000               2715  dataMask  EQU 0
000023C5                          2716  ***
000023C5                          2717  
000023C5                          2718  ***Bcc Codes***
000023C5  =00000004               2719  CC EQU $04
000023C5  =00000005               2720  CS EQU $05
000023C5  =00000007               2721  EQ EQU $07
000023C5  =0000000C               2722  GE EQU $0C
000023C5  =0000000E               2723  GT EQU $0E
000023C5  =00000002               2724  HI EQU $02
000023C5  =0000000F               2725  LE EQU $0F
000023C5  =00000003               2726  LS EQU $03
000023C5  =0000000D               2727  LT EQU $0D
000023C5  =0000000B               2728  MI EQU $0B
000023C5  =00000006               2729  NE EQU $06
000023C5  =0000000A               2730  PL EQU $0A
000023C5  =00000008               2731  VC EQU $08
000023C5  =00000009               2732  VS EQU $09
000023C5  =00000000               2733  RA EQU $00 ;not really a Condition Code
000023C5  =00000001               2734  SR EQU $01 ;not really a Condition Code
000023C5                          2735  
000023C5= 43 43 20 00             2736  CCm DC.B 'CC ',0
000023C9= 43 53 20 00             2737  CSm DC.B 'CS ',0
000023CD= 45 51 20 00             2738  EQm DC.B 'EQ ',0
000023D1= 47 45 20 00             2739  GEm DC.B 'GE ',0
000023D5= 47 54 20 00             2740  GTm DC.B 'GT ',0
000023D9= 48 49 20 00             2741  HIm DC.B 'HI ',0
000023DD= 4C 45 20 00             2742  LEm DC.B 'LE ',0
000023E1= 4C 53 20 00             2743  LSm DC.B 'LS ',0
000023E5= 4C 54 20 00             2744  LTm DC.B 'LT ',0
000023E9= 4D 49 20 00             2745  MIm DC.B 'MI ',0
000023ED= 4E 45 20 00             2746  NEm DC.B 'NE ',0
000023F1= 50 4C 20 00             2747  PLm DC.B 'PL ',0
000023F5= 56 43 20 00             2748  VCm DC.B 'VC ',0
000023F9= 56 53 20 00             2749  VSm DC.B 'VS ',0
000023FD= 52 41 20 00             2750  RAm DC.B 'RA ',0
00002401= 53 52 20 00             2751  SRm DC.B 'SR ',0
00002405                          2752  
00002405= 01 04 05 07 0C 0E ...   2753  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
00002416= 00002401 000023C5 ...   2754  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
00002456                          2755  ***
00002456                          2756  
00002456= 45 6E 74 65 72 20 ...   2757  startLocationPrompt DC.B    'Enter start location',0
0000246B= 45 6E 74 65 72 20 ...   2758  endLocationPrompt   DC.B    'Enter end location',0
0000247E                          2759  
0000247E= 0D 0A 00                2760  clearLine  DC.B $0D,$0A,0
00002481                          2761  
00002481= 4C 45 41 20 00          2762  leaMessage      DC.B 'LEA ',0
00002486= 44 49 56 53 20 00       2763  divsMessage     DC.B 'DIVS ',0
0000248C= 4D 55 4C 53 20 00       2764  mulsMessage     DC.B 'MULS ',0
00002492= 52 4F 4C 20 00          2765  rslMessage      DC.B 'ROL ',0
00002497= 52 4F 52 20 00          2766  rsrMessage      DC.B 'ROR ',0
0000249C= 41 53 4C 20 00          2767  aslMessage      DC.B 'ASL ',0
000024A1= 41 53 52 20 00          2768  asrMessage      DC.B 'ASR ',0
000024A6= 4C 53 4C 20 00          2769  lslMessage      DC.B 'LSL ',0
000024AB= 4C 53 52 20 00          2770  lsrMessage      DC.B 'LSR ',0
000024B0= 53 55 42 51 20 00       2771  subqMessage     DC.B 'SUBQ ',0
000024B6= 53 55 42 20 00          2772  subMessage      DC.B 'SUB ',0 
000024BB= 41 44 44 41 20 00       2773  addaMessage     DC.B 'ADDA ',0
000024C1= 41 44 44 20 00          2774  addMessage      DC.B 'ADD ',0
000024C6= 4D 4F 56 45 4D 20 00    2775  movemMessage    DC.B 'MOVEM ',0
000024CD= 41 44 44 49 20 00       2776  addiMessage     DC.B 'ADDI ',0
000024D3= 4F 52 49 20 00          2777  oriMessage      DC.B 'ORI ',0
000024D8= 43 4D 50 49 20 00       2778  cmpiMessage     DC.B 'CMPI ',0
000024DE= 4A 53 52 20 00          2779  jsrMessage      DC.B 'JSR ',0
000024E3= 52 54 53 20 00          2780  rtsMessage      DC.B 'RTS ',0
000024E8= 4E 4F 50 20 00          2781  nopMessage      DC.B 'NOP ',0 
000024ED= 4D 4F 56 45 20 00       2782  moveMessage     DC.B 'MOVE ',0
000024F3= 42 00                   2783  bccMessage      DC.B 'B',0
000024F5= 4E 45 47 20 00          2784  negMessage      DC.B 'NEG ',0
000024FA= 44 41 54 41 20 00       2785  dataMessage     DC.B 'DATA ',0
00002500= 4D 4F 56 45 41 20 00    2786  moveaMessage    DC.B 'MOVEA ',0
00002507                          2787  
00002507= 28 78 78 78 29 2E ...   2788  xxxW            DC.B '(xxx).W: ',0
00002511= 28 78 78 78 29 2E ...   2789  xxxL            DC.B '(xxx).L: ',0
0000251B= 23 28 64 61 74 61 ...   2790  iData           DC.B '#(data): ',0
00002525                          2791  
00002525= 41 00                   2792  letterA         DC.B 'A', 0
00002527= 44 00                   2793  letterD         DC.B 'D', 0
00002529                          2794  
00002529= 2B 00                   2795  plus            DC.B '+', 0
0000252B= 2D 00                   2796  minus           DC.B '-', 0
0000252D= 28 00                   2797  lPrn            DC.B '(', 0
0000252F= 29 00                   2798  rPrn            DC.B ')', 0
00002531                          2799  
00002531                          2800  
00002532= 00000000                2801  startLocation       DC.L    0
00002536= 00000000                2802  endLocation         DC.L    0
0000253A                          2803  
0000253A                          2804  
0000253A                          2805     
0000253A                          2806      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 1898
ADDA                17FA
ADDABODY            1842
ADDAINSTRUCTION     D000
ADDAMASK            F000
ADDAMESSAGE         24BB
ADDDEST             195C
ADDDESTEA           188C
ADDDESTEAMASKS      1892
ADDI                1ACA
ADDIBODY            1AF6
ADDIDONE            1B34
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         24CD
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          24C1
ADDRESS_DONE        1F5C
ADDRESS_EXIT        1F56
ADDR_ABS_LONG       21C4
ADDR_ABS_SHORT      21AA
ADDR_IMMEDIATE_DATA  21D8
ADDR_REG_DIRECT     20E2
ADDR_REG_INDIRECT   20FC
ADDR_REG_INDIRECT_DEC  216C
ADDR_REG_INDIRECT_INC  212E
ADDSOURCE           1914
ASLEA               1464
ASLMESSAGE          249C
ASLREG              14AA
ASREA               1454
ASRLREG             1474
ASRLREGINSTRUCTION  E000
ASRLREGMASK         F018
ASRLWEA             1414
ASRLWEACHECKDIRECTION  1440
ASRLWEAINSTRUCTION  E0C0
ASRLWEAMASK         FEC0
ASRMESSAGE          24A1
ASRREG              149A
BCC                 1E10
BCCBYTE             1E62
BCCDONE             1E78
BCCINSTRUCTION      6000
BCCLIST             2405
BCCLONG             1E70
BCCMASK             F000
BCCMESSAGE          24F3
BCCWORD             1E68
BEGIN               5001
BEGIN_ADDRESS       1EE8
BYTE                1
CC                  4
CCM                 23C5
CHECKCC             1E26
CHECKMOVEADEST      1DBC
CHECKMOVEDEST       1D0A
CHECKOPCODE         1072
CK_ADDR_DONE        206C
CK_ADDR_RANGE       2040
CK_ADDR_RANGE_ERROR  205C
CK_BOUNDRY          1F84
CK_BOUNDRY_ERROR    1FA6
CK_SIZE_ERROR       1FBA
CLEARLINE           247E
CMPI                1BCC
CMPIBODY            1BF4
CMPIDONE            1C32
CMPIEA              1BBE
CMPIEAMASKS         1BC5
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         24D8
CONDITIONCODEMESSAGE  2416
CONVERTHEXTOASCII   227C
CS                  5
CSM                 23C9
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         24FA
DATA_REG_DIRECT     20C8
DIVS                127A
DIVSBODY            12A6
DIVSINSTRUCTION     81C0
DIVSMASK            F1C0
DIVSMESSAGE         2486
ELPROMPT            22E7
END                 FFFFFE
ENDLOCATION         2536
ENDLOCATIONPROMPT   246B
END_ADDRESS         1F2C
ENTER_ADDR_EDIT_ALL  1F5E
ENTER_ADDR_EDIT_ALL_EXIT  1F82
EQ                  7
EQM                 23CD
EVEN_MSG            23A3
FALSEPOSITIVE       1092
FARLABEL            FFE
FIN                 1EE4
FOUNDCC             1E38
GE                  C
GEM                 23D1
GET_EFFECTIVE_ADDRESS  2070
GET_EFFECTIVE_ADDRESS_EXIT  21E8
GET_EFFECTIVE_ADDRESS_OTHER  20AC
GT                  E
GTM                 23D5
HANDLEBYTEDATA      1EB8
HEXBYTE             226E
HEXLONG             2222
HEXOUTPUTBUFFER     21EA
HEXWORD             2254
HEX_RANGE_ERROR     2028
HI                  2
HIM                 23D9
IDATA               251B
INSTLABELLIST       1118
INSTLABELLIST2      1120
INSTMASKLIST        10E8
INSTOPLIST          10B8
INSTOPLIST2         10CA
INVALIDEA           21E8
INVALIDMSG          2316
INVCHARMSG          235B
JSR                 1C4A
JSRBODY             1C72
JSRDONE             1C92
JSREA               1C42
JSREAMASKS          1C46
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          24DE
LCASEHEX            200A
LE                  F
LEA                 1208
LEABODY             1230
LEAEA               1200
LEAEAMASKS          1204
LEAINSTRUCTION      41C0
LEAMASK             F1C0
LEAMESSAGE          2481
LEM                 23DD
LETTER              2296
LETTERA             2525
LETTERD             2527
LONG                4
LPRN                252D
LS                  3
LSLEA               1512
LSLMESSAGE          24A6
LSLREG              157C
LSM                 23E1
LSREA               1502
LSRLCHECKI          15E4
LSRLCHECKIR         15CE
LSRLCHECKIRRETURN   15E2
LSRLCHECKR          1618
LSRLEA              14BA
LSRLEAMASKS         14C0
LSRLREG             1546
LSRLREGBODY         158C
LSRLREGINSTRUCTION  E008
LSRLREGMASK         F018
LSRLWEA             14C6
LSRLWEABODY         1522
LSRLWEACHECKDIRECTION  14EE
LSRLWEAINSTRUCTION  E2C0
LSRLWEAMASK         FEC0
LSRMESSAGE          24AB
LSRREG              156C
LT                  D
LTM                 23E5
MAIN_LOOP           1026
MATCH               1098
MI                  B
MIM                 23E9
MINUS               252B
MOVE                1CE2
MOVEA               1D94
MOVEABODY           1DEA
MOVEADESTEA         1D90
MOVEADESTEAMASKS    1D92
MOVEAMESSAGE        2500
MOVEBODY            1D38
MOVEDESTEA          1CD4
MOVEDESTEAMASKS     1CDB
MOVEINSTRUCTION     0
MOVEM               19B8
MOVEMASK            C000
MOVEMBODY           1A22
MOVEMESSAGE         24ED
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     19AE
MOVEMMEMTOREGEAMASKS  19B3
MOVEMMESSAGE        24C6
MOVEMREGTOMEMEA     19A4
MOVEMREGTOMEMEAMASKS  19A9
MOVESOURCEEA        1CC2
MOVESOURCEEAMASKS   1CCB
MULS                12FE
MULSBODY            1326
MULSEA              12EE
MULSEAMASKS         12F6
MULSINSTRUCTION     C1C0
MULSMASK            F1C0
MULSMESSAGE         248C
NE                  6
NEG                 1A64
NEGBODY             1A8C
NEGDONE             1ABA
NEGEA               1A54
NEGEAMASKS          1A5C
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          24F5
NEM                 23ED
NEXTHEX             1FD0
NEXTHEXDONE         2022
NEXTHEXRETURN       203E
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 1CA2
NOPMESSAGE          24E8
NUMBER              228E
ORI                 1B44
ORIBODY             1B70
ORIDONE             1BAE
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          24D3
OUTPUTHEX           21F6
OUTPUTHEXDONE       220E
PARSEHEXSTRING      1FCE
PL                  A
PLM                 23F1
PLUS                2529
PRGORG              1000
PROCESS_OP_CODES    206E
PROCESS_OP_CODES_EXIT  206E
PROMPT_USER         1014
RA                  0
RAM                 23FD
RPRN                252F
RSLEA               13BE
RSLMESSAGE          2492
RSLREG              1404
RSREA               13AE
RSRLREG             13CE
RSRLREGINSTRUCTION  E018
RSRLREGMASK         F018
RSRLWEA             136E
RSRLWEACHECKDIRECTION  139A
RSRLWEAINSTRUCTION  E6C0
RSRLWEAMASK         FEC0
RSRMESSAGE          2497
RSRREG              13F4
RTS                 1CB2
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          24E3
SLPROMPT            22B6
SNIPPET             1178
SNIPPETEND          11FC
SPC                 23C3
SPC_LEN             23C4
SR                  1
SRM                 2401
STACK               5000
START               1000
STARTLOCATION       2532
STARTLOCATIONPROMPT  2456
SUB                 16EA
SUBDEST             17B2
SUBINSTRUCTION      9000
SUBMASK             F000
SUBMESSAGE          24B6
SUBQ                1642
SUBQBODY            167A
SUBQEA              1632
SUBQEAMASKS         163A
SUBQINSTRUCTION     5100
SUBQMASK            F100
SUBQMESSAGE         24B0
SUBSOURCE           176A
SWITCHMODEANDREG    22A2
TOEIGHT             16E6
UCASEHEX            1FF2
UNKNOWNOPCODE       1E92
VALIDADDA           1818
VALIDADDDESTEA      18E8
VALIDADDIMODES      1ACC
VALIDADDSOURCEEA    18BE
VALIDASRL           1416
VALIDCMPIMODES      1BCE
VALIDDIVSMODES      127C
VALIDJSRMODES       1C4C
VALIDLEAMODES       120A
VALIDLSRL           14C8
VALIDMEMTOREG       19F4
VALIDMOVEADESTMODES  1DBE
VALIDMOVEASOURCEMODES  1D96
VALIDMOVEDESTMODES  1D0C
VALIDMOVESOURCEMODES  1CE4
VALIDMULSMODES      1300
VALIDNEGMODES       1A66
VALIDORIMODES       1B46
VALIDREGTOMEM       19CE
VALIDRSRL           1370
VALIDSUBDESTEA      173A
VALIDSUBQ           1654
VALIDSUBSOURCEEA    1710
VC                  8
VCM                 23F5
VS                  9
VSM                 23F9
WORD                2
XXXL                2511
XXXW                2507
ZEROTOEIGHT         16DC
ZEROTOEIGHTRETURN   16E4

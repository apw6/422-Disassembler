00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/9/2014 12:37:26 AM

00000000                             1  *##########################################################################
00000000                             2  * Title      : 
00000000                             3  * Written by : Andrew Watson
00000000                             4  *            : Elaine Keller
00000000                             5  *            : Robert Anderson
00000000                             6  * Date       : 11/14/2014
00000000                             7  * Description: 
00000000                             8  *##########################################################################
00000000                             9  
00000000                            10  ***Possible Bug***
00000000                            11  *can not tell data from an
00000000                            12  *unidentified instruction from an actual
00000000                            13  *instruction therefore causing errors.
00000000                            14  *may not actually be a bug because data
00000000                            15  *is data to the machine, and if you modify
00000000                            16  *the instructions in memory for a program
00000000                            17  *by moivng data, you can modify the instuctions
00000000                            18  *executed.
00000000                            19  
00000000                            20  
00000000                            21  ***************************************************************************
00000000                            22  *                   Variable/Data Definitions
00000000                            23  ***************************************************************************
00000000                            24  
00000000  =00005000                 25  stack   EQU   $00005000
00000000  =00005001                 26  begin   EQU   $00005001
00000000  =00FFFFFE                 27  end     EQU   $00FFFFFE
00000000  =00000001                 28  byte    EQU   1
00000000  =00000002                 29  word    EQU   2
00000000  =00000004                 30  long    EQU   4
00000000  =00001000                 31  prgorg  EQU   $1000
00000000                            32  
00000FFE                            33      ORG $00000FFE
00000FFE                            34  FarLabel:
00001000                            35      ORG    prgorg
00001000                            36  start:
00001000  4FF8 5000                 37          LEA stack, SP ;initialize stack
00001004                            38  
00001000                            39      ORG    prgorg
00001000                            40  
00001000                            41  ******************************************************************************
00001000                            42  *                   Begin processing active code
00001000                            43  ******************************************************************************
00001000                            44      
00001000                            45  start:
00001000                            46  
00001000  4FF8 5000                 47          LEA         stack, SP           ;Initialize stack
00001004                            48          
00001004                            49  *.............................................................................
00001004                            50  * Debug Mode - Comment out when done
00001004  267C 0000111E             51          MOVE.L      #snippet,A3
0000100A  287C 00001170             52          MOVE.L      #snippetEnd,A4
00001010  6000 0014                 53          BRA         main_Loop
00001014                            54  * Debug Mode - Comment out when done
00001014                            55  *.............................................................................        
00001014                            56          
00001014                            57  prompt_user:
00001014                            58  
00001014  6100 0B7A                 59          BSR         begin_address
00001018  B67C FFFF                 60          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000101C  6700 0B6E                 61          BEQ         fin                 ;Yes, then exit
00001020                            62          
00001020  6000 0004                 63          BRA         main_Loop
00001024                            64          ;BSR         process_op_codes
00001024  60EE                      65          BRA         prompt_user
00001026                            66                  
00001026                            67  ******************************************************************************
00001026                            68  *                   Begin processing OP Codes
00001026                            69  ******************************************************************************
00001026                            70   
00001026                            71  main_Loop:
00001026                            72  
00001026  B9CB                      73          CMPA.L A3,A4 ;check end of prog
00001028  6700 0B62                 74          BEQ fin
0000102C                            75          
0000102C  3213                      76          MOVE.W (A3),D1 ;copy word from other prog to analyze as instruction
0000102E                            77          
0000102E                            78          ;handle an odd memory access(instructions will never be misaligned)
0000102E  240B                      79          MOVE.L A3,D2 ; copy address to D2
00001030  0202 0001                 80          ANDI.B #%00000001,D2 ;mask everything except the least significant bit
00001034  0C02 0001                 81          CMPI.B #1,D2 ;compare the least sig bit of the address to one
00001038  6700 0B26                 82          BEQ handlebytedata ;the least sig bit will only be one if the insrtuction
0000103C                            83                             ;is odd(misaligned) and therefore not an instruction
0000103C                            84          
0000103C  7600                      85          MOVEQ.L #0,D3
0000103E                            86          
0000103E                            87          ***things to save A3,A4,D1(?)***
0000103E  48E7 0018                 88          MOVEM.L A3-A4,-(SP)
00001042  6100 000C                 89          BSR checkOPcode
00001046  4CDF 1800                 90          MOVEM.L (SP)+,A3-A4
0000104A  D7C7                      91          ADDA.L  D7,A3 ;look past data that was part of the instruction
0000104C                            92          
0000104C  548B                      93          ADDQ.L  #word,A3
0000104E  60D6                      94          BRA     main_Loop 
00001050                            95          
00001050                            96  checkOPcode:
00001050                            97  
00001050                            98  
00001050  7E00                      99          MOVEQ.L #0,D7
00001052                           100          
00001052  41F9 00001096            101          LEA     instOPList,A0 ;get instruction signitrue list in A0
00001058  D1C3                     102          ADDA.L  D3,A0 ;get correct sig         
0000105A                           103          
0000105A  43F9 000010B8            104          LEA     instMaskList,A1 ;get instruction mask in A1
00001060  D3C3                     105          ADDA.L  D3,A1  ;get correct mast
00001062                           106          
00001062  3401                     107          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001064                           108          
00001064  C451                     109          AND.W   (A1),D2 ;mask instruction
00001066                           110          
00001066                           111          
00001066                           112          
00001066                           113          
00001066  B450                     114          CMP.W   (A0),D2 ;compare to sig
00001068  6700 000C                115          BEQ     match ;if sig matches branch
0000106C  5483                     116          ADDQ.L  #word,D3 ;add to D3 to check for next instruction
0000106E  60E0                     117          BRA checkOPcode
00001070                           118          
00001070                           119  falsePositive:
00001070                           120          
00001070  103C 00FF                121          MOVE.B #-1,D0
00001074  4E75                     122          RTS
00001076                           123  
00001076                           124  match:
00001076                           125          
00001076  43F9 000010DA            126          LEA     instLabelList,A1 ;get instruction code label
0000107C  D3C3                     127          ADDA.L  D3,A1 ;get correct label
0000107E  D3C3                     128          ADDA.L  D3,A1
00001080  5483                     129          ADDQ.L  #word,D3 ;add to D3 incase false positive
00001082  2251                     130          MOVEA.L (A1),A1
00001084  48E7 1000                131          MOVEM.L D3,-(SP) ; save D3
00001088  4E91                     132          JSR     (A1)
0000108A  4CDF 0008                133          MOVEM.L (SP)+,D3 ;restore D3
0000108E  B03C 00FF                134          CMP.B   #-1,D0
00001092  67BC                     135          BEQ     checkOPcode
00001094  4E75                     136          RTS
00001096                           137          
00001096                           138  
00001096= E2C0 E008                139  instOPList  DC.W lsrlweaInstruction,lsrlregInstruction
0000109A= 5100 9000 D000 D...      140  instOPList2 DC.W subqInstruction,subInstruction,addaInstruction,addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruct
000010B8                           141      
000010B8= FEC0 F018 F100 F...      142  instMaskList DC.W lsrlweaMask,lsrlregMask,subqMask,subMask,addaMask,addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
000010DA= 00001180 00001200 ...    143  instLabelList DC.L LSRLWEA,LSRLREG,SUBQ,SUB,ADDA,ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
0000111E                           144  
0000111E                           145  snippet:
0000111E  4E71                     146           NOP
00001120  60FC                     147           BRA snippet
00001122  6000 FEDA                148           BRA FarLabel
00001126  67F6                     149           BEQ snippet
00001128  6E00 05E2                150           BGT NEG
0000112C  61F0                     151           BSR snippet
0000112E  4441                     152           NEG D1
00001130  3239 00008500            153           MOVE.W $8500,D1
00001136  0645 001E                154           ADDI.W #30,D5
0000113A  4E75                     155           RTS
0000113C  4EB8 0054                156           JSR $54
00001140  0C41 0003                157           CMPI #3,D1
00001144  0041 0003                158           ORI  #3,D1
00001148  48E7 0018                159           MOVEM.L A3-A4,-(SP)
0000114C  D401                     160           ADD.B D1,D2
0000114E  0603 000A                161           ADD.B #10,D3
00001152  D7FC 00000463            162           ADDA.L #1123,A3
00001158  9A43                     163           SUB.W D3,D5
0000115A  5105                     164           SUBQ.B #8,D5
0000115C  5305                     165           SUBQ.B #1,D5
0000115E  E64B                     166           LSR #3,D3
00001160  E74C                     167           LSL #3,D4
00001162  E369                     168           LSL D1,D1
00001164  E66F                     169           LSR D3,D7
00001166  E2F8 3563                170           LSR $3563
0000116A  E3F9 00486412            171           LSL $486412
00001170                           172  
00001170                           173           
00001170                           174  snippetEnd:
00001170  FFFF FFFF                175           SIMHALT
00001174                           176  
00001174                           177  
00001174= 10 18 20 38 39 00        178  lsrlEA        DC.B %010000,%011000,%100000,%111000,%111001,0
0000117A= 38 38 38 3F 3F 00        179  lsrlEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0       
00001180                           180  
00001180                           181  LSRLWEA:
00001180                           182          
00001180                           183  
00001180                           184          
00001180  7000                     185          MOVEQ.L #0, D0 ;clear D0
00001182                           186          
00001182                           187  validLSRL:
00001182                           188          
00001182  43F8 117A                189          LEA lsrlEAmasks,A1 ;load the list of masks
00001186  D3C0                     190          ADDA.L D0,A1 ;displace to a specific mask
00001188  1A11                     191          MOVE.B (A1),D5 ;move the mask to D5
0000118A                           192          
0000118A  0C05 0000                193          CMPI.B #0,D5 ;check if the mask is 0
0000118E  6700 FEE0                194          BEQ falsePositive ;branch if it is
00001192                           195          
00001192  1401                     196          MOVE.B D1,D2 ;copy instruction to D2
00001194  C405                     197          AND.B D5,D2  ;mask D2
00001196                           198          
00001196  43F8 1174                199          LEA lsrlEA,A1 ;load the list of valid modes
0000119A  D3C0                     200          ADDA.L D0,A1 ;displace to a specific mode
0000119C  1811                     201          MOVE.B (A1),D4 ;move mode to D4
0000119E  B404                     202          CMP.B D4,D2 ;compare mode to masked value
000011A0  6700 0006                203          BEQ  lsrlweaCheckDirection ;if its match, its a valid mode and we can procede
000011A4                           204          
000011A4  5280                     205          ADDQ.L #1,D0 ;add one to displacement
000011A6  60DA                     206          BRA validLSRL ;check for next mode
000011A8                           207  
000011A8                           208  lsrlweaCheckDirection:
000011A8                           209          ;Figure out which direction we are going
000011A8  3401                     210          MOVE.W D1,D2 ;copy inst to D2
000011AA  E04A                     211          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000011AC  0202 0001                212          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000011B0  0C02 0000                213          CMPI.B #0,D2 ;compare bit to zero
000011B4  6700 0006                214          BEQ LSREA ;if zero, right
000011B8  6000 0012                215          BRA LSLEA ;else, its left
000011BC                           216  
000011BC                           217  LSREA:
000011BC                           218  
000011BC  43F9 00002070            219          LEA     lsrMessage,A1  ;move string for MOVE
000011C2  103C 000E                220          MOVE.B  #14,D0        ;set for task to display null terminated 
000011C6                           221                                ;string with CR, LF
000011C6  4E4F                     222          TRAP    #15
000011C8  6000 0012                223          BRA lsrlweaBody
000011CC                           224          
000011CC                           225  LSLEA:
000011CC                           226          
000011CC  43F9 0000206B            227          LEA     lslMessage,A1  ;move string for MOVE
000011D2  103C 000E                228          MOVE.B  #14,D0        ;set for task to display null terminated 
000011D6                           229                                ;string with CR, LF
000011D6  4E4F                     230          TRAP    #15
000011D8  6000 0002                231          BRA lsrlweaBody        
000011DC                           232          
000011DC                           233  lsrlweaBody:
000011DC                           234  
000011DC                           235          
000011DC  3401                     236          MOVE.W  D1,D2 ;check mode
000011DE  C43C 003F                237          AND.B   #%00111111,D2
000011E2  1A02                     238          MOVE.B  D2,D5
000011E4  48E7 4000                239          MOVEM.L D1,-(SP)
000011E8  6100 0B2E                240          BSR     Get_Effective_Address
000011EC  4CDF 0002                241          MOVEM.L (SP)+,D1
000011F0                           242          
000011F0                           243          
000011F0  43F9 00002068            244          LEA     clearLine,A1  ;move string for a CR and LF
000011F6  103C 000E                245          MOVE.B  #14,D0        ;set for task to display null terminated 
000011FA                           246                                ;string without CR, LF
000011FA  4E4F                     247          TRAP    #15
000011FC                           248  
000011FC  7000                     249          MOVEQ.L #0,D0
000011FE  4E75                     250          RTS
00001200                           251  
00001200                           252  
00001200                           253  LSRLREG:
00001200                           254          
00001200                           255  
00001200                           256          
00001200  7000                     257          MOVEQ.L #0, D0 ;clear D0
00001202                           258          
00001202                           259          ;check valid size field
00001202  3401                     260          MOVE.W D1,D2 ;copy inst to D2
00001204  EC4A                     261          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
00001206  0202 0003                262          ANDI.B #%00000011,D2 ;mask out rest of byte
0000120A  0C02 0003                263          CMPI.B #%11,D2 ;compare to 3
0000120E  6700 FE60                264          BEQ falsePositive ;invalid size
00001212                           265  
00001212                           266          
00001212                           267          ;Figure out which direction we are going
00001212  3401                     268          MOVE.W D1,D2 ;copy inst to D2
00001214  E04A                     269          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
00001216  0202 0001                270          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
0000121A  0C02 0000                271          CMPI.B #0,D2 ;compare bit to zero
0000121E  6700 0006                272          BEQ LSRreg ;if zero, right
00001222  6000 0012                273          BRA LSLreg ;else, its left        
00001226                           274          
00001226                           275  LSRreg:
00001226                           276  
00001226  43F9 00002070            277          LEA     lsrMessage,A1  ;move string for MOVE
0000122C  103C 000E                278          MOVE.B  #14,D0        ;set for task to display null terminated 
00001230                           279                                ;string with CR, LF
00001230  4E4F                     280          TRAP    #15
00001232  6000 0012                281          BRA LSRLregBody
00001236                           282          
00001236                           283  LSLreg:
00001236                           284          
00001236  43F9 0000206B            285          LEA     lslMessage,A1  ;move string for MOVE
0000123C  103C 000E                286          MOVE.B  #14,D0        ;set for task to display null terminated 
00001240                           287                                ;string with CR, LF
00001240  4E4F                     288          TRAP    #15
00001242  6000 0002                289          BRA LSRLregBody
00001246                           290          
00001246                           291  LSRLregBody:
00001246                           292                      
00001246                           293          ;check i/r
00001246  48E7 4000                294          MOVEM.L D1,-(SP)
0000124A  6100 002A                295          BSR LSRLcheckIR
0000124E  4CDF 0002                296          MOVEM.L (SP)+,D1
00001252                           297          
00001252  3401                     298          MOVE.W  D1,D2 ;check mode
00001254  C43C 0007                299          AND.B   #%00000111,D2
00001258  1A02                     300          MOVE.B  D2,D5
0000125A  48E7 4000                301          MOVEM.L D1,-(SP)
0000125E  6100 0AB8                302          BSR     Get_Effective_Address
00001262  4CDF 0002                303          MOVEM.L (SP)+,D1
00001266                           304          
00001266                           305          
00001266  43F9 00002068            306          LEA     clearLine,A1  ;move string for a CR and LF
0000126C  103C 000E                307          MOVE.B  #14,D0        ;set for task to display null terminated 
00001270                           308                                ;string without CR, LF
00001270  4E4F                     309          TRAP    #15
00001272                           310  
00001272  7000                     311          MOVEQ.L #0,D0
00001274  4E75                     312          RTS
00001276                           313  
00001276                           314  LSRLcheckIR:
00001276                           315  
00001276  1401                     316          MOVE.B D1,D2 ;move inst to D2
00001278  EA0A                     317          LSR.B  #5,D2
0000127A  C43C 0001                318          AND.B  #%00000001,D2
0000127E  0C02 0000                319          CMPI.B #0,D2
00001282  6700 0008                320          BEQ  LSRLcheckI
00001286  6000 0038                321          BRA  LSRLcheckR
0000128A                           322  LSRLcheckIRreturn:
0000128A  4E75                     323          RTS
0000128C                           324          
0000128C                           325  LSRLcheckI:
0000128C                           326          ;print '#'
0000128C  48E7 4000                327          MOVEM.L D1,-(SP) ;save D1 to the stack
00001290  123C 0023                328          MOVE.B #'#',D1 ;put ascii value of '#' in D1
00001294  103C 0006                329          MOVE.B #6,D0 ;move task 6 into D0
00001298  4E4F                     330          TRAP #15 ;prin char
0000129A  4CDF 0002                331          MOVEM.L (SP)+,D1 ;pull D1 off the stack
0000129E                           332          
0000129E                           333          ;print number
0000129E  48E7 4000                334          MOVEM.L D1,-(SP)
000012A2  3401                     335          MOVE.W D1,D2 ;copy inst to d2
000012A4  E04A                     336          LSR.W #8,D2 ;shift data section
000012A6  E20A                     337          LSR.B #1,D2
000012A8  C43C 0007                338          AND.B #%00000111,D2 ;mask out rest of data
000012AC  6100 00D6                339          BSR ZeroToEight ;handle zero
000012B0  7200                     340          MOVEQ.L #0,D1 ;clear D1
000012B2  1202                     341          MOVE.B D2,D1 ;move number to display into D1
000012B4  103C 0003                342          MOVE.B #3,D0 ;move task 3 to D0
000012B8  4E4F                     343          TRAP #15
000012BA  4CDF 0002                344          MOVEM.L (SP)+,D1
000012BE  60CA                     345          BRA LSRLcheckIRreturn
000012C0                           346          
000012C0                           347  LSRLcheckR:
000012C0  3401                     348          MOVE.W D1,D2 ;copy inst to d2
000012C2  E04A                     349          LSR.W #8,D2 ;shift data section
000012C4  E20A                     350          LSR.B #1,D2
000012C6  C43C 0007                351          AND.B #%00000111,D2 ;mask out rest of data
000012CA  1A02                     352          MOVE.B D2,D5 ;force Dn
000012CC  48E7 4000                353          MOVEM.L D1,-(SP)
000012D0  6100 0A46                354          BSR     Get_Effective_Address
000012D4  4CDF 0002                355          MOVEM.L (SP)+,D1
000012D8  60B0                     356          BRA LSRLcheckIRreturn
000012DA                           357          
000012DA= 00 08 10 18 20 38 ...    358  subqEA        DC.B %000000,%001000,%010000,%011000,%100000,%111000,%111001,0
000012E2= 38 38 38 38 38 3F ...    359  subqEAmasks   DC.B %111000,%111000,%111000,%111000,%111000,%111111,%111111,0
000012EA                           360  
000012EA                           361  SUBQ:
000012EA                           362          
000012EA                           363  
000012EA                           364          
000012EA  7000                     365          MOVEQ.L #0, D0 ;clear D0
000012EC                           366          
000012EC                           367          ;check valid size field
000012EC  3401                     368          MOVE.W D1,D2 ;copy inst to D2
000012EE  EC4A                     369          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
000012F0  0202 0003                370          ANDI.B #%00000011,D2 ;mask out rest of byte
000012F4  0C02 0003                371          CMPI.B #%11,D2 ;compare to 3
000012F8  6700 FD76                372          BEQ falsePositive ;invalid size
000012FC                           373          
000012FC                           374  validSubq:
000012FC                           375          
000012FC  43F8 12E2                376          LEA subqEAmasks,A1 ;load the list of masks
00001300  D3C0                     377          ADDA.L D0,A1 ;displace to a specific mask
00001302  1A11                     378          MOVE.B (A1),D5 ;move the mask to D5
00001304                           379          
00001304  0C05 0000                380          CMPI.B #0,D5 ;check if the mask is 0
00001308  6700 FD66                381          BEQ falsePositive ;branch if it is
0000130C                           382          
0000130C  1401                     383          MOVE.B D1,D2 ;copy instruction to D2
0000130E  C405                     384          AND.B D5,D2  ;mask D2
00001310                           385          
00001310  43F8 12DA                386          LEA subqEA,A1 ;load the list of valid modes
00001314  D3C0                     387          ADDA.L D0,A1 ;displace to a specific mode
00001316  1811                     388          MOVE.B (A1),D4 ;move mode to D4
00001318  B404                     389          CMP.B D4,D2 ;compare mode to masked value
0000131A  6700 0006                390          BEQ  subqBody ;if its match, its a valid mode and we can procede
0000131E                           391          
0000131E  5280                     392          ADDQ.L #1,D0 ;add one to displacement
00001320  60DA                     393          BRA validSubq ;check for next mode
00001322                           394          
00001322                           395          
00001322                           396  subqBody
00001322                           397  
00001322  43F9 00002075            398          LEA     subqMessage,A1  ;move string for MOVE
00001328  103C 000E                399          MOVE.B  #14,D0        ;set for task to display null terminated 
0000132C                           400                                ;string with CR, LF
0000132C  4E4F                     401          TRAP    #15
0000132E                           402          
0000132E                           403          ;immediate data
0000132E                           404          
0000132E                           405          ;print '#'
0000132E  48E7 4000                406          MOVEM.L D1,-(SP) ;save D1 to the stack
00001332  123C 0023                407          MOVE.B #'#',D1 ;put ascii value of '#' in D1
00001336  103C 0006                408          MOVE.B #6,D0 ;move task 6 into D0
0000133A  4E4F                     409          TRAP #15 ;prin char
0000133C  4CDF 0002                410          MOVEM.L (SP)+,D1 ;pull D1 off the stack
00001340                           411          
00001340                           412          ;print number
00001340  48E7 4000                413          MOVEM.L D1,-(SP)
00001344  3401                     414          MOVE.W D1,D2 ;copy inst to d2
00001346  E04A                     415          LSR.W #8,D2 ;shift data section
00001348  E20A                     416          LSR.B #1,D2
0000134A  C43C 0007                417          AND.B #%00000111,D2 ;mask out rest of data
0000134E  6100 0034                418          BSR ZeroToEight ;handle zero
00001352  7200                     419          MOVEQ.L #0,D1 ;clear D1
00001354  1202                     420          MOVE.B D2,D1 ;move number to display into D1
00001356  103C 0003                421          MOVE.B #3,D0 ;move task 3 to D0
0000135A  4E4F                     422          TRAP #15
0000135C  4CDF 0002                423          MOVEM.L (SP)+,D1
00001360                           424          
00001360                           425          ;print separator
00001360                           426          
00001360                           427          ;Then do EA
00001360                           428          
00001360  3401                     429          MOVE.W  D1,D2 ;check mode
00001362  C43C 003F                430          AND.B   #%00111111,D2
00001366  1A02                     431          MOVE.B  D2,D5
00001368  48E7 4000                432          MOVEM.L D1,-(SP)
0000136C  6100 09AA                433          BSR     Get_Effective_Address
00001370  4CDF 0002                434          MOVEM.L (SP)+,D1
00001374                           435          
00001374  43F9 00002068            436          LEA     clearLine,A1  ;move string for a CR and LF
0000137A  103C 000E                437          MOVE.B  #14,D0        ;set for task to display null terminated 
0000137E                           438                                ;string without CR, LF
0000137E  4E4F                     439          TRAP    #15
00001380                           440  
00001380  7000                     441          MOVEQ.L #0,D0
00001382  4E75                     442          RTS
00001384                           443          
00001384                           444  ZeroToEight:
00001384                           445          
00001384  0C02 0000                446          CMPI.B #0,D2
00001388  6700 0004                447          BEQ toEight
0000138C                           448  ZeroToEightReturn:
0000138C                           449          
0000138C  4E75                     450          RTS
0000138E                           451  toEight:
0000138E                           452          
0000138E  5002                     453          ADDQ.B #8,D2
00001390  60FA                     454          BRA ZeroToEightReturn
00001392                           455  
00001392                           456      
00001392                           457  SUB:
00001392                           458          
00001392                           459  
00001392                           460          
00001392  7000                     461          MOVEQ.L #0, D0 ;clear D0
00001394                           462          
00001394                           463          ;Figure out if EA is source or destination
00001394  3401                     464          MOVE.W D1,D2 ;copy inst to D2
00001396  EC4A                     465          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
00001398  0202 0007                466          ANDI.B #%00000111,D2 ;mask out rest of byte
0000139C  0C02 0002                467          CMPI.B #2,D2 ;compare to 2
000013A0  6F00 0016                468          BLE validSubSourceEA ;2 or less is EA is source
000013A4                           469          
000013A4  0C02 0007                470          CMPI.B #%111,D2 ;compare to 7
000013A8  6700 FCC6                471          BEQ falsePositive ;thats not valid
000013AC  0C02 0003                472          CMPI.B #%11,D2 ;compare to 3
000013B0  6700 FCBE                473          BEQ falsePositive ;also not valid
000013B4  6000 002C                474          BRA validSubDestEA ;all thats left is valid EA as Dest 
000013B8                           475          
000013B8                           476  validSubSourceEA:
000013B8                           477          
000013B8  43F9 00001973            478          LEA moveSourceEAmasks,A1 ;load the list of masks
000013BE  D3C0                     479          ADDA.L D0,A1 ;displace to a specific mask
000013C0  1A11                     480          MOVE.B (A1),D5 ;move the mask to D5
000013C2                           481          
000013C2  0C05 0000                482          CMPI.B #0,D5 ;check if the mask is 0
000013C6  6700 FCA8                483          BEQ falsePositive ;branch if it is
000013CA                           484          
000013CA  1401                     485          MOVE.B D1,D2 ;copy instruction to D2
000013CC  C405                     486          AND.B D5,D2  ;mask D2
000013CE                           487          
000013CE  43F9 0000196A            488          LEA moveSourceEA,A1 ;load the list of valid modes
000013D4  D3C0                     489          ADDA.L D0,A1 ;displace to a specific mode
000013D6  1811                     490          MOVE.B (A1),D4 ;move mode to D4
000013D8  B404                     491          CMP.B D4,D2 ;compare mode to masked value
000013DA  6700 0036                492          BEQ  subSource ;if its match, its a valid mode and we can procede
000013DE                           493          
000013DE  5280                     494          ADDQ.L #1,D0 ;add one to displacement
000013E0  60D6                     495          BRA validSubSourceEA ;check for next mode
000013E2                           496          
000013E2                           497          
000013E2                           498  validSubDestEA:
000013E2                           499          
000013E2  43F9 0000153A            500          LEA addDestEAmasks,A1 ;load the list of masks
000013E8  D3C0                     501          ADDA.L D0,A1 ;displace to a specific mask
000013EA  1A11                     502          MOVE.B (A1),D5 ;move the mask to D5
000013EC                           503          
000013EC  0C05 0000                504          CMPI.B #0,D5 ;check if the mask is 0
000013F0  6700 FC7E                505          BEQ falsePositive ;branch if it is
000013F4                           506          
000013F4  3401                     507          MOVE.W D1,D2 ;copy instruction to D2
000013F6  EC4A                     508          LSR.W #6,D2  ;move mode
000013F8  6100 0A92                509          BSR switchModeAndReg ;switch register and mode
000013FC  C405                     510          AND.B D5,D2  ;mask D2
000013FE                           511          
000013FE  43F9 00001534            512          LEA addDestEA,A1 ;load the list of valid modes
00001404  D3C0                     513          ADDA.L D0,A1 ;displace to a specific mode
00001406  1811                     514          MOVE.B (A1),D4 ;move mode to D4
00001408  B404                     515          CMP.B D4,D2 ;compare mode to masked value
0000140A  6700 004E                516          BEQ subDest ;if its match, its a valid mode and we can procede
0000140E                           517          
0000140E  5280                     518          ADDQ.L #1,D0 ;add one to displacement
00001410  60D0                     519          BRA validSubDestEA ;check for next mode
00001412                           520          
00001412                           521  subSource
00001412                           522  
00001412  43F9 0000207B            523          LEA     subMessage,A1  ;move string for MOVE
00001418  103C 000E                524          MOVE.B  #14,D0        ;set for task to display null terminated 
0000141C                           525                                ;string with CR, LF
0000141C  4E4F                     526          TRAP    #15
0000141E                           527          
0000141E                           528          ;do EA
0000141E                           529          
0000141E  3401                     530          MOVE.W  D1,D2 ;check mode
00001420  C43C 003F                531          AND.B   #%00111111,D2
00001424  1A02                     532          MOVE.B  D2,D5
00001426  48E7 4000                533          MOVEM.L D1,-(SP)
0000142A  6100 08EC                534          BSR     Get_Effective_Address
0000142E  4CDF 0002                535          MOVEM.L (SP)+,D1
00001432                           536          
00001432                           537          ;print separator
00001432                           538          
00001432                           539          ;Then do Dn
00001432                           540          
00001432  3401                     541          MOVE.W  D1,D2
00001434  E04A                     542          LSR.W   #8,D2 ;move reg into first byte
00001436  E20A                     543          LSR.B   #1,D2 ;line it up to least sig bit
00001438  C43C 0007                544          AND.B   #%00000111,D2 ;force mode to Dn
0000143C  1A02                     545          MOVE.B  D2,D5
0000143E  48E7 4000                546          MOVEM.L D1,-(SP)
00001442  6100 08D4                547          BSR     Get_Effective_Address
00001446  4CDF 0002                548          MOVEM.L (SP)+,D1
0000144A                           549          
0000144A  43F9 00002068            550          LEA     clearLine,A1  ;move string for a CR and LF
00001450  103C 000E                551          MOVE.B  #14,D0        ;set for task to display null terminated 
00001454                           552                                ;string without CR, LF
00001454  4E4F                     553          TRAP    #15
00001456                           554  
00001456  7000                     555          MOVEQ.L #0,D0
00001458  4E75                     556          RTS
0000145A                           557  
0000145A                           558  subDest
0000145A                           559  
0000145A  43F9 0000207B            560          LEA     subMessage,A1  ;move string for MOVE
00001460  103C 000E                561          MOVE.B  #14,D0        ;set for task to display null terminated 
00001464                           562                                ;string with CR, LF
00001464  4E4F                     563          TRAP    #15
00001466                           564          
00001466                           565          ;Do Dn
00001466                           566          
00001466  3401                     567          MOVE.W  D1,D2
00001468  E04A                     568          LSR.W   #8,D2 ;move reg into first byte
0000146A  E20A                     569          LSR.B   #1,D2 ;line it up to least sig bit
0000146C  C43C 0007                570          AND.B   #%00000111,D2 ;force mode to Dn
00001470  1A02                     571          MOVE.B  D2,D5
00001472  48E7 4000                572          MOVEM.L D1,-(SP)
00001476  6100 08A0                573          BSR     Get_Effective_Address
0000147A  4CDF 0002                574          MOVEM.L (SP)+,D1
0000147E                           575          
0000147E                           576          
0000147E                           577          ;print separator
0000147E                           578          
0000147E                           579          ;Then do EA
0000147E                           580          
0000147E  3401                     581          MOVE.W  D1,D2 ;check mode
00001480  C43C 003F                582          AND.B   #%00111111,D2
00001484  1A02                     583          MOVE.B  D2,D5
00001486  48E7 4000                584          MOVEM.L D1,-(SP)
0000148A  6100 088C                585          BSR     Get_Effective_Address
0000148E  4CDF 0002                586          MOVEM.L (SP)+,D1
00001492                           587          
00001492                           588          
00001492  43F9 00002068            589          LEA     clearLine,A1  ;move string for a CR and LF
00001498  103C 000E                590          MOVE.B  #14,D0        ;set for task to display null terminated 
0000149C                           591                                ;string without CR, LF
0000149C  4E4F                     592          TRAP    #15
0000149E                           593  
0000149E  7000                     594          MOVEQ.L #0,D0
000014A0  4E75                     595          RTS
000014A2                           596  
000014A2                           597  
000014A2                           598  ADDA:
000014A2                           599          
000014A2                           600  
000014A2                           601          
000014A2  7000                     602          MOVEQ.L #0, D0 ;clear D0
000014A4                           603          
000014A4                           604          ;check opmode field
000014A4  3401                     605          MOVE.W D1,D2 ;copy inst to D2
000014A6  EC4A                     606          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
000014A8  0202 0007                607          ANDI.B #%00000111,D2 ;mask out rest of byte
000014AC  0C02 0007                608          CMPI.B #%111,D2 ;compare to 7
000014B0  6700 000E                609          BEQ validAdda ;thats valid
000014B4  0C02 0003                610          CMPI.B #%11,D2 ;compare to 3
000014B8  6700 0006                611          BEQ validAdda ;also valid
000014BC  6000 FBB2                612          BRA falsePositive ;all thats left is invalid 
000014C0                           613          
000014C0                           614  validAdda:
000014C0                           615          
000014C0  43F9 00001973            616          LEA moveSourceEAmasks,A1 ;load the list of masks
000014C6  D3C0                     617          ADDA.L D0,A1 ;displace to a specific mask
000014C8  1A11                     618          MOVE.B (A1),D5 ;move the mask to D5
000014CA                           619          
000014CA  0C05 0000                620          CMPI.B #0,D5 ;check if the mask is 0
000014CE  6700 FBA0                621          BEQ falsePositive ;branch if it is
000014D2                           622          
000014D2  1401                     623          MOVE.B D1,D2 ;copy instruction to D2
000014D4  C405                     624          AND.B D5,D2  ;mask D2
000014D6                           625          
000014D6  43F9 0000196A            626          LEA moveSourceEA,A1 ;load the list of valid modes
000014DC  D3C0                     627          ADDA.L D0,A1 ;displace to a specific mode
000014DE  1811                     628          MOVE.B (A1),D4 ;move mode to D4
000014E0  B404                     629          CMP.B D4,D2 ;compare mode to masked value
000014E2  6700 0006                630          BEQ  addaBody ;if its match, its a valid mode and we can procede
000014E6                           631          
000014E6  5280                     632          ADDQ.L #1,D0 ;add one to displacement
000014E8  60D6                     633          BRA validAdda ;check for next mode
000014EA                           634          
000014EA                           635          
000014EA                           636  addaBody
000014EA                           637  
000014EA  43F9 00002080            638          LEA     addaMessage,A1  ;move string for MOVE
000014F0  103C 000E                639          MOVE.B  #14,D0        ;set for task to display null terminated 
000014F4                           640                                ;string with CR, LF
000014F4  4E4F                     641          TRAP    #15
000014F6                           642          
000014F6                           643          ;do EA
000014F6                           644          
000014F6  3401                     645          MOVE.W  D1,D2 ;check mode
000014F8  C43C 003F                646          AND.B   #%00111111,D2
000014FC  1A02                     647          MOVE.B  D2,D5
000014FE  48E7 4000                648          MOVEM.L D1,-(SP)
00001502  6100 0814                649          BSR     Get_Effective_Address
00001506  4CDF 0002                650          MOVEM.L (SP)+,D1
0000150A                           651          
0000150A                           652          ;print separator
0000150A                           653          
0000150A                           654          ;Then do Dn
0000150A                           655          
0000150A  3401                     656          MOVE.W  D1,D2
0000150C  E04A                     657          LSR.W   #8,D2 ;move reg into first byte
0000150E  E20A                     658          LSR.B   #1,D2 ;line it up to least sig bit
00001510  C43C 0007                659          AND.B   #%00000111,D2 ;force mode to An
00001514  5002                     660          ADDI.B  #%00001000,D2 
00001516  1A02                     661          MOVE.B  D2,D5
00001518  48E7 4000                662          MOVEM.L D1,-(SP)
0000151C  6100 07FA                663          BSR     Get_Effective_Address
00001520  4CDF 0002                664          MOVEM.L (SP)+,D1
00001524                           665          
00001524  43F9 00002068            666          LEA     clearLine,A1  ;move string for a CR and LF
0000152A  103C 000E                667          MOVE.B  #14,D0        ;set for task to display null terminated 
0000152E                           668                                ;string without CR, LF
0000152E  4E4F                     669          TRAP    #15
00001530                           670  
00001530  7000                     671          MOVEQ.L #0,D0
00001532  4E75                     672          RTS
00001534                           673  
00001534                           674  
00001534                           675      
00001534= 10 18 20 38 39 00        676  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
0000153A= 38 38 38 3F 3F 00        677  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
00001540                           678  
00001540                           679  ADD:
00001540                           680          
00001540                           681  
00001540                           682          
00001540  7000                     683          MOVEQ.L #0, D0 ;clear D0
00001542                           684          
00001542                           685          ;Figure out if EA is source or destination
00001542  3401                     686          MOVE.W D1,D2 ;copy inst to D2
00001544  EC4A                     687          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
00001546  0202 0007                688          ANDI.B #%00000111,D2 ;mask out rest of byte
0000154A  0C02 0002                689          CMPI.B #2,D2 ;compare to 2
0000154E  6F00 0016                690          BLE validAddSourceEA ;2 or less is EA is source
00001552                           691          
00001552  0C02 0007                692          CMPI.B #%111,D2 ;compare to 7
00001556  6700 FB18                693          BEQ falsePositive ;thats not valid
0000155A  0C02 0003                694          CMPI.B #%11,D2 ;compare to 3
0000155E  6700 FB10                695          BEQ falsePositive ;also not valid
00001562  6000 002C                696          BRA validAddDestEA ;all thats left is valid EA as Dest 
00001566                           697          
00001566                           698  validAddSourceEA:
00001566                           699          
00001566  43F9 00001973            700          LEA moveSourceEAmasks,A1 ;load the list of masks
0000156C  D3C0                     701          ADDA.L D0,A1 ;displace to a specific mask
0000156E  1A11                     702          MOVE.B (A1),D5 ;move the mask to D5
00001570                           703          
00001570  0C05 0000                704          CMPI.B #0,D5 ;check if the mask is 0
00001574  6700 FAFA                705          BEQ falsePositive ;branch if it is
00001578                           706          
00001578  1401                     707          MOVE.B D1,D2 ;copy instruction to D2
0000157A  C405                     708          AND.B D5,D2  ;mask D2
0000157C                           709          
0000157C  43F9 0000196A            710          LEA moveSourceEA,A1 ;load the list of valid modes
00001582  D3C0                     711          ADDA.L D0,A1 ;displace to a specific mode
00001584  1811                     712          MOVE.B (A1),D4 ;move mode to D4
00001586  B404                     713          CMP.B D4,D2 ;compare mode to masked value
00001588  6700 0032                714          BEQ  addSource ;if its match, its a valid mode and we can procede
0000158C                           715          
0000158C  5280                     716          ADDQ.L #1,D0 ;add one to displacement
0000158E  60D6                     717          BRA validAddSourceEA ;check for next mode
00001590                           718          
00001590                           719          
00001590                           720  validAddDestEA:
00001590                           721          
00001590  43F8 153A                722          LEA addDestEAmasks,A1 ;load the list of masks
00001594  D3C0                     723          ADDA.L D0,A1 ;displace to a specific mask
00001596  1A11                     724          MOVE.B (A1),D5 ;move the mask to D5
00001598                           725          
00001598  0C05 0000                726          CMPI.B #0,D5 ;check if the mask is 0
0000159C  6700 FAD2                727          BEQ falsePositive ;branch if it is
000015A0                           728          
000015A0  3401                     729          MOVE.W D1,D2 ;copy instruction to D2
000015A2  EC4A                     730          LSR.W #6,D2  ;move mode
000015A4  6100 08E6                731          BSR switchModeAndReg ;switch register and mode
000015A8  C405                     732          AND.B D5,D2  ;mask D2
000015AA                           733          
000015AA  43F8 1534                734          LEA addDestEA,A1 ;load the list of valid modes
000015AE  D3C0                     735          ADDA.L D0,A1 ;displace to a specific mode
000015B0  1811                     736          MOVE.B (A1),D4 ;move mode to D4
000015B2  B404                     737          CMP.B D4,D2 ;compare mode to masked value
000015B4  6700 004E                738          BEQ addDest ;if its match, its a valid mode and we can procede
000015B8                           739          
000015B8  5280                     740          ADDQ.L #1,D0 ;add one to displacement
000015BA  60D4                     741          BRA validAddDestEA ;check for next mode
000015BC                           742          
000015BC                           743  addSource
000015BC                           744  
000015BC  43F9 00002086            745          LEA     addMessage,A1  ;move string for MOVE
000015C2  103C 000E                746          MOVE.B  #14,D0        ;set for task to display null terminated 
000015C6                           747                                ;string with CR, LF
000015C6  4E4F                     748          TRAP    #15
000015C8                           749          
000015C8                           750          ;do EA
000015C8                           751          
000015C8  3401                     752          MOVE.W  D1,D2 ;check mode
000015CA  C43C 003F                753          AND.B   #%00111111,D2
000015CE  1A02                     754          MOVE.B  D2,D5
000015D0  48E7 4000                755          MOVEM.L D1,-(SP)
000015D4  6100 0742                756          BSR     Get_Effective_Address
000015D8  4CDF 0002                757          MOVEM.L (SP)+,D1
000015DC                           758          
000015DC                           759          ;print separator
000015DC                           760          
000015DC                           761          ;Then do Dn
000015DC                           762          
000015DC  3401                     763          MOVE.W  D1,D2
000015DE  E04A                     764          LSR.W   #8,D2 ;move reg into first byte
000015E0  E20A                     765          LSR.B   #1,D2 ;line it up to least sig bit
000015E2  C43C 0007                766          AND.B   #%00000111,D2 ;force mode to Dn
000015E6  1A02                     767          MOVE.B  D2,D5
000015E8  48E7 4000                768          MOVEM.L D1,-(SP)
000015EC  6100 072A                769          BSR     Get_Effective_Address
000015F0  4CDF 0002                770          MOVEM.L (SP)+,D1
000015F4                           771          
000015F4  43F9 00002068            772          LEA     clearLine,A1  ;move string for a CR and LF
000015FA  103C 000E                773          MOVE.B  #14,D0        ;set for task to display null terminated 
000015FE                           774                                ;string without CR, LF
000015FE  4E4F                     775          TRAP    #15
00001600                           776  
00001600  7000                     777          MOVEQ.L #0,D0
00001602  4E75                     778          RTS
00001604                           779  
00001604                           780  addDest
00001604                           781  
00001604  43F9 00002086            782          LEA     addMessage,A1  ;move string for MOVE
0000160A  103C 000E                783          MOVE.B  #14,D0        ;set for task to display null terminated 
0000160E                           784                                ;string with CR, LF
0000160E  4E4F                     785          TRAP    #15
00001610                           786          
00001610                           787          ;Do Dn
00001610                           788          
00001610  3401                     789          MOVE.W  D1,D2
00001612  E04A                     790          LSR.W   #8,D2 ;move reg into first byte
00001614  E20A                     791          LSR.B   #1,D2 ;line it up to least sig bit
00001616  C43C 0007                792          AND.B   #%00000111,D2 ;force mode to Dn
0000161A  1A02                     793          MOVE.B  D2,D5
0000161C  48E7 4000                794          MOVEM.L D1,-(SP)
00001620  6100 06F6                795          BSR     Get_Effective_Address
00001624  4CDF 0002                796          MOVEM.L (SP)+,D1
00001628                           797          
00001628                           798          
00001628                           799          ;print separator
00001628                           800          
00001628                           801          ;Then do EA
00001628                           802          
00001628  3401                     803          MOVE.W  D1,D2 ;check mode
0000162A  C43C 003F                804          AND.B   #%00111111,D2
0000162E  1A02                     805          MOVE.B  D2,D5
00001630  48E7 4000                806          MOVEM.L D1,-(SP)
00001634  6100 06E2                807          BSR     Get_Effective_Address
00001638  4CDF 0002                808          MOVEM.L (SP)+,D1
0000163C                           809          
0000163C                           810          
0000163C  43F9 00002068            811          LEA     clearLine,A1  ;move string for a CR and LF
00001642  103C 000E                812          MOVE.B  #14,D0        ;set for task to display null terminated 
00001646                           813                                ;string without CR, LF
00001646  4E4F                     814          TRAP    #15
00001648                           815  
00001648  7000                     816          MOVEQ.L #0,D0
0000164A  4E75                     817          RTS
0000164C                           818  
0000164C                           819  
0000164C= 10 20 38 39 00           820  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
00001651= 38 38 3F 3F 00           821  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
00001656                           822  
00001656= 10 18 38 39 00           823  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
0000165B= 38 38 3F 3F 00           824  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
00001660                           825  
00001660                           826  MOVEM:
00001660                           827          
00001660                           828  
00001660                           829          
00001660  7000                     830          MOVEQ.L #0, D0 ;clear D0
00001662                           831          
00001662                           832          ;Figure out which direction we are going
00001662  3401                     833          MOVE.W D1,D2 ;copy inst to D2
00001664  E64A                     834          LSR.W #3,D2 ;shift direction bit into most sig bit of first byte
00001666  0202 0080                835          ANDI.B #%10000000,D2 ;mask out everything but direction bit in first byte
0000166A  0C02 0000                836          CMPI.B #0,D2 ;compare bit to zero
0000166E  6700 0006                837          BEQ validRegToMem ;if zero, reg to mem
00001672  6000 0028                838          BRA validMemToReg ;else, its mem to reg
00001676                           839          
00001676                           840  validRegToMem:
00001676                           841          
00001676  43F8 1651                842          LEA movemRegToMemEAmasks,A1 ;load the list of masks
0000167A  D3C0                     843          ADDA.L D0,A1 ;displace to a specific mask
0000167C  1A11                     844          MOVE.B (A1),D5 ;move the mask to D5
0000167E                           845          
0000167E  0C05 0000                846          CMPI.B #0,D5 ;check if the mask is 0
00001682  6700 F9EC                847          BEQ falsePositive ;branch if it is
00001686                           848          
00001686  1401                     849          MOVE.B D1,D2 ;copy instruction to D2
00001688  C405                     850          AND.B D5,D2  ;mask D2
0000168A                           851          
0000168A  43F8 164C                852          LEA movemRegToMemEA,A1 ;load the list of valid modes
0000168E  D3C0                     853          ADDA.L D0,A1 ;displace to a specific mode
00001690  1811                     854          MOVE.B (A1),D4 ;move mode to D4
00001692  B404                     855          CMP.B D4,D2 ;compare mode to masked value
00001694  6700 0034                856          BEQ  movemBody ;if its match, its a valid mode and we can procede
00001698                           857          
00001698  5280                     858          ADDQ.L #1,D0 ;add one to displacement
0000169A  60DA                     859          BRA validRegToMem ;check for next mode
0000169C                           860          
0000169C                           861          
0000169C                           862  validMemToReg:
0000169C                           863          
0000169C  43F8 165B                864          LEA movemMemToRegEAmasks,A1 ;load the list of masks
000016A0  D3C0                     865          ADDA.L D0,A1 ;displace to a specific mask
000016A2  1A11                     866          MOVE.B (A1),D5 ;move the mask to D5
000016A4                           867          
000016A4  0C05 0000                868          CMPI.B #0,D5 ;check if the mask is 0
000016A8  6700 F9C6                869          BEQ falsePositive ;branch if it is
000016AC                           870          
000016AC  3401                     871          MOVE.W D1,D2 ;copy instruction to D2
000016AE  EC4A                     872          LSR.W #6,D2  ;move mode
000016B0  6100 07DA                873          BSR switchModeAndReg ;switch register and mode
000016B4  C405                     874          AND.B D5,D2  ;mask D2
000016B6                           875          
000016B6  43F8 1656                876          LEA movemMemToRegEA,A1 ;load the list of valid modes
000016BA  D3C0                     877          ADDA.L D0,A1 ;displace to a specific mode
000016BC  1811                     878          MOVE.B (A1),D4 ;move mode to D4
000016BE  B404                     879          CMP.B D4,D2 ;compare mode to masked value
000016C0  6700 0008                880          BEQ movemBody ;if its match, its a valid mode and we can procede
000016C4                           881          
000016C4  5280                     882          ADDQ.L #1,D0 ;add one to displacement
000016C6  6000 02EC                883          BRA validMoveDestModes ;check for next mode
000016CA                           884          
000016CA                           885  movemBody
000016CA                           886  
000016CA  43F9 0000208B            887          LEA     movemMessage,A1  ;move string for MOVE
000016D0  103C 000E                888          MOVE.B  #14,D0        ;set for task to display null terminated 
000016D4                           889                                ;string with CR, LF
000016D4  4E4F                     890          TRAP    #15
000016D6                           891          
000016D6                           892          ;show list
000016D6                           893          
000016D6  5487                     894          ADDQ.L #word,D7 ;read past the register list mask(word) following
000016D8                           895                          ;the instruction
000016D8                           896          
000016D8                           897          ;print separator
000016D8                           898          
000016D8  3401                     899          MOVE.W  D1,D2 ;check mode
000016DA  C43C 003F                900          AND.B   #%00111111,D2
000016DE  1A02                     901          MOVE.B  D2,D5
000016E0  48E7 4000                902          MOVEM.L D1,-(SP)
000016E4  6100 0632                903          BSR     Get_Effective_Address
000016E8  4CDF 0002                904          MOVEM.L (SP)+,D1
000016EC                           905          
000016EC                           906          
000016EC  43F9 00002068            907          LEA     clearLine,A1  ;move string for a CR and LF
000016F2  103C 000E                908          MOVE.B  #14,D0        ;set for task to display null terminated 
000016F6                           909                                ;string without CR, LF
000016F6  4E4F                     910          TRAP    #15
000016F8                           911  
000016F8  7000                     912          MOVEQ.L #0,D0
000016FA  4E75                     913          RTS
000016FC                           914  
000016FC                           915  
000016FC                           916      
000016FC= 00 10 18 20 28 38 ...    917  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
00001704= 38 38 38 38 38 3F ...    918  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
0000170C                           919     
0000170C                           920  NEG:            
0000170C                           921       
0000170C  7000                     922          MOVEQ.L #0, D0 ;clear D0
0000170E                           923          
0000170E                           924  validNegModes:
0000170E                           925          
0000170E  43F8 1704                926          LEA NegEAmasks,A1 ;load the list of masks
00001712  D3C0                     927          ADDA.L D0,A1 ;displace to a specific mask
00001714  1A11                     928          MOVE.B (A1),D5 ;move the mask to D5
00001716                           929          
00001716  0C05 0000                930          CMPI.B #0,D5 ;check if the mask is 0
0000171A  6700 F954                931          BEQ falsePositive ;branch if it is
0000171E                           932          
0000171E  1401                     933          MOVE.B D1,D2 ;copy instruction to D2
00001720  C405                     934          AND.B D5,D2  ;mask D2
00001722  43F8 16FC                935          LEA NegEA,A1 ;load the list of valid modes
00001726  D3C0                     936          ADDA.L D0,A1 ;displace to a specific mode
00001728  1811                     937          MOVE.B (A1),D4 ;move mode to D4
0000172A  B404                     938          CMP.B D4,D2 ;compare mode to masked value
0000172C  6700 0006                939          BEQ NegBody ;if its match, its a valid mode and we can procede
00001730                           940          
00001730  5280                     941          ADDQ.L #1,D0 ;add one to displacement
00001732  60DA                     942          BRA validNegModes ;check for next mode
00001734                           943          
00001734                           944  NegBody:
00001734                           945  
00001734                           946  
00001734  3401                     947          MOVE.W  D1,D2 ;copy inst to D2
00001736  C47C 0600                948          AND.W  #%0011000000000,D2 ;mask word for size
0000173A  0C42 0000                949          CMPI.W #0,D2 ;0 is the only non valid size
0000173E  6700 F930                950          BEQ falsePositive ; zero is not valid
00001742                           951  
00001742  43F9 000020BA            952          LEA     negMessage,A1  ;move string for NEG info
00001748  103C 000E                953          MOVE.B  #14,D0        ;set for task to display null terminated 
0000174C                           954                                ;string without CR, LF
0000174C  4E4F                     955          TRAP    #15
0000174E                           956          
0000174E  3401                     957          MOVE.W D1,D2
00001750  C47C 003F                958          AND #%000000000111111,D2
00001754  1A02                     959          MOVE.B D2,D5
00001756                           960          
00001756  48E7 4000                961          MOVEM.L D1,-(SP)
0000175A  6100 05BC                962          BSR     Get_Effective_Address
0000175E  4CDF 0002                963          MOVEM.L (SP)+,D1
00001762                           964          
00001762                           965                
00001762                           966          
00001762                           967  NEGdone:
00001762                           968  
00001762  43F9 00002068            969          LEA     clearLine,A1  ;move string for a CR and LF
00001768  103C 000E                970          MOVE.B  #14,D0        ;set for task to display null terminated 
0000176C                           971                                ;string without CR, LF
0000176C  4E4F                     972          TRAP    #15
0000176E  7000                     973          MOVEQ.L #0,D0
00001770  4E75                     974          RTS
00001772                           975          
00001772                           976   ADDI:            
00001772                           977       
00001772  7000                     978          MOVEQ.L #0, D0 ;clear D0
00001774                           979          
00001774                           980  validAddiModes:
00001774                           981          
00001774                           982          
00001774  43F9 0000186D            983          LEA cmpiEAmasks,A1 ;load the list of masks
0000177A  D3C0                     984          ADDA.L D0,A1 ;displace to a specific mask
0000177C  1A11                     985          MOVE.B (A1),D5 ;move the mask to D5
0000177E                           986          
0000177E  0C05 0000                987          CMPI.B #0,D5 ;check if the mask is 0
00001782  6700 F8EC                988          BEQ falsePositive ;branch if it is
00001786                           989          
00001786  1401                     990          MOVE.B D1,D2 ;copy instruction to D2
00001788  C405                     991          AND.B D5,D2  ;mask D2
0000178A  43F9 00001866            992          LEA cmpiEA,A1 ;load the list of valid modes
00001790  D3C0                     993          ADDA.L D0,A1 ;displace to a specific mode
00001792  1811                     994          MOVE.B (A1),D4 ;move mode to D4
00001794  B404                     995          CMP.B D4,D2 ;compare mode to masked value
00001796  6700 0006                996          BEQ addiBody ;if its match, its a valid mode and we can procede
0000179A                           997          
0000179A  5280                     998          ADDQ.L #1,D0 ;add one to displacement
0000179C  60D6                     999          BRA validAddiModes ;check for next mode
0000179E                          1000          
0000179E                          1001  addiBody:
0000179E                          1002  
0000179E                          1003  
0000179E  3401                    1004          MOVE.W  D1,D2 ;copy inst to D2
000017A0  C47C 00C0               1005          AND.W  #%0000000011000000,D2 ;mask word for size
000017A4  0C42 00C0               1006          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
000017A8  6700 F8C6               1007          BEQ falsePositive
000017AC                          1008  
000017AC  43F9 00002092           1009          LEA     addiMessage,A1  ;move string for NEG info
000017B2  103C 000E               1010          MOVE.B  #14,D0        ;set for task to display null terminated 
000017B6                          1011                                ;string without CR, LF
000017B6  4E4F                    1012          TRAP    #15
000017B8                          1013          
000017B8                          1014          ;go to Effective_Address for immediate data
000017B8  143C 003C               1015          MOVE.B #%00111100,D2
000017BC  48E7 4000               1016          MOVEM.L D1,-(SP)
000017C0  6100 0556               1017          BSR     Get_Effective_Address
000017C4  4CDF 0002               1018          MOVEM.L (SP)+,D1
000017C8                          1019          
000017C8  3401                    1020          MOVE.W D1,D2 ;copy inst to D2
000017CA  C47C 003F               1021          AND #%000000000111111,D2 ;and out everything but modes and regs
000017CE  1A02                    1022          MOVE.B D2,D5 ; copy to D5 for following BSR
000017D0                          1023          
000017D0  48E7 4000               1024          MOVEM.L D1,-(SP)
000017D4  6100 0542               1025          BSR     Get_Effective_Address
000017D8  4CDF 0002               1026          MOVEM.L (SP)+,D1
000017DC                          1027          
000017DC                          1028                
000017DC                          1029          
000017DC                          1030  addidone:
000017DC                          1031  
000017DC  43F9 00002068           1032          LEA     clearLine,A1  ;move string for a CR and LF
000017E2  103C 000E               1033          MOVE.B  #14,D0        ;set for task to display null terminated 
000017E6                          1034                                ;string without CR, LF
000017E6  4E4F                    1035          TRAP    #15
000017E8  7000                    1036          MOVEQ.L #0,D0
000017EA  4E75                    1037          RTS
000017EC                          1038    
000017EC                          1039  ORI:            
000017EC                          1040       
000017EC  7000                    1041          MOVEQ.L #0, D0 ;clear D0
000017EE                          1042          
000017EE                          1043  validOriModes:
000017EE                          1044          
000017EE                          1045          
000017EE  43F9 0000186D           1046          LEA cmpiEAmasks,A1 ;load the list of masks
000017F4  D3C0                    1047          ADDA.L D0,A1 ;displace to a specific mask
000017F6  1A11                    1048          MOVE.B (A1),D5 ;move the mask to D5
000017F8                          1049          
000017F8  0C05 0000               1050          CMPI.B #0,D5 ;check if the mask is 0
000017FC  6700 F872               1051          BEQ falsePositive ;branch if it is
00001800                          1052          
00001800  1401                    1053          MOVE.B D1,D2 ;copy instruction to D2
00001802  C405                    1054          AND.B D5,D2  ;mask D2
00001804  43F9 00001866           1055          LEA cmpiEA,A1 ;load the list of valid modes
0000180A  D3C0                    1056          ADDA.L D0,A1 ;displace to a specific mode
0000180C  1811                    1057          MOVE.B (A1),D4 ;move mode to D4
0000180E  B404                    1058          CMP.B D4,D2 ;compare mode to masked value
00001810  6700 0006               1059          BEQ oriBody ;if its match, its a valid mode and we can procede
00001814                          1060          
00001814  5280                    1061          ADDQ.L #1,D0 ;add one to displacement
00001816  60D6                    1062          BRA validOriModes ;check for next mode
00001818                          1063          
00001818                          1064  oriBody:
00001818                          1065  
00001818                          1066  
00001818  3401                    1067          MOVE.W  D1,D2 ;copy inst to D2
0000181A  C47C 00C0               1068          AND.W  #%0000000011000000,D2 ;mask word for size
0000181E  0C42 00C0               1069          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001822  6700 F84C               1070          BEQ falsePositive
00001826                          1071  
00001826  43F9 00002098           1072          LEA     oriMessage,A1  ;move string for NEG info
0000182C  103C 000E               1073          MOVE.B  #14,D0        ;set for task to display null terminated 
00001830                          1074                                ;string without CR, LF
00001830  4E4F                    1075          TRAP    #15
00001832                          1076          
00001832                          1077          ;go to Effective_Address for immediate data
00001832  143C 003C               1078          MOVE.B #%00111100,D2
00001836  48E7 4000               1079          MOVEM.L D1,-(SP)
0000183A  6100 04DC               1080          BSR     Get_Effective_Address
0000183E  4CDF 0002               1081          MOVEM.L (SP)+,D1
00001842                          1082          
00001842  3401                    1083          MOVE.W D1,D2 ;copy inst to D2
00001844  C47C 003F               1084          AND #%000000000111111,D2 ;and out everything but modes and regs
00001848  1A02                    1085          MOVE.B D2,D5 ; copy to D5 for following BSR
0000184A                          1086          
0000184A  48E7 4000               1087          MOVEM.L D1,-(SP)
0000184E  6100 04C8               1088          BSR     Get_Effective_Address
00001852  4CDF 0002               1089          MOVEM.L (SP)+,D1
00001856                          1090          
00001856                          1091                
00001856                          1092          
00001856                          1093  oridone:
00001856                          1094  
00001856  43F9 00002068           1095          LEA     clearLine,A1  ;move string for a CR and LF
0000185C  103C 000E               1096          MOVE.B  #14,D0        ;set for task to display null terminated 
00001860                          1097                                ;string without CR, LF
00001860  4E4F                    1098          TRAP    #15
00001862  7000                    1099          MOVEQ.L #0,D0
00001864  4E75                    1100          RTS
00001866                          1101  
00001866                          1102          
00001866                          1103          
00001866= 20 18 00 10 38 39 00    1104  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
0000186D= 38 38 38 38 3F 3F 00    1105  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
00001874                          1106     
00001874                          1107  CMPI:            
00001874                          1108       
00001874  7000                    1109          MOVEQ.L #0, D0 ;clear D0
00001876                          1110          
00001876                          1111  validCmpiModes:
00001876                          1112          
00001876                          1113          
00001876  43F8 186D               1114          LEA cmpiEAmasks,A1 ;load the list of masks
0000187A  D3C0                    1115          ADDA.L D0,A1 ;displace to a specific mask
0000187C  1A11                    1116          MOVE.B (A1),D5 ;move the mask to D5
0000187E                          1117          
0000187E  0C05 0000               1118          CMPI.B #0,D5 ;check if the mask is 0
00001882  6700 F7EC               1119          BEQ falsePositive ;branch if it is
00001886                          1120          
00001886  1401                    1121          MOVE.B D1,D2 ;copy instruction to D2
00001888  C405                    1122          AND.B D5,D2  ;mask D2
0000188A  43F8 1866               1123          LEA cmpiEA,A1 ;load the list of valid modes
0000188E  D3C0                    1124          ADDA.L D0,A1 ;displace to a specific mode
00001890  1811                    1125          MOVE.B (A1),D4 ;move mode to D4
00001892  B404                    1126          CMP.B D4,D2 ;compare mode to masked value
00001894  6700 0006               1127          BEQ CMPIBody ;if its match, its a valid mode and we can procede
00001898                          1128          
00001898  5280                    1129          ADDQ.L #1,D0 ;add one to displacement
0000189A  60DA                    1130          BRA validCmpiModes ;check for next mode
0000189C                          1131          
0000189C                          1132  CMPIBody:
0000189C                          1133  
0000189C                          1134  
0000189C  3401                    1135          MOVE.W  D1,D2 ;copy inst to D2
0000189E  C47C 00C0               1136          AND.W  #%0000000011000000,D2 ;mask word for size
000018A2  0C42 00C0               1137          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
000018A6  6700 F7C8               1138          BEQ falsePositive
000018AA                          1139  
000018AA  43F9 0000209D           1140          LEA     cmpiMessage,A1  ;move string for NEG info
000018B0  103C 000E               1141          MOVE.B  #14,D0        ;set for task to display null terminated 
000018B4                          1142                                ;string without CR, LF
000018B4  4E4F                    1143          TRAP    #15
000018B6                          1144          
000018B6                          1145          ;go to Effective_Address for immediate data
000018B6  143C 003C               1146          MOVE.B #%00111100,D2
000018BA  48E7 4000               1147          MOVEM.L D1,-(SP)
000018BE  6100 0458               1148          BSR     Get_Effective_Address
000018C2  4CDF 0002               1149          MOVEM.L (SP)+,D1
000018C6                          1150          
000018C6  3401                    1151          MOVE.W D1,D2 ;copy inst to D2
000018C8  C47C 003F               1152          AND #%000000000111111,D2 ;and out everything but modes and regs
000018CC  1A02                    1153          MOVE.B D2,D5 ; copy to D5 for following BSR
000018CE                          1154          
000018CE  48E7 4000               1155          MOVEM.L D1,-(SP)
000018D2  6100 0444               1156          BSR     Get_Effective_Address
000018D6  4CDF 0002               1157          MOVEM.L (SP)+,D1
000018DA                          1158          
000018DA                          1159                
000018DA                          1160          
000018DA                          1161  CMPidone:
000018DA                          1162  
000018DA  43F9 00002068           1163          LEA     clearLine,A1  ;move string for a CR and LF
000018E0  103C 000E               1164          MOVE.B  #14,D0        ;set for task to display null terminated 
000018E4                          1165                                ;string without CR, LF
000018E4  4E4F                    1166          TRAP    #15
000018E6  7000                    1167          MOVEQ.L #0,D0
000018E8  4E75                    1168          RTS
000018EA                          1169  
000018EA                          1170          
000018EA= 10 38 39 00             1171  JsrEA        DC.B %010000, %111000, %111001,0
000018EE= 38 3F 3F 00             1172  JsrEAmasks   DC.B %111000, %111111, %111111,0
000018F2                          1173     
000018F2                          1174  JSR:            
000018F2                          1175       
000018F2  7000                    1176          MOVEQ.L #0, D0 ;clear D0
000018F4                          1177          
000018F4                          1178  validJsrModes:
000018F4                          1179          
000018F4  43F8 18EE               1180          LEA JsrEAmasks,A1 ;load the list of masks
000018F8  D3C0                    1181          ADDA.L D0,A1 ;displace to a specific mask
000018FA  1A11                    1182          MOVE.B (A1),D5 ;move the mask to D5
000018FC                          1183          
000018FC  0C05 0000               1184          CMPI.B #0,D5 ;check if the mask is 0
00001900  6700 F76E               1185          BEQ falsePositive ;branch if it is
00001904                          1186          
00001904  1401                    1187          MOVE.B D1,D2 ;copy instruction to D2
00001906  C405                    1188          AND.B D5,D2  ;mask D2
00001908  43F8 18EA               1189          LEA JsrEA,A1 ;load the list of valid modes
0000190C  D3C0                    1190          ADDA.L D0,A1 ;displace to a specific mode
0000190E  1811                    1191          MOVE.B (A1),D4 ;move mode to D4
00001910  B404                    1192          CMP.B D4,D2 ;compare mode to masked value
00001912  6700 0006               1193          BEQ JsrBody ;if its match, its a valid mode and we can procede
00001916                          1194          
00001916  5280                    1195          ADDQ.L #1,D0 ;add one to displacement
00001918  60DA                    1196          BRA validJsrModes ;check for next mode
0000191A                          1197          
0000191A                          1198  JsrBody:
0000191A                          1199  
0000191A                          1200  
0000191A  43F9 000020A3           1201          LEA     jsrMessage,A1  ;move string for NEG info
00001920  103C 000E               1202          MOVE.B  #14,D0        ;set for task to display null terminated 
00001924                          1203                                ;string without CR, LF
00001924  4E4F                    1204          TRAP    #15
00001926                          1205          
00001926  3401                    1206          MOVE.W D1,D2 ;copy inst to D2
00001928  C47C 003F               1207          AND #%000000000111111,D2 ;and out everything but modes and regs
0000192C  1A02                    1208          MOVE.B D2,D5 ; copy to D5 for following BSR
0000192E                          1209          
0000192E  48E7 4000               1210          MOVEM.L D1,-(SP)
00001932  6100 03E4               1211          BSR     Get_Effective_Address
00001936  4CDF 0002               1212          MOVEM.L (SP)+,D1
0000193A                          1213          
0000193A                          1214                
0000193A                          1215          
0000193A                          1216  Jsrdone:
0000193A                          1217  
0000193A  43F9 00002068           1218          LEA     clearLine,A1  ;move string for a CR and LF
00001940  103C 000E               1219          MOVE.B  #14,D0        ;set for task to display null terminated 
00001944                          1220                                ;string without CR, LF
00001944  4E4F                    1221          TRAP    #15
00001946  7000                    1222          MOVEQ.L #0,D0
00001948  4E75                    1223          RTS
0000194A                          1224  
0000194A                          1225  
0000194A                          1226          
0000194A                          1227  NOP:
0000194A                          1228  
0000194A  43F9 000020AD           1229          LEA     nopMessage,A1 ;move string for NOP info
00001950  103C 000D               1230          MOVE.B  #13,D0        ;set for task to display null terminated 
00001954                          1231                                ;string with CR, LF
00001954  4E4F                    1232          TRAP    #15
00001956                          1233          
00001956  7000                    1234          MOVEQ.L #0,D0
00001958  4E75                    1235          RTS
0000195A                          1236          
0000195A                          1237  RTS:
0000195A                          1238          
0000195A  43F9 000020A8           1239          LEA     rtsMessage,A1  ;move string for rts info
00001960  103C 000D               1240          MOVE.B  #13,D0        ;set for task to display null terminated 
00001964                          1241                                ;string with CR, LF
00001964  4E4F                    1242          TRAP    #15  
00001966                          1243     
00001966  7000                    1244          MOVEQ.L #0,D0
00001968  4E75                    1245          RTS   
0000196A                          1246  
0000196A= 3C 08 00 10 18 20 ...   1247  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
00001973= 3F 38 38 38 38 38 ...   1248  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
0000197C                          1249  
0000197C= 00 10 18 20 38 39 00    1250  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
00001983= 38 38 38 38 3F 3F 00    1251  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
0000198A                          1252  
0000198A                          1253  MOVE:
0000198A                          1254          
0000198A                          1255  
0000198A                          1256          
0000198A  7000                    1257          MOVEQ.L #0, D0 ;clear D0
0000198C                          1258          
0000198C                          1259  validMoveSourceModes:
0000198C                          1260          
0000198C  43F8 1973               1261          LEA moveSourceEAmasks,A1 ;load the list of masks
00001990  D3C0                    1262          ADDA.L D0,A1 ;displace to a specific mask
00001992  1A11                    1263          MOVE.B (A1),D5 ;move the mask to D5
00001994                          1264          
00001994  0C05 0000               1265          CMPI.B #0,D5 ;check if the mask is 0
00001998  6700 F6D6               1266          BEQ falsePositive ;branch if it is
0000199C                          1267          
0000199C  1401                    1268          MOVE.B D1,D2 ;copy instruction to D2
0000199E  C405                    1269          AND.B D5,D2  ;mask D2
000019A0                          1270          
000019A0  43F8 196A               1271          LEA moveSourceEA,A1 ;load the list of valid modes
000019A4  D3C0                    1272          ADDA.L D0,A1 ;displace to a specific mode
000019A6  1811                    1273          MOVE.B (A1),D4 ;move mode to D4
000019A8  B404                    1274          CMP.B D4,D2 ;compare mode to masked value
000019AA  6700 0006               1275          BEQ  checkMoveDest ;if its match, its a valid mode and we can procede
000019AE                          1276          
000019AE  5280                    1277          ADDQ.L #1,D0 ;add one to displacement
000019B0  60DA                    1278          BRA validMoveSourceModes ;check for next mode
000019B2                          1279          
000019B2                          1280  checkMoveDest:
000019B2  7000                    1281          MOVEQ.L #0, D0 ;clear D0
000019B4                          1282          
000019B4                          1283  validMoveDestModes:
000019B4                          1284          
000019B4  43F8 1983               1285          LEA moveDestEAmasks,A1 ;load the list of masks
000019B8  D3C0                    1286          ADDA.L D0,A1 ;displace to a specific mask
000019BA  1A11                    1287          MOVE.B (A1),D5 ;move the mask to D5
000019BC                          1288          
000019BC  0C05 0000               1289          CMPI.B #0,D5 ;check if the mask is 0
000019C0  6700 F6AE               1290          BEQ falsePositive ;branch if it is
000019C4                          1291          
000019C4  3401                    1292          MOVE.W D1,D2 ;copy instruction to D2
000019C6  EC4A                    1293          LSR.W #6,D2  ;move mode
000019C8  6100 04C2               1294          BSR switchModeAndReg ;switch register and mode
000019CC  C405                    1295          AND.B D5,D2  ;mask D2
000019CE                          1296          
000019CE  43F8 197C               1297          LEA moveDestEA,A1 ;load the list of valid modes
000019D2  D3C0                    1298          ADDA.L D0,A1 ;displace to a specific mode
000019D4  1811                    1299          MOVE.B (A1),D4 ;move mode to D4
000019D6  B404                    1300          CMP.B D4,D2 ;compare mode to masked value
000019D8  6700 0006               1301          BEQ moveBody ;if its match, its a valid mode and we can procede
000019DC                          1302          
000019DC  5280                    1303          ADDQ.L #1,D0 ;add one to displacement
000019DE  60D4                    1304          BRA validMoveDestModes ;check for next mode
000019E0                          1305          
000019E0                          1306  moveBody
000019E0  3401                    1307          MOVE.W  D1,D2 ;copy inst to D2
000019E2  C47C 3000               1308          AND.W  #%0011000000000000,D2 ;mask word for size
000019E6  0C42 0000               1309          CMPI.W #0,D2 ;0 is the only non valid size
000019EA  6700 F684               1310          BEQ falsePositive ; if zero, this is not move
000019EE                          1311  
000019EE  43F9 000020B2           1312          LEA     moveMessage,A1  ;move string for MOVE
000019F4  103C 000E               1313          MOVE.B  #14,D0        ;set for task to display null terminated 
000019F8                          1314                                ;string with CR, LF
000019F8  4E4F                    1315          TRAP    #15
000019FA                          1316          
000019FA                          1317          
000019FA  3401                    1318          MOVE.W  D1,D2 ;check source mode
000019FC  C43C 003F               1319          AND.B   #%00111111,D2
00001A00  1A02                    1320          MOVE.B  D2,D5
00001A02  48E7 4000               1321          MOVEM.L D1,-(SP)
00001A06  6100 0310               1322          BSR     Get_Effective_Address
00001A0A  4CDF 0002               1323          MOVEM.L (SP)+,D1
00001A0E                          1324          
00001A0E                          1325          ;print separator
00001A0E                          1326          
00001A0E  3401                    1327          MOVE.W  D1,D2 ;check dest mode
00001A10  EC4A                    1328          LSR.W   #6,D2
00001A12  6100 0478               1329          BSR  switchModeAndReg
00001A16  C43C 003F               1330          AND.B   #%00111111,D2
00001A1A  1A02                    1331          MOVE.B  D2,D5
00001A1C  48E7 4000               1332          MOVEM.L D1,-(SP)
00001A20  6100 02F6               1333          BSR     Get_Effective_Address
00001A24  4CDF 0002               1334          MOVEM.L (SP)+,D1
00001A28                          1335          
00001A28                          1336          
00001A28                          1337          
00001A28  43F9 00002068           1338          LEA     clearLine,A1  ;move string for a CR and LF
00001A2E  103C 000E               1339          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A32                          1340                                ;string without CR, LF
00001A32  4E4F                    1341          TRAP    #15
00001A34                          1342  
00001A34  7000                    1343          MOVEQ.L #0,D0
00001A36  4E75                    1344          RTS
00001A38                          1345          
00001A38= 08 00                   1346  moveADestEA        DC.B %001000,0
00001A3A= 38 00                   1347  moveADestEAmasks   DC.B %111000,0
00001A3C                          1348          
00001A3C                          1349  MOVEA:
00001A3C                          1350  
00001A3C  7000                    1351          MOVEQ.L #0, D0 ;clear D0
00001A3E                          1352          
00001A3E                          1353  validMoveASourceModes:
00001A3E                          1354          
00001A3E  43F8 1973               1355          LEA moveSourceEAmasks,A1 ;load the list of masks
00001A42  D3C0                    1356          ADDA.L D0,A1 ;displace to a specific mask
00001A44  1A11                    1357          MOVE.B (A1),D5 ;move the mask to D5
00001A46                          1358          
00001A46  0C05 0000               1359          CMPI.B #0,D5 ;check if the mask is 0
00001A4A  6700 F624               1360          BEQ falsePositive ;branch if it is
00001A4E                          1361          
00001A4E  1401                    1362          MOVE.B D1,D2 ;copy instruction to D2
00001A50  C405                    1363          AND.B D5,D2  ;mask D2
00001A52                          1364          
00001A52  43F8 196A               1365          LEA moveSourceEA,A1 ;load the list of valid modes
00001A56  D3C0                    1366          ADDA.L D0,A1 ;displace to a specific mode
00001A58  1811                    1367          MOVE.B (A1),D4 ;move mode to D4
00001A5A  B404                    1368          CMP.B D4,D2 ;compare mode to masked value
00001A5C  6700 0006               1369          BEQ  checkMoveADest ;if its match, its a valid mode and we can procede
00001A60                          1370          
00001A60  5280                    1371          ADDQ.L #1,D0 ;add one to displacement
00001A62  60DA                    1372          BRA validMoveASourceModes ;check for next mode
00001A64                          1373          
00001A64                          1374  checkMoveADest:
00001A64  7000                    1375          MOVEQ.L #0, D0 ;clear D0
00001A66                          1376  validMoveADestModes:
00001A66                          1377          
00001A66  43F8 1A3A               1378          LEA moveADestEAmasks,A1 ;load the list of masks
00001A6A  D3C0                    1379          ADDA.L D0,A1 ;displace to a specific mask
00001A6C  1A11                    1380          MOVE.B (A1),D5 ;move the mask to D5
00001A6E                          1381          
00001A6E  0C05 0000               1382          CMPI.B #0,D5 ;check if the mask is 0
00001A72  6700 F5FC               1383          BEQ falsePositive ;branch if it is
00001A76                          1384          
00001A76  3401                    1385          MOVE.W D1,D2 ;copy instruction to D2
00001A78  EA4A                    1386          LSR.W #5,D2  ;move mode
00001A7A  6100 0410               1387          BSR switchModeAndReg ;switch register and mode
00001A7E  C405                    1388          AND.B D5,D2  ;mask D2
00001A80                          1389          
00001A80  43F8 1A38               1390          LEA moveADestEA,A1 ;load the list of valid modes
00001A84  D3C0                    1391          ADDA.L D0,A1 ;displace to a specific mode
00001A86  1811                    1392          MOVE.B (A1),D4 ;move mode to D4
00001A88  B404                    1393          CMP.B D4,D2 ;compare mode to masked value
00001A8A  6700 0006               1394          BEQ moveABody ;if its match, its a valid mode and we can procede
00001A8E                          1395          
00001A8E  5280                    1396          ADDQ.L #1,D0 ;add one to displacement
00001A90  60D4                    1397          BRA validMoveADestModes ;check for next mode
00001A92                          1398  moveABody:
00001A92  3401                    1399          MOVE.W  D1,D2 ;copy inst to D2
00001A94  C47C 3000               1400          AND.W  #%0011000000000000,D2 ;mask word for size
00001A98  0C42 0000               1401          CMPI.W #0,D2 ;0 is the non valid size
00001A9C  6700 F5D2               1402          BEQ falsePositive ; if zero, this is not move
00001AA0  0C42 1000               1403          CMPI.W #%0001000000000000,D2
00001AA4  6700 F5CA               1404          BEQ falsePositive ; if byte, this is not movea
00001AA8                          1405  
00001AA8                          1406  
00001AA8  43F9 000020C5           1407          LEA     moveAMessage,A1  ;move string for MOVE
00001AAE  103C 000D               1408          MOVE.B  #13,D0        ;set for task to display null terminated 
00001AB2                          1409                                ;string with CR, LF
00001AB2  4E4F                    1410          TRAP    #15
00001AB4                          1411  
00001AB4  7000                    1412          MOVEQ.L #0,D0
00001AB6  4E75                    1413          RTS
00001AB8                          1414  
00001AB8                          1415             
00001AB8                          1416  Bcc:
00001AB8                          1417  
00001AB8  43F9 000020B8           1418          LEA     bccMessage,A1  ;move string for BRA info
00001ABE  103C 000E               1419          MOVE.B  #14,D0        ;set for task to display null terminated 
00001AC2                          1420                                ;string without CR, LF
00001AC2  4E4F                    1421          TRAP    #15
00001AC4                          1422          
00001AC4  7000                    1423          MOVEQ.L #0,D0 ;clear D0
00001AC6  3401                    1424          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001AC8  E04A                    1425          LSR.W   #8,D2
00001ACA  C47C 000F               1426          AND.W   #$0F,D2 ;mask instruction
00001ACE                          1427          
00001ACE                          1428  checkCC:        
00001ACE  41F9 00001FEF           1429          LEA     bccList,A0 ;get condition code signature list in A0
00001AD4  D1C0                    1430          ADDA.L  D0,A0 ;get correct sig         
00001AD6  B410                    1431          CMP.B   (A0),D2 ;compare to sig
00001AD8  6700 0006               1432          BEQ     foundCC ;if sig matches branch
00001ADC  5200                    1433          ADDQ.B  #byte,D0
00001ADE  60EE                    1434          BRA     checkCC
00001AE0                          1435  foundCC:
00001AE0  43F9 00002000           1436          LEA     conditionCodeMessage,A1 ;get condition code message in A1
00001AE6  C0FC 0004               1437          MULU.W  #long,D0 ;adjust size of D0 for a long
00001AEA  D3C0                    1438          ADDA.L  D0,A1 ;get correct message location
00001AEC  2251                    1439          MOVEA.L (A1),A1 ;get correct message
00001AEE                          1440          
00001AEE  103C 000E               1441          MOVE.B  #14,D0        ;set for task to display null terminated 
00001AF2                          1442                                ;string without CR, LF
00001AF2  4E4F                    1443          TRAP    #15
00001AF4                          1444  
00001AF4                          1445          
00001AF4                          1446          
00001AF4  548B                    1447          ADDQ.L  #word,A3 ;move past instruction in case long displacement
00001AF6  C27C 00FF               1448          AND.W   #$00FF,D1   ;check for word sized displacement
00001AFA                          1449          
00001AFA  B23C 0000               1450          CMP.B   #$0,D1
00001AFE  6700 0010               1451          BEQ     BccWord
00001B02                          1452          
00001B02  B23C 00FF               1453          CMP.B   #$FF,D1 check for long sized displacement
00001B06  6700 0010               1454          BEQ     BccLong
00001B0A                          1455          
00001B0A                          1456  BccByte:
00001B0A                          1457          
00001B0A  7E00                    1458          MOVEQ.L #0,D7 ;pass back no extra data followed
00001B0C  6000 0012               1459          BRA     BccDone
00001B10                          1460  BccWord:
00001B10  3213                    1461          MOVE.W  (A3),D1
00001B12                          1462          
00001B12  7E02                    1463          MOVEQ.L #word,D7 ;pass back an extra word followed
00001B14  6000 000A               1464          BRA     BccDone
00001B18                          1465  BccLong:
00001B18  2213                    1466          MOVE.L  (A3),D1
00001B1A                          1467          
00001B1A  7E04                    1468          MOVEQ.L #long,D7 ;pass back an extra long followed
00001B1C  6000 0002               1469          BRA     BccDone
00001B20                          1470  BccDone:
00001B20                          1471  
00001B20  343C 0010               1472          MOVE.W  #16,D2 ;put base in D2
00001B24  303C 000F               1473          MOVE.W  #15,D0  ;put task #15 in D0
00001B28  4E4F                    1474          TRAP    #15
00001B2A                          1475          
00001B2A  43F9 00002068           1476          LEA     clearLine,A1  ;move string for a CR and LF
00001B30  103C 000E               1477          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B34                          1478                                ;string without CR, LF
00001B34  4E4F                    1479          TRAP    #15
00001B36                          1480  
00001B36  7000                    1481          MOVEQ.L #0,D0
00001B38  4E75                    1482          RTS
00001B3A                          1483          
00001B3A                          1484          
00001B3A                          1485  unknownOpCode:
00001B3A  43F9 000020BF           1486          LEA     dataMessage,A1 ;move string for data info
00001B40  103C 000E               1487          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B44                          1488                                ;string without CR, LF
00001B44  4E4F                    1489          TRAP    #15
00001B46                          1490          
00001B46  143C 0010               1491          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001B4A  103C 000F               1492          MOVE.B  #15,D0
00001B4E  4E4F                    1493          TRAP    #15
00001B50                          1494          
00001B50  43F9 00002068           1495          LEA     clearLine,A1  ;move string for a CR and LF
00001B56  103C 000E               1496          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B5A                          1497                                ;string without CR, LF
00001B5A  4E4F                    1498          TRAP    #15
00001B5C                          1499          
00001B5C  7000                    1500          MOVEQ.L #0,D0
00001B5E  4E75                    1501          RTS
00001B60                          1502          
00001B60                          1503  handlebytedata:
00001B60                          1504  
00001B60  43F9 000020BF           1505          LEA     dataMessage,A1 ;move string for data info
00001B66  103C 000E               1506          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B6A                          1507                                ;string without CR, LF
00001B6A  4E4F                    1508          TRAP    #15
00001B6C                          1509          
00001B6C  E049                    1510          LSR.W   #8,D1 ;shift the word read into D1 by a byte
00001B6E                          1511          
00001B6E  143C 0010               1512          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001B72  103C 000F               1513          MOVE.B  #15,D0
00001B76  4E4F                    1514          TRAP    #15
00001B78                          1515          
00001B78  43F9 00002068           1516          LEA     clearLine,A1  ;move string for a CR and LF
00001B7E  103C 000E               1517          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B82                          1518                                ;string without CR, LF
00001B82  4E4F                    1519          TRAP    #15
00001B84                          1520          
00001B84  7000                    1521          MOVEQ.L #0,D0
00001B86                          1522          
00001B86  528B                    1523          ADDQ.L  #byte,A3
00001B88  6000 F49C               1524          BRA main_Loop
00001B8C                          1525  
00001B8C                          1526          
00001B8C                          1527          
00001B8C                          1528  fin
00001B8C                          1529  
00001B8C                          1530          
00001B8C                          1531          
00001B8C  FFFF FFFF               1532          simhalt
00001B90                          1533          
00001B90                          1534  
00001B90                          1535  *******************************************************************************
00001B90                          1536  *                            SUB ROUTINES
00001B90                          1537  *******************************************************************************
00001B90                          1538  
00001B90                          1539  *******************************************************************************
00001B90                          1540  *                          IO ROLE ROUTINES
00001B90                          1541  *******************************************************************************
00001B90                          1542  
00001B90                          1543  *==========================================================================
00001B90                          1544  *                   Enter / Validate beginning address 
00001B90                          1545  *==========================================================================
00001B90                          1546   
00001B90                          1547  begin_address:
00001B90                          1548  
00001B90                          1549         
00001B90  43F9 00001EA0           1550          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00001B96  2239 00001EA0           1551          MOVE.L      slPrompt,D1         ;Load display length to D1
00001B9C  700E                    1552          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001B9E  4E4F                    1553          TRAP        #15                 ;Perform task 14 (display)
00001BA0                          1554          
00001BA0  43F9 000020F6           1555          LEA         startLocation,A1    ;Load address to store user input
00001BA6  103C 0002               1556          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001BAA  4E4F                    1557          TRAP        #15                 ;Perform task 2 (input)
00001BAC                          1558          
00001BAC  0C11 001B               1559          CMP.B       #27,(A1)            ;Check for ESC entered
00001BB0  6700 004C               1560          BEQ         address_Exit        ;Exit condition 
00001BB4                          1561          
00001BB4  6100 0050               1562          BSR         enter_addr_edit_all
00001BB8  B67C FFFF               1563          CMP.W       #-1,D3              ;Did the edit pass?
00001BBC  67D2                    1564          BEQ         begin_address       ;No, loop and ask for correct input
00001BBE                          1565          
00001BBE  2643                    1566          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
00001BC0                          1567          
00001BC0  43F9 00001FAD           1568          LEA         spc,A1              ;Load address for starting loaction prompt
00001BC6  1239 00001FAE           1569          MOVE.B      spc_len,D1          ;Load empty line length
00001BCC  7000                    1570          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
00001BCE  4E4F                    1571          TRAP        #15                 ;Perform task 14 (display)
00001BD0  6000 0002               1572          BRA         end_address
00001BD4                          1573  
00001BD4                          1574  *===========================================================================
00001BD4                          1575  *                   Enter / Validate ending address 
00001BD4                          1576  *===========================================================================
00001BD4                          1577  
00001BD4                          1578  end_address:
00001BD4                          1579          
00001BD4  43F9 00001ED1           1580          LEA         elPrompt,A1         ;Load address for ending loaction prompt
00001BDA                          1581          ;MOVE.L     elPrompt,D1         ;Load display length to D1
00001BDA  7250                    1582          MOVE.L      #80,D1       ;did not like previous command, do not know why, it should have worked
00001BDC  700E                    1583          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001BDE  4E4F                    1584          TRAP        #15                 ;Perform task 14 (display)
00001BE0                          1585          
00001BE0  103C 0002               1586          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001BE4  4E4F                    1587          TRAP        #15                 ;Perform task 2 (input)
00001BE6                          1588          
00001BE6  0C11 001B               1589          CMP.B       #27,(A1)            ;Check for ESC entered
00001BEA  6700 0012               1590          BEQ         address_Exit        ;Exit condition 
00001BEE                          1591          
00001BEE  6100 0016               1592          BSR         enter_addr_edit_all
00001BF2  B67C FFFF               1593          CMP.W       #-1,D3              ;Did the edit pass?
00001BF6  67DC                    1594          BEQ         end_address         ;No, loop and ask for correct input
00001BF8                          1595  
00001BF8  2843                    1596          MOVEA.L     D3,A4               ;Ending address gets stored in A4
00001BFA  6000 0008               1597          BRA         address_done
00001BFE                          1598  
00001BFE                          1599  address_Exit:
00001BFE                          1600  
00001BFE  76FF                    1601          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001C00  6000 0002               1602          BRA         address_done
00001C04                          1603          
00001C04                          1604  address_done:
00001C04                          1605  
00001C04  4E75                    1606          RTS    
00001C06                          1607  
00001C06                          1608  *==============================================================================
00001C06                          1609  * enter_addr_edit_all - Enter address edit check to edit all errors  
00001C06                          1610  *                       using multiple different error checking routines.
00001C06                          1611  *
00001C06                          1612  * Parameters -
00001C06                          1613  *   Input   A1      The data that needs checked.
00001C06                          1614  *   Input   D1      The number of characters input     
00001C06                          1615  *   Output  D3      Returns '-1' when there is an error.
00001C06                          1616  *==============================================================================
00001C06                          1617  
00001C06                          1618  enter_addr_edit_all
00001C06                          1619  
00001C06                          1620  *------------------------------------------------------------------------------
00001C06                          1621  * Test for odd number of characters entered, not allowed
00001C06                          1622  *------------------------------------------------------------------------------
00001C06                          1623         
00001C06  6100 0024               1624          BSR         ck_boundry          ;check if the input is on a odd / even boundry
00001C0A  B67C FFFF               1625          CMP.W       #-1,D3              ;Is the address odd?
00001C0E  6700 001A               1626          BEQ         enter_addr_edit_all_exit     ;No, return
00001C12                          1627  
00001C12                          1628  *------------------------------------------------------------------------------
00001C12                          1629  * Ttest for character entered all being valid address characters
00001C12                          1630  * Note: lower case a-f, gets converted to upper case A-F in D3
00001C12                          1631  *------------------------------------------------------------------------------
00001C12                          1632          
00001C12  6100 0062               1633          BSR         parseHexString      ;check if the input contains valid Hex characters
00001C16  B67C FFFF               1634          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
00001C1A  6700 000E               1635          BEQ         enter_addr_edit_all_exit     ;No, return
00001C1E                          1636  
00001C1E                          1637  *------------------------------------------------------------------------------
00001C1E                          1638  * Verify that the address entered is witin the range defined in the Equate
00001C1E                          1639  *------------------------------------------------------------------------------        
00001C1E                          1640          
00001C1E  6100 00C8               1641          BSR         ck_addr_range       ;is address entered witin the range 
00001C22                          1642                                          ;   as defined in the Equate? 
00001C22  B67C FFFF               1643          CMP.W       #-1,D3              ;is the address  valid?
00001C26  6700 0002               1644          BEQ         enter_addr_edit_all_exit     ;No, return
00001C2A                          1645  
00001C2A                          1646  enter_addr_edit_all_exit:
00001C2A                          1647  
00001C2A  4E75                    1648          RTS                             ;return
00001C2C                          1649  
00001C2C                          1650  *==============================================================================
00001C2C                          1651  * ck_boundry - Check the size of the data characters input and determine
00001C2C                          1652  *              if an odd number of characters was entered
00001C2C                          1653  *
00001C2C                          1654  * Parameters -
00001C2C                          1655  *   Input   A1      The data that needs checked for odd length.
00001C2C                          1656  *   Input   D1      The number of characters input     
00001C2C                          1657  *   Output  D3      Returns '-1' when there is an odd length.
00001C2C                          1658  *==============================================================================
00001C2C                          1659  
00001C2C                          1660  ck_boundry:
00001C2C                          1661  
00001C2C  4243                    1662          CLR.W       D3                  ;Clear the return
00001C2E                          1663  
00001C2E  B23C 0000               1664          CMP.B       #0,D1               ;Check for nothing entered
00001C32  6700 002E               1665          BEQ         ck_size_error       ;Number of characters entered must be 
00001C36                          1666                                          ;greater than 0  
00001C36                          1667          
00001C36                          1668          
00001C36                          1669          * The program will branch to ck_size_error if D1 is greater than #8        
00001C36  B23C 0008               1670          CMP.B       #8,D1               ;Check for more than 8 characters entered
00001C3A  6E00 0026               1671          BGT         ck_size_error       ;Number of characters entered must be less
00001C3E                          1672                                          ;than 9
00001C3E                          1673          
00001C3E  7402                    1674          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
00001C40  82C2                    1675          DIVU        D2,D1               ;Divide address by 2
00001C42  4841                    1676          SWAP        D1                  ;get remainder
00001C44  B23C 0001               1677          CMP.B       #$01,D1             ;Check for remainder of 1
00001C48  6700 0004               1678          BEQ         ck_boundry_error    ;Number of characters entered must be an 
00001C4C                          1679                                          ;even number   
00001C4C                          1680    
00001C4C  4E75                    1681          RTS                             ;return
00001C4E                          1682  
00001C4E                          1683  *------------------------------------------------------------------------------
00001C4E                          1684  * ck_boundry_error - An odd number of characters was entered
00001C4E                          1685  *                  - Load error message and display it
00001C4E                          1686  *                  - Return error condition
00001C4E                          1687  *------------------------------------------------------------------------------
00001C4E                          1688          
00001C4E                          1689  ck_boundry_error:
00001C4E                          1690  
00001C4E  43F9 00001F8D           1691          LEA         even_msg,A1         ;Load odd error message into A1
00001C54  2239 00001F8D           1692          MOVE.L      even_msg,D1         ;Load error length to D1
00001C5A                          1693          
00001C5A  7000                    1694          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001C5C                          1695                                          ; n is D1.W with CR, LF. 
00001C5C  4E4F                    1696          TRAP #15                        ;Display the error message
00001C5E  76FF                    1697          MOVE.L #-1,D3                   ;Load -1 into return parameter
00001C60  4E75                    1698          RTS                             ;Return
00001C62                          1699          
00001C62                          1700  *------------------------------------------------------------------------------
00001C62                          1701  * ck_size_error -   The number of characters entered must be more than zero
00001C62                          1702  *                  - Load error message and display it
00001C62                          1703  *                  - Return error condition
00001C62                          1704  *------------------------------------------------------------------------------
00001C62                          1705          
00001C62                          1706  ck_size_error:
00001C62                          1707  
00001C62  43F9 00001F00           1708          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001C68  2239 00001F00           1709          MOVE.L      invalidMsg,D1       ;Load error length to D1
00001C6E                          1710          
00001C6E  7000                    1711          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001C70                          1712                                          ; n is D1.W with CR, LF. 
00001C70  4E4F                    1713          TRAP        #15                 ;Display the error message
00001C72  76FF                    1714          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001C74  4E75                    1715          RTS                             ;Return        
00001C76                          1716  
00001C76                          1717  
00001C76                          1718  *==============================================================================
00001C76                          1719  * parseHexString - Converts user input string into a valid memory address
00001C76                          1720  *                - Stores parsed address data into D3
00001C76                          1721  *                - Stores good/bad (1/0) data in D4 
00001C76                          1722  *
00001C76                          1723  * Hex values are stored as bytes in D2, the ASCII chart shows their value
00001C76                          1724  *   The ASCII chart values we care about are in the ranges of: 
00001C76                          1725  *                            Hex            Decimal
00001C76                          1726  *       No Value           NULL = 0         0
00001C76                          1727  *       Numeric Values:     0-9 = 30-39     48-57
00001C76                          1728  *       Upper Case letters: A-F = 41-46     65-70
00001C76                          1729  *       Lower Case letterc: a-f = 61-66     97-102
00001C76                          1730  
00001C76                          1731  * Parameters -
00001C76                          1732  *   Input   A1      The data that needs checked for valid input.
00001C76                          1733  *   Output  D3      The return value, '-1' for error
00001C76                          1734  *==============================================================================
00001C76                          1735  
00001C76                          1736  parseHexString:
00001C76                          1737  
00001C76                          1738  * setup any initializing item that do not get looped through
00001C76  4243                    1739          CLR.W       D3                  ;Clear the return
00001C78                          1740  
00001C78                          1741          
00001C78                          1742  *------------------------------------------------------------------------------
00001C78                          1743  * NextHex - Loop through all bytes and vaildate the input
00001C78                          1744  * Parameters -
00001C78                          1745  *   Input   A1      The data that needs checked for valid input.
00001C78                          1746  *   Output  D3      The return value, '-1' for error
00001C78                          1747  *------------------------------------------------------------------------------
00001C78                          1748          
00001C78                          1749  NextHex:
00001C78                          1750  
00001C78  1419                    1751          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00001C7A  B43C 0000               1752          CMP.B       #0,D2               ;Check character for null 
00001C7E  6700 0066               1753          BEQ         NextHexReturn       ;Character is null (end of input)
00001C82                          1754          
00001C82                          1755  *................................................................................
00001C82                          1756  *  Check decimal values 0-9 by testing hexadecimal values 30-39
00001C82                          1757  *................................................................................
00001C82                          1758                  
00001C82                          1759          * The program will branch to hex_range_error if D2 is less than #30
00001C82  B43C 0030               1760          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
00001C86  6D00 0048               1761          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001C8A                          1762                                          ;processing
00001C8A                          1763          
00001C8A                          1764          * The program will branch to UcaseHex if D2 is greater than #39
00001C8A  B43C 0039               1765          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
00001C8E  6E00 000A               1766          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
00001C92                          1767          
00001C92                          1768          *a valid number was found within this range
00001C92  0402 0030               1769          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
00001C96  6000 0032               1770          BRA         NextHexDone         ;Done parsing this byte
00001C9A                          1771  
00001C9A                          1772  
00001C9A                          1773  *..............................................................................
00001C9A                          1774  *  Check upper case values A-F by testing hexadecimal values 41-46
00001C9A                          1775  *..............................................................................
00001C9A                          1776  
00001C9A                          1777  UcaseHex:
00001C9A                          1778  
00001C9A                          1779          * The program will branch to hex_range_error if D2 is less than #41
00001C9A  B43C 0041               1780          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
00001C9E  6D00 0030               1781          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001CA2                          1782                                          ;processing
00001CA2                          1783          
00001CA2  B43C 0046               1784          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
00001CA6  6E00 000A               1785          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
00001CAA                          1786                                          ;processing
00001CAA                          1787          
00001CAA                          1788          *a valid number was found within this range
00001CAA  0402 0037               1789          SUBI.B      #55,D2              ;Change uppercase character to actual value
00001CAE  6000 001A               1790          BRA         NextHexDone         ;Done parsing this byte
00001CB2                          1791  
00001CB2                          1792  
00001CB2                          1793  *..............................................................................
00001CB2                          1794  *  Check lower case values a-f by testing hexadecimal values 61-66
00001CB2                          1795  *..............................................................................
00001CB2                          1796  
00001CB2                          1797  LcaseHex
00001CB2                          1798          
00001CB2                          1799          * The program will branch to hex_range_error if D2 is less than #61
00001CB2  B43C 0061               1800          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
00001CB6  6D00 0018               1801          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
00001CBA                          1802                                          ;processing
00001CBA                          1803  
00001CBA  B43C 0066               1804          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
00001CBE  6E00 0010               1805          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
00001CC2                          1806                                          ;processing
00001CC2                          1807  
00001CC2                          1808          *a valid number was found within this range
00001CC2  0402 0057               1809          SUBI.B      #87,D2              ;Change lowercase character to actual value
00001CC6  6000 0002               1810          BRA         NextHexDone         ;Done parsing this byte
00001CCA                          1811  
00001CCA                          1812  NextHexDone:
00001CCA                          1813  
00001CCA  E983                    1814          ASL.L       #4,D3               ; Make rooom for new byte in the return register
00001CCC  D602                    1815          ADD.B       D2,D3               ; Move the new byte into the return register
00001CCE  60A8                    1816          BRA         NextHex             ; We're ready to parse the next byte
00001CD0                          1817          
00001CD0                          1818  *-------------------------------------------------------------------------------------
00001CD0                          1819  * hex_range_error -  A character entered was within the valid range for a hex address
00001CD0                          1820  *                 -  Load error message and display it
00001CD0                          1821  *                 -  Return error condition
00001CD0                          1822  *-------------------------------------------------------------------------------------
00001CD0                          1823          
00001CD0                          1824  hex_range_error:
00001CD0                          1825  
00001CD0  43F9 00001F45           1826          LEA         invCharMsg,A1       ;Load invalid range message into A1
00001CD6  2239 00001F45           1827          MOVE.L      invCharMsg,D1       ;Load error length to D1
00001CDC                          1828          
00001CDC  7000                    1829          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001CDE                          1830                                          ; n is D1.W with CR, LF. 
00001CDE  4E4F                    1831          TRAP        #15                 ;Display the error message
00001CE0  76FF                    1832          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001CE2  6000 0002               1833          BRA         NextHexReturn
00001CE6                          1834          
00001CE6                          1835  NextHexReturn:
00001CE6                          1836          
00001CE6  4E75                    1837          RTS                             ;Return      
00001CE8                          1838  
00001CE8                          1839  
00001CE8                          1840  *===============================================================================
00001CE8                          1841  * ck_addr_range - check the address input is within a valid memory address range
00001CE8                          1842  *                - Parsed address data into D3
00001CE8                          1843  *
00001CE8                          1844  * Parameters -
00001CE8                          1845  *   Input   A1      The data that needs checked for valid address.
00001CE8                          1846  *   Output  D3      The return value, '-1' for error
00001CE8                          1847  *===============================================================================
00001CE8                          1848  
00001CE8                          1849  
00001CE8                          1850  ck_addr_range:   
00001CE8                          1851  
00001CE8                          1852  *------------------------------------------------------------------------------
00001CE8                          1853  * Verify that the address entered is witin the 
00001CE8                          1854  * beginning range ('begin') as defined in the Equate
00001CE8                          1855  *------------------------------------------------------------------------------   
00001CE8                          1856              
00001CE8  2C3C 00005001           1857          MOVE.L      #begin,D6           * Load minimum starting address
00001CEE  B686                    1858          CMP.L       D6,D3               * Is input at or above minimum?
00001CF0  6D00 0012               1859          BLT         ck_addr_range_error 
00001CF4                          1860          
00001CF4                          1861  *------------------------------------------------------------------------------
00001CF4                          1862  * Verify that the address entered is witin the 
00001CF4                          1863  * ending range ('end') as defined in the Equate
00001CF4                          1864  *------------------------------------------------------------------------------
00001CF4                          1865          
00001CF4  2C3C 00FFFFFE           1866          MOVE.L      #end,D6             * Load maximum starting address
00001CFA  B686                    1867          CMP.L       D6,D3               * Is input at or below maximum?
00001CFC  6E00 0006               1868          BGT         ck_addr_range_error 
00001D00  6000 0012               1869          BRA         ck_addr_done        ;done checking
00001D04                          1870          
00001D04                          1871  *..............................................................................
00001D04                          1872  * ck_addr_range_error -  A address entered is not within the 
00001D04                          1873  *                        valid range for a hex address
00001D04                          1874  *..............................................................................
00001D04                          1875          
00001D04                          1876  ck_addr_range_error
00001D04                          1877  
00001D04  43F9 00001F00           1878          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001D0A                          1879          
00001D0A  700D                    1880          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
00001D0C                          1881                                          ;with CR, LF. 
00001D0C  4E4F                    1882          TRAP        #15                 ;Display the error message
00001D0E  76FF                    1883          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001D10  6000 0002               1884          BRA         ck_addr_done 
00001D14                          1885  
00001D14                          1886  ck_addr_done:
00001D14                          1887  
00001D14  4E75                    1888          RTS                             ;Return
00001D16                          1889  
00001D16                          1890  *******************************************************************************
00001D16                          1891  *                          OP CODE ROLE ROUTINES
00001D16                          1892  *******************************************************************************
00001D16                          1893  
00001D16                          1894  process_op_codes:
00001D16                          1895  
00001D16                          1896  
00001D16                          1897  
00001D16                          1898  process_op_codes_exit:
00001D16                          1899  
00001D16  4E75                    1900          RTS
00001D18                          1901  
00001D18                          1902  
00001D18                          1903  *******************************************************************************
00001D18                          1904  *                    Effective Addressing ROLE ROUTINES
00001D18                          1905  *******************************************************************************
00001D18                          1906  
00001D18                          1907  Get_Effective_Address:
00001D18                          1908  
00001D18  1C05                    1909          MOVE.B      D5,D6
00001D1A  E60E                    1910          LSR.B       #3,D6               ;mode
00001D1C  CA3C 0007               1911          And.B       #%00000111,D5       ;register
00001D20                          1912          
00001D20  BC3C 0000               1913          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
00001D24  6700 004A               1914          BEQ         Data_Reg_Direct
00001D28                          1915          
00001D28  BC3C 0001               1916          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
00001D2C  6700 005C               1917          BEQ         Addr_Reg_Direct
00001D30                          1918          
00001D30  BC3C 0002               1919          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
00001D34  6700 006E               1920          BEQ         Addr_Reg_Indirect
00001D38                          1921          
00001D38  BC3C 0003               1922          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
00001D3C  6700 0098               1923          BEQ         Addr_Reg_Indirect_Inc
00001D40                          1924          
00001D40  BC3C 0004               1925          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
00001D44  6700 00CE               1926          BEQ         Addr_Reg_Indirect_Dec
00001D48                          1927          
00001D48  BC3C 0007               1928          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
00001D4C  6700 0006               1929          BEQ         Get_Effective_Address_Other
00001D50                          1930          
00001D50  6000 0138               1931          BRA         invalidEA
00001D54                          1932          
00001D54                          1933  Get_Effective_Address_Other:        
00001D54                          1934          
00001D54  BA3C 0000               1935          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00001D58  6700 00F8               1936          BEQ Addr_Abs_Short
00001D5C                          1937          
00001D5C  BA3C 0001               1938          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
00001D60  6700 0104               1939          BEQ Addr_Abs_Long
00001D64                          1940          
00001D64  BA3C 0004               1941          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
00001D68  6700 0110               1942          BEQ Addr_Immediate_Data
00001D6C                          1943          
00001D6C  6000 011C               1944          BRA         invalidEA
00001D70                          1945          
00001D70                          1946  Data_Reg_Direct:                        ;case 0(0000)
00001D70                          1947  
00001D70  43F9 000020EC           1948          LEA         letterD,A1          ;output 'D' for data register
00001D76  103C 000E               1949          MOVE.B      #14,D0              ;set for task to display null terminated 
00001D7A  4E4F                    1950          TRAP        #15                 ;string without CR, LF
00001D7C                          1951                          
00001D7C  4281                    1952          CLR.L       D1
00001D7E  1205                    1953          MOVE.B      D5,D1               ;move register number for display into D1
00001D80  103C 0003               1954          MOVE.B      #3,D0               ;set for task to display null terminated 
00001D84  4E4F                    1955          TRAP        #15                 ;string without CR, LF
00001D86                          1956                 
00001D86  6000 0102               1957          BRA         Get_Effective_Address_Exit  ;return
00001D8A                          1958          
00001D8A                          1959          
00001D8A                          1960  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
00001D8A                          1961        
00001D8A  43F9 000020EA           1962          LEA         letterA,A1          ;output 'A' for address register
00001D90  103C 000E               1963          MOVE.B      #14,D0              ;set for task to display null terminated 
00001D94  4E4F                    1964          TRAP        #15                 ;string without CR, LF
00001D96                          1965          
00001D96  4281                    1966          CLR.L       D1
00001D98  1205                    1967          MOVE.B      D5,D1               ;move register number for display into D1
00001D9A  103C 0003               1968          MOVE.B      #3,D0               ;set for task to display null terminated 
00001D9E  4E4F                    1969          TRAP        #15                 ;string without CR, LF
00001DA0                          1970          
00001DA0  6000 00E8               1971          BRA         Get_Effective_Address_Exit  ;return
00001DA4                          1972  
00001DA4                          1973  
00001DA4                          1974  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
00001DA4                          1975          
00001DA4  43F9 000020F2           1976          LEA         lprn,A1             ;output 'D' for data register
00001DAA  103C 000E               1977          MOVE.B      #14,D0              ;set for task to display null terminated 
00001DAE  4E4F                    1978          TRAP        #15                 ;string without CR, LF
00001DB0                          1979  
00001DB0  43F9 000020EA           1980          LEA         letterA,A1          ;output 'A' for address register
00001DB6  103C 000E               1981          MOVE.B      #14,D0              ;set for task to display null terminated 
00001DBA  4E4F                    1982          TRAP        #15                 ;string without CR, LF
00001DBC                          1983          
00001DBC  4281                    1984          CLR.L       D1
00001DBE  1205                    1985          MOVE.B      D5,D1               ;move register number for display into D1
00001DC0  103C 0003               1986          MOVE.B      #3,D0               ;set for task to display null terminated 
00001DC4  4E4F                    1987          TRAP        #15                 ;string without CR, LF
00001DC6                          1988  
00001DC6  43F9 000020F4           1989          LEA         rprn,A1             ;output 'D' for data register
00001DCC  103C 000E               1990          MOVE.B      #14,D0              ;set for task to display null terminated 
00001DD0  4E4F                    1991          TRAP        #15                 ;string without CR, LF
00001DD2                          1992          
00001DD2  6000 00B6               1993          BRA         Get_Effective_Address_Exit  ;return
00001DD6                          1994  
00001DD6                          1995                 
00001DD6                          1996  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
00001DD6                          1997  
00001DD6  43F9 000020F2           1998          LEA         lprn,A1             ;output 'D' for data register
00001DDC  103C 000E               1999          MOVE.B      #14,D0              ;set for task to display null terminated 
00001DE0  4E4F                    2000          TRAP        #15                 ;string without CR, LF
00001DE2                          2001  
00001DE2  43F9 000020EA           2002          LEA         letterA,A1          ;output 'A' for address register
00001DE8  103C 000E               2003          MOVE.B      #14,D0              ;set for task to display null terminated 
00001DEC  4E4F                    2004          TRAP        #15                 ;string without CR, LF
00001DEE                          2005          
00001DEE  4281                    2006          CLR.L       D1
00001DF0  1205                    2007          MOVE.B      D5,D1               ;move register number for display into D1
00001DF2  103C 0003               2008          MOVE.B      #3,D0               ;set for task to display null terminated 
00001DF6  4E4F                    2009          TRAP        #15                 ;string without CR, LF
00001DF8                          2010  
00001DF8  43F9 000020F4           2011          LEA         rprn,A1             ;output 'D' for data register
00001DFE  103C 000E               2012          MOVE.B      #14,D0              ;set for task to display null terminated 
00001E02  4E4F                    2013          TRAP        #15                 ;string without CR, LF
00001E04                          2014          
00001E04  43F9 000020EE           2015          LEA         plus,A1             ;output 'D' for data register
00001E0A  103C 000E               2016          MOVE.B      #14,D0              ;set for task to display null terminated 
00001E0E  4E4F                    2017          TRAP        #15                 ;string without CR, LF
00001E10                          2018          
00001E10  6000 0078               2019          BRA         Get_Effective_Address_Exit  ;return
00001E14                          2020  
00001E14                          2021  Addr_Reg_Indirect_Dec                   ;4 = (An) - Address Register Indirect with Predecrement (100)
00001E14                          2022  
00001E14  43F9 000020F0           2023          LEA         minus,A1            ;output '-' for Predecrement
00001E1A  103C 000E               2024          MOVE.B      #14,D0              ;set for task to display null terminated 
00001E1E  4E4F                    2025          TRAP        #15                 ;string without CR, LF
00001E20                          2026  
00001E20  43F9 000020F2           2027          LEA         lprn,A1             ;output 'D' for data register
00001E26  103C 000E               2028          MOVE.B      #14,D0              ;set for task to display null terminated 
00001E2A  4E4F                    2029          TRAP        #15                 ;string without CR, LF
00001E2C                          2030  
00001E2C  43F9 000020EA           2031          LEA         letterA,A1          ;output 'A' for address register
00001E32  103C 000E               2032          MOVE.B      #14,D0              ;set for task to display null terminated 
00001E36  4E4F                    2033          TRAP        #15                 ;string without CR, LF
00001E38                          2034          
00001E38  4281                    2035          CLR.L       D1
00001E3A  1205                    2036          MOVE.B      D5,D1               ;move register number for display into D1
00001E3C  103C 0003               2037          MOVE.B      #3,D0               ;set for task to display null terminated 
00001E40  4E4F                    2038          TRAP        #15                 ;string without CR, LF
00001E42                          2039  
00001E42  43F9 000020F4           2040          LEA         rprn,A1             ;output 'D' for data register
00001E48  103C 000E               2041          MOVE.B      #14,D0              ;set for task to display null terminated 
00001E4C  4E4F                    2042          TRAP        #15                 ;string without CR, LF
00001E4E                          2043          
00001E4E  6000 003A               2044          BRA         Get_Effective_Address_Exit  ;return
00001E52                          2045          
00001E52                          2046                         
00001E52                          2047  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00001E52                          2048          
00001E52                          2049          
00001E52  43F9 000020CC           2050          LEA         xxxW,A1             ;output 'D' for data register
00001E58  103C 000E               2051          MOVE.B      #14,D0              ;set for task to display null terminated 
00001E5C  4E4F                    2052          TRAP        #15                 ;string without CR, LF
00001E5E                          2053  
00001E5E  548B                    2054          ADDA.L      #word,A3
00001E60                          2055          
00001E60                          2056          ;print word (A3)
00001E60                          2057          ;MOVE.W      A3,(A1)
00001E60                          2058          ;MOVE.B      #1,D0               ;set for task to display null terminated 
00001E60                          2059          ;TRAP        #15                 ;string without CR, LF
00001E60                          2060          
00001E60  5487                    2061          ADDI.L      #word,D7 
00001E62  6000 0026               2062          BRA         Get_Effective_Address_Exit  ;return
00001E66                          2063                         
00001E66                          2064  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
00001E66                          2065          
00001E66  43F9 000020D6           2066          LEA         xxxL,A1             ;output 'D' for data register
00001E6C  103C 000E               2067          MOVE.B      #14,D0              ;set for task to display null terminated 
00001E70  4E4F                    2068          TRAP        #15                 ;string without CR, LF
00001E72                          2069  
00001E72  548B                    2070          ADDA.L      #word,A3
00001E74                          2071          
00001E74                          2072          ;print long (A3)
00001E74                          2073          ;MOVE.L      A3,(A1)
00001E74                          2074          ;MOVE.B      #14,D0              ;set for task to display null terminated 
00001E74                          2075          ;TRAP        #15                 ;string without CR, LF
00001E74                          2076          
00001E74  5887                    2077          ADDI.L      #long,D7
00001E76  6000 0012               2078          BRA         Get_Effective_Address_Exit  ;return
00001E7A                          2079                         
00001E7A                          2080  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
00001E7A                          2081  
00001E7A  43F9 000020E0           2082          LEA         iData,A1            ;output 'D' for data register
00001E80  103C 000E               2083          MOVE.B      #14,D0              ;set for task to display null terminated 
00001E84  4E4F                    2084          TRAP        #15                 ;string without CR, LF
00001E86                          2085          
00001E86                          2086          *need another input param for size
00001E86  6000 0002               2087          BRA         Get_Effective_Address_Exit  ;return
00001E8A                          2088  
00001E8A                          2089  invalidEA:
00001E8A                          2090  
00001E8A                          2091          ;do something
00001E8A                          2092   
00001E8A                          2093  Get_Effective_Address_Exit:     
00001E8A                          2094  
00001E8A  4E75                    2095          RTS                             ;return
00001E8C                          2096  
00001E8C                          2097  switchModeAndReg:
00001E8C                          2098  ***
00001E8C                          2099  * Assumed in D2
00001E8C                          2100  *
00001E8C                          2101  * Assumed that they are in least significant byte:
00001E8C                          2102  *
00001E8C                          2103  *            _this_
00001E8C                          2104  *           /      \
00001E8C                          2105  *  ........ ........
00001E8C                          2106  *  \                /
00001E8C                          2107  *   -----word-------
00001E8C                          2108  *
00001E8C                          2109  *  and that in that byte they are ordered:
00001E8C                          2110  *
00001E8C                          2111  *       ........   
00001E8C                          2112  *       \/\_/\_/
00001E8C                          2113  *      /  /    \
00001E8C                          2114  *    /   /      \
00001E8C                          2115  * dont  one    other
00001E8C                          2116  * care
00001E8C                          2117  *
00001E8C                          2118  * after they will be
00001E8C                          2119  *
00001E8C                          2120  *       ........   
00001E8C                          2121  *       \/\_/\_/
00001E8C                          2122  *      /  /    \
00001E8C                          2123  *    /   /      \
00001E8C                          2124  * dont other    one
00001E8C                          2125  * care
00001E8C                          2126  *** 
00001E8C  0202 003F               2127          AndI.B #%00111111,D2 ;remove unwanted bits from D2
00001E90  0283 00000000           2128          ANDI.L #0,D3 ;clear D3
00001E96  1602                    2129          MOVE.B D2,D3 ;copy to D3
00001E98  E70B                    2130          LSL.B  #3,D3 
00001E9A  E60A                    2131          LSR.B  #3,D2
00001E9C  D403                    2132          ADD.B  D3,D2
00001E9E  4E75                    2133          RTS
00001EA0                          2134  
00001EA0                          2135          
00001EA0                          2136  *==============================================================================
00001EA0                          2137  *                            variables and constants
00001EA0                          2138  *==============================================================================
00001EA0                          2139  
00001EA0                          2140  
00001EA0                          2141  ***initial user prompt stuff        
00001EA0= 45 6E 74 65 72 20 ...   2142  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE: $',0
00001ED1= 45 6E 74 65 72 20 ...   2143  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE: $',0
00001F00                          2144  
00001F00= 20 41 64 64 72 65 ...   2145  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
00001F45= 20 41 20 43 68 61 ...   2146  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
00001F8D                          2147  
00001F8D= 20 59 6F 75 20 6D ...   2148  even_msg        DC.B    ' You must enter an even address!'
00001FAD                          2149  
00001FAD= 20                      2150  spc             DC.B    ' '
00001FAE= 01                      2151  spc_len         DC.B    spc_len-spc
00001FAF                          2152  ***
00001FAF                          2153  
00001FAF                          2154  
00001FAF                          2155  
00001FAF                          2156  ***list of OP codes
00001FAF  =0000E2C0               2157  lsrlweaInstruction  EQU %1110001011000000
00001FAF  =0000E008               2158  lsrlregInstruction  EQU %1110000000001000
00001FAF  =00005100               2159  subqInstruction  EQU %0101000100000000
00001FAF  =00009000               2160  subInstruction   EQU %1001000000000000
00001FAF  =0000D000               2161  addaInstruction  EQU %1101000000000000
00001FAF  =0000D000               2162  addInstruction   EQU %1101000000000000
00001FAF  =00004880               2163  movemInstruction EQU %0100100010000000
00001FAF  =00000600               2164  addiInstruction  EQU %0000011000000000
00001FAF  =00000000               2165  oriInstruction   EQU 0
00001FAF  =00000C00               2166  cmpiInstruction  EQU %0000110000000000
00001FAF  =00004E80               2167  jsrInstruction   EQU %0100111010000000
00001FAF  =00004E75               2168  rtsInstruction   EQU %0100111001110101
00001FAF  =00004E71               2169  NoOpInstruction  EQU %0100111001110001
00001FAF  =00000000               2170  moveInstruction  EQU 0
00001FAF  =00006000               2171  bccInstruction   EQU %0110000000000000
00001FAF  =00004400               2172  negInstruction   EQU %0100010000000000
00001FAF  =00000000               2173  dataInstruction  EQU 0
00001FAF                          2174  
00001FAF                          2175  ***
00001FAF                          2176  
00001FAF                          2177  ***list of OP masks
00001FAF                          2178  
00001FAF  =0000FEC0               2179  lsrlweaMask  EQU %1111111011000000
00001FAF  =0000F018               2180  lsrlregMask  EQU %1111000000011000
00001FAF  =0000F100               2181  subqMask  EQU %1111000100000000
00001FAF  =0000F000               2182  subMask   EQU %1111000000000000
00001FAF  =0000F000               2183  addaMask  EQU %1111000000000000
00001FAF  =0000F000               2184  addMask   EQU %1111000000000000
00001FAF  =0000FB80               2185  movemMask EQU %1111101110000000
00001FAF  =0000FF00               2186  addiMask  EQU %1111111100000000
00001FAF  =0000FF00               2187  oriMask   EQU %1111111100000000
00001FAF  =0000FF00               2188  cmpiMask  EQU %1111111100000000
00001FAF  =0000FFC0               2189  jsrMask   EQU %1111111111000000
00001FAF  =0000FFFF               2190  rtsMask   EQU $FFFF
00001FAF  =0000FFFF               2191  NoOpMask  EQU $FFFF
00001FAF  =0000C000               2192  moveMask  EQU $C000
00001FAF  =0000F000               2193  bccMask   EQU $F000
00001FAF  =0000FF00               2194  negMask   EQU $FF00
00001FAF  =00000000               2195  dataMask  EQU 0
00001FAF                          2196  ***
00001FAF                          2197  
00001FAF                          2198  ***Bcc Codes***
00001FAF  =00000004               2199  CC EQU $04
00001FAF  =00000005               2200  CS EQU $05
00001FAF  =00000007               2201  EQ EQU $07
00001FAF  =0000000C               2202  GE EQU $0C
00001FAF  =0000000E               2203  GT EQU $0E
00001FAF  =00000002               2204  HI EQU $02
00001FAF  =0000000F               2205  LE EQU $0F
00001FAF  =00000003               2206  LS EQU $03
00001FAF  =0000000D               2207  LT EQU $0D
00001FAF  =0000000B               2208  MI EQU $0B
00001FAF  =00000006               2209  NE EQU $06
00001FAF  =0000000A               2210  PL EQU $0A
00001FAF  =00000008               2211  VC EQU $08
00001FAF  =00000009               2212  VS EQU $09
00001FAF  =00000000               2213  RA EQU $00 ;not really a Condition Code
00001FAF  =00000001               2214  SR EQU $01 ;not really a Condition Code
00001FAF                          2215  
00001FAF= 43 43 20 00             2216  CCm DC.B 'CC ',0
00001FB3= 43 53 20 00             2217  CSm DC.B 'CS ',0
00001FB7= 45 51 20 00             2218  EQm DC.B 'EQ ',0
00001FBB= 47 45 20 00             2219  GEm DC.B 'GE ',0
00001FBF= 47 54 20 00             2220  GTm DC.B 'GT ',0
00001FC3= 48 49 20 00             2221  HIm DC.B 'HI ',0
00001FC7= 4C 45 20 00             2222  LEm DC.B 'LE ',0
00001FCB= 4C 53 20 00             2223  LSm DC.B 'LS ',0
00001FCF= 4C 54 20 00             2224  LTm DC.B 'LT ',0
00001FD3= 4D 49 20 00             2225  MIm DC.B 'MI ',0
00001FD7= 4E 45 20 00             2226  NEm DC.B 'NE ',0
00001FDB= 50 4C 20 00             2227  PLm DC.B 'PL ',0
00001FDF= 56 43 20 00             2228  VCm DC.B 'VC ',0
00001FE3= 56 53 20 00             2229  VSm DC.B 'VS ',0
00001FE7= 52 41 20 00             2230  RAm DC.B 'RA ',0
00001FEB= 53 52 20 00             2231  SRm DC.B 'SR ',0
00001FEF                          2232  
00001FEF= 01 04 05 07 0C 0E ...   2233  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
00002000= 00001FEB 00001FAF ...   2234  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
00002040                          2235  ***
00002040                          2236  
00002040= 45 6E 74 65 72 20 ...   2237  startLocationPrompt DC.B    'Enter start location',0
00002055= 45 6E 74 65 72 20 ...   2238  endLocationPrompt   DC.B    'Enter end location',0
00002068                          2239  
00002068= 0D 0A 00                2240  clearLine  DC.B $0D,$0A,0
0000206B                          2241  
0000206B= 4C 53 4C 20 00          2242  lslMessage      DC.B 'LSL ',0
00002070= 4C 53 52 20 00          2243  lsrMessage      DC.B 'LSR ',0
00002075= 53 55 42 51 20 00       2244  subqMessage     DC.B 'SUBQ ',0
0000207B= 53 55 42 20 00          2245  subMessage      DC.B 'SUB ',0 
00002080= 41 44 44 41 20 00       2246  addaMessage     DC.B 'ADDA ',0
00002086= 41 44 44 20 00          2247  addMessage      DC.B 'ADD ',0
0000208B= 4D 4F 56 45 4D 20 00    2248  movemMessage    DC.B 'MOVEM ',0
00002092= 41 44 44 49 20 00       2249  addiMessage     DC.B 'ADDI ',0
00002098= 4F 52 49 20 00          2250  oriMessage      DC.B 'ORI ',0
0000209D= 43 4D 50 49 20 00       2251  cmpiMessage     DC.B 'CMPI ',0
000020A3= 4A 53 52 20 00          2252  jsrMessage      DC.B 'JSR ',0
000020A8= 52 54 53 20 00          2253  rtsMessage      DC.B 'RTS ',0
000020AD= 4E 4F 50 20 00          2254  nopMessage      DC.B 'NOP ',0 
000020B2= 4D 4F 56 45 20 00       2255  moveMessage     DC.B 'MOVE ',0
000020B8= 42 00                   2256  bccMessage      DC.B 'B',0
000020BA= 4E 45 47 20 00          2257  negMessage      DC.B 'NEG ',0
000020BF= 44 41 54 41 20 00       2258  dataMessage     DC.B 'DATA ',0
000020C5= 4D 4F 56 45 41 20 00    2259  moveaMessage    DC.B 'MOVEA ',0
000020CC                          2260  
000020CC= 28 78 78 78 29 2E ...   2261  xxxW            DC.B '(xxx).W: ',0
000020D6= 28 78 78 78 29 2E ...   2262  xxxL            DC.B '(xxx).L: ',0
000020E0= 23 28 64 61 74 61 ...   2263  iData           DC.B '#(data): ',0
000020EA                          2264  
000020EA= 41 00                   2265  letterA         DC.B 'A', 0
000020EC= 44 00                   2266  letterD         DC.B 'D', 0
000020EE                          2267  
000020EE= 2B 00                   2268  plus            DC.B '+', 0
000020F0= 2D 00                   2269  minus           DC.B '-', 0
000020F2= 28 00                   2270  lPrn            DC.B '(', 0
000020F4= 29 00                   2271  rPrn            DC.B ')', 0
000020F6                          2272  
000020F6                          2273  
000020F6= 00000000                2274  startLocation       DC.L    0
000020FA= 00000000                2275  endLocation         DC.L    0
000020FE                          2276  
000020FE                          2277  
000020FE                          2278     
000020FE                          2279      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 1540
ADDA                14A2
ADDABODY            14EA
ADDAINSTRUCTION     D000
ADDAMASK            F000
ADDAMESSAGE         2080
ADDDEST             1604
ADDDESTEA           1534
ADDDESTEAMASKS      153A
ADDI                1772
ADDIBODY            179E
ADDIDONE            17DC
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         2092
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          2086
ADDRESS_DONE        1C04
ADDRESS_EXIT        1BFE
ADDR_ABS_LONG       1E66
ADDR_ABS_SHORT      1E52
ADDR_IMMEDIATE_DATA  1E7A
ADDR_REG_DIRECT     1D8A
ADDR_REG_INDIRECT   1DA4
ADDR_REG_INDIRECT_DEC  1E14
ADDR_REG_INDIRECT_INC  1DD6
ADDSOURCE           15BC
BCC                 1AB8
BCCBYTE             1B0A
BCCDONE             1B20
BCCINSTRUCTION      6000
BCCLIST             1FEF
BCCLONG             1B18
BCCMASK             F000
BCCMESSAGE          20B8
BCCWORD             1B10
BEGIN               5001
BEGIN_ADDRESS       1B90
BYTE                1
CC                  4
CCM                 1FAF
CHECKCC             1ACE
CHECKMOVEADEST      1A64
CHECKMOVEDEST       19B2
CHECKOPCODE         1050
CK_ADDR_DONE        1D14
CK_ADDR_RANGE       1CE8
CK_ADDR_RANGE_ERROR  1D04
CK_BOUNDRY          1C2C
CK_BOUNDRY_ERROR    1C4E
CK_SIZE_ERROR       1C62
CLEARLINE           2068
CMPI                1874
CMPIBODY            189C
CMPIDONE            18DA
CMPIEA              1866
CMPIEAMASKS         186D
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         209D
CONDITIONCODEMESSAGE  2000
CS                  5
CSM                 1FB3
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         20BF
DATA_REG_DIRECT     1D70
ELPROMPT            1ED1
END                 FFFFFE
ENDLOCATION         20FA
ENDLOCATIONPROMPT   2055
END_ADDRESS         1BD4
ENTER_ADDR_EDIT_ALL  1C06
ENTER_ADDR_EDIT_ALL_EXIT  1C2A
EQ                  7
EQM                 1FB7
EVEN_MSG            1F8D
FALSEPOSITIVE       1070
FARLABEL            FFE
FIN                 1B8C
FOUNDCC             1AE0
GE                  C
GEM                 1FBB
GET_EFFECTIVE_ADDRESS  1D18
GET_EFFECTIVE_ADDRESS_EXIT  1E8A
GET_EFFECTIVE_ADDRESS_OTHER  1D54
GT                  E
GTM                 1FBF
HANDLEBYTEDATA      1B60
HEX_RANGE_ERROR     1CD0
HI                  2
HIM                 1FC3
IDATA               20E0
INSTLABELLIST       10DA
INSTMASKLIST        10B8
INSTOPLIST          1096
INSTOPLIST2         109A
INVALIDEA           1E8A
INVALIDMSG          1F00
INVCHARMSG          1F45
JSR                 18F2
JSRBODY             191A
JSRDONE             193A
JSREA               18EA
JSREAMASKS          18EE
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          20A3
LCASEHEX            1CB2
LE                  F
LEM                 1FC7
LETTERA             20EA
LETTERD             20EC
LONG                4
LPRN                20F2
LS                  3
LSLEA               11CC
LSLMESSAGE          206B
LSLREG              1236
LSM                 1FCB
LSREA               11BC
LSRLCHECKI          128C
LSRLCHECKIR         1276
LSRLCHECKIRRETURN   128A
LSRLCHECKR          12C0
LSRLEA              1174
LSRLEAMASKS         117A
LSRLREG             1200
LSRLREGBODY         1246
LSRLREGINSTRUCTION  E008
LSRLREGMASK         F018
LSRLWEA             1180
LSRLWEABODY         11DC
LSRLWEACHECKDIRECTION  11A8
LSRLWEAINSTRUCTION  E2C0
LSRLWEAMASK         FEC0
LSRMESSAGE          2070
LSRREG              1226
LT                  D
LTM                 1FCF
MAIN_LOOP           1026
MATCH               1076
MI                  B
MIM                 1FD3
MINUS               20F0
MOVE                198A
MOVEA               1A3C
MOVEABODY           1A92
MOVEADESTEA         1A38
MOVEADESTEAMASKS    1A3A
MOVEAMESSAGE        20C5
MOVEBODY            19E0
MOVEDESTEA          197C
MOVEDESTEAMASKS     1983
MOVEINSTRUCTION     0
MOVEM               1660
MOVEMASK            C000
MOVEMBODY           16CA
MOVEMESSAGE         20B2
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     1656
MOVEMMEMTOREGEAMASKS  165B
MOVEMMESSAGE        208B
MOVEMREGTOMEMEA     164C
MOVEMREGTOMEMEAMASKS  1651
MOVESOURCEEA        196A
MOVESOURCEEAMASKS   1973
NE                  6
NEG                 170C
NEGBODY             1734
NEGDONE             1762
NEGEA               16FC
NEGEAMASKS          1704
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          20BA
NEM                 1FD7
NEXTHEX             1C78
NEXTHEXDONE         1CCA
NEXTHEXRETURN       1CE6
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 194A
NOPMESSAGE          20AD
ORI                 17EC
ORIBODY             1818
ORIDONE             1856
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          2098
PARSEHEXSTRING      1C76
PL                  A
PLM                 1FDB
PLUS                20EE
PRGORG              1000
PROCESS_OP_CODES    1D16
PROCESS_OP_CODES_EXIT  1D16
PROMPT_USER         1014
RA                  0
RAM                 1FE7
RPRN                20F4
RTS                 195A
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          20A8
SLPROMPT            1EA0
SNIPPET             111E
SNIPPETEND          1170
SPC                 1FAD
SPC_LEN             1FAE
SR                  1
SRM                 1FEB
STACK               5000
START               1000
STARTLOCATION       20F6
STARTLOCATIONPROMPT  2040
SUB                 1392
SUBDEST             145A
SUBINSTRUCTION      9000
SUBMASK             F000
SUBMESSAGE          207B
SUBQ                12EA
SUBQBODY            1322
SUBQEA              12DA
SUBQEAMASKS         12E2
SUBQINSTRUCTION     5100
SUBQMASK            F100
SUBQMESSAGE         2075
SUBSOURCE           1412
SWITCHMODEANDREG    1E8C
TOEIGHT             138E
UCASEHEX            1C9A
UNKNOWNOPCODE       1B3A
VALIDADDA           14C0
VALIDADDDESTEA      1590
VALIDADDIMODES      1774
VALIDADDSOURCEEA    1566
VALIDCMPIMODES      1876
VALIDJSRMODES       18F4
VALIDLSRL           1182
VALIDMEMTOREG       169C
VALIDMOVEADESTMODES  1A66
VALIDMOVEASOURCEMODES  1A3E
VALIDMOVEDESTMODES  19B4
VALIDMOVESOURCEMODES  198C
VALIDNEGMODES       170E
VALIDORIMODES       17EE
VALIDREGTOMEM       1676
VALIDSUBDESTEA      13E2
VALIDSUBQ           12FC
VALIDSUBSOURCEEA    13B8
VC                  8
VCM                 1FDF
VS                  9
VSM                 1FE3
WORD                2
XXXL                20D6
XXXW                20CC
ZEROTOEIGHT         1384
ZEROTOEIGHTRETURN   138C

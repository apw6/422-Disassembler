00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/6/2014 4:47:07 PM

00000000                             1  *##########################################################################
00000000                             2  * Title      : 
00000000                             3  * Written by : Andrew Watson
00000000                             4  *            : Elaine Keller
00000000                             5  *            : Robert Anderson
00000000                             6  * Date       : 11/14/2014
00000000                             7  * Description: 
00000000                             8  *##########################################################################
00000000                             9  
00000000                            10  ***Possible Bug***
00000000                            11  *can not tell data from an
00000000                            12  *unidentified instruction from an actual
00000000                            13  *instruction therefore causing errors.
00000000                            14  *may not actually be a bug because data
00000000                            15  *is data to the machine, and if you modify
00000000                            16  *the instructions in memory for a program
00000000                            17  *by moivng data, you can modify the instuctions
00000000                            18  *executed.
00000000                            19  
00000000                            20  
00000000                            21  ***************************************************************************
00000000                            22  *                   Variable/Data Definitions
00000000                            23  ***************************************************************************
00000000                            24  
00000000  =00005000                 25  stack   EQU   $00005000
00000000  =00005001                 26  begin   EQU   $00005001
00000000  =00FFFFFE                 27  end     EQU   $00FFFFFE
00000000  =00000001                 28  byte    EQU   1
00000000  =00000002                 29  word    EQU   2
00000000  =00000004                 30  long    EQU   4
00000000  =00001000                 31  prgorg  EQU   $1000
00000000                            32  
00000FFE                            33      ORG $00000FFE
00000FFE                            34  FarLabel:
00001000                            35      ORG    prgorg
00001000                            36  start:
00001000  4FF8 5000                 37          LEA stack, SP ;initialize stack
00001004                            38  
00001000                            39      ORG    prgorg
00001000                            40  
00001000                            41  ******************************************************************************
00001000                            42  *                   Begin processing active code
00001000                            43  ******************************************************************************
00001000                            44      
00001000                            45  start:
00001000                            46  
00001000  4FF8 5000                 47          LEA         stack, SP           ;Initialize stack
00001004                            48          
00001004                            49  *.............................................................................
00001004                            50  * Debug Mode - Comment out when done
00001004  267C 000010FE             51          MOVE.L      #snippet,A3
0000100A  287C 00001138             52          MOVE.L      #snippetEnd,A4
00001010  6000 0014                 53          BRA         main_Loop
00001014                            54  * Debug Mode - Comment out when done
00001014                            55  *.............................................................................        
00001014                            56          
00001014                            57  prompt_user:
00001014                            58  
00001014  6100 0814                 59          BSR         begin_address
00001018  B67C FFFF                 60          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000101C  6700 0808                 61          BEQ         fin                 ;Yes, then exit
00001020                            62          
00001020  6000 0004                 63          BRA         main_Loop
00001024                            64          ;BSR         process_op_codes
00001024  60EE                      65          BRA         prompt_user
00001026                            66                  
00001026                            67  ******************************************************************************
00001026                            68  *                   Begin processing OP Codes
00001026                            69  ******************************************************************************
00001026                            70   
00001026                            71  main_Loop:
00001026                            72  
00001026  B9CB                      73          CMPA.L A3,A4 ;check end of prog
00001028  6700 07FC                 74          BEQ fin
0000102C                            75          
0000102C  3213                      76          MOVE.W (A3),D1 ;copy word from other prog to analyze as instruction
0000102E                            77          
0000102E                            78          ;handle an odd memory access(instructions will never be misaligned)
0000102E  240B                      79          MOVE.L A3,D2 ; copy address to D2
00001030  0202 0001                 80          ANDI.B #%00000001,D2 ;mask everything except the least significant bit
00001034  0C02 0001                 81          CMPI.B #1,D2 ;compare the least sig bit of the address to one
00001038  6700 07C0                 82          BEQ handlebytedata ;the least sig bit will only be one if the insrtuction
0000103C                            83                             ;is odd(misaligned) and therefore not an instruction
0000103C                            84          
0000103C  7600                      85          MOVEQ.L #0,D3
0000103E                            86          
0000103E                            87          ***things to save A3,A4,D1(?)***
0000103E  48E7 0018                 88          MOVEM.L A3-A4,-(SP)
00001042  6100 000C                 89          BSR checkOPcode
00001046  4CDF 1800                 90          MOVEM.L (SP)+,A3-A4
0000104A  D7C7                      91          ADDA.L  D7,A3 ;look past data that was part of the instruction
0000104C                            92          
0000104C  548B                      93          ADDQ.L  #word,A3
0000104E  60D6                      94          BRA     main_Loop 
00001050                            95          
00001050                            96  checkOPcode:
00001050                            97  
00001050                            98  
00001050  7E00                      99          MOVEQ.L #0,D7
00001052                           100          
00001052  41F9 00001096            101          LEA     instOPList,A0 ;get instruction signitrue list in A0
00001058  D1C3                     102          ADDA.L  D3,A0 ;get correct sig         
0000105A                           103          
0000105A  43F9 000010B0            104          LEA     instMaskList,A1 ;get instruction mask in A1
00001060  D3C3                     105          ADDA.L  D3,A1  ;get correct mast
00001062                           106          
00001062  3401                     107          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001064                           108          
00001064  C451                     109          AND.W   (A1),D2 ;mask instruction
00001066                           110          
00001066                           111          
00001066                           112          
00001066                           113          
00001066  B450                     114          CMP.W   (A0),D2 ;compare to sig
00001068  6700 000C                115          BEQ     match ;if sig matches branch
0000106C  5483                     116          ADDQ.L  #word,D3 ;add to D3 to check for next instruction
0000106E  60E0                     117          BRA checkOPcode
00001070                           118          
00001070                           119  falsePositive:
00001070                           120          
00001070  103C 00FF                121          MOVE.B #-1,D0
00001074  4E75                     122          RTS
00001076                           123  
00001076                           124  match:
00001076                           125          
00001076  43F9 000010CA            126          LEA     instLabelList,A1 ;get instruction code label
0000107C  D3C3                     127          ADDA.L  D3,A1 ;get correct label
0000107E  D3C3                     128          ADDA.L  D3,A1
00001080  5483                     129          ADDQ.L  #word,D3 ;add to D3 incase false positive
00001082  2251                     130          MOVEA.L (A1),A1
00001084  48E7 1000                131          MOVEM.L D3,-(SP) ; save D3
00001088  4E91                     132          JSR     (A1)
0000108A  4CDF 0008                133          MOVEM.L (SP)+,D3 ;restore D3
0000108E  B03C 00FF                134          CMP.B   #-1,D0
00001092  67BC                     135          BEQ     checkOPcode
00001094  4E75                     136          RTS
00001096                           137          
00001096                           138  
00001096= D000 D000 4880 0...      139  instOPList DC.W addaInstruction,addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruction         
000010B0= F000 F000 FB80 F...      140  instMaskList DC.W addaMask,addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
000010CA= 0000113C 000011DA ...    141  instLabelList DC.L ADDA,ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
000010FE                           142  
000010FE                           143  snippet:
000010FE  4E71                     144           NOP
00001100  60FC                     145           BRA snippet
00001102  6000 FEFA                146           BRA FarLabel
00001106  67F6                     147           BEQ snippet
00001108  6E00 029C                148           BGT NEG
0000110C  61F0                     149           BSR snippet
0000110E  4441                     150           NEG D1
00001110  3239 00008500            151           MOVE.W $8500,D1
00001116  0645 001E                152           ADDI.W #30,D5
0000111A  4E75                     153           RTS
0000111C  4EB8 0054                154           JSR $54
00001120  0C41 0003                155           CMPI #3,D1
00001124  0041 0003                156           ORI  #3,D1
00001128  48E7 0018                157           MOVEM.L A3-A4,-(SP)
0000112C  D401                     158           ADD.B D1,D2
0000112E  0603 000A                159           ADD.B #10,D3
00001132  D7FC 00000463            160           ADDA.L #1123,A3
00001138                           161           
00001138                           162  
00001138                           163           
00001138                           164  snippetEnd:
00001138  FFFF FFFF                165           SIMHALT
0000113C                           166      
0000113C                           167  
0000113C                           168  ADDA:
0000113C                           169          
0000113C                           170  
0000113C                           171          
0000113C  7000                     172          MOVEQ.L #0, D0 ;clear D0
0000113E                           173          
0000113E                           174          ;check opmode field
0000113E  3401                     175          MOVE.W D1,D2 ;copy inst to D2
00001140  EC4A                     176          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
00001142  0202 0007                177          ANDI.B #%00000111,D2 ;mask out rest of byte
00001146  0C02 0007                178          CMPI.B #%111,D2 ;compare to 7
0000114A  6700 000E                179          BEQ validAdda ;thats valid
0000114E  0C02 0003                180          CMPI.B #%11,D2 ;compare to 3
00001152  6700 0006                181          BEQ validAdda ;also valid
00001156  6000 FF18                182          BRA falsePositive ;all thats left is invalid 
0000115A                           183          
0000115A                           184  validAdda:
0000115A                           185          
0000115A  43F9 0000160D            186          LEA moveSourceEAmasks,A1 ;load the list of masks
00001160  D3C0                     187          ADDA.L D0,A1 ;displace to a specific mask
00001162  1A11                     188          MOVE.B (A1),D5 ;move the mask to D5
00001164                           189          
00001164  0C05 0000                190          CMPI.B #0,D5 ;check if the mask is 0
00001168  6700 FF06                191          BEQ falsePositive ;branch if it is
0000116C                           192          
0000116C  1401                     193          MOVE.B D1,D2 ;copy instruction to D2
0000116E  C405                     194          AND.B D5,D2  ;mask D2
00001170                           195          
00001170  43F9 00001604            196          LEA moveSourceEA,A1 ;load the list of valid modes
00001176  D3C0                     197          ADDA.L D0,A1 ;displace to a specific mode
00001178  1811                     198          MOVE.B (A1),D4 ;move mode to D4
0000117A  B404                     199          CMP.B D4,D2 ;compare mode to masked value
0000117C  6700 0006                200          BEQ  addaBody ;if its match, its a valid mode and we can procede
00001180                           201          
00001180  5280                     202          ADDQ.L #1,D0 ;add one to displacement
00001182  60D6                     203          BRA validAdda ;check for next mode
00001184                           204          
00001184                           205          
00001184                           206  addaBody
00001184                           207  
00001184  43F9 00001D05            208          LEA     addaMessage,A1  ;move string for MOVE
0000118A  103C 000E                209          MOVE.B  #14,D0        ;set for task to display null terminated 
0000118E                           210                                ;string with CR, LF
0000118E  4E4F                     211          TRAP    #15
00001190                           212          
00001190                           213          ;do EA
00001190                           214          
00001190  3401                     215          MOVE.W  D1,D2 ;check mode
00001192  C43C 003F                216          AND.B   #%00111111,D2
00001196  1A02                     217          MOVE.B  D2,D5
00001198  48E7 4000                218          MOVEM.L D1,-(SP)
0000119C  6100 0814                219          BSR     Get_Effective_Address
000011A0  4CDF 0002                220          MOVEM.L (SP)+,D1
000011A4                           221          
000011A4                           222          ;print separator
000011A4                           223          
000011A4                           224          ;Then do Dn
000011A4                           225          
000011A4  3401                     226          MOVE.W  D1,D2
000011A6  E04A                     227          LSR.W   #8,D2 ;move reg into first byte
000011A8  E20A                     228          LSR.B   #1,D2 ;line it up to least sig bit
000011AA  C43C 0007                229          AND.B   #%00000111,D2 ;force mode to An
000011AE  5002                     230          ADDI.B  #%00001000,D2 
000011B0  1A02                     231          MOVE.B  D2,D5
000011B2  48E7 4000                232          MOVEM.L D1,-(SP)
000011B6  6100 07FA                233          BSR     Get_Effective_Address
000011BA  4CDF 0002                234          MOVEM.L (SP)+,D1
000011BE                           235          
000011BE  43F9 00001D02            236          LEA     clearLine,A1  ;move string for a CR and LF
000011C4  103C 000E                237          MOVE.B  #14,D0        ;set for task to display null terminated 
000011C8                           238                                ;string without CR, LF
000011C8  4E4F                     239          TRAP    #15
000011CA                           240  
000011CA  7000                     241          MOVEQ.L #0,D0
000011CC  4E75                     242          RTS
000011CE                           243  
000011CE                           244  
000011CE                           245      
000011CE= 10 18 20 38 39 00        246  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
000011D4= 38 38 38 3F 3F 00        247  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
000011DA                           248  
000011DA                           249  ADD:
000011DA                           250          
000011DA                           251  
000011DA                           252          
000011DA  7000                     253          MOVEQ.L #0, D0 ;clear D0
000011DC                           254          
000011DC                           255          ;Figure out if EA is source or destination
000011DC  3401                     256          MOVE.W D1,D2 ;copy inst to D2
000011DE  EC4A                     257          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
000011E0  0202 0007                258          ANDI.B #%00000111,D2 ;mask out rest of byte
000011E4  0C02 0002                259          CMPI.B #2,D2 ;compare to 2
000011E8  6F00 0016                260          BLE validAddSourceEA ;2 or less is EA is source
000011EC                           261          
000011EC  0C02 0007                262          CMPI.B #%111,D2 ;compare to 7
000011F0  6700 FE7E                263          BEQ falsePositive ;thats not valid
000011F4  0C02 0003                264          CMPI.B #%11,D2 ;compare to 3
000011F8  6700 FE76                265          BEQ falsePositive ;also not valid
000011FC  6000 002C                266          BRA validAddDestEA ;all thats left is valid EA as Dest 
00001200                           267          
00001200                           268  validAddSourceEA:
00001200                           269          
00001200  43F9 0000160D            270          LEA moveSourceEAmasks,A1 ;load the list of masks
00001206  D3C0                     271          ADDA.L D0,A1 ;displace to a specific mask
00001208  1A11                     272          MOVE.B (A1),D5 ;move the mask to D5
0000120A                           273          
0000120A  0C05 0000                274          CMPI.B #0,D5 ;check if the mask is 0
0000120E  6700 FE60                275          BEQ falsePositive ;branch if it is
00001212                           276          
00001212  1401                     277          MOVE.B D1,D2 ;copy instruction to D2
00001214  C405                     278          AND.B D5,D2  ;mask D2
00001216                           279          
00001216  43F9 00001604            280          LEA moveSourceEA,A1 ;load the list of valid modes
0000121C  D3C0                     281          ADDA.L D0,A1 ;displace to a specific mode
0000121E  1811                     282          MOVE.B (A1),D4 ;move mode to D4
00001220  B404                     283          CMP.B D4,D2 ;compare mode to masked value
00001222  6700 0032                284          BEQ  addSource ;if its match, its a valid mode and we can procede
00001226                           285          
00001226  5280                     286          ADDQ.L #1,D0 ;add one to displacement
00001228  60D6                     287          BRA validAddSourceEA ;check for next mode
0000122A                           288          
0000122A                           289          
0000122A                           290  validAddDestEA:
0000122A                           291          
0000122A  43F8 11D4                292          LEA addDestEAmasks,A1 ;load the list of masks
0000122E  D3C0                     293          ADDA.L D0,A1 ;displace to a specific mask
00001230  1A11                     294          MOVE.B (A1),D5 ;move the mask to D5
00001232                           295          
00001232  0C05 0000                296          CMPI.B #0,D5 ;check if the mask is 0
00001236  6700 FE38                297          BEQ falsePositive ;branch if it is
0000123A                           298          
0000123A  3401                     299          MOVE.W D1,D2 ;copy instruction to D2
0000123C  EC4A                     300          LSR.W #6,D2  ;move mode
0000123E  6100 08E6                301          BSR switchModeAndReg ;switch register and mode
00001242  C405                     302          AND.B D5,D2  ;mask D2
00001244                           303          
00001244  43F8 11CE                304          LEA addDestEA,A1 ;load the list of valid modes
00001248  D3C0                     305          ADDA.L D0,A1 ;displace to a specific mode
0000124A  1811                     306          MOVE.B (A1),D4 ;move mode to D4
0000124C  B404                     307          CMP.B D4,D2 ;compare mode to masked value
0000124E  6700 004E                308          BEQ addDest ;if its match, its a valid mode and we can procede
00001252                           309          
00001252  5280                     310          ADDQ.L #1,D0 ;add one to displacement
00001254  60D4                     311          BRA validAddDestEA ;check for next mode
00001256                           312          
00001256                           313  addSource
00001256                           314  
00001256  43F9 00001D0C            315          LEA     addMessage,A1  ;move string for MOVE
0000125C  103C 000E                316          MOVE.B  #14,D0        ;set for task to display null terminated 
00001260                           317                                ;string with CR, LF
00001260  4E4F                     318          TRAP    #15
00001262                           319          
00001262                           320          ;do EA
00001262                           321          
00001262  3401                     322          MOVE.W  D1,D2 ;check mode
00001264  C43C 003F                323          AND.B   #%00111111,D2
00001268  1A02                     324          MOVE.B  D2,D5
0000126A  48E7 4000                325          MOVEM.L D1,-(SP)
0000126E  6100 0742                326          BSR     Get_Effective_Address
00001272  4CDF 0002                327          MOVEM.L (SP)+,D1
00001276                           328          
00001276                           329          ;print separator
00001276                           330          
00001276                           331          ;Then do Dn
00001276                           332          
00001276  3401                     333          MOVE.W  D1,D2
00001278  E04A                     334          LSR.W   #8,D2 ;move reg into first byte
0000127A  E20A                     335          LSR.B   #1,D2 ;line it up to least sig bit
0000127C  C43C 0007                336          AND.B   #%00000111,D2 ;force mode to Dn
00001280  1A02                     337          MOVE.B  D2,D5
00001282  48E7 4000                338          MOVEM.L D1,-(SP)
00001286  6100 072A                339          BSR     Get_Effective_Address
0000128A  4CDF 0002                340          MOVEM.L (SP)+,D1
0000128E                           341          
0000128E  43F9 00001D02            342          LEA     clearLine,A1  ;move string for a CR and LF
00001294  103C 000E                343          MOVE.B  #14,D0        ;set for task to display null terminated 
00001298                           344                                ;string without CR, LF
00001298  4E4F                     345          TRAP    #15
0000129A                           346  
0000129A  7000                     347          MOVEQ.L #0,D0
0000129C  4E75                     348          RTS
0000129E                           349  
0000129E                           350  addDest
0000129E                           351  
0000129E  43F9 00001D0C            352          LEA     addMessage,A1  ;move string for MOVE
000012A4  103C 000E                353          MOVE.B  #14,D0        ;set for task to display null terminated 
000012A8                           354                                ;string with CR, LF
000012A8  4E4F                     355          TRAP    #15
000012AA                           356          
000012AA                           357          ;Do Dn
000012AA                           358          
000012AA  3401                     359          MOVE.W  D1,D2
000012AC  E04A                     360          LSR.W   #8,D2 ;move reg into first byte
000012AE  E20A                     361          LSR.B   #1,D2 ;line it up to least sig bit
000012B0  C43C 0007                362          AND.B   #%00000111,D2 ;force mode to Dn
000012B4  1A02                     363          MOVE.B  D2,D5
000012B6  48E7 4000                364          MOVEM.L D1,-(SP)
000012BA  6100 06F6                365          BSR     Get_Effective_Address
000012BE  4CDF 0002                366          MOVEM.L (SP)+,D1
000012C2                           367          
000012C2                           368          
000012C2                           369          ;print separator
000012C2                           370          
000012C2                           371          ;Then do EA
000012C2                           372          
000012C2  3401                     373          MOVE.W  D1,D2 ;check mode
000012C4  C43C 003F                374          AND.B   #%00111111,D2
000012C8  1A02                     375          MOVE.B  D2,D5
000012CA  48E7 4000                376          MOVEM.L D1,-(SP)
000012CE  6100 06E2                377          BSR     Get_Effective_Address
000012D2  4CDF 0002                378          MOVEM.L (SP)+,D1
000012D6                           379          
000012D6                           380          
000012D6  43F9 00001D02            381          LEA     clearLine,A1  ;move string for a CR and LF
000012DC  103C 000E                382          MOVE.B  #14,D0        ;set for task to display null terminated 
000012E0                           383                                ;string without CR, LF
000012E0  4E4F                     384          TRAP    #15
000012E2                           385  
000012E2  7000                     386          MOVEQ.L #0,D0
000012E4  4E75                     387          RTS
000012E6                           388  
000012E6                           389  
000012E6= 10 20 38 39 00           390  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
000012EB= 38 38 3F 3F 00           391  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
000012F0                           392  
000012F0= 10 18 38 39 00           393  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
000012F5= 38 38 3F 3F 00           394  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
000012FA                           395  
000012FA                           396  MOVEM:
000012FA                           397          
000012FA                           398  
000012FA                           399          
000012FA  7000                     400          MOVEQ.L #0, D0 ;clear D0
000012FC                           401          
000012FC                           402          ;Figure out which direction we are going
000012FC  3401                     403          MOVE.W D1,D2 ;copy inst to D2
000012FE  E64A                     404          LSR.W #3,D2 ;shift direction bit into most sig bit of first byte
00001300  0202 0080                405          ANDI.B #%10000000,D2 ;mask out everything but direction bit in first byte
00001304  0C02 0000                406          CMPI.B #0,D2 ;compare bit to zero
00001308  6700 0006                407          BEQ validRegToMem ;if zero, reg to mem
0000130C  6000 0028                408          BRA validMemToReg ;else, its mem to reg
00001310                           409          
00001310                           410  validRegToMem:
00001310                           411          
00001310  43F8 12EB                412          LEA movemRegToMemEAmasks,A1 ;load the list of masks
00001314  D3C0                     413          ADDA.L D0,A1 ;displace to a specific mask
00001316  1A11                     414          MOVE.B (A1),D5 ;move the mask to D5
00001318                           415          
00001318  0C05 0000                416          CMPI.B #0,D5 ;check if the mask is 0
0000131C  6700 FD52                417          BEQ falsePositive ;branch if it is
00001320                           418          
00001320  1401                     419          MOVE.B D1,D2 ;copy instruction to D2
00001322  C405                     420          AND.B D5,D2  ;mask D2
00001324                           421          
00001324  43F8 12E6                422          LEA movemRegToMemEA,A1 ;load the list of valid modes
00001328  D3C0                     423          ADDA.L D0,A1 ;displace to a specific mode
0000132A  1811                     424          MOVE.B (A1),D4 ;move mode to D4
0000132C  B404                     425          CMP.B D4,D2 ;compare mode to masked value
0000132E  6700 0034                426          BEQ  movemBody ;if its match, its a valid mode and we can procede
00001332                           427          
00001332  5280                     428          ADDQ.L #1,D0 ;add one to displacement
00001334  60DA                     429          BRA validRegToMem ;check for next mode
00001336                           430          
00001336                           431          
00001336                           432  validMemToReg:
00001336                           433          
00001336  43F8 12F5                434          LEA movemMemToRegEAmasks,A1 ;load the list of masks
0000133A  D3C0                     435          ADDA.L D0,A1 ;displace to a specific mask
0000133C  1A11                     436          MOVE.B (A1),D5 ;move the mask to D5
0000133E                           437          
0000133E  0C05 0000                438          CMPI.B #0,D5 ;check if the mask is 0
00001342  6700 FD2C                439          BEQ falsePositive ;branch if it is
00001346                           440          
00001346  3401                     441          MOVE.W D1,D2 ;copy instruction to D2
00001348  EC4A                     442          LSR.W #6,D2  ;move mode
0000134A  6100 07DA                443          BSR switchModeAndReg ;switch register and mode
0000134E  C405                     444          AND.B D5,D2  ;mask D2
00001350                           445          
00001350  43F8 12F0                446          LEA movemMemToRegEA,A1 ;load the list of valid modes
00001354  D3C0                     447          ADDA.L D0,A1 ;displace to a specific mode
00001356  1811                     448          MOVE.B (A1),D4 ;move mode to D4
00001358  B404                     449          CMP.B D4,D2 ;compare mode to masked value
0000135A  6700 0008                450          BEQ movemBody ;if its match, its a valid mode and we can procede
0000135E                           451          
0000135E  5280                     452          ADDQ.L #1,D0 ;add one to displacement
00001360  6000 02EC                453          BRA validMoveDestModes ;check for next mode
00001364                           454          
00001364                           455  movemBody
00001364                           456  
00001364  43F9 00001D12            457          LEA     movemMessage,A1  ;move string for MOVE
0000136A  103C 000E                458          MOVE.B  #14,D0        ;set for task to display null terminated 
0000136E                           459                                ;string with CR, LF
0000136E  4E4F                     460          TRAP    #15
00001370                           461          
00001370                           462          ;show list
00001370                           463          
00001370  5487                     464          ADDQ.L #word,D7 ;read past the register list mask(word) following
00001372                           465                          ;the instruction
00001372                           466          
00001372                           467          ;print separator
00001372                           468          
00001372  3401                     469          MOVE.W  D1,D2 ;check mode
00001374  C43C 003F                470          AND.B   #%00111111,D2
00001378  1A02                     471          MOVE.B  D2,D5
0000137A  48E7 4000                472          MOVEM.L D1,-(SP)
0000137E  6100 0632                473          BSR     Get_Effective_Address
00001382  4CDF 0002                474          MOVEM.L (SP)+,D1
00001386                           475          
00001386                           476          
00001386  43F9 00001D02            477          LEA     clearLine,A1  ;move string for a CR and LF
0000138C  103C 000E                478          MOVE.B  #14,D0        ;set for task to display null terminated 
00001390                           479                                ;string without CR, LF
00001390  4E4F                     480          TRAP    #15
00001392                           481  
00001392  7000                     482          MOVEQ.L #0,D0
00001394  4E75                     483          RTS
00001396                           484  
00001396                           485  
00001396                           486      
00001396= 00 10 18 20 28 38 ...    487  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
0000139E= 38 38 38 38 38 3F ...    488  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
000013A6                           489     
000013A6                           490  NEG:            
000013A6                           491       
000013A6  7000                     492          MOVEQ.L #0, D0 ;clear D0
000013A8                           493          
000013A8                           494  validNegModes:
000013A8                           495          
000013A8  43F8 139E                496          LEA NegEAmasks,A1 ;load the list of masks
000013AC  D3C0                     497          ADDA.L D0,A1 ;displace to a specific mask
000013AE  1A11                     498          MOVE.B (A1),D5 ;move the mask to D5
000013B0                           499          
000013B0  0C05 0000                500          CMPI.B #0,D5 ;check if the mask is 0
000013B4  6700 FCBA                501          BEQ falsePositive ;branch if it is
000013B8                           502          
000013B8  1401                     503          MOVE.B D1,D2 ;copy instruction to D2
000013BA  C405                     504          AND.B D5,D2  ;mask D2
000013BC  43F8 1396                505          LEA NegEA,A1 ;load the list of valid modes
000013C0  D3C0                     506          ADDA.L D0,A1 ;displace to a specific mode
000013C2  1811                     507          MOVE.B (A1),D4 ;move mode to D4
000013C4  B404                     508          CMP.B D4,D2 ;compare mode to masked value
000013C6  6700 0006                509          BEQ NegBody ;if its match, its a valid mode and we can procede
000013CA                           510          
000013CA  5280                     511          ADDQ.L #1,D0 ;add one to displacement
000013CC  60DA                     512          BRA validNegModes ;check for next mode
000013CE                           513          
000013CE                           514  NegBody:
000013CE                           515  
000013CE                           516  
000013CE  3401                     517          MOVE.W  D1,D2 ;copy inst to D2
000013D0  C47C 0600                518          AND.W  #%0011000000000,D2 ;mask word for size
000013D4  0C42 0000                519          CMPI.W #0,D2 ;0 is the only non valid size
000013D8  6700 FC96                520          BEQ falsePositive ; zero is not valid
000013DC                           521  
000013DC  43F9 00001D48            522          LEA     negMessage,A1  ;move string for NEG info
000013E2  103C 000E                523          MOVE.B  #14,D0        ;set for task to display null terminated 
000013E6                           524                                ;string without CR, LF
000013E6  4E4F                     525          TRAP    #15
000013E8                           526          
000013E8  3401                     527          MOVE.W D1,D2
000013EA  C47C 003F                528          AND #%000000000111111,D2
000013EE  1A02                     529          MOVE.B D2,D5
000013F0                           530          
000013F0  48E7 4000                531          MOVEM.L D1,-(SP)
000013F4  6100 05BC                532          BSR     Get_Effective_Address
000013F8  4CDF 0002                533          MOVEM.L (SP)+,D1
000013FC                           534          
000013FC                           535                
000013FC                           536          
000013FC                           537  NEGdone:
000013FC                           538  
000013FC  43F9 00001D02            539          LEA     clearLine,A1  ;move string for a CR and LF
00001402  103C 000E                540          MOVE.B  #14,D0        ;set for task to display null terminated 
00001406                           541                                ;string without CR, LF
00001406  4E4F                     542          TRAP    #15
00001408  7000                     543          MOVEQ.L #0,D0
0000140A  4E75                     544          RTS
0000140C                           545          
0000140C                           546   ADDI:            
0000140C                           547       
0000140C  7000                     548          MOVEQ.L #0, D0 ;clear D0
0000140E                           549          
0000140E                           550  validAddiModes:
0000140E                           551          
0000140E                           552          
0000140E  43F9 00001507            553          LEA cmpiEAmasks,A1 ;load the list of masks
00001414  D3C0                     554          ADDA.L D0,A1 ;displace to a specific mask
00001416  1A11                     555          MOVE.B (A1),D5 ;move the mask to D5
00001418                           556          
00001418  0C05 0000                557          CMPI.B #0,D5 ;check if the mask is 0
0000141C  6700 FC52                558          BEQ falsePositive ;branch if it is
00001420                           559          
00001420  1401                     560          MOVE.B D1,D2 ;copy instruction to D2
00001422  C405                     561          AND.B D5,D2  ;mask D2
00001424  43F9 00001500            562          LEA cmpiEA,A1 ;load the list of valid modes
0000142A  D3C0                     563          ADDA.L D0,A1 ;displace to a specific mode
0000142C  1811                     564          MOVE.B (A1),D4 ;move mode to D4
0000142E  B404                     565          CMP.B D4,D2 ;compare mode to masked value
00001430  6700 0006                566          BEQ addiBody ;if its match, its a valid mode and we can procede
00001434                           567          
00001434  5280                     568          ADDQ.L #1,D0 ;add one to displacement
00001436  60D6                     569          BRA validAddiModes ;check for next mode
00001438                           570          
00001438                           571  addiBody:
00001438                           572  
00001438                           573  
00001438  3401                     574          MOVE.W  D1,D2 ;copy inst to D2
0000143A  C47C 00C0                575          AND.W  #%0000000011000000,D2 ;mask word for size
0000143E  0C42 00C0                576          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001442  6700 FC2C                577          BEQ falsePositive
00001446                           578  
00001446  43F9 00001D1A            579          LEA     addiMessage,A1  ;move string for NEG info
0000144C  103C 000E                580          MOVE.B  #14,D0        ;set for task to display null terminated 
00001450                           581                                ;string without CR, LF
00001450  4E4F                     582          TRAP    #15
00001452                           583          
00001452                           584          ;go to Effective_Address for immediate data
00001452  143C 003C                585          MOVE.B #%00111100,D2
00001456  48E7 4000                586          MOVEM.L D1,-(SP)
0000145A  6100 0556                587          BSR     Get_Effective_Address
0000145E  4CDF 0002                588          MOVEM.L (SP)+,D1
00001462                           589          
00001462  3401                     590          MOVE.W D1,D2 ;copy inst to D2
00001464  C47C 003F                591          AND #%000000000111111,D2 ;and out everything but modes and regs
00001468  1A02                     592          MOVE.B D2,D5 ; copy to D5 for following BSR
0000146A                           593          
0000146A  48E7 4000                594          MOVEM.L D1,-(SP)
0000146E  6100 0542                595          BSR     Get_Effective_Address
00001472  4CDF 0002                596          MOVEM.L (SP)+,D1
00001476                           597          
00001476                           598                
00001476                           599          
00001476                           600  addidone:
00001476                           601  
00001476  43F9 00001D02            602          LEA     clearLine,A1  ;move string for a CR and LF
0000147C  103C 000E                603          MOVE.B  #14,D0        ;set for task to display null terminated 
00001480                           604                                ;string without CR, LF
00001480  4E4F                     605          TRAP    #15
00001482  7000                     606          MOVEQ.L #0,D0
00001484  4E75                     607          RTS
00001486                           608    
00001486                           609  ORI:            
00001486                           610       
00001486  7000                     611          MOVEQ.L #0, D0 ;clear D0
00001488                           612          
00001488                           613  validOriModes:
00001488                           614          
00001488                           615          
00001488  43F9 00001507            616          LEA cmpiEAmasks,A1 ;load the list of masks
0000148E  D3C0                     617          ADDA.L D0,A1 ;displace to a specific mask
00001490  1A11                     618          MOVE.B (A1),D5 ;move the mask to D5
00001492                           619          
00001492  0C05 0000                620          CMPI.B #0,D5 ;check if the mask is 0
00001496  6700 FBD8                621          BEQ falsePositive ;branch if it is
0000149A                           622          
0000149A  1401                     623          MOVE.B D1,D2 ;copy instruction to D2
0000149C  C405                     624          AND.B D5,D2  ;mask D2
0000149E  43F9 00001500            625          LEA cmpiEA,A1 ;load the list of valid modes
000014A4  D3C0                     626          ADDA.L D0,A1 ;displace to a specific mode
000014A6  1811                     627          MOVE.B (A1),D4 ;move mode to D4
000014A8  B404                     628          CMP.B D4,D2 ;compare mode to masked value
000014AA  6700 0006                629          BEQ oriBody ;if its match, its a valid mode and we can procede
000014AE                           630          
000014AE  5280                     631          ADDQ.L #1,D0 ;add one to displacement
000014B0  60D6                     632          BRA validOriModes ;check for next mode
000014B2                           633          
000014B2                           634  oriBody:
000014B2                           635  
000014B2                           636  
000014B2  3401                     637          MOVE.W  D1,D2 ;copy inst to D2
000014B4  C47C 00C0                638          AND.W  #%0000000011000000,D2 ;mask word for size
000014B8  0C42 00C0                639          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
000014BC  6700 FBB2                640          BEQ falsePositive
000014C0                           641  
000014C0  43F9 00001D21            642          LEA     oriMessage,A1  ;move string for NEG info
000014C6  103C 000E                643          MOVE.B  #14,D0        ;set for task to display null terminated 
000014CA                           644                                ;string without CR, LF
000014CA  4E4F                     645          TRAP    #15
000014CC                           646          
000014CC                           647          ;go to Effective_Address for immediate data
000014CC  143C 003C                648          MOVE.B #%00111100,D2
000014D0  48E7 4000                649          MOVEM.L D1,-(SP)
000014D4  6100 04DC                650          BSR     Get_Effective_Address
000014D8  4CDF 0002                651          MOVEM.L (SP)+,D1
000014DC                           652          
000014DC  3401                     653          MOVE.W D1,D2 ;copy inst to D2
000014DE  C47C 003F                654          AND #%000000000111111,D2 ;and out everything but modes and regs
000014E2  1A02                     655          MOVE.B D2,D5 ; copy to D5 for following BSR
000014E4                           656          
000014E4  48E7 4000                657          MOVEM.L D1,-(SP)
000014E8  6100 04C8                658          BSR     Get_Effective_Address
000014EC  4CDF 0002                659          MOVEM.L (SP)+,D1
000014F0                           660          
000014F0                           661                
000014F0                           662          
000014F0                           663  oridone:
000014F0                           664  
000014F0  43F9 00001D02            665          LEA     clearLine,A1  ;move string for a CR and LF
000014F6  103C 000E                666          MOVE.B  #14,D0        ;set for task to display null terminated 
000014FA                           667                                ;string without CR, LF
000014FA  4E4F                     668          TRAP    #15
000014FC  7000                     669          MOVEQ.L #0,D0
000014FE  4E75                     670          RTS
00001500                           671  
00001500                           672          
00001500                           673          
00001500= 20 18 00 10 38 39 00     674  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
00001507= 38 38 38 38 3F 3F 00     675  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
0000150E                           676     
0000150E                           677  CMPI:            
0000150E                           678       
0000150E  7000                     679          MOVEQ.L #0, D0 ;clear D0
00001510                           680          
00001510                           681  validCmpiModes:
00001510                           682          
00001510                           683          
00001510  43F8 1507                684          LEA cmpiEAmasks,A1 ;load the list of masks
00001514  D3C0                     685          ADDA.L D0,A1 ;displace to a specific mask
00001516  1A11                     686          MOVE.B (A1),D5 ;move the mask to D5
00001518                           687          
00001518  0C05 0000                688          CMPI.B #0,D5 ;check if the mask is 0
0000151C  6700 FB52                689          BEQ falsePositive ;branch if it is
00001520                           690          
00001520  1401                     691          MOVE.B D1,D2 ;copy instruction to D2
00001522  C405                     692          AND.B D5,D2  ;mask D2
00001524  43F8 1500                693          LEA cmpiEA,A1 ;load the list of valid modes
00001528  D3C0                     694          ADDA.L D0,A1 ;displace to a specific mode
0000152A  1811                     695          MOVE.B (A1),D4 ;move mode to D4
0000152C  B404                     696          CMP.B D4,D2 ;compare mode to masked value
0000152E  6700 0006                697          BEQ CMPIBody ;if its match, its a valid mode and we can procede
00001532                           698          
00001532  5280                     699          ADDQ.L #1,D0 ;add one to displacement
00001534  60DA                     700          BRA validCmpiModes ;check for next mode
00001536                           701          
00001536                           702  CMPIBody:
00001536                           703  
00001536                           704  
00001536  3401                     705          MOVE.W  D1,D2 ;copy inst to D2
00001538  C47C 00C0                706          AND.W  #%0000000011000000,D2 ;mask word for size
0000153C  0C42 00C0                707          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001540  6700 FB2E                708          BEQ falsePositive
00001544                           709  
00001544  43F9 00001D27            710          LEA     cmpiMessage,A1  ;move string for NEG info
0000154A  103C 000E                711          MOVE.B  #14,D0        ;set for task to display null terminated 
0000154E                           712                                ;string without CR, LF
0000154E  4E4F                     713          TRAP    #15
00001550                           714          
00001550                           715          ;go to Effective_Address for immediate data
00001550  143C 003C                716          MOVE.B #%00111100,D2
00001554  48E7 4000                717          MOVEM.L D1,-(SP)
00001558  6100 0458                718          BSR     Get_Effective_Address
0000155C  4CDF 0002                719          MOVEM.L (SP)+,D1
00001560                           720          
00001560  3401                     721          MOVE.W D1,D2 ;copy inst to D2
00001562  C47C 003F                722          AND #%000000000111111,D2 ;and out everything but modes and regs
00001566  1A02                     723          MOVE.B D2,D5 ; copy to D5 for following BSR
00001568                           724          
00001568  48E7 4000                725          MOVEM.L D1,-(SP)
0000156C  6100 0444                726          BSR     Get_Effective_Address
00001570  4CDF 0002                727          MOVEM.L (SP)+,D1
00001574                           728          
00001574                           729                
00001574                           730          
00001574                           731  CMPidone:
00001574                           732  
00001574  43F9 00001D02            733          LEA     clearLine,A1  ;move string for a CR and LF
0000157A  103C 000E                734          MOVE.B  #14,D0        ;set for task to display null terminated 
0000157E                           735                                ;string without CR, LF
0000157E  4E4F                     736          TRAP    #15
00001580  7000                     737          MOVEQ.L #0,D0
00001582  4E75                     738          RTS
00001584                           739  
00001584                           740          
00001584= 10 38 39 00              741  JsrEA        DC.B %010000, %111000, %111001,0
00001588= 38 3F 3F 00              742  JsrEAmasks   DC.B %111000, %111111, %111111,0
0000158C                           743     
0000158C                           744  JSR:            
0000158C                           745       
0000158C  7000                     746          MOVEQ.L #0, D0 ;clear D0
0000158E                           747          
0000158E                           748  validJsrModes:
0000158E                           749          
0000158E  43F8 1588                750          LEA JsrEAmasks,A1 ;load the list of masks
00001592  D3C0                     751          ADDA.L D0,A1 ;displace to a specific mask
00001594  1A11                     752          MOVE.B (A1),D5 ;move the mask to D5
00001596                           753          
00001596  0C05 0000                754          CMPI.B #0,D5 ;check if the mask is 0
0000159A  6700 FAD4                755          BEQ falsePositive ;branch if it is
0000159E                           756          
0000159E  1401                     757          MOVE.B D1,D2 ;copy instruction to D2
000015A0  C405                     758          AND.B D5,D2  ;mask D2
000015A2  43F8 1584                759          LEA JsrEA,A1 ;load the list of valid modes
000015A6  D3C0                     760          ADDA.L D0,A1 ;displace to a specific mode
000015A8  1811                     761          MOVE.B (A1),D4 ;move mode to D4
000015AA  B404                     762          CMP.B D4,D2 ;compare mode to masked value
000015AC  6700 0006                763          BEQ JsrBody ;if its match, its a valid mode and we can procede
000015B0                           764          
000015B0  5280                     765          ADDQ.L #1,D0 ;add one to displacement
000015B2  60DA                     766          BRA validJsrModes ;check for next mode
000015B4                           767          
000015B4                           768  JsrBody:
000015B4                           769  
000015B4                           770  
000015B4  43F9 00001D2E            771          LEA     jsrMessage,A1  ;move string for NEG info
000015BA  103C 000E                772          MOVE.B  #14,D0        ;set for task to display null terminated 
000015BE                           773                                ;string without CR, LF
000015BE  4E4F                     774          TRAP    #15
000015C0                           775          
000015C0  3401                     776          MOVE.W D1,D2 ;copy inst to D2
000015C2  C47C 003F                777          AND #%000000000111111,D2 ;and out everything but modes and regs
000015C6  1A02                     778          MOVE.B D2,D5 ; copy to D5 for following BSR
000015C8                           779          
000015C8  48E7 4000                780          MOVEM.L D1,-(SP)
000015CC  6100 03E4                781          BSR     Get_Effective_Address
000015D0  4CDF 0002                782          MOVEM.L (SP)+,D1
000015D4                           783          
000015D4                           784                
000015D4                           785          
000015D4                           786  Jsrdone:
000015D4                           787  
000015D4  43F9 00001D02            788          LEA     clearLine,A1  ;move string for a CR and LF
000015DA  103C 000E                789          MOVE.B  #14,D0        ;set for task to display null terminated 
000015DE                           790                                ;string without CR, LF
000015DE  4E4F                     791          TRAP    #15
000015E0  7000                     792          MOVEQ.L #0,D0
000015E2  4E75                     793          RTS
000015E4                           794  
000015E4                           795  
000015E4                           796          
000015E4                           797  NOP:
000015E4                           798  
000015E4  43F9 00001D39            799          LEA     nopMessage,A1 ;move string for NOP info
000015EA  103C 000D                800          MOVE.B  #13,D0        ;set for task to display null terminated 
000015EE                           801                                ;string with CR, LF
000015EE  4E4F                     802          TRAP    #15
000015F0                           803          
000015F0  7000                     804          MOVEQ.L #0,D0
000015F2  4E75                     805          RTS
000015F4                           806          
000015F4                           807  RTS:
000015F4                           808          
000015F4  43F9 00001D34            809          LEA     rtsMessage,A1  ;move string for rts info
000015FA  103C 000D                810          MOVE.B  #13,D0        ;set for task to display null terminated 
000015FE                           811                                ;string with CR, LF
000015FE  4E4F                     812          TRAP    #15  
00001600                           813     
00001600  7000                     814          MOVEQ.L #0,D0
00001602  4E75                     815          RTS   
00001604                           816  
00001604= 3C 08 00 10 18 20 ...    817  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
0000160D= 3F 38 38 38 38 38 ...    818  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001616                           819  
00001616= 00 10 18 20 38 39 00     820  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
0000161D= 38 38 38 38 3F 3F 00     821  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
00001624                           822  
00001624                           823  MOVE:
00001624                           824          
00001624                           825  
00001624                           826          
00001624  7000                     827          MOVEQ.L #0, D0 ;clear D0
00001626                           828          
00001626                           829  validMoveSourceModes:
00001626                           830          
00001626  43F8 160D                831          LEA moveSourceEAmasks,A1 ;load the list of masks
0000162A  D3C0                     832          ADDA.L D0,A1 ;displace to a specific mask
0000162C  1A11                     833          MOVE.B (A1),D5 ;move the mask to D5
0000162E                           834          
0000162E  0C05 0000                835          CMPI.B #0,D5 ;check if the mask is 0
00001632  6700 FA3C                836          BEQ falsePositive ;branch if it is
00001636                           837          
00001636  1401                     838          MOVE.B D1,D2 ;copy instruction to D2
00001638  C405                     839          AND.B D5,D2  ;mask D2
0000163A                           840          
0000163A  43F8 1604                841          LEA moveSourceEA,A1 ;load the list of valid modes
0000163E  D3C0                     842          ADDA.L D0,A1 ;displace to a specific mode
00001640  1811                     843          MOVE.B (A1),D4 ;move mode to D4
00001642  B404                     844          CMP.B D4,D2 ;compare mode to masked value
00001644  6700 0006                845          BEQ  checkMoveDest ;if its match, its a valid mode and we can procede
00001648                           846          
00001648  5280                     847          ADDQ.L #1,D0 ;add one to displacement
0000164A  60DA                     848          BRA validMoveSourceModes ;check for next mode
0000164C                           849          
0000164C                           850  checkMoveDest:
0000164C  7000                     851          MOVEQ.L #0, D0 ;clear D0
0000164E                           852          
0000164E                           853  validMoveDestModes:
0000164E                           854          
0000164E  43F8 161D                855          LEA moveDestEAmasks,A1 ;load the list of masks
00001652  D3C0                     856          ADDA.L D0,A1 ;displace to a specific mask
00001654  1A11                     857          MOVE.B (A1),D5 ;move the mask to D5
00001656                           858          
00001656  0C05 0000                859          CMPI.B #0,D5 ;check if the mask is 0
0000165A  6700 FA14                860          BEQ falsePositive ;branch if it is
0000165E                           861          
0000165E  3401                     862          MOVE.W D1,D2 ;copy instruction to D2
00001660  EC4A                     863          LSR.W #6,D2  ;move mode
00001662  6100 04C2                864          BSR switchModeAndReg ;switch register and mode
00001666  C405                     865          AND.B D5,D2  ;mask D2
00001668                           866          
00001668  43F8 1616                867          LEA moveDestEA,A1 ;load the list of valid modes
0000166C  D3C0                     868          ADDA.L D0,A1 ;displace to a specific mode
0000166E  1811                     869          MOVE.B (A1),D4 ;move mode to D4
00001670  B404                     870          CMP.B D4,D2 ;compare mode to masked value
00001672  6700 0006                871          BEQ moveBody ;if its match, its a valid mode and we can procede
00001676                           872          
00001676  5280                     873          ADDQ.L #1,D0 ;add one to displacement
00001678  60D4                     874          BRA validMoveDestModes ;check for next mode
0000167A                           875          
0000167A                           876  moveBody
0000167A  3401                     877          MOVE.W  D1,D2 ;copy inst to D2
0000167C  C47C 3000                878          AND.W  #%0011000000000000,D2 ;mask word for size
00001680  0C42 0000                879          CMPI.W #0,D2 ;0 is the only non valid size
00001684  6700 F9EA                880          BEQ falsePositive ; if zero, this is not move
00001688                           881  
00001688  43F9 00001D3F            882          LEA     moveMessage,A1  ;move string for MOVE
0000168E  103C 000E                883          MOVE.B  #14,D0        ;set for task to display null terminated 
00001692                           884                                ;string with CR, LF
00001692  4E4F                     885          TRAP    #15
00001694                           886          
00001694                           887          
00001694  3401                     888          MOVE.W  D1,D2 ;check source mode
00001696  C43C 003F                889          AND.B   #%00111111,D2
0000169A  1A02                     890          MOVE.B  D2,D5
0000169C  48E7 4000                891          MOVEM.L D1,-(SP)
000016A0  6100 0310                892          BSR     Get_Effective_Address
000016A4  4CDF 0002                893          MOVEM.L (SP)+,D1
000016A8                           894          
000016A8                           895          ;print separator
000016A8                           896          
000016A8  3401                     897          MOVE.W  D1,D2 ;check dest mode
000016AA  EC4A                     898          LSR.W   #6,D2
000016AC  6100 0478                899          BSR  switchModeAndReg
000016B0  C43C 003F                900          AND.B   #%00111111,D2
000016B4  1A02                     901          MOVE.B  D2,D5
000016B6  48E7 4000                902          MOVEM.L D1,-(SP)
000016BA  6100 02F6                903          BSR     Get_Effective_Address
000016BE  4CDF 0002                904          MOVEM.L (SP)+,D1
000016C2                           905          
000016C2                           906          
000016C2                           907          
000016C2  43F9 00001D02            908          LEA     clearLine,A1  ;move string for a CR and LF
000016C8  103C 000E                909          MOVE.B  #14,D0        ;set for task to display null terminated 
000016CC                           910                                ;string without CR, LF
000016CC  4E4F                     911          TRAP    #15
000016CE                           912  
000016CE  7000                     913          MOVEQ.L #0,D0
000016D0  4E75                     914          RTS
000016D2                           915          
000016D2= 08 00                    916  moveADestEA        DC.B %001000,0
000016D4= 38 00                    917  moveADestEAmasks   DC.B %111000,0
000016D6                           918          
000016D6                           919  MOVEA:
000016D6                           920  
000016D6  7000                     921          MOVEQ.L #0, D0 ;clear D0
000016D8                           922          
000016D8                           923  validMoveASourceModes:
000016D8                           924          
000016D8  43F8 160D                925          LEA moveSourceEAmasks,A1 ;load the list of masks
000016DC  D3C0                     926          ADDA.L D0,A1 ;displace to a specific mask
000016DE  1A11                     927          MOVE.B (A1),D5 ;move the mask to D5
000016E0                           928          
000016E0  0C05 0000                929          CMPI.B #0,D5 ;check if the mask is 0
000016E4  6700 F98A                930          BEQ falsePositive ;branch if it is
000016E8                           931          
000016E8  1401                     932          MOVE.B D1,D2 ;copy instruction to D2
000016EA  C405                     933          AND.B D5,D2  ;mask D2
000016EC                           934          
000016EC  43F8 1604                935          LEA moveSourceEA,A1 ;load the list of valid modes
000016F0  D3C0                     936          ADDA.L D0,A1 ;displace to a specific mode
000016F2  1811                     937          MOVE.B (A1),D4 ;move mode to D4
000016F4  B404                     938          CMP.B D4,D2 ;compare mode to masked value
000016F6  6700 0006                939          BEQ  checkMoveADest ;if its match, its a valid mode and we can procede
000016FA                           940          
000016FA  5280                     941          ADDQ.L #1,D0 ;add one to displacement
000016FC  60DA                     942          BRA validMoveASourceModes ;check for next mode
000016FE                           943          
000016FE                           944  checkMoveADest:
000016FE  7000                     945          MOVEQ.L #0, D0 ;clear D0
00001700                           946  validMoveADestModes:
00001700                           947          
00001700  43F8 16D4                948          LEA moveADestEAmasks,A1 ;load the list of masks
00001704  D3C0                     949          ADDA.L D0,A1 ;displace to a specific mask
00001706  1A11                     950          MOVE.B (A1),D5 ;move the mask to D5
00001708                           951          
00001708  0C05 0000                952          CMPI.B #0,D5 ;check if the mask is 0
0000170C  6700 F962                953          BEQ falsePositive ;branch if it is
00001710                           954          
00001710  3401                     955          MOVE.W D1,D2 ;copy instruction to D2
00001712  EA4A                     956          LSR.W #5,D2  ;move mode
00001714  6100 0410                957          BSR switchModeAndReg ;switch register and mode
00001718  C405                     958          AND.B D5,D2  ;mask D2
0000171A                           959          
0000171A  43F8 16D2                960          LEA moveADestEA,A1 ;load the list of valid modes
0000171E  D3C0                     961          ADDA.L D0,A1 ;displace to a specific mode
00001720  1811                     962          MOVE.B (A1),D4 ;move mode to D4
00001722  B404                     963          CMP.B D4,D2 ;compare mode to masked value
00001724  6700 0006                964          BEQ moveABody ;if its match, its a valid mode and we can procede
00001728                           965          
00001728  5280                     966          ADDQ.L #1,D0 ;add one to displacement
0000172A  60D4                     967          BRA validMoveADestModes ;check for next mode
0000172C                           968  moveABody:
0000172C  3401                     969          MOVE.W  D1,D2 ;copy inst to D2
0000172E  C47C 3000                970          AND.W  #%0011000000000000,D2 ;mask word for size
00001732  0C42 0000                971          CMPI.W #0,D2 ;0 is the non valid size
00001736  6700 F938                972          BEQ falsePositive ; if zero, this is not move
0000173A  0C42 1000                973          CMPI.W #%0001000000000000,D2
0000173E  6700 F930                974          BEQ falsePositive ; if byte, this is not movea
00001742                           975  
00001742                           976  
00001742  43F9 00001D55            977          LEA     moveAMessage,A1  ;move string for MOVE
00001748  103C 000D                978          MOVE.B  #13,D0        ;set for task to display null terminated 
0000174C                           979                                ;string with CR, LF
0000174C  4E4F                     980          TRAP    #15
0000174E                           981  
0000174E  7000                     982          MOVEQ.L #0,D0
00001750  4E75                     983          RTS
00001752                           984  
00001752                           985             
00001752                           986  Bcc:
00001752                           987  
00001752  43F9 00001D46            988          LEA     bccMessage,A1  ;move string for BRA info
00001758  103C 000E                989          MOVE.B  #14,D0        ;set for task to display null terminated 
0000175C                           990                                ;string without CR, LF
0000175C  4E4F                     991          TRAP    #15
0000175E                           992          
0000175E  7000                     993          MOVEQ.L #0,D0 ;clear D0
00001760  3401                     994          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001762  E04A                     995          LSR.W   #8,D2
00001764  C47C 000F                996          AND.W   #$0F,D2 ;mask instruction
00001768                           997          
00001768                           998  checkCC:        
00001768  41F9 00001C89            999          LEA     bccList,A0 ;get condition code signature list in A0
0000176E  D1C0                    1000          ADDA.L  D0,A0 ;get correct sig         
00001770  B410                    1001          CMP.B   (A0),D2 ;compare to sig
00001772  6700 0006               1002          BEQ     foundCC ;if sig matches branch
00001776  5200                    1003          ADDQ.B  #byte,D0
00001778  60EE                    1004          BRA     checkCC
0000177A                          1005  foundCC:
0000177A  43F9 00001C9A           1006          LEA     conditionCodeMessage,A1 ;get condition code message in A1
00001780  C0FC 0004               1007          MULU.W  #long,D0 ;adjust size of D0 for a long
00001784  D3C0                    1008          ADDA.L  D0,A1 ;get correct message location
00001786  2251                    1009          MOVEA.L (A1),A1 ;get correct message
00001788                          1010          
00001788  103C 000E               1011          MOVE.B  #14,D0        ;set for task to display null terminated 
0000178C                          1012                                ;string without CR, LF
0000178C  4E4F                    1013          TRAP    #15
0000178E                          1014  
0000178E                          1015          
0000178E                          1016          
0000178E  548B                    1017          ADDQ.L  #word,A3 ;move past instruction in case long displacement
00001790  C27C 00FF               1018          AND.W   #$00FF,D1   ;check for word sized displacement
00001794                          1019          
00001794  B23C 0000               1020          CMP.B   #$0,D1
00001798  6700 0010               1021          BEQ     BccWord
0000179C                          1022          
0000179C  B23C 00FF               1023          CMP.B   #$FF,D1 check for long sized displacement
000017A0  6700 0010               1024          BEQ     BccLong
000017A4                          1025          
000017A4                          1026  BccByte:
000017A4                          1027          
000017A4  7E00                    1028          MOVEQ.L #0,D7 ;pass back no extra data followed
000017A6  6000 0012               1029          BRA     BccDone
000017AA                          1030  BccWord:
000017AA  3213                    1031          MOVE.W  (A3),D1
000017AC                          1032          
000017AC  7E02                    1033          MOVEQ.L #word,D7 ;pass back an extra word followed
000017AE  6000 000A               1034          BRA     BccDone
000017B2                          1035  BccLong:
000017B2  2213                    1036          MOVE.L  (A3),D1
000017B4                          1037          
000017B4  7E04                    1038          MOVEQ.L #long,D7 ;pass back an extra long followed
000017B6  6000 0002               1039          BRA     BccDone
000017BA                          1040  BccDone:
000017BA                          1041  
000017BA  343C 0010               1042          MOVE.W  #16,D2 ;put base in D2
000017BE  303C 000F               1043          MOVE.W  #15,D0  ;put task #15 in D0
000017C2  4E4F                    1044          TRAP    #15
000017C4                          1045          
000017C4  43F9 00001D02           1046          LEA     clearLine,A1  ;move string for a CR and LF
000017CA  103C 000E               1047          MOVE.B  #14,D0        ;set for task to display null terminated 
000017CE                          1048                                ;string without CR, LF
000017CE  4E4F                    1049          TRAP    #15
000017D0                          1050  
000017D0  7000                    1051          MOVEQ.L #0,D0
000017D2  4E75                    1052          RTS
000017D4                          1053          
000017D4                          1054          
000017D4                          1055  unknownOpCode:
000017D4  43F9 00001D4E           1056          LEA     dataMessage,A1 ;move string for data info
000017DA  103C 000E               1057          MOVE.B  #14,D0        ;set for task to display null terminated 
000017DE                          1058                                ;string without CR, LF
000017DE  4E4F                    1059          TRAP    #15
000017E0                          1060          
000017E0  143C 0010               1061          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
000017E4  103C 000F               1062          MOVE.B  #15,D0
000017E8  4E4F                    1063          TRAP    #15
000017EA                          1064          
000017EA  43F9 00001D02           1065          LEA     clearLine,A1  ;move string for a CR and LF
000017F0  103C 000E               1066          MOVE.B  #14,D0        ;set for task to display null terminated 
000017F4                          1067                                ;string without CR, LF
000017F4  4E4F                    1068          TRAP    #15
000017F6                          1069          
000017F6  7000                    1070          MOVEQ.L #0,D0
000017F8  4E75                    1071          RTS
000017FA                          1072          
000017FA                          1073  handlebytedata:
000017FA                          1074  
000017FA  43F9 00001D4E           1075          LEA     dataMessage,A1 ;move string for data info
00001800  103C 000E               1076          MOVE.B  #14,D0        ;set for task to display null terminated 
00001804                          1077                                ;string without CR, LF
00001804  4E4F                    1078          TRAP    #15
00001806                          1079          
00001806  E049                    1080          LSR.W   #8,D1 ;shift the word read into D1 by a byte
00001808                          1081          
00001808  143C 0010               1082          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
0000180C  103C 000F               1083          MOVE.B  #15,D0
00001810  4E4F                    1084          TRAP    #15
00001812                          1085          
00001812  43F9 00001D02           1086          LEA     clearLine,A1  ;move string for a CR and LF
00001818  103C 000E               1087          MOVE.B  #14,D0        ;set for task to display null terminated 
0000181C                          1088                                ;string without CR, LF
0000181C  4E4F                    1089          TRAP    #15
0000181E                          1090          
0000181E  7000                    1091          MOVEQ.L #0,D0
00001820                          1092          
00001820  528B                    1093          ADDQ.L  #byte,A3
00001822  6000 F802               1094          BRA main_Loop
00001826                          1095  
00001826                          1096          
00001826                          1097          
00001826                          1098  fin
00001826                          1099  
00001826                          1100          
00001826                          1101          
00001826  FFFF FFFF               1102          simhalt
0000182A                          1103          
0000182A                          1104  
0000182A                          1105  *******************************************************************************
0000182A                          1106  *                            SUB ROUTINES
0000182A                          1107  *******************************************************************************
0000182A                          1108  
0000182A                          1109  *******************************************************************************
0000182A                          1110  *                          IO ROLE ROUTINES
0000182A                          1111  *******************************************************************************
0000182A                          1112  
0000182A                          1113  *==========================================================================
0000182A                          1114  *                   Enter / Validate beginning address 
0000182A                          1115  *==========================================================================
0000182A                          1116   
0000182A                          1117  begin_address:
0000182A                          1118  
0000182A                          1119         
0000182A  43F9 00001B3A           1120          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00001830  2239 00001B3A           1121          MOVE.L      slPrompt,D1         ;Load display length to D1
00001836  700E                    1122          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001838  4E4F                    1123          TRAP        #15                 ;Perform task 14 (display)
0000183A                          1124          
0000183A  43F9 00001D88           1125          LEA         startLocation,A1    ;Load address to store user input
00001840  103C 0002               1126          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001844  4E4F                    1127          TRAP        #15                 ;Perform task 2 (input)
00001846                          1128          
00001846  0C11 001B               1129          CMP.B       #27,(A1)            ;Check for ESC entered
0000184A  6700 004C               1130          BEQ         address_Exit        ;Exit condition 
0000184E                          1131          
0000184E  6100 0050               1132          BSR         enter_addr_edit_all
00001852  B67C FFFF               1133          CMP.W       #-1,D3              ;Did the edit pass?
00001856  67D2                    1134          BEQ         begin_address       ;No, loop and ask for correct input
00001858                          1135          
00001858  2643                    1136          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
0000185A                          1137          
0000185A  43F9 00001C47           1138          LEA         spc,A1              ;Load address for starting loaction prompt
00001860  1239 00001C48           1139          MOVE.B      spc_len,D1          ;Load empty line length
00001866  7000                    1140          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
00001868  4E4F                    1141          TRAP        #15                 ;Perform task 14 (display)
0000186A  6000 0002               1142          BRA         end_address
0000186E                          1143  
0000186E                          1144  *===========================================================================
0000186E                          1145  *                   Enter / Validate ending address 
0000186E                          1146  *===========================================================================
0000186E                          1147  
0000186E                          1148  end_address:
0000186E                          1149          
0000186E  43F9 00001B6B           1150          LEA         elPrompt,A1         ;Load address for ending loaction prompt
00001874                          1151          ;MOVE.L     elPrompt,D1         ;Load display length to D1
00001874  7250                    1152          MOVE.L      #80,D1       ;did not like previous command, do not know why, it should have worked
00001876  700E                    1153          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001878  4E4F                    1154          TRAP        #15                 ;Perform task 14 (display)
0000187A                          1155          
0000187A  103C 0002               1156          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
0000187E  4E4F                    1157          TRAP        #15                 ;Perform task 2 (input)
00001880                          1158          
00001880  0C11 001B               1159          CMP.B       #27,(A1)            ;Check for ESC entered
00001884  6700 0012               1160          BEQ         address_Exit        ;Exit condition 
00001888                          1161          
00001888  6100 0016               1162          BSR         enter_addr_edit_all
0000188C  B67C FFFF               1163          CMP.W       #-1,D3              ;Did the edit pass?
00001890  67DC                    1164          BEQ         end_address         ;No, loop and ask for correct input
00001892                          1165  
00001892  2843                    1166          MOVEA.L     D3,A4               ;Ending address gets stored in A4
00001894  6000 0008               1167          BRA         address_done
00001898                          1168  
00001898                          1169  address_Exit:
00001898                          1170  
00001898  76FF                    1171          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000189A  6000 0002               1172          BRA         address_done
0000189E                          1173          
0000189E                          1174  address_done:
0000189E                          1175  
0000189E  4E75                    1176          RTS    
000018A0                          1177  
000018A0                          1178  *==============================================================================
000018A0                          1179  * enter_addr_edit_all - Enter address edit check to edit all errors  
000018A0                          1180  *                       using multiple different error checking routines.
000018A0                          1181  *
000018A0                          1182  * Parameters -
000018A0                          1183  *   Input   A1      The data that needs checked.
000018A0                          1184  *   Input   D1      The number of characters input     
000018A0                          1185  *   Output  D3      Returns '-1' when there is an error.
000018A0                          1186  *==============================================================================
000018A0                          1187  
000018A0                          1188  enter_addr_edit_all
000018A0                          1189  
000018A0                          1190  *------------------------------------------------------------------------------
000018A0                          1191  * Test for odd number of characters entered, not allowed
000018A0                          1192  *------------------------------------------------------------------------------
000018A0                          1193         
000018A0  6100 0024               1194          BSR         ck_boundry          ;check if the input is on a odd / even boundry
000018A4  B67C FFFF               1195          CMP.W       #-1,D3              ;Is the address odd?
000018A8  6700 001A               1196          BEQ         enter_addr_edit_all_exit     ;No, return
000018AC                          1197  
000018AC                          1198  *------------------------------------------------------------------------------
000018AC                          1199  * Ttest for character entered all being valid address characters
000018AC                          1200  * Note: lower case a-f, gets converted to upper case A-F in D3
000018AC                          1201  *------------------------------------------------------------------------------
000018AC                          1202          
000018AC  6100 0062               1203          BSR         parseHexString      ;check if the input contains valid Hex characters
000018B0  B67C FFFF               1204          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
000018B4  6700 000E               1205          BEQ         enter_addr_edit_all_exit     ;No, return
000018B8                          1206  
000018B8                          1207  *------------------------------------------------------------------------------
000018B8                          1208  * Verify that the address entered is witin the range defined in the Equate
000018B8                          1209  *------------------------------------------------------------------------------        
000018B8                          1210          
000018B8  6100 00C8               1211          BSR         ck_addr_range       ;is address entered witin the range 
000018BC                          1212                                          ;   as defined in the Equate? 
000018BC  B67C FFFF               1213          CMP.W       #-1,D3              ;is the address  valid?
000018C0  6700 0002               1214          BEQ         enter_addr_edit_all_exit     ;No, return
000018C4                          1215  
000018C4                          1216  enter_addr_edit_all_exit:
000018C4                          1217  
000018C4  4E75                    1218          RTS                             ;return
000018C6                          1219  
000018C6                          1220  *==============================================================================
000018C6                          1221  * ck_boundry - Check the size of the data characters input and determine
000018C6                          1222  *              if an odd number of characters was entered
000018C6                          1223  *
000018C6                          1224  * Parameters -
000018C6                          1225  *   Input   A1      The data that needs checked for odd length.
000018C6                          1226  *   Input   D1      The number of characters input     
000018C6                          1227  *   Output  D3      Returns '-1' when there is an odd length.
000018C6                          1228  *==============================================================================
000018C6                          1229  
000018C6                          1230  ck_boundry:
000018C6                          1231  
000018C6  4243                    1232          CLR.W       D3                  ;Clear the return
000018C8                          1233  
000018C8  B23C 0000               1234          CMP.B       #0,D1               ;Check for nothing entered
000018CC  6700 002E               1235          BEQ         ck_size_error       ;Number of characters entered must be 
000018D0                          1236                                          ;greater than 0  
000018D0                          1237          
000018D0                          1238          
000018D0                          1239          * The program will branch to ck_size_error if D1 is greater than #8        
000018D0  B23C 0008               1240          CMP.B       #8,D1               ;Check for more than 8 characters entered
000018D4  6E00 0026               1241          BGT         ck_size_error       ;Number of characters entered must be less
000018D8                          1242                                          ;than 9
000018D8                          1243          
000018D8  7402                    1244          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
000018DA  82C2                    1245          DIVU        D2,D1               ;Divide address by 2
000018DC  4841                    1246          SWAP        D1                  ;get remainder
000018DE  B23C 0001               1247          CMP.B       #$01,D1             ;Check for remainder of 1
000018E2  6700 0004               1248          BEQ         ck_boundry_error    ;Number of characters entered must be an 
000018E6                          1249                                          ;even number   
000018E6                          1250    
000018E6  4E75                    1251          RTS                             ;return
000018E8                          1252  
000018E8                          1253  *------------------------------------------------------------------------------
000018E8                          1254  * ck_boundry_error - An odd number of characters was entered
000018E8                          1255  *                  - Load error message and display it
000018E8                          1256  *                  - Return error condition
000018E8                          1257  *------------------------------------------------------------------------------
000018E8                          1258          
000018E8                          1259  ck_boundry_error:
000018E8                          1260  
000018E8  43F9 00001C27           1261          LEA         even_msg,A1         ;Load odd error message into A1
000018EE  2239 00001C27           1262          MOVE.L      even_msg,D1         ;Load error length to D1
000018F4                          1263          
000018F4  7000                    1264          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
000018F6                          1265                                          ; n is D1.W with CR, LF. 
000018F6  4E4F                    1266          TRAP #15                        ;Display the error message
000018F8  76FF                    1267          MOVE.L #-1,D3                   ;Load -1 into return parameter
000018FA  4E75                    1268          RTS                             ;Return
000018FC                          1269          
000018FC                          1270  *------------------------------------------------------------------------------
000018FC                          1271  * ck_size_error -   The number of characters entered must be more than zero
000018FC                          1272  *                  - Load error message and display it
000018FC                          1273  *                  - Return error condition
000018FC                          1274  *------------------------------------------------------------------------------
000018FC                          1275          
000018FC                          1276  ck_size_error:
000018FC                          1277  
000018FC  43F9 00001B9A           1278          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001902  2239 00001B9A           1279          MOVE.L      invalidMsg,D1       ;Load error length to D1
00001908                          1280          
00001908  7000                    1281          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
0000190A                          1282                                          ; n is D1.W with CR, LF. 
0000190A  4E4F                    1283          TRAP        #15                 ;Display the error message
0000190C  76FF                    1284          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000190E  4E75                    1285          RTS                             ;Return        
00001910                          1286  
00001910                          1287  
00001910                          1288  *==============================================================================
00001910                          1289  * parseHexString - Converts user input string into a valid memory address
00001910                          1290  *                - Stores parsed address data into D3
00001910                          1291  *                - Stores good/bad (1/0) data in D4 
00001910                          1292  *
00001910                          1293  * Hex values are stored as bytes in D2, the ASCII chart shows their value
00001910                          1294  *   The ASCII chart values we care about are in the ranges of: 
00001910                          1295  *                            Hex            Decimal
00001910                          1296  *       No Value           NULL = 0         0
00001910                          1297  *       Numeric Values:     0-9 = 30-39     48-57
00001910                          1298  *       Upper Case letters: A-F = 41-46     65-70
00001910                          1299  *       Lower Case letterc: a-f = 61-66     97-102
00001910                          1300  
00001910                          1301  * Parameters -
00001910                          1302  *   Input   A1      The data that needs checked for valid input.
00001910                          1303  *   Output  D3      The return value, '-1' for error
00001910                          1304  *==============================================================================
00001910                          1305  
00001910                          1306  parseHexString:
00001910                          1307  
00001910                          1308  * setup any initializing item that do not get looped through
00001910  4243                    1309          CLR.W       D3                  ;Clear the return
00001912                          1310  
00001912                          1311          
00001912                          1312  *------------------------------------------------------------------------------
00001912                          1313  * NextHex - Loop through all bytes and vaildate the input
00001912                          1314  * Parameters -
00001912                          1315  *   Input   A1      The data that needs checked for valid input.
00001912                          1316  *   Output  D3      The return value, '-1' for error
00001912                          1317  *------------------------------------------------------------------------------
00001912                          1318          
00001912                          1319  NextHex:
00001912                          1320  
00001912  1419                    1321          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00001914  B43C 0000               1322          CMP.B       #0,D2               ;Check character for null 
00001918  6700 0066               1323          BEQ         NextHexReturn       ;Character is null (end of input)
0000191C                          1324          
0000191C                          1325  *................................................................................
0000191C                          1326  *  Check decimal values 0-9 by testing hexadecimal values 30-39
0000191C                          1327  *................................................................................
0000191C                          1328                  
0000191C                          1329          * The program will branch to hex_range_error if D2 is less than #30
0000191C  B43C 0030               1330          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
00001920  6D00 0048               1331          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001924                          1332                                          ;processing
00001924                          1333          
00001924                          1334          * The program will branch to UcaseHex if D2 is greater than #39
00001924  B43C 0039               1335          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
00001928  6E00 000A               1336          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
0000192C                          1337          
0000192C                          1338          *a valid number was found within this range
0000192C  0402 0030               1339          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
00001930  6000 0032               1340          BRA         NextHexDone         ;Done parsing this byte
00001934                          1341  
00001934                          1342  
00001934                          1343  *..............................................................................
00001934                          1344  *  Check upper case values A-F by testing hexadecimal values 41-46
00001934                          1345  *..............................................................................
00001934                          1346  
00001934                          1347  UcaseHex:
00001934                          1348  
00001934                          1349          * The program will branch to hex_range_error if D2 is less than #41
00001934  B43C 0041               1350          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
00001938  6D00 0030               1351          BLT         hex_range_error     ;Branch to handle range error hexidecimal
0000193C                          1352                                          ;processing
0000193C                          1353          
0000193C  B43C 0046               1354          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
00001940  6E00 000A               1355          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
00001944                          1356                                          ;processing
00001944                          1357          
00001944                          1358          *a valid number was found within this range
00001944  0402 0037               1359          SUBI.B      #55,D2              ;Change uppercase character to actual value
00001948  6000 001A               1360          BRA         NextHexDone         ;Done parsing this byte
0000194C                          1361  
0000194C                          1362  
0000194C                          1363  *..............................................................................
0000194C                          1364  *  Check lower case values a-f by testing hexadecimal values 61-66
0000194C                          1365  *..............................................................................
0000194C                          1366  
0000194C                          1367  LcaseHex
0000194C                          1368          
0000194C                          1369          * The program will branch to hex_range_error if D2 is less than #61
0000194C  B43C 0061               1370          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
00001950  6D00 0018               1371          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
00001954                          1372                                          ;processing
00001954                          1373  
00001954  B43C 0066               1374          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
00001958  6E00 0010               1375          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
0000195C                          1376                                          ;processing
0000195C                          1377  
0000195C                          1378          *a valid number was found within this range
0000195C  0402 0057               1379          SUBI.B      #87,D2              ;Change lowercase character to actual value
00001960  6000 0002               1380          BRA         NextHexDone         ;Done parsing this byte
00001964                          1381  
00001964                          1382  NextHexDone:
00001964                          1383  
00001964  E983                    1384          ASL.L       #4,D3               ; Make rooom for new byte in the return register
00001966  D602                    1385          ADD.B       D2,D3               ; Move the new byte into the return register
00001968  60A8                    1386          BRA         NextHex             ; We're ready to parse the next byte
0000196A                          1387          
0000196A                          1388  *-------------------------------------------------------------------------------------
0000196A                          1389  * hex_range_error -  A character entered was within the valid range for a hex address
0000196A                          1390  *                 -  Load error message and display it
0000196A                          1391  *                 -  Return error condition
0000196A                          1392  *-------------------------------------------------------------------------------------
0000196A                          1393          
0000196A                          1394  hex_range_error:
0000196A                          1395  
0000196A  43F9 00001BDF           1396          LEA         invCharMsg,A1       ;Load invalid range message into A1
00001970  2239 00001BDF           1397          MOVE.L      invCharMsg,D1       ;Load error length to D1
00001976                          1398          
00001976  7000                    1399          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001978                          1400                                          ; n is D1.W with CR, LF. 
00001978  4E4F                    1401          TRAP        #15                 ;Display the error message
0000197A  76FF                    1402          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000197C  6000 0002               1403          BRA         NextHexReturn
00001980                          1404          
00001980                          1405  NextHexReturn:
00001980                          1406          
00001980  4E75                    1407          RTS                             ;Return      
00001982                          1408  
00001982                          1409  
00001982                          1410  *===============================================================================
00001982                          1411  * ck_addr_range - check the address input is within a valid memory address range
00001982                          1412  *                - Parsed address data into D3
00001982                          1413  *
00001982                          1414  * Parameters -
00001982                          1415  *   Input   A1      The data that needs checked for valid address.
00001982                          1416  *   Output  D3      The return value, '-1' for error
00001982                          1417  *===============================================================================
00001982                          1418  
00001982                          1419  
00001982                          1420  ck_addr_range:   
00001982                          1421  
00001982                          1422  *------------------------------------------------------------------------------
00001982                          1423  * Verify that the address entered is witin the 
00001982                          1424  * beginning range ('begin') as defined in the Equate
00001982                          1425  *------------------------------------------------------------------------------   
00001982                          1426              
00001982  2C3C 00005001           1427          MOVE.L      #begin,D6           * Load minimum starting address
00001988  B686                    1428          CMP.L       D6,D3               * Is input at or above minimum?
0000198A  6D00 0012               1429          BLT         ck_addr_range_error 
0000198E                          1430          
0000198E                          1431  *------------------------------------------------------------------------------
0000198E                          1432  * Verify that the address entered is witin the 
0000198E                          1433  * ending range ('end') as defined in the Equate
0000198E                          1434  *------------------------------------------------------------------------------
0000198E                          1435          
0000198E  2C3C 00FFFFFE           1436          MOVE.L      #end,D6             * Load maximum starting address
00001994  B686                    1437          CMP.L       D6,D3               * Is input at or below maximum?
00001996  6E00 0006               1438          BGT         ck_addr_range_error 
0000199A  6000 0012               1439          BRA         ck_addr_done        ;done checking
0000199E                          1440          
0000199E                          1441  *..............................................................................
0000199E                          1442  * ck_addr_range_error -  A address entered is not within the 
0000199E                          1443  *                        valid range for a hex address
0000199E                          1444  *..............................................................................
0000199E                          1445          
0000199E                          1446  ck_addr_range_error
0000199E                          1447  
0000199E  43F9 00001B9A           1448          LEA         invalidMsg,A1       ;Load invalid range message into A1
000019A4                          1449          
000019A4  700D                    1450          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
000019A6                          1451                                          ;with CR, LF. 
000019A6  4E4F                    1452          TRAP        #15                 ;Display the error message
000019A8  76FF                    1453          MOVE.L      #-1,D3              ;Load -1 into return parameter
000019AA  6000 0002               1454          BRA         ck_addr_done 
000019AE                          1455  
000019AE                          1456  ck_addr_done:
000019AE                          1457  
000019AE  4E75                    1458          RTS                             ;Return
000019B0                          1459  
000019B0                          1460  *******************************************************************************
000019B0                          1461  *                          OP CODE ROLE ROUTINES
000019B0                          1462  *******************************************************************************
000019B0                          1463  
000019B0                          1464  process_op_codes:
000019B0                          1465  
000019B0                          1466  
000019B0                          1467  
000019B0                          1468  process_op_codes_exit:
000019B0                          1469  
000019B0  4E75                    1470          RTS
000019B2                          1471  
000019B2                          1472  
000019B2                          1473  *******************************************************************************
000019B2                          1474  *                    Effective Addressing ROLE ROUTINES
000019B2                          1475  *******************************************************************************
000019B2                          1476  
000019B2                          1477  Get_Effective_Address:
000019B2                          1478  
000019B2  1C05                    1479          MOVE.B      D5,D6
000019B4  E60E                    1480          LSR.B       #3,D6               ;mode
000019B6  CA3C 0007               1481          And.B       #%00000111,D5       ;register
000019BA                          1482          
000019BA  BC3C 0000               1483          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
000019BE  6700 004A               1484          BEQ         Data_Reg_Direct
000019C2                          1485          
000019C2  BC3C 0001               1486          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
000019C6  6700 0076               1487          BEQ         Addr_Reg_Indirect
000019CA                          1488          
000019CA  BC3C 0002               1489          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
000019CE  6700 006E               1490          BEQ         Addr_Reg_Indirect
000019D2                          1491          
000019D2  BC3C 0003               1492          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
000019D6  6700 0098               1493          BEQ         Addr_Reg_Indirect_Inc
000019DA                          1494          
000019DA  BC3C 0004               1495          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
000019DE  6700 00CE               1496          BEQ         Addr_Reg_Indirect_Dec
000019E2                          1497          
000019E2  BC3C 0007               1498          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
000019E6  6700 0006               1499          BEQ         Get_Effective_Address_Other
000019EA                          1500          
000019EA  6000 0138               1501          BRA         invalidEA
000019EE                          1502          
000019EE                          1503  Get_Effective_Address_Other:        
000019EE                          1504          
000019EE  BA3C 0000               1505          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
000019F2  6700 00F8               1506          BEQ Addr_Abs_Short
000019F6                          1507          
000019F6  BA3C 0001               1508          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
000019FA  6700 0104               1509          BEQ Addr_Abs_Long
000019FE                          1510          
000019FE  BA3C 0004               1511          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
00001A02  6700 0110               1512          BEQ Addr_Immediate_Data
00001A06                          1513          
00001A06  6000 011C               1514          BRA         invalidEA
00001A0A                          1515          
00001A0A                          1516  Data_Reg_Direct:                        ;case 0(0000)
00001A0A                          1517  
00001A0A  43F9 00001D7D           1518          LEA         letterD,A1          ;output 'D' for data register
00001A10  103C 000E               1519          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A14  4E4F                    1520          TRAP        #15                 ;string without CR, LF
00001A16                          1521                          
00001A16  4281                    1522          CLR.L       D1
00001A18  1205                    1523          MOVE.B      D5,D1               ;move register number for display into D1
00001A1A  103C 0003               1524          MOVE.B      #3,D0               ;set for task to display null terminated 
00001A1E  4E4F                    1525          TRAP        #15                 ;string without CR, LF
00001A20                          1526                 
00001A20  6000 0102               1527          BRA         Get_Effective_Address_Exit  ;return
00001A24                          1528          
00001A24                          1529          
00001A24                          1530  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
00001A24                          1531        
00001A24  43F9 00001D7B           1532          LEA         letterA,A1          ;output 'A' for address register
00001A2A  103C 000E               1533          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A2E  4E4F                    1534          TRAP        #15                 ;string without CR, LF
00001A30                          1535          
00001A30  4281                    1536          CLR.L       D1
00001A32  1205                    1537          MOVE.B      D5,D1               ;move register number for display into D1
00001A34  103C 0003               1538          MOVE.B      #3,D0               ;set for task to display null terminated 
00001A38  4E4F                    1539          TRAP        #15                 ;string without CR, LF
00001A3A                          1540          
00001A3A  6000 00E8               1541          BRA         Get_Effective_Address_Exit  ;return
00001A3E                          1542  
00001A3E                          1543  
00001A3E                          1544  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
00001A3E                          1545          
00001A3E  43F9 00001D83           1546          LEA         lprn,A1             ;output 'D' for data register
00001A44  103C 000E               1547          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A48  4E4F                    1548          TRAP        #15                 ;string without CR, LF
00001A4A                          1549  
00001A4A  43F9 00001D7B           1550          LEA         letterA,A1          ;output 'A' for address register
00001A50  103C 000E               1551          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A54  4E4F                    1552          TRAP        #15                 ;string without CR, LF
00001A56                          1553          
00001A56  4281                    1554          CLR.L       D1
00001A58  1205                    1555          MOVE.B      D5,D1               ;move register number for display into D1
00001A5A  103C 0003               1556          MOVE.B      #3,D0               ;set for task to display null terminated 
00001A5E  4E4F                    1557          TRAP        #15                 ;string without CR, LF
00001A60                          1558  
00001A60  43F9 00001D85           1559          LEA         rprn,A1             ;output 'D' for data register
00001A66  103C 000E               1560          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A6A  4E4F                    1561          TRAP        #15                 ;string without CR, LF
00001A6C                          1562          
00001A6C  6000 00B6               1563          BRA         Get_Effective_Address_Exit  ;return
00001A70                          1564  
00001A70                          1565                 
00001A70                          1566  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
00001A70                          1567  
00001A70  43F9 00001D83           1568          LEA         lprn,A1             ;output 'D' for data register
00001A76  103C 000E               1569          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A7A  4E4F                    1570          TRAP        #15                 ;string without CR, LF
00001A7C                          1571  
00001A7C  43F9 00001D7B           1572          LEA         letterA,A1          ;output 'A' for address register
00001A82  103C 000E               1573          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A86  4E4F                    1574          TRAP        #15                 ;string without CR, LF
00001A88                          1575          
00001A88  4281                    1576          CLR.L       D1
00001A8A  1205                    1577          MOVE.B      D5,D1               ;move register number for display into D1
00001A8C  103C 0003               1578          MOVE.B      #3,D0               ;set for task to display null terminated 
00001A90  4E4F                    1579          TRAP        #15                 ;string without CR, LF
00001A92                          1580  
00001A92  43F9 00001D85           1581          LEA         rprn,A1             ;output 'D' for data register
00001A98  103C 000E               1582          MOVE.B      #14,D0              ;set for task to display null terminated 
00001A9C  4E4F                    1583          TRAP        #15                 ;string without CR, LF
00001A9E                          1584          
00001A9E  43F9 00001D7F           1585          LEA         plus,A1             ;output 'D' for data register
00001AA4  103C 000E               1586          MOVE.B      #14,D0              ;set for task to display null terminated 
00001AA8  4E4F                    1587          TRAP        #15                 ;string without CR, LF
00001AAA                          1588          
00001AAA  6000 0078               1589          BRA         Get_Effective_Address_Exit  ;return
00001AAE                          1590  
00001AAE                          1591  Addr_Reg_Indirect_Dec                   ;4 = (An) - Address Register Indirect with Predecrement (100)
00001AAE                          1592  
00001AAE  43F9 00001D81           1593          LEA         minus,A1            ;output '-' for Predecrement
00001AB4  103C 000E               1594          MOVE.B      #14,D0              ;set for task to display null terminated 
00001AB8  4E4F                    1595          TRAP        #15                 ;string without CR, LF
00001ABA                          1596  
00001ABA  43F9 00001D83           1597          LEA         lprn,A1             ;output 'D' for data register
00001AC0  103C 000E               1598          MOVE.B      #14,D0              ;set for task to display null terminated 
00001AC4  4E4F                    1599          TRAP        #15                 ;string without CR, LF
00001AC6                          1600  
00001AC6  43F9 00001D7B           1601          LEA         letterA,A1          ;output 'A' for address register
00001ACC  103C 000E               1602          MOVE.B      #14,D0              ;set for task to display null terminated 
00001AD0  4E4F                    1603          TRAP        #15                 ;string without CR, LF
00001AD2                          1604          
00001AD2  4281                    1605          CLR.L       D1
00001AD4  1205                    1606          MOVE.B      D5,D1               ;move register number for display into D1
00001AD6  103C 0003               1607          MOVE.B      #3,D0               ;set for task to display null terminated 
00001ADA  4E4F                    1608          TRAP        #15                 ;string without CR, LF
00001ADC                          1609  
00001ADC  43F9 00001D85           1610          LEA         rprn,A1             ;output 'D' for data register
00001AE2  103C 000E               1611          MOVE.B      #14,D0              ;set for task to display null terminated 
00001AE6  4E4F                    1612          TRAP        #15                 ;string without CR, LF
00001AE8                          1613          
00001AE8  6000 003A               1614          BRA         Get_Effective_Address_Exit  ;return
00001AEC                          1615          
00001AEC                          1616                         
00001AEC                          1617  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00001AEC                          1618          
00001AEC                          1619          
00001AEC  43F9 00001D5D           1620          LEA         xxxW,A1             ;output 'D' for data register
00001AF2  103C 000E               1621          MOVE.B      #14,D0              ;set for task to display null terminated 
00001AF6  4E4F                    1622          TRAP        #15                 ;string without CR, LF
00001AF8                          1623  
00001AF8  548B                    1624          ADDA.L      #word,A3
00001AFA                          1625          
00001AFA                          1626          ;print word (A3)
00001AFA                          1627          ;MOVE.W      A3,(A1)
00001AFA                          1628          ;MOVE.B      #1,D0               ;set for task to display null terminated 
00001AFA                          1629          ;TRAP        #15                 ;string without CR, LF
00001AFA                          1630          
00001AFA  5487                    1631          ADDI.L      #word,D7 
00001AFC  6000 0026               1632          BRA         Get_Effective_Address_Exit  ;return
00001B00                          1633                         
00001B00                          1634  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
00001B00                          1635          
00001B00  43F9 00001D67           1636          LEA         xxxL,A1             ;output 'D' for data register
00001B06  103C 000E               1637          MOVE.B      #14,D0              ;set for task to display null terminated 
00001B0A  4E4F                    1638          TRAP        #15                 ;string without CR, LF
00001B0C                          1639  
00001B0C  548B                    1640          ADDA.L      #word,A3
00001B0E                          1641          
00001B0E                          1642          ;print long (A3)
00001B0E                          1643          ;MOVE.L      A3,(A1)
00001B0E                          1644          ;MOVE.B      #14,D0              ;set for task to display null terminated 
00001B0E                          1645          ;TRAP        #15                 ;string without CR, LF
00001B0E                          1646          
00001B0E  5887                    1647          ADDI.L      #long,D7
00001B10  6000 0012               1648          BRA         Get_Effective_Address_Exit  ;return
00001B14                          1649                         
00001B14                          1650  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
00001B14                          1651  
00001B14  43F9 00001D71           1652          LEA         iData,A1            ;output 'D' for data register
00001B1A  103C 000E               1653          MOVE.B      #14,D0              ;set for task to display null terminated 
00001B1E  4E4F                    1654          TRAP        #15                 ;string without CR, LF
00001B20                          1655          
00001B20                          1656          *need another input param for size
00001B20  6000 0002               1657          BRA         Get_Effective_Address_Exit  ;return
00001B24                          1658  
00001B24                          1659  invalidEA:
00001B24                          1660  
00001B24                          1661          ;do something
00001B24                          1662   
00001B24                          1663  Get_Effective_Address_Exit:     
00001B24                          1664  
00001B24  4E75                    1665          RTS                             ;return
00001B26                          1666  
00001B26                          1667  switchModeAndReg:
00001B26                          1668  ***
00001B26                          1669  * Assumed in D2
00001B26                          1670  *
00001B26                          1671  * Assumed that they are in least significant byte:
00001B26                          1672  *
00001B26                          1673  *            _this_
00001B26                          1674  *           /      \
00001B26                          1675  *  ........ ........
00001B26                          1676  *  \                /
00001B26                          1677  *   -----word-------
00001B26                          1678  *
00001B26                          1679  *  and that in that byte they are ordered:
00001B26                          1680  *
00001B26                          1681  *       ........   
00001B26                          1682  *       \/\_/\_/
00001B26                          1683  *      /  /    \
00001B26                          1684  *    /   /      \
00001B26                          1685  * dont  one    other
00001B26                          1686  * care
00001B26                          1687  *
00001B26                          1688  * after they will be
00001B26                          1689  *
00001B26                          1690  *       ........   
00001B26                          1691  *       \/\_/\_/
00001B26                          1692  *      /  /    \
00001B26                          1693  *    /   /      \
00001B26                          1694  * dont other    one
00001B26                          1695  * care
00001B26                          1696  *** 
00001B26  0202 003F               1697          AndI.B #%00111111,D2 ;remove unwanted bits from D2
00001B2A  0283 00000000           1698          ANDI.L #0,D3 ;clear D3
00001B30  1602                    1699          MOVE.B D2,D3 ;copy to D3
00001B32  E70B                    1700          LSL.B  #3,D3 
00001B34  E60A                    1701          LSR.B  #3,D2
00001B36  D403                    1702          ADD.B  D3,D2
00001B38  4E75                    1703          RTS
00001B3A                          1704  
00001B3A                          1705          
00001B3A                          1706  *==============================================================================
00001B3A                          1707  *                            variables and constants
00001B3A                          1708  *==============================================================================
00001B3A                          1709  
00001B3A                          1710  
00001B3A                          1711  ***initial user prompt stuff        
00001B3A= 45 6E 74 65 72 20 ...   1712  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE: $',0
00001B6B= 45 6E 74 65 72 20 ...   1713  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE: $',0
00001B9A                          1714  
00001B9A= 20 41 64 64 72 65 ...   1715  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
00001BDF= 20 41 20 43 68 61 ...   1716  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
00001C27                          1717  
00001C27= 20 59 6F 75 20 6D ...   1718  even_msg        DC.B    ' You must enter an even address!'
00001C47                          1719  
00001C47= 20                      1720  spc             DC.B    ' '
00001C48= 01                      1721  spc_len         DC.B    spc_len-spc
00001C49                          1722  ***
00001C49                          1723  
00001C49                          1724  
00001C49                          1725  
00001C49                          1726  ***list of OP codes
00001C49                          1727  
00001C49  =0000D000               1728  addaInstruction  EQU %1101000000000000
00001C49  =0000D000               1729  addInstruction   EQU %1101000000000000
00001C49  =00004880               1730  movemInstruction EQU %0100100010000000
00001C49  =00000600               1731  addiInstruction  EQU %0000011000000000
00001C49  =00000000               1732  oriInstruction   EQU 0
00001C49  =00000C00               1733  cmpiInstruction  EQU %0000110000000000
00001C49  =00004E80               1734  jsrInstruction   EQU %0100111010000000
00001C49  =00004E75               1735  rtsInstruction   EQU %0100111001110101
00001C49  =00004E71               1736  NoOpInstruction  EQU %0100111001110001
00001C49  =00000000               1737  moveInstruction  EQU 0
00001C49  =00006000               1738  bccInstruction   EQU %0110000000000000
00001C49  =00004400               1739  negInstruction   EQU %0100010000000000
00001C49  =00000000               1740  dataInstruction  EQU 0
00001C49                          1741  
00001C49                          1742  ***
00001C49                          1743  
00001C49                          1744  ***list of OP masks
00001C49                          1745  
00001C49  =0000F000               1746  addaMask  EQU %1111000000000000
00001C49  =0000F000               1747  addMask   EQU %1111000000000000
00001C49  =0000FB80               1748  movemMask EQU %1111101110000000
00001C49  =0000FF00               1749  addiMask  EQU %1111111100000000
00001C49  =0000FF00               1750  oriMask   EQU %1111111100000000
00001C49  =0000FF00               1751  cmpiMask  EQU %1111111100000000
00001C49  =0000FFC0               1752  jsrMask   EQU %1111111111000000
00001C49  =0000FFFF               1753  rtsMask   EQU $FFFF
00001C49  =0000FFFF               1754  NoOpMask  EQU $FFFF
00001C49  =0000C000               1755  moveMask  EQU $C000
00001C49  =0000F000               1756  bccMask   EQU $F000
00001C49  =0000FF00               1757  negMask   EQU $FF00
00001C49  =00000000               1758  dataMask  EQU 0
00001C49                          1759  ***
00001C49                          1760  
00001C49                          1761  ***Bcc Codes***
00001C49  =00000004               1762  CC EQU $04
00001C49  =00000005               1763  CS EQU $05
00001C49  =00000007               1764  EQ EQU $07
00001C49  =0000000C               1765  GE EQU $0C
00001C49  =0000000E               1766  GT EQU $0E
00001C49  =00000002               1767  HI EQU $02
00001C49  =0000000F               1768  LE EQU $0F
00001C49  =00000003               1769  LS EQU $03
00001C49  =0000000D               1770  LT EQU $0D
00001C49  =0000000B               1771  MI EQU $0B
00001C49  =00000006               1772  NE EQU $06
00001C49  =0000000A               1773  PL EQU $0A
00001C49  =00000008               1774  VC EQU $08
00001C49  =00000009               1775  VS EQU $09
00001C49  =00000000               1776  RA EQU $00 ;not really a Condition Code
00001C49  =00000001               1777  SR EQU $01 ;not really a Condition Code
00001C49                          1778  
00001C49= 43 43 20 00             1779  CCm DC.B 'CC ',0
00001C4D= 43 53 20 00             1780  CSm DC.B 'CS ',0
00001C51= 45 51 20 00             1781  EQm DC.B 'EQ ',0
00001C55= 47 45 20 00             1782  GEm DC.B 'GE ',0
00001C59= 47 54 20 00             1783  GTm DC.B 'GT ',0
00001C5D= 48 49 20 00             1784  HIm DC.B 'HI ',0
00001C61= 4C 45 20 00             1785  LEm DC.B 'LE ',0
00001C65= 4C 53 20 00             1786  LSm DC.B 'LS ',0
00001C69= 4C 54 20 00             1787  LTm DC.B 'LT ',0
00001C6D= 4D 49 20 00             1788  MIm DC.B 'MI ',0
00001C71= 4E 45 20 00             1789  NEm DC.B 'NE ',0
00001C75= 50 4C 20 00             1790  PLm DC.B 'PL ',0
00001C79= 56 43 20 00             1791  VCm DC.B 'VC ',0
00001C7D= 56 53 20 00             1792  VSm DC.B 'VS ',0
00001C81= 52 41 20 00             1793  RAm DC.B 'RA ',0
00001C85= 53 52 20 00             1794  SRm DC.B 'SR ',0
00001C89                          1795  
00001C89= 01 04 05 07 0C 0E ...   1796  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
00001C9A= 00001C85 00001C49 ...   1797  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
00001CDA                          1798  ***
00001CDA                          1799  
00001CDA= 45 6E 74 65 72 20 ...   1800  startLocationPrompt DC.B    'Enter start location',0
00001CEF= 45 6E 74 65 72 20 ...   1801  endLocationPrompt   DC.B    'Enter end location',0
00001D02                          1802  
00001D02= 0D 0A 00                1803  clearLine  DC.B $0D,$0A,0
00001D05                          1804  
00001D05= 41 44 44 41 3A 20 00    1805  addaMessage     DC.B 'ADDA: ',0
00001D0C= 41 44 44 3A 20 00       1806  addMessage      DC.B 'ADD: ',0
00001D12= 4D 4F 56 45 4D 3A ...   1807  movemMessage    DC.B 'MOVEM: ',0
00001D1A= 41 44 44 49 3A 20 00    1808  addiMessage     DC.B 'ADDI: ',0
00001D21= 4F 52 49 3A 20 00       1809  oriMessage      DC.B 'ORI: ',0
00001D27= 43 4D 50 49 3A 20 00    1810  cmpiMessage     DC.B 'CMPI: ',0
00001D2E= 4A 53 52 3A 20 00       1811  jsrMessage      DC.B 'JSR: ',0
00001D34= 52 54 53 20 00          1812  rtsMessage      DC.B 'RTS ',0
00001D39= 4E 4F 50 3A 20 00       1813  nopMessage      DC.B 'NOP: ',0 
00001D3F= 4D 4F 56 45 3A 20 00    1814  moveMessage     DC.B 'MOVE: ',0
00001D46= 42 00                   1815  bccMessage      DC.B 'B',0
00001D48= 4E 45 47 3A 20 00       1816  negMessage      DC.B 'NEG: ',0
00001D4E= 44 41 54 41 3A 20 00    1817  dataMessage     DC.B 'DATA: ',0
00001D55                          1818  
00001D55= 4D 4F 56 45 41 3A ...   1819  moveaMessage    DC.B 'MOVEA: ',0
00001D5D                          1820  
00001D5D= 28 78 78 78 29 2E ...   1821  xxxW            DC.B '(xxx).W: ',0
00001D67= 28 78 78 78 29 2E ...   1822  xxxL            DC.B '(xxx).L: ',0
00001D71= 23 28 64 61 74 61 ...   1823  iData           DC.B '#(data): ',0
00001D7B                          1824  
00001D7B= 41 00                   1825  letterA         DC.B 'A', 0
00001D7D= 44 00                   1826  letterD         DC.B 'D', 0
00001D7F                          1827  
00001D7F= 2B 00                   1828  plus            DC.B '+', 0
00001D81= 2D 00                   1829  minus           DC.B '-', 0
00001D83= 28 00                   1830  lPrn            DC.B '(', 0
00001D85= 29 00                   1831  rPrn            DC.B ')', 0
00001D87                          1832  
00001D87                          1833  
00001D88= 00000000                1834  startLocation       DC.L    0
00001D8C= 00000000                1835  endLocation         DC.L    0
00001D90                          1836  
00001D90                          1837  
00001D90                          1838     
00001D90                          1839      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 11DA
ADDA                113C
ADDABODY            1184
ADDAINSTRUCTION     D000
ADDAMASK            F000
ADDAMESSAGE         1D05
ADDDEST             129E
ADDDESTEA           11CE
ADDDESTEAMASKS      11D4
ADDI                140C
ADDIBODY            1438
ADDIDONE            1476
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         1D1A
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          1D0C
ADDRESS_DONE        189E
ADDRESS_EXIT        1898
ADDR_ABS_LONG       1B00
ADDR_ABS_SHORT      1AEC
ADDR_IMMEDIATE_DATA  1B14
ADDR_REG_DIRECT     1A24
ADDR_REG_INDIRECT   1A3E
ADDR_REG_INDIRECT_DEC  1AAE
ADDR_REG_INDIRECT_INC  1A70
ADDSOURCE           1256
BCC                 1752
BCCBYTE             17A4
BCCDONE             17BA
BCCINSTRUCTION      6000
BCCLIST             1C89
BCCLONG             17B2
BCCMASK             F000
BCCMESSAGE          1D46
BCCWORD             17AA
BEGIN               5001
BEGIN_ADDRESS       182A
BYTE                1
CC                  4
CCM                 1C49
CHECKCC             1768
CHECKMOVEADEST      16FE
CHECKMOVEDEST       164C
CHECKOPCODE         1050
CK_ADDR_DONE        19AE
CK_ADDR_RANGE       1982
CK_ADDR_RANGE_ERROR  199E
CK_BOUNDRY          18C6
CK_BOUNDRY_ERROR    18E8
CK_SIZE_ERROR       18FC
CLEARLINE           1D02
CMPI                150E
CMPIBODY            1536
CMPIDONE            1574
CMPIEA              1500
CMPIEAMASKS         1507
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         1D27
CONDITIONCODEMESSAGE  1C9A
CS                  5
CSM                 1C4D
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         1D4E
DATA_REG_DIRECT     1A0A
ELPROMPT            1B6B
END                 FFFFFE
ENDLOCATION         1D8C
ENDLOCATIONPROMPT   1CEF
END_ADDRESS         186E
ENTER_ADDR_EDIT_ALL  18A0
ENTER_ADDR_EDIT_ALL_EXIT  18C4
EQ                  7
EQM                 1C51
EVEN_MSG            1C27
FALSEPOSITIVE       1070
FARLABEL            FFE
FIN                 1826
FOUNDCC             177A
GE                  C
GEM                 1C55
GET_EFFECTIVE_ADDRESS  19B2
GET_EFFECTIVE_ADDRESS_EXIT  1B24
GET_EFFECTIVE_ADDRESS_OTHER  19EE
GT                  E
GTM                 1C59
HANDLEBYTEDATA      17FA
HEX_RANGE_ERROR     196A
HI                  2
HIM                 1C5D
IDATA               1D71
INSTLABELLIST       10CA
INSTMASKLIST        10B0
INSTOPLIST          1096
INVALIDEA           1B24
INVALIDMSG          1B9A
INVCHARMSG          1BDF
JSR                 158C
JSRBODY             15B4
JSRDONE             15D4
JSREA               1584
JSREAMASKS          1588
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          1D2E
LCASEHEX            194C
LE                  F
LEM                 1C61
LETTERA             1D7B
LETTERD             1D7D
LONG                4
LPRN                1D83
LS                  3
LSM                 1C65
LT                  D
LTM                 1C69
MAIN_LOOP           1026
MATCH               1076
MI                  B
MIM                 1C6D
MINUS               1D81
MOVE                1624
MOVEA               16D6
MOVEABODY           172C
MOVEADESTEA         16D2
MOVEADESTEAMASKS    16D4
MOVEAMESSAGE        1D55
MOVEBODY            167A
MOVEDESTEA          1616
MOVEDESTEAMASKS     161D
MOVEINSTRUCTION     0
MOVEM               12FA
MOVEMASK            C000
MOVEMBODY           1364
MOVEMESSAGE         1D3F
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     12F0
MOVEMMEMTOREGEAMASKS  12F5
MOVEMMESSAGE        1D12
MOVEMREGTOMEMEA     12E6
MOVEMREGTOMEMEAMASKS  12EB
MOVESOURCEEA        1604
MOVESOURCEEAMASKS   160D
NE                  6
NEG                 13A6
NEGBODY             13CE
NEGDONE             13FC
NEGEA               1396
NEGEAMASKS          139E
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          1D48
NEM                 1C71
NEXTHEX             1912
NEXTHEXDONE         1964
NEXTHEXRETURN       1980
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 15E4
NOPMESSAGE          1D39
ORI                 1486
ORIBODY             14B2
ORIDONE             14F0
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          1D21
PARSEHEXSTRING      1910
PL                  A
PLM                 1C75
PLUS                1D7F
PRGORG              1000
PROCESS_OP_CODES    19B0
PROCESS_OP_CODES_EXIT  19B0
PROMPT_USER         1014
RA                  0
RAM                 1C81
RPRN                1D85
RTS                 15F4
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          1D34
SLPROMPT            1B3A
SNIPPET             10FE
SNIPPETEND          1138
SPC                 1C47
SPC_LEN             1C48
SR                  1
SRM                 1C85
STACK               5000
START               1000
STARTLOCATION       1D88
STARTLOCATIONPROMPT  1CDA
SWITCHMODEANDREG    1B26
UCASEHEX            1934
UNKNOWNOPCODE       17D4
VALIDADDA           115A
VALIDADDDESTEA      122A
VALIDADDIMODES      140E
VALIDADDSOURCEEA    1200
VALIDCMPIMODES      1510
VALIDJSRMODES       158E
VALIDMEMTOREG       1336
VALIDMOVEADESTMODES  1700
VALIDMOVEASOURCEMODES  16D8
VALIDMOVEDESTMODES  164E
VALIDMOVESOURCEMODES  1626
VALIDNEGMODES       13A8
VALIDORIMODES       1488
VALIDREGTOMEM       1310
VC                  8
VCM                 1C79
VS                  9
VSM                 1C7D
WORD                2
XXXL                1D67
XXXW                1D5D

00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/10/2014 1:43:54 PM

00000000                             1  *##########################################################################
00000000                             2  * Title      : 
00000000                             3  * Written by : Andrew Watson
00000000                             4  *            : Elaine Keller
00000000                             5  *            : Robert Anderson
00000000                             6  * Date       : 11/14/2014
00000000                             7  * Description: 
00000000                             8  *##########################################################################
00000000                             9  
00000000                            10  ***Possible Bug***
00000000                            11  *can not tell data from an
00000000                            12  *unidentified instruction from an actual
00000000                            13  *instruction therefore causing errors.
00000000                            14  *may not actually be a bug because data
00000000                            15  *is data to the machine, and if you modify
00000000                            16  *the instructions in memory for a program
00000000                            17  *by moivng data, you can modify the instuctions
00000000                            18  *executed.
00000000                            19  
00000000                            20  
00000000                            21  ***************************************************************************
00000000                            22  *                   Variable/Data Definitions
00000000                            23  ***************************************************************************
00000000                            24  
00000000  =00005000                 25  stack   EQU   $00005000
00000000  =00005001                 26  begin   EQU   $00005001
00000000  =00FFFFFE                 27  end     EQU   $00FFFFFE
00000000  =00000001                 28  byte    EQU   1
00000000  =00000002                 29  word    EQU   2
00000000  =00000004                 30  long    EQU   4
00000000  =00001000                 31  prgorg  EQU   $1000
00000000                            32  
00000FFE                            33      ORG $00000FFE
00000FFE                            34  FarLabel:
00001000                            35      ORG    prgorg
00001000                            36  start:
00001000  4FF8 5000                 37          LEA stack, SP ;initialize stack
00001004                            38  
00001000                            39      ORG    prgorg
00001000                            40  
00001000                            41  ******************************************************************************
00001000                            42  *                   Begin processing active code
00001000                            43  ******************************************************************************
00001000                            44      
00001000                            45  start:
00001000                            46  
00001000  4FF8 5000                 47          LEA         stack, SP           ;Initialize stack
00001004                            48          
00001004                            49  *.............................................................................
00001004                            50  * Debug Mode - Comment out when done
00001004  267C 00001156             51          MOVE.L      #snippet,A3
0000100A  287C 000011DA             52          MOVE.L      #snippetEnd,A4
00001010  6000 0014                 53          BRA         main_Loop
00001014                            54  * Debug Mode - Comment out when done
00001014                            55  *.............................................................................        
00001014                            56          
00001014                            57  prompt_user:
00001014                            58  
00001014  6100 0EB0                 59          BSR         begin_address
00001018  B67C FFFF                 60          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000101C  6700 0EA4                 61          BEQ         fin                 ;Yes, then exit
00001020                            62          
00001020  6000 0004                 63          BRA         main_Loop
00001024                            64          ;BSR         process_op_codes
00001024  60EE                      65          BRA         prompt_user
00001026                            66                  
00001026                            67  ******************************************************************************
00001026                            68  *                   Begin processing OP Codes
00001026                            69  ******************************************************************************
00001026                            70   
00001026                            71  main_Loop:
00001026                            72  
00001026  B9CB                      73          CMPA.L A3,A4 ;check end of prog
00001028  6700 0E98                 74          BEQ fin
0000102C                            75          
0000102C  3213                      76          MOVE.W (A3),D1 ;copy word from other prog to analyze as instruction
0000102E                            77          
0000102E                            78          ;handle an odd memory access(instructions will never be misaligned)
0000102E  240B                      79          MOVE.L A3,D2 ; copy address to D2
00001030  0202 0001                 80          ANDI.B #%00000001,D2 ;mask everything except the least significant bit
00001034  0C02 0001                 81          CMPI.B #1,D2 ;compare the least sig bit of the address to one
00001038  6700 0E5C                 82          BEQ handlebytedata ;the least sig bit will only be one if the insrtuction
0000103C                            83                             ;is odd(misaligned) and therefore not an instruction
0000103C                            84          
0000103C  7600                      85          MOVEQ.L #0,D3
0000103E                            86          
0000103E                            87          ***things to save A3,A4,D1(?)***
0000103E  48E7 0018                 88          MOVEM.L A3-A4,-(SP)
00001042  6100 000C                 89          BSR checkOPcode
00001046  4CDF 1800                 90          MOVEM.L (SP)+,A3-A4
0000104A  D7C7                      91          ADDA.L  D7,A3 ;look past data that was part of the instruction
0000104C                            92          
0000104C  548B                      93          ADDQ.L  #word,A3
0000104E  60D6                      94          BRA     main_Loop 
00001050                            95          
00001050                            96  checkOPcode:
00001050                            97  
00001050                            98  
00001050  7E00                      99          MOVEQ.L #0,D7
00001052                           100          
00001052  41F9 00001096            101          LEA     instOPList,A0 ;get instruction signitrue list in A0
00001058  D1C3                     102          ADDA.L  D3,A0 ;get correct sig         
0000105A                           103          
0000105A  43F9 000010C6            104          LEA     instMaskList,A1 ;get instruction mask in A1
00001060  D3C3                     105          ADDA.L  D3,A1  ;get correct mast
00001062                           106          
00001062  3401                     107          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001064                           108          
00001064  C451                     109          AND.W   (A1),D2 ;mask instruction
00001066                           110          
00001066                           111          
00001066                           112          
00001066                           113          
00001066  B450                     114          CMP.W   (A0),D2 ;compare to sig
00001068  6700 000C                115          BEQ     match ;if sig matches branch
0000106C  5483                     116          ADDQ.L  #word,D3 ;add to D3 to check for next instruction
0000106E  60E0                     117          BRA checkOPcode
00001070                           118          
00001070                           119  falsePositive:
00001070                           120          
00001070  103C 00FF                121          MOVE.B #-1,D0
00001074  4E75                     122          RTS
00001076                           123  
00001076                           124  match:
00001076                           125          
00001076  43F9 000010F6            126          LEA     instLabelList,A1 ;get instruction code label
0000107C  D3C3                     127          ADDA.L  D3,A1 ;get correct label
0000107E  D3C3                     128          ADDA.L  D3,A1
00001080  5483                     129          ADDQ.L  #word,D3 ;add to D3 incase false positive
00001082  2251                     130          MOVEA.L (A1),A1
00001084  48E7 1000                131          MOVEM.L D3,-(SP) ; save D3
00001088  4E91                     132          JSR     (A1)
0000108A  4CDF 0008                133          MOVEM.L (SP)+,D3 ;restore D3
0000108E  B03C 00FF                134          CMP.B   #-1,D0
00001092  67BC                     135          BEQ     checkOPcode
00001094  4E75                     136          RTS
00001096                           137          
00001096                           138  
00001096= 41C0 81C0 C1C0 E...      139  instOPList  DC.W leaInstruction,divsInstruction,mulsInstruction,rsrlweaInstruction,rsrlregInstruction,asrlweaInstruction,asrlregInstruction,lsrlweaInstruction,lsrlregInstruction
000010A8= 5100 9000 D000 D...      140  instOPList2 DC.W subqInstruction,subInstruction,addaInstruction,addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruct
000010C6                           141      
000010C6= F1C0 F1C0 F1C0 F...      142  instMaskList DC.W leaMask,divsMask,mulsMask,rsrlweaMask,rsrlregMask,asrlweaMask,asrlregMask,lsrlweaMask,lsrlregMask,subqMask,subMask,addaMask,addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask   
000010F6= 000011E6 00001258        143  instLabelList  DC.L LEA,DIVS
000010FE= 000012DC 0000134C ...    144  instLabelList2 DC.L MULS,RSRLWEA,RSRLREG,ASRLWEA,ASRLREG,LSRLWEA,LSRLREG,SUBQ,SUB,ADDA,ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
00001156                           145  
00001156                           146  snippet:
00001156  4E71                     147           NOP
00001158  60FC                     148           BRA snippet
0000115A  6000 FEA2                149           BRA FarLabel
0000115E  67F6                     150           BEQ snippet
00001160  6E00 08E0                151           BGT NEG
00001164  61F0                     152           BSR snippet
00001166  4441                     153           NEG D1
00001168  3239 00008500            154           MOVE.W $8500,D1
0000116E  0645 001E                155           ADDI.W #30,D5
00001172  4E75                     156           RTS
00001174  4EB8 0054                157           JSR $54
00001178  0C41 0003                158           CMPI #3,D1
0000117C  0041 0003                159           ORI  #3,D1
00001180  48E7 0018                160           MOVEM.L A3-A4,-(SP)
00001184  D401                     161           ADD.B D1,D2
00001186  0603 000A                162           ADD.B #10,D3
0000118A  D7FC 00000463            163           ADDA.L #1123,A3
00001190  9A43                     164           SUB.W D3,D5
00001192  5105                     165           SUBQ.B #8,D5
00001194  5305                     166           SUBQ.B #1,D5
00001196  E64B                     167           LSR #3,D3
00001198  E74C                     168           LSL #3,D4
0000119A  E369                     169           LSL D1,D1
0000119C  E66F                     170           LSR D3,D7
0000119E  E2F8 3563                171           LSR $3563
000011A2  E3F9 00486412            172           LSL $486412
000011A8  E643                     173           ASR #3,D3
000011AA  E744                     174           ASL #3,D4
000011AC  E361                     175           ASL D1,D1
000011AE  E667                     176           ASR D3,D7
000011B0  E0F8 3563                177           ASR $3563
000011B4  E1F9 00486412            178           ASL $486412
000011BA  E65B                     179           ROR #3,D3
000011BC  E75C                     180           ROL #3,D4
000011BE  E379                     181           ROL D1,D1
000011C0  E67F                     182           ROR D3,D7
000011C2  E6F8 3563                183           ROR $3563
000011C6  E7F9 00486412            184           ROL $486412
000011CC  C5FC 4562                185           MULS #$4562,D2
000011D0  85FC 4562                186           DIVS #$4562,D2
000011D4  43F9 000011E2            187           LEA leaEAmasks,A1
000011DA                           188  
000011DA                           189           
000011DA                           190  snippetEnd:
000011DA  FFFF FFFF                191           SIMHALT
000011DE                           192  
000011DE= 10 38 39 00              193  leaEA        DC.B %010000,%111000,%111001,0
000011E2= 38 3F 3F 00              194  leaEAmasks   DC.B %111000,%111111,%111111,0
000011E6                           195          
000011E6                           196  LEA:
000011E6                           197  
000011E6  7000                     198          MOVEQ.L #0, D0 ;clear D0
000011E8                           199          
000011E8                           200  validLeaModes:
000011E8                           201          
000011E8  43F8 11E2                202          LEA leaEAmasks,A1 ;load the list of masks
000011EC  D3C0                     203          ADDA.L D0,A1 ;displace to a specific mask
000011EE  1A11                     204          MOVE.B (A1),D5 ;move the mask to D5
000011F0                           205          
000011F0  0C05 0000                206          CMPI.B #0,D5 ;check if the mask is 0
000011F4  6700 FE7A                207          BEQ falsePositive ;branch if it is
000011F8                           208          
000011F8  1401                     209          MOVE.B D1,D2 ;copy instruction to D2
000011FA  C405                     210          AND.B D5,D2  ;mask D2
000011FC                           211          
000011FC  43F8 11DE                212          LEA leaEA,A1 ;load the list of valid modes
00001200  D3C0                     213          ADDA.L D0,A1 ;displace to a specific mode
00001202  1811                     214          MOVE.B (A1),D4 ;move mode to D4
00001204  B404                     215          CMP.B D4,D2 ;compare mode to masked value
00001206  6700 0006                216          BEQ  leaBody ;if its match, its a valid mode and we can procede
0000120A                           217          
0000120A  5280                     218          ADDQ.L #1,D0 ;add one to displacement
0000120C  60DA                     219          BRA validLeaModes ;check for next mode
0000120E                           220          
0000120E                           221  leaBody:
0000120E                           222          
0000120E                           223  
0000120E                           224  
0000120E  43F9 000023A1            225          LEA     leaMessage,A1  ;move string for MOVE
00001214  103C 000E                226          MOVE.B  #14,D0        ;set for task to display null terminated 
00001218                           227                                ;string without CR, LF
00001218  4E4F                     228          TRAP    #15
0000121A                           229  
0000121A                           230          ;do source EA
0000121A  3401                     231          MOVE.W  D1,D2 ;check mode
0000121C  C43C 003F                232          AND.B   #%00111111,D2
00001220  1A02                     233          MOVE.B  D2,D5
00001222  48E7 4000                234          MOVEM.L D1,-(SP)
00001226  6100 0E26                235          BSR     Get_Effective_Address
0000122A  4CDF 0002                236          MOVEM.L (SP)+,D1
0000122E                           237  
0000122E                           238          ;print separator
0000122E                           239          
0000122E                           240          ;do dest addr reg
0000122E  3401                     241          MOVE.W  D1,D2 ;check mode
00001230  E04A                     242          LSR.W #8,D2 ;shift reg over
00001232  E20A                     243          LSR.B #1,D2
00001234  C43C 0007                244          AND.B   #%00000111,D2 ;force recognition as a An
00001238  5002                     245          ADDQ.B #%1000,D2
0000123A  1A02                     246          MOVE.B  D2,D5
0000123C  48E7 4000                247          MOVEM.L D1,-(SP)
00001240  6100 0E0C                248          BSR     Get_Effective_Address
00001244  4CDF 0002                249          MOVEM.L (SP)+,D1
00001248                           250          
00001248  43F9 0000239E            251          LEA     clearLine,A1  ;move string for a CR and LF
0000124E  103C 000E                252          MOVE.B  #14,D0        ;set for task to display null terminated 
00001252                           253                                ;string without CR, LF
00001252  4E4F                     254          TRAP    #15
00001254                           255  
00001254  7000                     256          MOVEQ.L #0,D0
00001256  4E75                     257          RTS
00001258                           258  
00001258                           259  
00001258                           260  
00001258                           261  DIVS:
00001258                           262  
00001258  7000                     263          MOVEQ.L #0, D0 ;clear D0
0000125A                           264          
0000125A                           265  validDivsModes:
0000125A                           266          
0000125A  43F9 000012D4            267          LEA mulsEAmasks,A1 ;load the list of masks
00001260  D3C0                     268          ADDA.L D0,A1 ;displace to a specific mask
00001262  1A11                     269          MOVE.B (A1),D5 ;move the mask to D5
00001264                           270          
00001264  0C05 0000                271          CMPI.B #0,D5 ;check if the mask is 0
00001268  6700 FE06                272          BEQ falsePositive ;branch if it is
0000126C                           273          
0000126C  1401                     274          MOVE.B D1,D2 ;copy instruction to D2
0000126E  C405                     275          AND.B D5,D2  ;mask D2
00001270                           276          
00001270  43F9 000012CC            277          LEA mulsEA,A1 ;load the list of valid modes
00001276  D3C0                     278          ADDA.L D0,A1 ;displace to a specific mode
00001278  1811                     279          MOVE.B (A1),D4 ;move mode to D4
0000127A  B404                     280          CMP.B D4,D2 ;compare mode to masked value
0000127C  6700 0006                281          BEQ  divsBody ;if its match, its a valid mode and we can procede
00001280                           282          
00001280  5280                     283          ADDQ.L #1,D0 ;add one to displacement
00001282  60D6                     284          BRA validDivsModes ;check for next mode
00001284                           285          
00001284                           286  divsBody:
00001284                           287          
00001284                           288  
00001284                           289  
00001284  43F9 000023A6            290          LEA     divsMessage,A1  ;move string for MOVE
0000128A  103C 000E                291          MOVE.B  #14,D0        ;set for task to display null terminated 
0000128E                           292                                ;string without CR, LF
0000128E  4E4F                     293          TRAP    #15
00001290                           294  
00001290                           295          ;do source EA
00001290  3401                     296          MOVE.W  D1,D2 ;check mode
00001292  C43C 003F                297          AND.B   #%00111111,D2
00001296  1A02                     298          MOVE.B  D2,D5
00001298  48E7 4000                299          MOVEM.L D1,-(SP)
0000129C  6100 0DB0                300          BSR     Get_Effective_Address
000012A0  4CDF 0002                301          MOVEM.L (SP)+,D1
000012A4                           302  
000012A4                           303          ;print separator
000012A4                           304          
000012A4                           305          ;do dest data reg
000012A4  3401                     306          MOVE.W  D1,D2 ;check mode
000012A6  E04A                     307          LSR.W #8,D2 ;shift reg over
000012A8  E20A                     308          LSR.B #1,D2
000012AA  C43C 0007                309          AND.B   #%00000111,D2 ;force recognition as a Dn
000012AE  1A02                     310          MOVE.B  D2,D5
000012B0  48E7 4000                311          MOVEM.L D1,-(SP)
000012B4  6100 0D98                312          BSR     Get_Effective_Address
000012B8  4CDF 0002                313          MOVEM.L (SP)+,D1
000012BC                           314          
000012BC  43F9 0000239E            315          LEA     clearLine,A1  ;move string for a CR and LF
000012C2  103C 000E                316          MOVE.B  #14,D0        ;set for task to display null terminated 
000012C6                           317                                ;string without CR, LF
000012C6  4E4F                     318          TRAP    #15
000012C8                           319  
000012C8  7000                     320          MOVEQ.L #0,D0
000012CA  4E75                     321          RTS
000012CC                           322  
000012CC                           323  
000012CC                           324  
000012CC                           325  
000012CC= 00 10 18 20 38 39 ...    326  mulsEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,%111100,0
000012D4= 38 38 38 38 3F 3F ...    327  mulsEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,%111111,0
000012DC                           328          
000012DC                           329  MULS:
000012DC                           330  
000012DC  7000                     331          MOVEQ.L #0, D0 ;clear D0
000012DE                           332          
000012DE                           333  validMulsModes:
000012DE                           334          
000012DE  43F8 12D4                335          LEA mulsEAmasks,A1 ;load the list of masks
000012E2  D3C0                     336          ADDA.L D0,A1 ;displace to a specific mask
000012E4  1A11                     337          MOVE.B (A1),D5 ;move the mask to D5
000012E6                           338          
000012E6  0C05 0000                339          CMPI.B #0,D5 ;check if the mask is 0
000012EA  6700 FD84                340          BEQ falsePositive ;branch if it is
000012EE                           341          
000012EE  1401                     342          MOVE.B D1,D2 ;copy instruction to D2
000012F0  C405                     343          AND.B D5,D2  ;mask D2
000012F2                           344          
000012F2  43F8 12CC                345          LEA mulsEA,A1 ;load the list of valid modes
000012F6  D3C0                     346          ADDA.L D0,A1 ;displace to a specific mode
000012F8  1811                     347          MOVE.B (A1),D4 ;move mode to D4
000012FA  B404                     348          CMP.B D4,D2 ;compare mode to masked value
000012FC  6700 0006                349          BEQ  mulsBody ;if its match, its a valid mode and we can procede
00001300                           350          
00001300  5280                     351          ADDQ.L #1,D0 ;add one to displacement
00001302  60DA                     352          BRA validMulsModes ;check for next mode
00001304                           353          
00001304                           354  mulsBody:
00001304                           355          
00001304                           356  
00001304                           357  
00001304  43F9 000023AC            358          LEA     mulsMessage,A1  ;move string for MOVE
0000130A  103C 000E                359          MOVE.B  #14,D0        ;set for task to display null terminated 
0000130E                           360                                ;string without CR, LF
0000130E  4E4F                     361          TRAP    #15
00001310                           362  
00001310                           363          ;do source EA
00001310  3401                     364          MOVE.W  D1,D2 ;check mode
00001312  C43C 003F                365          AND.B   #%00111111,D2
00001316  1A02                     366          MOVE.B  D2,D5
00001318  48E7 4000                367          MOVEM.L D1,-(SP)
0000131C  6100 0D30                368          BSR     Get_Effective_Address
00001320  4CDF 0002                369          MOVEM.L (SP)+,D1
00001324                           370  
00001324                           371          ;print separator
00001324                           372          
00001324                           373          ;do dest data reg
00001324  3401                     374          MOVE.W  D1,D2 ;check mode
00001326  E04A                     375          LSR.W #8,D2 ;shift reg over
00001328  E20A                     376          LSR.B #1,D2
0000132A  C43C 0007                377          AND.B   #%00000111,D2 ;force recognition as a Dn
0000132E  1A02                     378          MOVE.B  D2,D5
00001330  48E7 4000                379          MOVEM.L D1,-(SP)
00001334  6100 0D18                380          BSR     Get_Effective_Address
00001338  4CDF 0002                381          MOVEM.L (SP)+,D1
0000133C                           382          
0000133C  43F9 0000239E            383          LEA     clearLine,A1  ;move string for a CR and LF
00001342  103C 000E                384          MOVE.B  #14,D0        ;set for task to display null terminated 
00001346                           385                                ;string without CR, LF
00001346  4E4F                     386          TRAP    #15
00001348                           387  
00001348  7000                     388          MOVEQ.L #0,D0
0000134A  4E75                     389          RTS
0000134C                           390  
0000134C                           391  
0000134C                           392  
0000134C                           393  RSRLWEA:
0000134C                           394          
0000134C                           395  
0000134C                           396          
0000134C  7000                     397          MOVEQ.L #0, D0 ;clear D0
0000134E                           398          
0000134E                           399  validRSRL:
0000134E                           400          
0000134E  43F9 0000149E            401          LEA lsrlEAmasks,A1 ;load the list of masks
00001354  D3C0                     402          ADDA.L D0,A1 ;displace to a specific mask
00001356  1A11                     403          MOVE.B (A1),D5 ;move the mask to D5
00001358                           404          
00001358  0C05 0000                405          CMPI.B #0,D5 ;check if the mask is 0
0000135C  6700 FD12                406          BEQ falsePositive ;branch if it is
00001360                           407          
00001360  1401                     408          MOVE.B D1,D2 ;copy instruction to D2
00001362  C405                     409          AND.B D5,D2  ;mask D2
00001364                           410          
00001364  43F9 00001498            411          LEA lsrlEA,A1 ;load the list of valid modes
0000136A  D3C0                     412          ADDA.L D0,A1 ;displace to a specific mode
0000136C  1811                     413          MOVE.B (A1),D4 ;move mode to D4
0000136E  B404                     414          CMP.B D4,D2 ;compare mode to masked value
00001370  6700 0006                415          BEQ  rsrlweaCheckDirection ;if its match, its a valid mode and we can procede
00001374                           416          
00001374  5280                     417          ADDQ.L #1,D0 ;add one to displacement
00001376  60D6                     418          BRA validRSRL ;check for next mode
00001378                           419  
00001378                           420  rsrlweaCheckDirection:
00001378                           421          ;Figure out which direction we are going
00001378  3401                     422          MOVE.W D1,D2 ;copy inst to D2
0000137A  E04A                     423          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
0000137C  0202 0001                424          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
00001380  0C02 0000                425          CMPI.B #0,D2 ;compare bit to zero
00001384  6700 0006                426          BEQ RSREA ;if zero, right
00001388  6000 0012                427          BRA RSLEA ;else, its left
0000138C                           428  
0000138C                           429  RSREA:
0000138C                           430  
0000138C  43F9 000023B7            431          LEA     rsrMessage,A1  ;move string for MOVE
00001392  103C 000E                432          MOVE.B  #14,D0        ;set for task to display null terminated 
00001396                           433                                ;string with CR, LF
00001396  4E4F                     434          TRAP    #15
00001398  6000 0166                435          BRA lsrlweaBody
0000139C                           436          
0000139C                           437  RSLEA:
0000139C                           438          
0000139C  43F9 000023B2            439          LEA     rslMessage,A1  ;move string for MOVE
000013A2  103C 000E                440          MOVE.B  #14,D0        ;set for task to display null terminated 
000013A6                           441                                ;string with CR, LF
000013A6  4E4F                     442          TRAP    #15
000013A8  6000 0156                443          BRA lsrlweaBody        
000013AC                           444          
000013AC                           445  
000013AC                           446  
000013AC                           447  RSRLREG:
000013AC                           448          
000013AC                           449  
000013AC                           450          
000013AC  7000                     451          MOVEQ.L #0, D0 ;clear D0
000013AE                           452          
000013AE                           453          ;check valid size field
000013AE  3401                     454          MOVE.W D1,D2 ;copy inst to D2
000013B0  EC4A                     455          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
000013B2  0202 0003                456          ANDI.B #%00000011,D2 ;mask out rest of byte
000013B6  0C02 0003                457          CMPI.B #%11,D2 ;compare to 3
000013BA  6700 FCB4                458          BEQ falsePositive ;invalid size
000013BE                           459  
000013BE                           460          
000013BE                           461          ;Figure out which direction we are going
000013BE  3401                     462          MOVE.W D1,D2 ;copy inst to D2
000013C0  E04A                     463          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000013C2  0202 0001                464          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000013C6  0C02 0000                465          CMPI.B #0,D2 ;compare bit to zero
000013CA  6700 0006                466          BEQ RSRreg ;if zero, right
000013CE  6000 0012                467          BRA RSLreg ;else, its left        
000013D2                           468          
000013D2                           469  RSRreg:
000013D2                           470  
000013D2  43F9 000023B7            471          LEA     rsrMessage,A1  ;move string for MOVE
000013D8  103C 000E                472          MOVE.B  #14,D0        ;set for task to display null terminated 
000013DC                           473                                ;string with CR, LF
000013DC  4E4F                     474          TRAP    #15
000013DE  6000 018A                475          BRA LSRLregBody
000013E2                           476          
000013E2                           477  RSLreg:
000013E2                           478          
000013E2  43F9 000023B2            479          LEA     rslMessage,A1  ;move string for MOVE
000013E8  103C 000E                480          MOVE.B  #14,D0        ;set for task to display null terminated 
000013EC                           481                                ;string with CR, LF
000013EC  4E4F                     482          TRAP    #15
000013EE  6000 017A                483          BRA LSRLregBody
000013F2                           484  
000013F2                           485       
000013F2                           486  
000013F2                           487  ASRLWEA:
000013F2                           488          
000013F2                           489  
000013F2                           490          
000013F2  7000                     491          MOVEQ.L #0, D0 ;clear D0
000013F4                           492          
000013F4                           493  validASRL:
000013F4                           494          
000013F4  43F9 0000149E            495          LEA lsrlEAmasks,A1 ;load the list of masks
000013FA  D3C0                     496          ADDA.L D0,A1 ;displace to a specific mask
000013FC  1A11                     497          MOVE.B (A1),D5 ;move the mask to D5
000013FE                           498          
000013FE  0C05 0000                499          CMPI.B #0,D5 ;check if the mask is 0
00001402  6700 FC6C                500          BEQ falsePositive ;branch if it is
00001406                           501          
00001406  1401                     502          MOVE.B D1,D2 ;copy instruction to D2
00001408  C405                     503          AND.B D5,D2  ;mask D2
0000140A                           504          
0000140A  43F9 00001498            505          LEA lsrlEA,A1 ;load the list of valid modes
00001410  D3C0                     506          ADDA.L D0,A1 ;displace to a specific mode
00001412  1811                     507          MOVE.B (A1),D4 ;move mode to D4
00001414  B404                     508          CMP.B D4,D2 ;compare mode to masked value
00001416  6700 0006                509          BEQ  asrlweaCheckDirection ;if its match, its a valid mode and we can procede
0000141A                           510          
0000141A  5280                     511          ADDQ.L #1,D0 ;add one to displacement
0000141C  60D6                     512          BRA validASRL ;check for next mode
0000141E                           513  
0000141E                           514  asrlweaCheckDirection:
0000141E                           515          ;Figure out which direction we are going
0000141E  3401                     516          MOVE.W D1,D2 ;copy inst to D2
00001420  E04A                     517          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
00001422  0202 0001                518          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
00001426  0C02 0000                519          CMPI.B #0,D2 ;compare bit to zero
0000142A  6700 0006                520          BEQ ASREA ;if zero, right
0000142E  6000 0012                521          BRA ASLEA ;else, its left
00001432                           522  
00001432                           523  ASREA:
00001432                           524  
00001432  43F9 000023C1            525          LEA     asrMessage,A1  ;move string for MOVE
00001438  103C 000E                526          MOVE.B  #14,D0        ;set for task to display null terminated 
0000143C                           527                                ;string with CR, LF
0000143C  4E4F                     528          TRAP    #15
0000143E  6000 00C0                529          BRA lsrlweaBody
00001442                           530          
00001442                           531  ASLEA:
00001442                           532          
00001442  43F9 000023BC            533          LEA     aslMessage,A1  ;move string for MOVE
00001448  103C 000E                534          MOVE.B  #14,D0        ;set for task to display null terminated 
0000144C                           535                                ;string with CR, LF
0000144C  4E4F                     536          TRAP    #15
0000144E  6000 00B0                537          BRA lsrlweaBody        
00001452                           538          
00001452                           539  
00001452                           540  
00001452                           541  ASRLREG:
00001452                           542          
00001452                           543  
00001452                           544          
00001452  7000                     545          MOVEQ.L #0, D0 ;clear D0
00001454                           546          
00001454                           547          ;check valid size field
00001454  3401                     548          MOVE.W D1,D2 ;copy inst to D2
00001456  EC4A                     549          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
00001458  0202 0003                550          ANDI.B #%00000011,D2 ;mask out rest of byte
0000145C  0C02 0003                551          CMPI.B #%11,D2 ;compare to 3
00001460  6700 FC0E                552          BEQ falsePositive ;invalid size
00001464                           553  
00001464                           554          
00001464                           555          ;Figure out which direction we are going
00001464  3401                     556          MOVE.W D1,D2 ;copy inst to D2
00001466  E04A                     557          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
00001468  0202 0001                558          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
0000146C  0C02 0000                559          CMPI.B #0,D2 ;compare bit to zero
00001470  6700 0006                560          BEQ ASRreg ;if zero, right
00001474  6000 0012                561          BRA ASLreg ;else, its left        
00001478                           562          
00001478                           563  ASRreg:
00001478                           564  
00001478  43F9 000023C1            565          LEA     asrMessage,A1  ;move string for MOVE
0000147E  103C 000E                566          MOVE.B  #14,D0        ;set for task to display null terminated 
00001482                           567                                ;string with CR, LF
00001482  4E4F                     568          TRAP    #15
00001484  6000 00E4                569          BRA LSRLregBody
00001488                           570          
00001488                           571  ASLreg:
00001488                           572          
00001488  43F9 000023BC            573          LEA     aslMessage,A1  ;move string for MOVE
0000148E  103C 000E                574          MOVE.B  #14,D0        ;set for task to display null terminated 
00001492                           575                                ;string with CR, LF
00001492  4E4F                     576          TRAP    #15
00001494  6000 00D4                577          BRA LSRLregBody
00001498                           578  
00001498                           579  
00001498= 10 18 20 38 39 00        580  lsrlEA        DC.B %010000,%011000,%100000,%111000,%111001,0
0000149E= 38 38 38 3F 3F 00        581  lsrlEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0       
000014A4                           582  
000014A4                           583  LSRLWEA:
000014A4                           584          
000014A4                           585  
000014A4                           586          
000014A4  7000                     587          MOVEQ.L #0, D0 ;clear D0
000014A6                           588          
000014A6                           589  validLSRL:
000014A6                           590          
000014A6  43F8 149E                591          LEA lsrlEAmasks,A1 ;load the list of masks
000014AA  D3C0                     592          ADDA.L D0,A1 ;displace to a specific mask
000014AC  1A11                     593          MOVE.B (A1),D5 ;move the mask to D5
000014AE                           594          
000014AE  0C05 0000                595          CMPI.B #0,D5 ;check if the mask is 0
000014B2  6700 FBBC                596          BEQ falsePositive ;branch if it is
000014B6                           597          
000014B6  1401                     598          MOVE.B D1,D2 ;copy instruction to D2
000014B8  C405                     599          AND.B D5,D2  ;mask D2
000014BA                           600          
000014BA  43F8 1498                601          LEA lsrlEA,A1 ;load the list of valid modes
000014BE  D3C0                     602          ADDA.L D0,A1 ;displace to a specific mode
000014C0  1811                     603          MOVE.B (A1),D4 ;move mode to D4
000014C2  B404                     604          CMP.B D4,D2 ;compare mode to masked value
000014C4  6700 0006                605          BEQ  lsrlweaCheckDirection ;if its match, its a valid mode and we can procede
000014C8                           606          
000014C8  5280                     607          ADDQ.L #1,D0 ;add one to displacement
000014CA  60DA                     608          BRA validLSRL ;check for next mode
000014CC                           609  
000014CC                           610  lsrlweaCheckDirection:
000014CC                           611          ;Figure out which direction we are going
000014CC  3401                     612          MOVE.W D1,D2 ;copy inst to D2
000014CE  E04A                     613          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000014D0  0202 0001                614          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000014D4  0C02 0000                615          CMPI.B #0,D2 ;compare bit to zero
000014D8  6700 0006                616          BEQ LSREA ;if zero, right
000014DC  6000 0012                617          BRA LSLEA ;else, its left
000014E0                           618  
000014E0                           619  LSREA:
000014E0                           620  
000014E0  43F9 000023CB            621          LEA     lsrMessage,A1  ;move string for MOVE
000014E6  103C 000E                622          MOVE.B  #14,D0        ;set for task to display null terminated 
000014EA                           623                                ;string with CR, LF
000014EA  4E4F                     624          TRAP    #15
000014EC  6000 0012                625          BRA lsrlweaBody
000014F0                           626          
000014F0                           627  LSLEA:
000014F0                           628          
000014F0  43F9 000023C6            629          LEA     lslMessage,A1  ;move string for MOVE
000014F6  103C 000E                630          MOVE.B  #14,D0        ;set for task to display null terminated 
000014FA                           631                                ;string with CR, LF
000014FA  4E4F                     632          TRAP    #15
000014FC  6000 0002                633          BRA lsrlweaBody        
00001500                           634          
00001500                           635  lsrlweaBody:
00001500                           636  
00001500                           637          
00001500  3401                     638          MOVE.W  D1,D2 ;check mode
00001502  C43C 003F                639          AND.B   #%00111111,D2
00001506  1A02                     640          MOVE.B  D2,D5
00001508  48E7 4000                641          MOVEM.L D1,-(SP)
0000150C  6100 0B40                642          BSR     Get_Effective_Address
00001510  4CDF 0002                643          MOVEM.L (SP)+,D1
00001514                           644          
00001514                           645          
00001514  43F9 0000239E            646          LEA     clearLine,A1  ;move string for a CR and LF
0000151A  103C 000E                647          MOVE.B  #14,D0        ;set for task to display null terminated 
0000151E                           648                                ;string without CR, LF
0000151E  4E4F                     649          TRAP    #15
00001520                           650  
00001520  7000                     651          MOVEQ.L #0,D0
00001522  4E75                     652          RTS
00001524                           653  
00001524                           654  
00001524                           655  LSRLREG:
00001524                           656          
00001524                           657  
00001524                           658          
00001524  7000                     659          MOVEQ.L #0, D0 ;clear D0
00001526                           660          
00001526                           661          ;check valid size field
00001526  3401                     662          MOVE.W D1,D2 ;copy inst to D2
00001528  EC4A                     663          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
0000152A  0202 0003                664          ANDI.B #%00000011,D2 ;mask out rest of byte
0000152E  0C02 0003                665          CMPI.B #%11,D2 ;compare to 3
00001532  6700 FB3C                666          BEQ falsePositive ;invalid size
00001536                           667  
00001536                           668          
00001536                           669          ;Figure out which direction we are going
00001536  3401                     670          MOVE.W D1,D2 ;copy inst to D2
00001538  E04A                     671          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
0000153A  0202 0001                672          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
0000153E  0C02 0000                673          CMPI.B #0,D2 ;compare bit to zero
00001542  6700 0006                674          BEQ LSRreg ;if zero, right
00001546  6000 0012                675          BRA LSLreg ;else, its left        
0000154A                           676          
0000154A                           677  LSRreg:
0000154A                           678  
0000154A  43F9 000023CB            679          LEA     lsrMessage,A1  ;move string for MOVE
00001550  103C 000E                680          MOVE.B  #14,D0        ;set for task to display null terminated 
00001554                           681                                ;string with CR, LF
00001554  4E4F                     682          TRAP    #15
00001556  6000 0012                683          BRA LSRLregBody
0000155A                           684          
0000155A                           685  LSLreg:
0000155A                           686          
0000155A  43F9 000023C6            687          LEA     lslMessage,A1  ;move string for MOVE
00001560  103C 000E                688          MOVE.B  #14,D0        ;set for task to display null terminated 
00001564                           689                                ;string with CR, LF
00001564  4E4F                     690          TRAP    #15
00001566  6000 0002                691          BRA LSRLregBody
0000156A                           692          
0000156A                           693  LSRLregBody:
0000156A                           694                      
0000156A                           695          ;check i/r
0000156A  48E7 4000                696          MOVEM.L D1,-(SP)
0000156E  6100 003C                697          BSR LSRLcheckIR
00001572  4CDF 0002                698          MOVEM.L (SP)+,D1
00001576                           699          
00001576                           700          ;print ','
00001576  48E7 4000                701          MOVEM.L D1,-(SP) ;save D1 to the stack
0000157A  123C 002C                702          MOVE.B #',',D1 ;put ascii value of '#' in D1
0000157E  103C 0006                703          MOVE.B #6,D0 ;move task 6 into D0
00001582  4E4F                     704          TRAP #15 ;prin char
00001584  4CDF 0002                705          MOVEM.L (SP)+,D1 ;pull D1 off the stack
00001588                           706          
00001588  3401                     707          MOVE.W  D1,D2 ;check mode
0000158A  C43C 0007                708          AND.B   #%00000111,D2
0000158E  1A02                     709          MOVE.B  D2,D5
00001590  48E7 4000                710          MOVEM.L D1,-(SP)
00001594  6100 0AB8                711          BSR     Get_Effective_Address
00001598  4CDF 0002                712          MOVEM.L (SP)+,D1
0000159C                           713          
0000159C                           714          
0000159C  43F9 0000239E            715          LEA     clearLine,A1  ;move string for a CR and LF
000015A2  103C 000E                716          MOVE.B  #14,D0        ;set for task to display null terminated 
000015A6                           717                                ;string without CR, LF
000015A6  4E4F                     718          TRAP    #15
000015A8                           719  
000015A8  7000                     720          MOVEQ.L #0,D0
000015AA  4E75                     721          RTS
000015AC                           722  
000015AC                           723  LSRLcheckIR:
000015AC                           724  
000015AC  1401                     725          MOVE.B D1,D2 ;move inst to D2
000015AE  EA0A                     726          LSR.B  #5,D2
000015B0  C43C 0001                727          AND.B  #%00000001,D2
000015B4  0C02 0000                728          CMPI.B #0,D2
000015B8  6700 0008                729          BEQ  LSRLcheckI
000015BC  6000 0038                730          BRA  LSRLcheckR
000015C0                           731  LSRLcheckIRreturn:
000015C0  4E75                     732          RTS
000015C2                           733          
000015C2                           734  LSRLcheckI:
000015C2                           735          ;print '#'
000015C2  48E7 4000                736          MOVEM.L D1,-(SP) ;save D1 to the stack
000015C6  123C 0023                737          MOVE.B #'#',D1 ;put ascii value of '#' in D1
000015CA  103C 0006                738          MOVE.B #6,D0 ;move task 6 into D0
000015CE  4E4F                     739          TRAP #15 ;prin char
000015D0  4CDF 0002                740          MOVEM.L (SP)+,D1 ;pull D1 off the stack
000015D4                           741          
000015D4                           742          
000015D4                           743          ;print number
000015D4  48E7 4000                744          MOVEM.L D1,-(SP)
000015D8  3401                     745          MOVE.W D1,D2 ;copy inst to d2
000015DA  E04A                     746          LSR.W #8,D2 ;shift data section
000015DC  E20A                     747          LSR.B #1,D2
000015DE  C43C 0007                748          AND.B #%00000111,D2 ;mask out rest of data
000015E2  6100 00D6                749          BSR ZeroToEight ;handle zero
000015E6  7200                     750          MOVEQ.L #0,D1 ;clear D1
000015E8  1202                     751          MOVE.B D2,D1 ;move number to display into D1
000015EA  103C 0003                752          MOVE.B #3,D0 ;move task 3 to D0
000015EE  4E4F                     753          TRAP #15
000015F0  4CDF 0002                754          MOVEM.L (SP)+,D1
000015F4  60CA                     755          BRA LSRLcheckIRreturn
000015F6                           756          
000015F6                           757  LSRLcheckR:
000015F6  3401                     758          MOVE.W D1,D2 ;copy inst to d2
000015F8  E04A                     759          LSR.W #8,D2 ;shift data section
000015FA  E20A                     760          LSR.B #1,D2
000015FC  C43C 0007                761          AND.B #%00000111,D2 ;mask out rest of data
00001600  1A02                     762          MOVE.B D2,D5 ;force Dn
00001602  48E7 4000                763          MOVEM.L D1,-(SP)
00001606  6100 0A46                764          BSR     Get_Effective_Address
0000160A  4CDF 0002                765          MOVEM.L (SP)+,D1
0000160E  60B0                     766          BRA LSRLcheckIRreturn
00001610                           767          
00001610= 00 08 10 18 20 38 ...    768  subqEA        DC.B %000000,%001000,%010000,%011000,%100000,%111000,%111001,0
00001618= 38 38 38 38 38 3F ...    769  subqEAmasks   DC.B %111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001620                           770  
00001620                           771  SUBQ:
00001620                           772          
00001620                           773  
00001620                           774          
00001620  7000                     775          MOVEQ.L #0, D0 ;clear D0
00001622                           776          
00001622                           777          ;check valid size field
00001622  3401                     778          MOVE.W D1,D2 ;copy inst to D2
00001624  EC4A                     779          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
00001626  0202 0003                780          ANDI.B #%00000011,D2 ;mask out rest of byte
0000162A  0C02 0003                781          CMPI.B #%11,D2 ;compare to 3
0000162E  6700 FA40                782          BEQ falsePositive ;invalid size
00001632                           783          
00001632                           784  validSubq:
00001632                           785          
00001632  43F8 1618                786          LEA subqEAmasks,A1 ;load the list of masks
00001636  D3C0                     787          ADDA.L D0,A1 ;displace to a specific mask
00001638  1A11                     788          MOVE.B (A1),D5 ;move the mask to D5
0000163A                           789          
0000163A  0C05 0000                790          CMPI.B #0,D5 ;check if the mask is 0
0000163E  6700 FA30                791          BEQ falsePositive ;branch if it is
00001642                           792          
00001642  1401                     793          MOVE.B D1,D2 ;copy instruction to D2
00001644  C405                     794          AND.B D5,D2  ;mask D2
00001646                           795          
00001646  43F8 1610                796          LEA subqEA,A1 ;load the list of valid modes
0000164A  D3C0                     797          ADDA.L D0,A1 ;displace to a specific mode
0000164C  1811                     798          MOVE.B (A1),D4 ;move mode to D4
0000164E  B404                     799          CMP.B D4,D2 ;compare mode to masked value
00001650  6700 0006                800          BEQ  subqBody ;if its match, its a valid mode and we can procede
00001654                           801          
00001654  5280                     802          ADDQ.L #1,D0 ;add one to displacement
00001656  60DA                     803          BRA validSubq ;check for next mode
00001658                           804          
00001658                           805          
00001658                           806  subqBody
00001658                           807  
00001658  43F9 000023D0            808          LEA     subqMessage,A1  ;move string for MOVE
0000165E  103C 000E                809          MOVE.B  #14,D0        ;set for task to display null terminated 
00001662                           810                                ;string with CR, LF
00001662  4E4F                     811          TRAP    #15
00001664                           812          
00001664                           813          ;immediate data
00001664                           814          
00001664                           815          ;print '#'
00001664  48E7 4000                816          MOVEM.L D1,-(SP) ;save D1 to the stack
00001668  123C 0023                817          MOVE.B #'#',D1 ;put ascii value of '#' in D1
0000166C  103C 0006                818          MOVE.B #6,D0 ;move task 6 into D0
00001670  4E4F                     819          TRAP #15 ;prin char
00001672  4CDF 0002                820          MOVEM.L (SP)+,D1 ;pull D1 off the stack
00001676                           821          
00001676                           822          ;print number
00001676  48E7 4000                823          MOVEM.L D1,-(SP)
0000167A  3401                     824          MOVE.W D1,D2 ;copy inst to d2
0000167C  E04A                     825          LSR.W #8,D2 ;shift data section
0000167E  E20A                     826          LSR.B #1,D2
00001680  C43C 0007                827          AND.B #%00000111,D2 ;mask out rest of data
00001684  6100 0034                828          BSR ZeroToEight ;handle zero
00001688  7200                     829          MOVEQ.L #0,D1 ;clear D1
0000168A  1202                     830          MOVE.B D2,D1 ;move number to display into D1
0000168C  103C 0003                831          MOVE.B #3,D0 ;move task 3 to D0
00001690  4E4F                     832          TRAP #15
00001692  4CDF 0002                833          MOVEM.L (SP)+,D1
00001696                           834          
00001696                           835          ;print separator
00001696                           836          
00001696                           837          ;Then do EA
00001696                           838          
00001696  3401                     839          MOVE.W  D1,D2 ;check mode
00001698  C43C 003F                840          AND.B   #%00111111,D2
0000169C  1A02                     841          MOVE.B  D2,D5
0000169E  48E7 4000                842          MOVEM.L D1,-(SP)
000016A2  6100 09AA                843          BSR     Get_Effective_Address
000016A6  4CDF 0002                844          MOVEM.L (SP)+,D1
000016AA                           845          
000016AA  43F9 0000239E            846          LEA     clearLine,A1  ;move string for a CR and LF
000016B0  103C 000E                847          MOVE.B  #14,D0        ;set for task to display null terminated 
000016B4                           848                                ;string without CR, LF
000016B4  4E4F                     849          TRAP    #15
000016B6                           850  
000016B6  7000                     851          MOVEQ.L #0,D0
000016B8  4E75                     852          RTS
000016BA                           853          
000016BA                           854  ZeroToEight:
000016BA                           855          
000016BA  0C02 0000                856          CMPI.B #0,D2
000016BE  6700 0004                857          BEQ toEight
000016C2                           858  ZeroToEightReturn:
000016C2                           859          
000016C2  4E75                     860          RTS
000016C4                           861  toEight:
000016C4                           862          
000016C4  5002                     863          ADDQ.B #8,D2
000016C6  60FA                     864          BRA ZeroToEightReturn
000016C8                           865  
000016C8                           866      
000016C8                           867  SUB:
000016C8                           868          
000016C8                           869  
000016C8                           870          
000016C8  7000                     871          MOVEQ.L #0, D0 ;clear D0
000016CA                           872          
000016CA                           873          ;Figure out if EA is source or destination
000016CA  3401                     874          MOVE.W D1,D2 ;copy inst to D2
000016CC  EC4A                     875          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
000016CE  0202 0007                876          ANDI.B #%00000111,D2 ;mask out rest of byte
000016D2  0C02 0002                877          CMPI.B #2,D2 ;compare to 2
000016D6  6F00 0016                878          BLE validSubSourceEA ;2 or less is EA is source
000016DA                           879          
000016DA  0C02 0007                880          CMPI.B #%111,D2 ;compare to 7
000016DE  6700 F990                881          BEQ falsePositive ;thats not valid
000016E2  0C02 0003                882          CMPI.B #%11,D2 ;compare to 3
000016E6  6700 F988                883          BEQ falsePositive ;also not valid
000016EA  6000 002C                884          BRA validSubDestEA ;all thats left is valid EA as Dest 
000016EE                           885          
000016EE                           886  validSubSourceEA:
000016EE                           887          
000016EE  43F9 00001CA9            888          LEA moveSourceEAmasks,A1 ;load the list of masks
000016F4  D3C0                     889          ADDA.L D0,A1 ;displace to a specific mask
000016F6  1A11                     890          MOVE.B (A1),D5 ;move the mask to D5
000016F8                           891          
000016F8  0C05 0000                892          CMPI.B #0,D5 ;check if the mask is 0
000016FC  6700 F972                893          BEQ falsePositive ;branch if it is
00001700                           894          
00001700  1401                     895          MOVE.B D1,D2 ;copy instruction to D2
00001702  C405                     896          AND.B D5,D2  ;mask D2
00001704                           897          
00001704  43F9 00001CA0            898          LEA moveSourceEA,A1 ;load the list of valid modes
0000170A  D3C0                     899          ADDA.L D0,A1 ;displace to a specific mode
0000170C  1811                     900          MOVE.B (A1),D4 ;move mode to D4
0000170E  B404                     901          CMP.B D4,D2 ;compare mode to masked value
00001710  6700 0036                902          BEQ  subSource ;if its match, its a valid mode and we can procede
00001714                           903          
00001714  5280                     904          ADDQ.L #1,D0 ;add one to displacement
00001716  60D6                     905          BRA validSubSourceEA ;check for next mode
00001718                           906          
00001718                           907          
00001718                           908  validSubDestEA:
00001718                           909          
00001718  43F9 00001870            910          LEA addDestEAmasks,A1 ;load the list of masks
0000171E  D3C0                     911          ADDA.L D0,A1 ;displace to a specific mask
00001720  1A11                     912          MOVE.B (A1),D5 ;move the mask to D5
00001722                           913          
00001722  0C05 0000                914          CMPI.B #0,D5 ;check if the mask is 0
00001726  6700 F948                915          BEQ falsePositive ;branch if it is
0000172A                           916          
0000172A  3401                     917          MOVE.W D1,D2 ;copy instruction to D2
0000172C  EC4A                     918          LSR.W #6,D2  ;move mode
0000172E  6100 0A92                919          BSR switchModeAndReg ;switch register and mode
00001732  C405                     920          AND.B D5,D2  ;mask D2
00001734                           921          
00001734  43F9 0000186A            922          LEA addDestEA,A1 ;load the list of valid modes
0000173A  D3C0                     923          ADDA.L D0,A1 ;displace to a specific mode
0000173C  1811                     924          MOVE.B (A1),D4 ;move mode to D4
0000173E  B404                     925          CMP.B D4,D2 ;compare mode to masked value
00001740  6700 004E                926          BEQ subDest ;if its match, its a valid mode and we can procede
00001744                           927          
00001744  5280                     928          ADDQ.L #1,D0 ;add one to displacement
00001746  60D0                     929          BRA validSubDestEA ;check for next mode
00001748                           930          
00001748                           931  subSource
00001748                           932  
00001748  43F9 000023D6            933          LEA     subMessage,A1  ;move string for MOVE
0000174E  103C 000E                934          MOVE.B  #14,D0        ;set for task to display null terminated 
00001752                           935                                ;string with CR, LF
00001752  4E4F                     936          TRAP    #15
00001754                           937          
00001754                           938          ;do EA
00001754                           939          
00001754  3401                     940          MOVE.W  D1,D2 ;check mode
00001756  C43C 003F                941          AND.B   #%00111111,D2
0000175A  1A02                     942          MOVE.B  D2,D5
0000175C  48E7 4000                943          MOVEM.L D1,-(SP)
00001760  6100 08EC                944          BSR     Get_Effective_Address
00001764  4CDF 0002                945          MOVEM.L (SP)+,D1
00001768                           946          
00001768                           947          ;print separator
00001768                           948          
00001768                           949          ;Then do Dn
00001768                           950          
00001768  3401                     951          MOVE.W  D1,D2
0000176A  E04A                     952          LSR.W   #8,D2 ;move reg into first byte
0000176C  E20A                     953          LSR.B   #1,D2 ;line it up to least sig bit
0000176E  C43C 0007                954          AND.B   #%00000111,D2 ;force mode to Dn
00001772  1A02                     955          MOVE.B  D2,D5
00001774  48E7 4000                956          MOVEM.L D1,-(SP)
00001778  6100 08D4                957          BSR     Get_Effective_Address
0000177C  4CDF 0002                958          MOVEM.L (SP)+,D1
00001780                           959          
00001780  43F9 0000239E            960          LEA     clearLine,A1  ;move string for a CR and LF
00001786  103C 000E                961          MOVE.B  #14,D0        ;set for task to display null terminated 
0000178A                           962                                ;string without CR, LF
0000178A  4E4F                     963          TRAP    #15
0000178C                           964  
0000178C  7000                     965          MOVEQ.L #0,D0
0000178E  4E75                     966          RTS
00001790                           967  
00001790                           968  subDest
00001790                           969  
00001790  43F9 000023D6            970          LEA     subMessage,A1  ;move string for MOVE
00001796  103C 000E                971          MOVE.B  #14,D0        ;set for task to display null terminated 
0000179A                           972                                ;string with CR, LF
0000179A  4E4F                     973          TRAP    #15
0000179C                           974          
0000179C                           975          ;Do Dn
0000179C                           976          
0000179C  3401                     977          MOVE.W  D1,D2
0000179E  E04A                     978          LSR.W   #8,D2 ;move reg into first byte
000017A0  E20A                     979          LSR.B   #1,D2 ;line it up to least sig bit
000017A2  C43C 0007                980          AND.B   #%00000111,D2 ;force mode to Dn
000017A6  1A02                     981          MOVE.B  D2,D5
000017A8  48E7 4000                982          MOVEM.L D1,-(SP)
000017AC  6100 08A0                983          BSR     Get_Effective_Address
000017B0  4CDF 0002                984          MOVEM.L (SP)+,D1
000017B4                           985          
000017B4                           986          
000017B4                           987          ;print separator
000017B4                           988          
000017B4                           989          ;Then do EA
000017B4                           990          
000017B4  3401                     991          MOVE.W  D1,D2 ;check mode
000017B6  C43C 003F                992          AND.B   #%00111111,D2
000017BA  1A02                     993          MOVE.B  D2,D5
000017BC  48E7 4000                994          MOVEM.L D1,-(SP)
000017C0  6100 088C                995          BSR     Get_Effective_Address
000017C4  4CDF 0002                996          MOVEM.L (SP)+,D1
000017C8                           997          
000017C8                           998          
000017C8  43F9 0000239E            999          LEA     clearLine,A1  ;move string for a CR and LF
000017CE  103C 000E               1000          MOVE.B  #14,D0        ;set for task to display null terminated 
000017D2                          1001                                ;string without CR, LF
000017D2  4E4F                    1002          TRAP    #15
000017D4                          1003  
000017D4  7000                    1004          MOVEQ.L #0,D0
000017D6  4E75                    1005          RTS
000017D8                          1006  
000017D8                          1007  
000017D8                          1008  ADDA:
000017D8                          1009          
000017D8                          1010  
000017D8                          1011          
000017D8  7000                    1012          MOVEQ.L #0, D0 ;clear D0
000017DA                          1013          
000017DA                          1014          ;check opmode field
000017DA  3401                    1015          MOVE.W D1,D2 ;copy inst to D2
000017DC  EC4A                    1016          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
000017DE  0202 0007               1017          ANDI.B #%00000111,D2 ;mask out rest of byte
000017E2  0C02 0007               1018          CMPI.B #%111,D2 ;compare to 7
000017E6  6700 000E               1019          BEQ validAdda ;thats valid
000017EA  0C02 0003               1020          CMPI.B #%11,D2 ;compare to 3
000017EE  6700 0006               1021          BEQ validAdda ;also valid
000017F2  6000 F87C               1022          BRA falsePositive ;all thats left is invalid 
000017F6                          1023          
000017F6                          1024  validAdda:
000017F6                          1025          
000017F6  43F9 00001CA9           1026          LEA moveSourceEAmasks,A1 ;load the list of masks
000017FC  D3C0                    1027          ADDA.L D0,A1 ;displace to a specific mask
000017FE  1A11                    1028          MOVE.B (A1),D5 ;move the mask to D5
00001800                          1029          
00001800  0C05 0000               1030          CMPI.B #0,D5 ;check if the mask is 0
00001804  6700 F86A               1031          BEQ falsePositive ;branch if it is
00001808                          1032          
00001808  1401                    1033          MOVE.B D1,D2 ;copy instruction to D2
0000180A  C405                    1034          AND.B D5,D2  ;mask D2
0000180C                          1035          
0000180C  43F9 00001CA0           1036          LEA moveSourceEA,A1 ;load the list of valid modes
00001812  D3C0                    1037          ADDA.L D0,A1 ;displace to a specific mode
00001814  1811                    1038          MOVE.B (A1),D4 ;move mode to D4
00001816  B404                    1039          CMP.B D4,D2 ;compare mode to masked value
00001818  6700 0006               1040          BEQ  addaBody ;if its match, its a valid mode and we can procede
0000181C                          1041          
0000181C  5280                    1042          ADDQ.L #1,D0 ;add one to displacement
0000181E  60D6                    1043          BRA validAdda ;check for next mode
00001820                          1044          
00001820                          1045          
00001820                          1046  addaBody
00001820                          1047  
00001820  43F9 000023DB           1048          LEA     addaMessage,A1  ;move string for MOVE
00001826  103C 000E               1049          MOVE.B  #14,D0        ;set for task to display null terminated 
0000182A                          1050                                ;string with CR, LF
0000182A  4E4F                    1051          TRAP    #15
0000182C                          1052          
0000182C                          1053          ;do EA
0000182C                          1054          
0000182C  3401                    1055          MOVE.W  D1,D2 ;check mode
0000182E  C43C 003F               1056          AND.B   #%00111111,D2
00001832  1A02                    1057          MOVE.B  D2,D5
00001834  48E7 4000               1058          MOVEM.L D1,-(SP)
00001838  6100 0814               1059          BSR     Get_Effective_Address
0000183C  4CDF 0002               1060          MOVEM.L (SP)+,D1
00001840                          1061          
00001840                          1062          ;print separator
00001840                          1063          
00001840                          1064          ;Then do Dn
00001840                          1065          
00001840  3401                    1066          MOVE.W  D1,D2
00001842  E04A                    1067          LSR.W   #8,D2 ;move reg into first byte
00001844  E20A                    1068          LSR.B   #1,D2 ;line it up to least sig bit
00001846  C43C 0007               1069          AND.B   #%00000111,D2 ;force mode to An
0000184A  5002                    1070          ADDI.B  #%00001000,D2 
0000184C  1A02                    1071          MOVE.B  D2,D5
0000184E  48E7 4000               1072          MOVEM.L D1,-(SP)
00001852  6100 07FA               1073          BSR     Get_Effective_Address
00001856  4CDF 0002               1074          MOVEM.L (SP)+,D1
0000185A                          1075          
0000185A  43F9 0000239E           1076          LEA     clearLine,A1  ;move string for a CR and LF
00001860  103C 000E               1077          MOVE.B  #14,D0        ;set for task to display null terminated 
00001864                          1078                                ;string without CR, LF
00001864  4E4F                    1079          TRAP    #15
00001866                          1080  
00001866  7000                    1081          MOVEQ.L #0,D0
00001868  4E75                    1082          RTS
0000186A                          1083  
0000186A                          1084  
0000186A                          1085      
0000186A= 10 18 20 38 39 00       1086  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
00001870= 38 38 38 3F 3F 00       1087  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
00001876                          1088  
00001876                          1089  ADD:
00001876                          1090          
00001876                          1091  
00001876                          1092          
00001876  7000                    1093          MOVEQ.L #0, D0 ;clear D0
00001878                          1094          
00001878                          1095          ;Figure out if EA is source or destination
00001878  3401                    1096          MOVE.W D1,D2 ;copy inst to D2
0000187A  EC4A                    1097          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
0000187C  0202 0007               1098          ANDI.B #%00000111,D2 ;mask out rest of byte
00001880  0C02 0002               1099          CMPI.B #2,D2 ;compare to 2
00001884  6F00 0016               1100          BLE validAddSourceEA ;2 or less is EA is source
00001888                          1101          
00001888  0C02 0007               1102          CMPI.B #%111,D2 ;compare to 7
0000188C  6700 F7E2               1103          BEQ falsePositive ;thats not valid
00001890  0C02 0003               1104          CMPI.B #%11,D2 ;compare to 3
00001894  6700 F7DA               1105          BEQ falsePositive ;also not valid
00001898  6000 002C               1106          BRA validAddDestEA ;all thats left is valid EA as Dest 
0000189C                          1107          
0000189C                          1108  validAddSourceEA:
0000189C                          1109          
0000189C  43F9 00001CA9           1110          LEA moveSourceEAmasks,A1 ;load the list of masks
000018A2  D3C0                    1111          ADDA.L D0,A1 ;displace to a specific mask
000018A4  1A11                    1112          MOVE.B (A1),D5 ;move the mask to D5
000018A6                          1113          
000018A6  0C05 0000               1114          CMPI.B #0,D5 ;check if the mask is 0
000018AA  6700 F7C4               1115          BEQ falsePositive ;branch if it is
000018AE                          1116          
000018AE  1401                    1117          MOVE.B D1,D2 ;copy instruction to D2
000018B0  C405                    1118          AND.B D5,D2  ;mask D2
000018B2                          1119          
000018B2  43F9 00001CA0           1120          LEA moveSourceEA,A1 ;load the list of valid modes
000018B8  D3C0                    1121          ADDA.L D0,A1 ;displace to a specific mode
000018BA  1811                    1122          MOVE.B (A1),D4 ;move mode to D4
000018BC  B404                    1123          CMP.B D4,D2 ;compare mode to masked value
000018BE  6700 0032               1124          BEQ  addSource ;if its match, its a valid mode and we can procede
000018C2                          1125          
000018C2  5280                    1126          ADDQ.L #1,D0 ;add one to displacement
000018C4  60D6                    1127          BRA validAddSourceEA ;check for next mode
000018C6                          1128          
000018C6                          1129          
000018C6                          1130  validAddDestEA:
000018C6                          1131          
000018C6  43F8 1870               1132          LEA addDestEAmasks,A1 ;load the list of masks
000018CA  D3C0                    1133          ADDA.L D0,A1 ;displace to a specific mask
000018CC  1A11                    1134          MOVE.B (A1),D5 ;move the mask to D5
000018CE                          1135          
000018CE  0C05 0000               1136          CMPI.B #0,D5 ;check if the mask is 0
000018D2  6700 F79C               1137          BEQ falsePositive ;branch if it is
000018D6                          1138          
000018D6  3401                    1139          MOVE.W D1,D2 ;copy instruction to D2
000018D8  EC4A                    1140          LSR.W #6,D2  ;move mode
000018DA  6100 08E6               1141          BSR switchModeAndReg ;switch register and mode
000018DE  C405                    1142          AND.B D5,D2  ;mask D2
000018E0                          1143          
000018E0  43F8 186A               1144          LEA addDestEA,A1 ;load the list of valid modes
000018E4  D3C0                    1145          ADDA.L D0,A1 ;displace to a specific mode
000018E6  1811                    1146          MOVE.B (A1),D4 ;move mode to D4
000018E8  B404                    1147          CMP.B D4,D2 ;compare mode to masked value
000018EA  6700 004E               1148          BEQ addDest ;if its match, its a valid mode and we can procede
000018EE                          1149          
000018EE  5280                    1150          ADDQ.L #1,D0 ;add one to displacement
000018F0  60D4                    1151          BRA validAddDestEA ;check for next mode
000018F2                          1152          
000018F2                          1153  addSource
000018F2                          1154  
000018F2  43F9 000023E1           1155          LEA     addMessage,A1  ;move string for MOVE
000018F8  103C 000E               1156          MOVE.B  #14,D0        ;set for task to display null terminated 
000018FC                          1157                                ;string with CR, LF
000018FC  4E4F                    1158          TRAP    #15
000018FE                          1159          
000018FE                          1160          ;do EA
000018FE                          1161          
000018FE  3401                    1162          MOVE.W  D1,D2 ;check mode
00001900  C43C 003F               1163          AND.B   #%00111111,D2
00001904  1A02                    1164          MOVE.B  D2,D5
00001906  48E7 4000               1165          MOVEM.L D1,-(SP)
0000190A  6100 0742               1166          BSR     Get_Effective_Address
0000190E  4CDF 0002               1167          MOVEM.L (SP)+,D1
00001912                          1168          
00001912                          1169          ;print separator
00001912                          1170          
00001912                          1171          ;Then do Dn
00001912                          1172          
00001912  3401                    1173          MOVE.W  D1,D2
00001914  E04A                    1174          LSR.W   #8,D2 ;move reg into first byte
00001916  E20A                    1175          LSR.B   #1,D2 ;line it up to least sig bit
00001918  C43C 0007               1176          AND.B   #%00000111,D2 ;force mode to Dn
0000191C  1A02                    1177          MOVE.B  D2,D5
0000191E  48E7 4000               1178          MOVEM.L D1,-(SP)
00001922  6100 072A               1179          BSR     Get_Effective_Address
00001926  4CDF 0002               1180          MOVEM.L (SP)+,D1
0000192A                          1181          
0000192A  43F9 0000239E           1182          LEA     clearLine,A1  ;move string for a CR and LF
00001930  103C 000E               1183          MOVE.B  #14,D0        ;set for task to display null terminated 
00001934                          1184                                ;string without CR, LF
00001934  4E4F                    1185          TRAP    #15
00001936                          1186  
00001936  7000                    1187          MOVEQ.L #0,D0
00001938  4E75                    1188          RTS
0000193A                          1189  
0000193A                          1190  addDest
0000193A                          1191  
0000193A  43F9 000023E1           1192          LEA     addMessage,A1  ;move string for MOVE
00001940  103C 000E               1193          MOVE.B  #14,D0        ;set for task to display null terminated 
00001944                          1194                                ;string with CR, LF
00001944  4E4F                    1195          TRAP    #15
00001946                          1196          
00001946                          1197          ;Do Dn
00001946                          1198          
00001946  3401                    1199          MOVE.W  D1,D2
00001948  E04A                    1200          LSR.W   #8,D2 ;move reg into first byte
0000194A  E20A                    1201          LSR.B   #1,D2 ;line it up to least sig bit
0000194C  C43C 0007               1202          AND.B   #%00000111,D2 ;force mode to Dn
00001950  1A02                    1203          MOVE.B  D2,D5
00001952  48E7 4000               1204          MOVEM.L D1,-(SP)
00001956  6100 06F6               1205          BSR     Get_Effective_Address
0000195A  4CDF 0002               1206          MOVEM.L (SP)+,D1
0000195E                          1207          
0000195E                          1208          
0000195E                          1209          ;print separator
0000195E                          1210          
0000195E                          1211          ;Then do EA
0000195E                          1212          
0000195E  3401                    1213          MOVE.W  D1,D2 ;check mode
00001960  C43C 003F               1214          AND.B   #%00111111,D2
00001964  1A02                    1215          MOVE.B  D2,D5
00001966  48E7 4000               1216          MOVEM.L D1,-(SP)
0000196A  6100 06E2               1217          BSR     Get_Effective_Address
0000196E  4CDF 0002               1218          MOVEM.L (SP)+,D1
00001972                          1219          
00001972                          1220          
00001972  43F9 0000239E           1221          LEA     clearLine,A1  ;move string for a CR and LF
00001978  103C 000E               1222          MOVE.B  #14,D0        ;set for task to display null terminated 
0000197C                          1223                                ;string without CR, LF
0000197C  4E4F                    1224          TRAP    #15
0000197E                          1225  
0000197E  7000                    1226          MOVEQ.L #0,D0
00001980  4E75                    1227          RTS
00001982                          1228  
00001982                          1229  
00001982= 10 20 38 39 00          1230  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
00001987= 38 38 3F 3F 00          1231  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
0000198C                          1232  
0000198C= 10 18 38 39 00          1233  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
00001991= 38 38 3F 3F 00          1234  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
00001996                          1235  
00001996                          1236  MOVEM:
00001996                          1237          
00001996                          1238  
00001996                          1239          
00001996  7000                    1240          MOVEQ.L #0, D0 ;clear D0
00001998                          1241          
00001998                          1242          ;Figure out which direction we are going
00001998  3401                    1243          MOVE.W D1,D2 ;copy inst to D2
0000199A  E64A                    1244          LSR.W #3,D2 ;shift direction bit into most sig bit of first byte
0000199C  0202 0080               1245          ANDI.B #%10000000,D2 ;mask out everything but direction bit in first byte
000019A0  0C02 0000               1246          CMPI.B #0,D2 ;compare bit to zero
000019A4  6700 0006               1247          BEQ validRegToMem ;if zero, reg to mem
000019A8  6000 0028               1248          BRA validMemToReg ;else, its mem to reg
000019AC                          1249          
000019AC                          1250  validRegToMem:
000019AC                          1251          
000019AC  43F8 1987               1252          LEA movemRegToMemEAmasks,A1 ;load the list of masks
000019B0  D3C0                    1253          ADDA.L D0,A1 ;displace to a specific mask
000019B2  1A11                    1254          MOVE.B (A1),D5 ;move the mask to D5
000019B4                          1255          
000019B4  0C05 0000               1256          CMPI.B #0,D5 ;check if the mask is 0
000019B8  6700 F6B6               1257          BEQ falsePositive ;branch if it is
000019BC                          1258          
000019BC  1401                    1259          MOVE.B D1,D2 ;copy instruction to D2
000019BE  C405                    1260          AND.B D5,D2  ;mask D2
000019C0                          1261          
000019C0  43F8 1982               1262          LEA movemRegToMemEA,A1 ;load the list of valid modes
000019C4  D3C0                    1263          ADDA.L D0,A1 ;displace to a specific mode
000019C6  1811                    1264          MOVE.B (A1),D4 ;move mode to D4
000019C8  B404                    1265          CMP.B D4,D2 ;compare mode to masked value
000019CA  6700 0034               1266          BEQ  movemBody ;if its match, its a valid mode and we can procede
000019CE                          1267          
000019CE  5280                    1268          ADDQ.L #1,D0 ;add one to displacement
000019D0  60DA                    1269          BRA validRegToMem ;check for next mode
000019D2                          1270          
000019D2                          1271          
000019D2                          1272  validMemToReg:
000019D2                          1273          
000019D2  43F8 1991               1274          LEA movemMemToRegEAmasks,A1 ;load the list of masks
000019D6  D3C0                    1275          ADDA.L D0,A1 ;displace to a specific mask
000019D8  1A11                    1276          MOVE.B (A1),D5 ;move the mask to D5
000019DA                          1277          
000019DA  0C05 0000               1278          CMPI.B #0,D5 ;check if the mask is 0
000019DE  6700 F690               1279          BEQ falsePositive ;branch if it is
000019E2                          1280          
000019E2  3401                    1281          MOVE.W D1,D2 ;copy instruction to D2
000019E4  EC4A                    1282          LSR.W #6,D2  ;move mode
000019E6  6100 07DA               1283          BSR switchModeAndReg ;switch register and mode
000019EA  C405                    1284          AND.B D5,D2  ;mask D2
000019EC                          1285          
000019EC  43F8 198C               1286          LEA movemMemToRegEA,A1 ;load the list of valid modes
000019F0  D3C0                    1287          ADDA.L D0,A1 ;displace to a specific mode
000019F2  1811                    1288          MOVE.B (A1),D4 ;move mode to D4
000019F4  B404                    1289          CMP.B D4,D2 ;compare mode to masked value
000019F6  6700 0008               1290          BEQ movemBody ;if its match, its a valid mode and we can procede
000019FA                          1291          
000019FA  5280                    1292          ADDQ.L #1,D0 ;add one to displacement
000019FC  6000 02EC               1293          BRA validMoveDestModes ;check for next mode
00001A00                          1294          
00001A00                          1295  movemBody
00001A00                          1296  
00001A00  43F9 000023E6           1297          LEA     movemMessage,A1  ;move string for MOVE
00001A06  103C 000E               1298          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A0A                          1299                                ;string with CR, LF
00001A0A  4E4F                    1300          TRAP    #15
00001A0C                          1301          
00001A0C                          1302          ;show list
00001A0C                          1303          
00001A0C  5487                    1304          ADDQ.L #word,D7 ;read past the register list mask(word) following
00001A0E                          1305                          ;the instruction
00001A0E                          1306          
00001A0E                          1307          ;print separator
00001A0E                          1308          
00001A0E  3401                    1309          MOVE.W  D1,D2 ;check mode
00001A10  C43C 003F               1310          AND.B   #%00111111,D2
00001A14  1A02                    1311          MOVE.B  D2,D5
00001A16  48E7 4000               1312          MOVEM.L D1,-(SP)
00001A1A  6100 0632               1313          BSR     Get_Effective_Address
00001A1E  4CDF 0002               1314          MOVEM.L (SP)+,D1
00001A22                          1315          
00001A22                          1316          
00001A22  43F9 0000239E           1317          LEA     clearLine,A1  ;move string for a CR and LF
00001A28  103C 000E               1318          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A2C                          1319                                ;string without CR, LF
00001A2C  4E4F                    1320          TRAP    #15
00001A2E                          1321  
00001A2E  7000                    1322          MOVEQ.L #0,D0
00001A30  4E75                    1323          RTS
00001A32                          1324  
00001A32                          1325  
00001A32                          1326      
00001A32= 00 10 18 20 28 38 ...   1327  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
00001A3A= 38 38 38 38 38 3F ...   1328  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
00001A42                          1329     
00001A42                          1330  NEG:            
00001A42                          1331       
00001A42  7000                    1332          MOVEQ.L #0, D0 ;clear D0
00001A44                          1333          
00001A44                          1334  validNegModes:
00001A44                          1335          
00001A44  43F8 1A3A               1336          LEA NegEAmasks,A1 ;load the list of masks
00001A48  D3C0                    1337          ADDA.L D0,A1 ;displace to a specific mask
00001A4A  1A11                    1338          MOVE.B (A1),D5 ;move the mask to D5
00001A4C                          1339          
00001A4C  0C05 0000               1340          CMPI.B #0,D5 ;check if the mask is 0
00001A50  6700 F61E               1341          BEQ falsePositive ;branch if it is
00001A54                          1342          
00001A54  1401                    1343          MOVE.B D1,D2 ;copy instruction to D2
00001A56  C405                    1344          AND.B D5,D2  ;mask D2
00001A58  43F8 1A32               1345          LEA NegEA,A1 ;load the list of valid modes
00001A5C  D3C0                    1346          ADDA.L D0,A1 ;displace to a specific mode
00001A5E  1811                    1347          MOVE.B (A1),D4 ;move mode to D4
00001A60  B404                    1348          CMP.B D4,D2 ;compare mode to masked value
00001A62  6700 0006               1349          BEQ NegBody ;if its match, its a valid mode and we can procede
00001A66                          1350          
00001A66  5280                    1351          ADDQ.L #1,D0 ;add one to displacement
00001A68  60DA                    1352          BRA validNegModes ;check for next mode
00001A6A                          1353          
00001A6A                          1354  NegBody:
00001A6A                          1355  
00001A6A                          1356  
00001A6A  3401                    1357          MOVE.W  D1,D2 ;copy inst to D2
00001A6C  C47C 0600               1358          AND.W  #%0011000000000,D2 ;mask word for size
00001A70  0C42 0000               1359          CMPI.W #0,D2 ;0 is the only non valid size
00001A74  6700 F5FA               1360          BEQ falsePositive ; zero is not valid
00001A78                          1361  
00001A78  43F9 00002415           1362          LEA     negMessage,A1  ;move string for NEG info
00001A7E  103C 000E               1363          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A82                          1364                                ;string without CR, LF
00001A82  4E4F                    1365          TRAP    #15
00001A84                          1366          
00001A84  3401                    1367          MOVE.W D1,D2
00001A86  C47C 003F               1368          AND #%000000000111111,D2
00001A8A  1A02                    1369          MOVE.B D2,D5
00001A8C                          1370          
00001A8C  48E7 4000               1371          MOVEM.L D1,-(SP)
00001A90  6100 05BC               1372          BSR     Get_Effective_Address
00001A94  4CDF 0002               1373          MOVEM.L (SP)+,D1
00001A98                          1374          
00001A98                          1375                
00001A98                          1376          
00001A98                          1377  NEGdone:
00001A98                          1378  
00001A98  43F9 0000239E           1379          LEA     clearLine,A1  ;move string for a CR and LF
00001A9E  103C 000E               1380          MOVE.B  #14,D0        ;set for task to display null terminated 
00001AA2                          1381                                ;string without CR, LF
00001AA2  4E4F                    1382          TRAP    #15
00001AA4  7000                    1383          MOVEQ.L #0,D0
00001AA6  4E75                    1384          RTS
00001AA8                          1385          
00001AA8                          1386   ADDI:            
00001AA8                          1387       
00001AA8  7000                    1388          MOVEQ.L #0, D0 ;clear D0
00001AAA                          1389          
00001AAA                          1390  validAddiModes:
00001AAA                          1391          
00001AAA                          1392          
00001AAA  43F9 00001BA3           1393          LEA cmpiEAmasks,A1 ;load the list of masks
00001AB0  D3C0                    1394          ADDA.L D0,A1 ;displace to a specific mask
00001AB2  1A11                    1395          MOVE.B (A1),D5 ;move the mask to D5
00001AB4                          1396          
00001AB4  0C05 0000               1397          CMPI.B #0,D5 ;check if the mask is 0
00001AB8  6700 F5B6               1398          BEQ falsePositive ;branch if it is
00001ABC                          1399          
00001ABC  1401                    1400          MOVE.B D1,D2 ;copy instruction to D2
00001ABE  C405                    1401          AND.B D5,D2  ;mask D2
00001AC0  43F9 00001B9C           1402          LEA cmpiEA,A1 ;load the list of valid modes
00001AC6  D3C0                    1403          ADDA.L D0,A1 ;displace to a specific mode
00001AC8  1811                    1404          MOVE.B (A1),D4 ;move mode to D4
00001ACA  B404                    1405          CMP.B D4,D2 ;compare mode to masked value
00001ACC  6700 0006               1406          BEQ addiBody ;if its match, its a valid mode and we can procede
00001AD0                          1407          
00001AD0  5280                    1408          ADDQ.L #1,D0 ;add one to displacement
00001AD2  60D6                    1409          BRA validAddiModes ;check for next mode
00001AD4                          1410          
00001AD4                          1411  addiBody:
00001AD4                          1412  
00001AD4                          1413  
00001AD4  3401                    1414          MOVE.W  D1,D2 ;copy inst to D2
00001AD6  C47C 00C0               1415          AND.W  #%0000000011000000,D2 ;mask word for size
00001ADA  0C42 00C0               1416          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001ADE  6700 F590               1417          BEQ falsePositive
00001AE2                          1418  
00001AE2  43F9 000023ED           1419          LEA     addiMessage,A1  ;move string for NEG info
00001AE8  103C 000E               1420          MOVE.B  #14,D0        ;set for task to display null terminated 
00001AEC                          1421                                ;string without CR, LF
00001AEC  4E4F                    1422          TRAP    #15
00001AEE                          1423          
00001AEE                          1424          ;go to Effective_Address for immediate data
00001AEE  143C 003C               1425          MOVE.B #%00111100,D2
00001AF2  48E7 4000               1426          MOVEM.L D1,-(SP)
00001AF6  6100 0556               1427          BSR     Get_Effective_Address
00001AFA  4CDF 0002               1428          MOVEM.L (SP)+,D1
00001AFE                          1429          
00001AFE  3401                    1430          MOVE.W D1,D2 ;copy inst to D2
00001B00  C47C 003F               1431          AND #%000000000111111,D2 ;and out everything but modes and regs
00001B04  1A02                    1432          MOVE.B D2,D5 ; copy to D5 for following BSR
00001B06                          1433          
00001B06  48E7 4000               1434          MOVEM.L D1,-(SP)
00001B0A  6100 0542               1435          BSR     Get_Effective_Address
00001B0E  4CDF 0002               1436          MOVEM.L (SP)+,D1
00001B12                          1437          
00001B12                          1438                
00001B12                          1439          
00001B12                          1440  addidone:
00001B12                          1441  
00001B12  43F9 0000239E           1442          LEA     clearLine,A1  ;move string for a CR and LF
00001B18  103C 000E               1443          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B1C                          1444                                ;string without CR, LF
00001B1C  4E4F                    1445          TRAP    #15
00001B1E  7000                    1446          MOVEQ.L #0,D0
00001B20  4E75                    1447          RTS
00001B22                          1448    
00001B22                          1449  ORI:            
00001B22                          1450       
00001B22  7000                    1451          MOVEQ.L #0, D0 ;clear D0
00001B24                          1452          
00001B24                          1453  validOriModes:
00001B24                          1454          
00001B24                          1455          
00001B24  43F9 00001BA3           1456          LEA cmpiEAmasks,A1 ;load the list of masks
00001B2A  D3C0                    1457          ADDA.L D0,A1 ;displace to a specific mask
00001B2C  1A11                    1458          MOVE.B (A1),D5 ;move the mask to D5
00001B2E                          1459          
00001B2E  0C05 0000               1460          CMPI.B #0,D5 ;check if the mask is 0
00001B32  6700 F53C               1461          BEQ falsePositive ;branch if it is
00001B36                          1462          
00001B36  1401                    1463          MOVE.B D1,D2 ;copy instruction to D2
00001B38  C405                    1464          AND.B D5,D2  ;mask D2
00001B3A  43F9 00001B9C           1465          LEA cmpiEA,A1 ;load the list of valid modes
00001B40  D3C0                    1466          ADDA.L D0,A1 ;displace to a specific mode
00001B42  1811                    1467          MOVE.B (A1),D4 ;move mode to D4
00001B44  B404                    1468          CMP.B D4,D2 ;compare mode to masked value
00001B46  6700 0006               1469          BEQ oriBody ;if its match, its a valid mode and we can procede
00001B4A                          1470          
00001B4A  5280                    1471          ADDQ.L #1,D0 ;add one to displacement
00001B4C  60D6                    1472          BRA validOriModes ;check for next mode
00001B4E                          1473          
00001B4E                          1474  oriBody:
00001B4E                          1475  
00001B4E                          1476  
00001B4E  3401                    1477          MOVE.W  D1,D2 ;copy inst to D2
00001B50  C47C 00C0               1478          AND.W  #%0000000011000000,D2 ;mask word for size
00001B54  0C42 00C0               1479          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001B58  6700 F516               1480          BEQ falsePositive
00001B5C                          1481  
00001B5C  43F9 000023F3           1482          LEA     oriMessage,A1  ;move string for NEG info
00001B62  103C 000E               1483          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B66                          1484                                ;string without CR, LF
00001B66  4E4F                    1485          TRAP    #15
00001B68                          1486          
00001B68                          1487          ;go to Effective_Address for immediate data
00001B68  143C 003C               1488          MOVE.B #%00111100,D2
00001B6C  48E7 4000               1489          MOVEM.L D1,-(SP)
00001B70  6100 04DC               1490          BSR     Get_Effective_Address
00001B74  4CDF 0002               1491          MOVEM.L (SP)+,D1
00001B78                          1492          
00001B78  3401                    1493          MOVE.W D1,D2 ;copy inst to D2
00001B7A  C47C 003F               1494          AND #%000000000111111,D2 ;and out everything but modes and regs
00001B7E  1A02                    1495          MOVE.B D2,D5 ; copy to D5 for following BSR
00001B80                          1496          
00001B80  48E7 4000               1497          MOVEM.L D1,-(SP)
00001B84  6100 04C8               1498          BSR     Get_Effective_Address
00001B88  4CDF 0002               1499          MOVEM.L (SP)+,D1
00001B8C                          1500          
00001B8C                          1501                
00001B8C                          1502          
00001B8C                          1503  oridone:
00001B8C                          1504  
00001B8C  43F9 0000239E           1505          LEA     clearLine,A1  ;move string for a CR and LF
00001B92  103C 000E               1506          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B96                          1507                                ;string without CR, LF
00001B96  4E4F                    1508          TRAP    #15
00001B98  7000                    1509          MOVEQ.L #0,D0
00001B9A  4E75                    1510          RTS
00001B9C                          1511  
00001B9C                          1512          
00001B9C                          1513          
00001B9C= 20 18 00 10 38 39 00    1514  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
00001BA3= 38 38 38 38 3F 3F 00    1515  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
00001BAA                          1516     
00001BAA                          1517  CMPI:            
00001BAA                          1518       
00001BAA  7000                    1519          MOVEQ.L #0, D0 ;clear D0
00001BAC                          1520          
00001BAC                          1521  validCmpiModes:
00001BAC                          1522          
00001BAC                          1523          
00001BAC  43F8 1BA3               1524          LEA cmpiEAmasks,A1 ;load the list of masks
00001BB0  D3C0                    1525          ADDA.L D0,A1 ;displace to a specific mask
00001BB2  1A11                    1526          MOVE.B (A1),D5 ;move the mask to D5
00001BB4                          1527          
00001BB4  0C05 0000               1528          CMPI.B #0,D5 ;check if the mask is 0
00001BB8  6700 F4B6               1529          BEQ falsePositive ;branch if it is
00001BBC                          1530          
00001BBC  1401                    1531          MOVE.B D1,D2 ;copy instruction to D2
00001BBE  C405                    1532          AND.B D5,D2  ;mask D2
00001BC0  43F8 1B9C               1533          LEA cmpiEA,A1 ;load the list of valid modes
00001BC4  D3C0                    1534          ADDA.L D0,A1 ;displace to a specific mode
00001BC6  1811                    1535          MOVE.B (A1),D4 ;move mode to D4
00001BC8  B404                    1536          CMP.B D4,D2 ;compare mode to masked value
00001BCA  6700 0006               1537          BEQ CMPIBody ;if its match, its a valid mode and we can procede
00001BCE                          1538          
00001BCE  5280                    1539          ADDQ.L #1,D0 ;add one to displacement
00001BD0  60DA                    1540          BRA validCmpiModes ;check for next mode
00001BD2                          1541          
00001BD2                          1542  CMPIBody:
00001BD2                          1543  
00001BD2                          1544  
00001BD2  3401                    1545          MOVE.W  D1,D2 ;copy inst to D2
00001BD4  C47C 00C0               1546          AND.W  #%0000000011000000,D2 ;mask word for size
00001BD8  0C42 00C0               1547          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001BDC  6700 F492               1548          BEQ falsePositive
00001BE0                          1549  
00001BE0  43F9 000023F8           1550          LEA     cmpiMessage,A1  ;move string for NEG info
00001BE6  103C 000E               1551          MOVE.B  #14,D0        ;set for task to display null terminated 
00001BEA                          1552                                ;string without CR, LF
00001BEA  4E4F                    1553          TRAP    #15
00001BEC                          1554          
00001BEC                          1555          ;go to Effective_Address for immediate data
00001BEC  143C 003C               1556          MOVE.B #%00111100,D2
00001BF0  48E7 4000               1557          MOVEM.L D1,-(SP)
00001BF4  6100 0458               1558          BSR     Get_Effective_Address
00001BF8  4CDF 0002               1559          MOVEM.L (SP)+,D1
00001BFC                          1560          
00001BFC  3401                    1561          MOVE.W D1,D2 ;copy inst to D2
00001BFE  C47C 003F               1562          AND #%000000000111111,D2 ;and out everything but modes and regs
00001C02  1A02                    1563          MOVE.B D2,D5 ; copy to D5 for following BSR
00001C04                          1564          
00001C04  48E7 4000               1565          MOVEM.L D1,-(SP)
00001C08  6100 0444               1566          BSR     Get_Effective_Address
00001C0C  4CDF 0002               1567          MOVEM.L (SP)+,D1
00001C10                          1568          
00001C10                          1569                
00001C10                          1570          
00001C10                          1571  CMPidone:
00001C10                          1572  
00001C10  43F9 0000239E           1573          LEA     clearLine,A1  ;move string for a CR and LF
00001C16  103C 000E               1574          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C1A                          1575                                ;string without CR, LF
00001C1A  4E4F                    1576          TRAP    #15
00001C1C  7000                    1577          MOVEQ.L #0,D0
00001C1E  4E75                    1578          RTS
00001C20                          1579  
00001C20                          1580          
00001C20= 10 38 39 00             1581  JsrEA        DC.B %010000, %111000, %111001,0
00001C24= 38 3F 3F 00             1582  JsrEAmasks   DC.B %111000, %111111, %111111,0
00001C28                          1583     
00001C28                          1584  JSR:            
00001C28                          1585       
00001C28  7000                    1586          MOVEQ.L #0, D0 ;clear D0
00001C2A                          1587          
00001C2A                          1588  validJsrModes:
00001C2A                          1589          
00001C2A  43F8 1C24               1590          LEA JsrEAmasks,A1 ;load the list of masks
00001C2E  D3C0                    1591          ADDA.L D0,A1 ;displace to a specific mask
00001C30  1A11                    1592          MOVE.B (A1),D5 ;move the mask to D5
00001C32                          1593          
00001C32  0C05 0000               1594          CMPI.B #0,D5 ;check if the mask is 0
00001C36  6700 F438               1595          BEQ falsePositive ;branch if it is
00001C3A                          1596          
00001C3A  1401                    1597          MOVE.B D1,D2 ;copy instruction to D2
00001C3C  C405                    1598          AND.B D5,D2  ;mask D2
00001C3E  43F8 1C20               1599          LEA JsrEA,A1 ;load the list of valid modes
00001C42  D3C0                    1600          ADDA.L D0,A1 ;displace to a specific mode
00001C44  1811                    1601          MOVE.B (A1),D4 ;move mode to D4
00001C46  B404                    1602          CMP.B D4,D2 ;compare mode to masked value
00001C48  6700 0006               1603          BEQ JsrBody ;if its match, its a valid mode and we can procede
00001C4C                          1604          
00001C4C  5280                    1605          ADDQ.L #1,D0 ;add one to displacement
00001C4E  60DA                    1606          BRA validJsrModes ;check for next mode
00001C50                          1607          
00001C50                          1608  JsrBody:
00001C50                          1609  
00001C50                          1610  
00001C50  43F9 000023FE           1611          LEA     jsrMessage,A1  ;move string for NEG info
00001C56  103C 000E               1612          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C5A                          1613                                ;string without CR, LF
00001C5A  4E4F                    1614          TRAP    #15
00001C5C                          1615          
00001C5C  3401                    1616          MOVE.W D1,D2 ;copy inst to D2
00001C5E  C47C 003F               1617          AND #%000000000111111,D2 ;and out everything but modes and regs
00001C62  1A02                    1618          MOVE.B D2,D5 ; copy to D5 for following BSR
00001C64                          1619          
00001C64  48E7 4000               1620          MOVEM.L D1,-(SP)
00001C68  6100 03E4               1621          BSR     Get_Effective_Address
00001C6C  4CDF 0002               1622          MOVEM.L (SP)+,D1
00001C70                          1623          
00001C70                          1624                
00001C70                          1625          
00001C70                          1626  Jsrdone:
00001C70                          1627  
00001C70  43F9 0000239E           1628          LEA     clearLine,A1  ;move string for a CR and LF
00001C76  103C 000E               1629          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C7A                          1630                                ;string without CR, LF
00001C7A  4E4F                    1631          TRAP    #15
00001C7C  7000                    1632          MOVEQ.L #0,D0
00001C7E  4E75                    1633          RTS
00001C80                          1634  
00001C80                          1635  
00001C80                          1636          
00001C80                          1637  NOP:
00001C80                          1638  
00001C80  43F9 00002408           1639          LEA     nopMessage,A1 ;move string for NOP info
00001C86  103C 000D               1640          MOVE.B  #13,D0        ;set for task to display null terminated 
00001C8A                          1641                                ;string with CR, LF
00001C8A  4E4F                    1642          TRAP    #15
00001C8C                          1643          
00001C8C  7000                    1644          MOVEQ.L #0,D0
00001C8E  4E75                    1645          RTS
00001C90                          1646          
00001C90                          1647  RTS:
00001C90                          1648          
00001C90  43F9 00002403           1649          LEA     rtsMessage,A1  ;move string for rts info
00001C96  103C 000D               1650          MOVE.B  #13,D0        ;set for task to display null terminated 
00001C9A                          1651                                ;string with CR, LF
00001C9A  4E4F                    1652          TRAP    #15  
00001C9C                          1653     
00001C9C  7000                    1654          MOVEQ.L #0,D0
00001C9E  4E75                    1655          RTS   
00001CA0                          1656  
00001CA0= 3C 08 00 10 18 20 ...   1657  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
00001CA9= 3F 38 38 38 38 38 ...   1658  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001CB2                          1659  
00001CB2= 00 10 18 20 38 39 00    1660  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
00001CB9= 38 38 38 38 3F 3F 00    1661  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
00001CC0                          1662  
00001CC0                          1663  MOVE:
00001CC0                          1664          
00001CC0                          1665  
00001CC0                          1666          
00001CC0  7000                    1667          MOVEQ.L #0, D0 ;clear D0
00001CC2                          1668          
00001CC2                          1669  validMoveSourceModes:
00001CC2                          1670          
00001CC2  43F8 1CA9               1671          LEA moveSourceEAmasks,A1 ;load the list of masks
00001CC6  D3C0                    1672          ADDA.L D0,A1 ;displace to a specific mask
00001CC8  1A11                    1673          MOVE.B (A1),D5 ;move the mask to D5
00001CCA                          1674          
00001CCA  0C05 0000               1675          CMPI.B #0,D5 ;check if the mask is 0
00001CCE  6700 F3A0               1676          BEQ falsePositive ;branch if it is
00001CD2                          1677          
00001CD2  1401                    1678          MOVE.B D1,D2 ;copy instruction to D2
00001CD4  C405                    1679          AND.B D5,D2  ;mask D2
00001CD6                          1680          
00001CD6  43F8 1CA0               1681          LEA moveSourceEA,A1 ;load the list of valid modes
00001CDA  D3C0                    1682          ADDA.L D0,A1 ;displace to a specific mode
00001CDC  1811                    1683          MOVE.B (A1),D4 ;move mode to D4
00001CDE  B404                    1684          CMP.B D4,D2 ;compare mode to masked value
00001CE0  6700 0006               1685          BEQ  checkMoveDest ;if its match, its a valid mode and we can procede
00001CE4                          1686          
00001CE4  5280                    1687          ADDQ.L #1,D0 ;add one to displacement
00001CE6  60DA                    1688          BRA validMoveSourceModes ;check for next mode
00001CE8                          1689          
00001CE8                          1690  checkMoveDest:
00001CE8  7000                    1691          MOVEQ.L #0, D0 ;clear D0
00001CEA                          1692          
00001CEA                          1693  validMoveDestModes:
00001CEA                          1694          
00001CEA  43F8 1CB9               1695          LEA moveDestEAmasks,A1 ;load the list of masks
00001CEE  D3C0                    1696          ADDA.L D0,A1 ;displace to a specific mask
00001CF0  1A11                    1697          MOVE.B (A1),D5 ;move the mask to D5
00001CF2                          1698          
00001CF2  0C05 0000               1699          CMPI.B #0,D5 ;check if the mask is 0
00001CF6  6700 F378               1700          BEQ falsePositive ;branch if it is
00001CFA                          1701          
00001CFA  3401                    1702          MOVE.W D1,D2 ;copy instruction to D2
00001CFC  EC4A                    1703          LSR.W #6,D2  ;move mode
00001CFE  6100 04C2               1704          BSR switchModeAndReg ;switch register and mode
00001D02  C405                    1705          AND.B D5,D2  ;mask D2
00001D04                          1706          
00001D04  43F8 1CB2               1707          LEA moveDestEA,A1 ;load the list of valid modes
00001D08  D3C0                    1708          ADDA.L D0,A1 ;displace to a specific mode
00001D0A  1811                    1709          MOVE.B (A1),D4 ;move mode to D4
00001D0C  B404                    1710          CMP.B D4,D2 ;compare mode to masked value
00001D0E  6700 0006               1711          BEQ moveBody ;if its match, its a valid mode and we can procede
00001D12                          1712          
00001D12  5280                    1713          ADDQ.L #1,D0 ;add one to displacement
00001D14  60D4                    1714          BRA validMoveDestModes ;check for next mode
00001D16                          1715          
00001D16                          1716  moveBody
00001D16  3401                    1717          MOVE.W  D1,D2 ;copy inst to D2
00001D18  C47C 3000               1718          AND.W  #%0011000000000000,D2 ;mask word for size
00001D1C  0C42 0000               1719          CMPI.W #0,D2 ;0 is the only non valid size
00001D20  6700 F34E               1720          BEQ falsePositive ; if zero, this is not move
00001D24                          1721  
00001D24  43F9 0000240D           1722          LEA     moveMessage,A1  ;move string for MOVE
00001D2A  103C 000E               1723          MOVE.B  #14,D0        ;set for task to display null terminated 
00001D2E                          1724                                ;string with CR, LF
00001D2E  4E4F                    1725          TRAP    #15
00001D30                          1726          
00001D30                          1727          
00001D30  3401                    1728          MOVE.W  D1,D2 ;check source mode
00001D32  C43C 003F               1729          AND.B   #%00111111,D2
00001D36  1A02                    1730          MOVE.B  D2,D5
00001D38  48E7 4000               1731          MOVEM.L D1,-(SP)
00001D3C  6100 0310               1732          BSR     Get_Effective_Address
00001D40  4CDF 0002               1733          MOVEM.L (SP)+,D1
00001D44                          1734          
00001D44                          1735          ;print separator
00001D44                          1736          
00001D44  3401                    1737          MOVE.W  D1,D2 ;check dest mode
00001D46  EC4A                    1738          LSR.W   #6,D2
00001D48  6100 0478               1739          BSR  switchModeAndReg
00001D4C  C43C 003F               1740          AND.B   #%00111111,D2
00001D50  1A02                    1741          MOVE.B  D2,D5
00001D52  48E7 4000               1742          MOVEM.L D1,-(SP)
00001D56  6100 02F6               1743          BSR     Get_Effective_Address
00001D5A  4CDF 0002               1744          MOVEM.L (SP)+,D1
00001D5E                          1745          
00001D5E                          1746          
00001D5E                          1747          
00001D5E  43F9 0000239E           1748          LEA     clearLine,A1  ;move string for a CR and LF
00001D64  103C 000E               1749          MOVE.B  #14,D0        ;set for task to display null terminated 
00001D68                          1750                                ;string without CR, LF
00001D68  4E4F                    1751          TRAP    #15
00001D6A                          1752  
00001D6A  7000                    1753          MOVEQ.L #0,D0
00001D6C  4E75                    1754          RTS
00001D6E                          1755          
00001D6E= 08 00                   1756  moveADestEA        DC.B %001000,0
00001D70= 38 00                   1757  moveADestEAmasks   DC.B %111000,0
00001D72                          1758          
00001D72                          1759  MOVEA:
00001D72                          1760  
00001D72  7000                    1761          MOVEQ.L #0, D0 ;clear D0
00001D74                          1762          
00001D74                          1763  validMoveASourceModes:
00001D74                          1764          
00001D74  43F8 1CA9               1765          LEA moveSourceEAmasks,A1 ;load the list of masks
00001D78  D3C0                    1766          ADDA.L D0,A1 ;displace to a specific mask
00001D7A  1A11                    1767          MOVE.B (A1),D5 ;move the mask to D5
00001D7C                          1768          
00001D7C  0C05 0000               1769          CMPI.B #0,D5 ;check if the mask is 0
00001D80  6700 F2EE               1770          BEQ falsePositive ;branch if it is
00001D84                          1771          
00001D84  1401                    1772          MOVE.B D1,D2 ;copy instruction to D2
00001D86  C405                    1773          AND.B D5,D2  ;mask D2
00001D88                          1774          
00001D88  43F8 1CA0               1775          LEA moveSourceEA,A1 ;load the list of valid modes
00001D8C  D3C0                    1776          ADDA.L D0,A1 ;displace to a specific mode
00001D8E  1811                    1777          MOVE.B (A1),D4 ;move mode to D4
00001D90  B404                    1778          CMP.B D4,D2 ;compare mode to masked value
00001D92  6700 0006               1779          BEQ  checkMoveADest ;if its match, its a valid mode and we can procede
00001D96                          1780          
00001D96  5280                    1781          ADDQ.L #1,D0 ;add one to displacement
00001D98  60DA                    1782          BRA validMoveASourceModes ;check for next mode
00001D9A                          1783          
00001D9A                          1784  checkMoveADest:
00001D9A  7000                    1785          MOVEQ.L #0, D0 ;clear D0
00001D9C                          1786  validMoveADestModes:
00001D9C                          1787          
00001D9C  43F8 1D70               1788          LEA moveADestEAmasks,A1 ;load the list of masks
00001DA0  D3C0                    1789          ADDA.L D0,A1 ;displace to a specific mask
00001DA2  1A11                    1790          MOVE.B (A1),D5 ;move the mask to D5
00001DA4                          1791          
00001DA4  0C05 0000               1792          CMPI.B #0,D5 ;check if the mask is 0
00001DA8  6700 F2C6               1793          BEQ falsePositive ;branch if it is
00001DAC                          1794          
00001DAC  3401                    1795          MOVE.W D1,D2 ;copy instruction to D2
00001DAE  EA4A                    1796          LSR.W #5,D2  ;move mode
00001DB0  6100 0410               1797          BSR switchModeAndReg ;switch register and mode
00001DB4  C405                    1798          AND.B D5,D2  ;mask D2
00001DB6                          1799          
00001DB6  43F8 1D6E               1800          LEA moveADestEA,A1 ;load the list of valid modes
00001DBA  D3C0                    1801          ADDA.L D0,A1 ;displace to a specific mode
00001DBC  1811                    1802          MOVE.B (A1),D4 ;move mode to D4
00001DBE  B404                    1803          CMP.B D4,D2 ;compare mode to masked value
00001DC0  6700 0006               1804          BEQ moveABody ;if its match, its a valid mode and we can procede
00001DC4                          1805          
00001DC4  5280                    1806          ADDQ.L #1,D0 ;add one to displacement
00001DC6  60D4                    1807          BRA validMoveADestModes ;check for next mode
00001DC8                          1808  moveABody:
00001DC8  3401                    1809          MOVE.W  D1,D2 ;copy inst to D2
00001DCA  C47C 3000               1810          AND.W  #%0011000000000000,D2 ;mask word for size
00001DCE  0C42 0000               1811          CMPI.W #0,D2 ;0 is the non valid size
00001DD2  6700 F29C               1812          BEQ falsePositive ; if zero, this is not move
00001DD6  0C42 1000               1813          CMPI.W #%0001000000000000,D2
00001DDA  6700 F294               1814          BEQ falsePositive ; if byte, this is not movea
00001DDE                          1815  
00001DDE                          1816  
00001DDE  43F9 00002420           1817          LEA     moveAMessage,A1  ;move string for MOVE
00001DE4  103C 000D               1818          MOVE.B  #13,D0        ;set for task to display null terminated 
00001DE8                          1819                                ;string with CR, LF
00001DE8  4E4F                    1820          TRAP    #15
00001DEA                          1821  
00001DEA  7000                    1822          MOVEQ.L #0,D0
00001DEC  4E75                    1823          RTS
00001DEE                          1824  
00001DEE                          1825             
00001DEE                          1826  Bcc:
00001DEE                          1827  
00001DEE  43F9 00002413           1828          LEA     bccMessage,A1  ;move string for BRA info
00001DF4  103C 000E               1829          MOVE.B  #14,D0        ;set for task to display null terminated 
00001DF8                          1830                                ;string without CR, LF
00001DF8  4E4F                    1831          TRAP    #15
00001DFA                          1832          
00001DFA  7000                    1833          MOVEQ.L #0,D0 ;clear D0
00001DFC  3401                    1834          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001DFE  E04A                    1835          LSR.W   #8,D2
00001E00  C47C 000F               1836          AND.W   #$0F,D2 ;mask instruction
00001E04                          1837          
00001E04                          1838  checkCC:        
00001E04  41F9 00002325           1839          LEA     bccList,A0 ;get condition code signature list in A0
00001E0A  D1C0                    1840          ADDA.L  D0,A0 ;get correct sig         
00001E0C  B410                    1841          CMP.B   (A0),D2 ;compare to sig
00001E0E  6700 0006               1842          BEQ     foundCC ;if sig matches branch
00001E12  5200                    1843          ADDQ.B  #byte,D0
00001E14  60EE                    1844          BRA     checkCC
00001E16                          1845  foundCC:
00001E16  43F9 00002336           1846          LEA     conditionCodeMessage,A1 ;get condition code message in A1
00001E1C  C0FC 0004               1847          MULU.W  #long,D0 ;adjust size of D0 for a long
00001E20  D3C0                    1848          ADDA.L  D0,A1 ;get correct message location
00001E22  2251                    1849          MOVEA.L (A1),A1 ;get correct message
00001E24                          1850          
00001E24  103C 000E               1851          MOVE.B  #14,D0        ;set for task to display null terminated 
00001E28                          1852                                ;string without CR, LF
00001E28  4E4F                    1853          TRAP    #15
00001E2A                          1854  
00001E2A                          1855          
00001E2A                          1856          
00001E2A  548B                    1857          ADDQ.L  #word,A3 ;move past instruction in case long displacement
00001E2C  C27C 00FF               1858          AND.W   #$00FF,D1   ;check for word sized displacement
00001E30                          1859          
00001E30  B23C 0000               1860          CMP.B   #$0,D1
00001E34  6700 0010               1861          BEQ     BccWord
00001E38                          1862          
00001E38  B23C 00FF               1863          CMP.B   #$FF,D1 check for long sized displacement
00001E3C  6700 0010               1864          BEQ     BccLong
00001E40                          1865          
00001E40                          1866  BccByte:
00001E40                          1867          
00001E40  7E00                    1868          MOVEQ.L #0,D7 ;pass back no extra data followed
00001E42  6000 0012               1869          BRA     BccDone
00001E46                          1870  BccWord:
00001E46  3213                    1871          MOVE.W  (A3),D1
00001E48                          1872          
00001E48  7E02                    1873          MOVEQ.L #word,D7 ;pass back an extra word followed
00001E4A  6000 000A               1874          BRA     BccDone
00001E4E                          1875  BccLong:
00001E4E  2213                    1876          MOVE.L  (A3),D1
00001E50                          1877          
00001E50  7E04                    1878          MOVEQ.L #long,D7 ;pass back an extra long followed
00001E52  6000 0002               1879          BRA     BccDone
00001E56                          1880  BccDone:
00001E56                          1881  
00001E56  343C 0010               1882          MOVE.W  #16,D2 ;put base in D2
00001E5A  303C 000F               1883          MOVE.W  #15,D0  ;put task #15 in D0
00001E5E  4E4F                    1884          TRAP    #15
00001E60                          1885          
00001E60  43F9 0000239E           1886          LEA     clearLine,A1  ;move string for a CR and LF
00001E66  103C 000E               1887          MOVE.B  #14,D0        ;set for task to display null terminated 
00001E6A                          1888                                ;string without CR, LF
00001E6A  4E4F                    1889          TRAP    #15
00001E6C                          1890  
00001E6C  7000                    1891          MOVEQ.L #0,D0
00001E6E  4E75                    1892          RTS
00001E70                          1893          
00001E70                          1894          
00001E70                          1895  unknownOpCode:
00001E70  43F9 0000241A           1896          LEA     dataMessage,A1 ;move string for data info
00001E76  103C 000E               1897          MOVE.B  #14,D0        ;set for task to display null terminated 
00001E7A                          1898                                ;string without CR, LF
00001E7A  4E4F                    1899          TRAP    #15
00001E7C                          1900          
00001E7C  143C 0010               1901          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001E80  103C 000F               1902          MOVE.B  #15,D0
00001E84  4E4F                    1903          TRAP    #15
00001E86                          1904          
00001E86  43F9 0000239E           1905          LEA     clearLine,A1  ;move string for a CR and LF
00001E8C  103C 000E               1906          MOVE.B  #14,D0        ;set for task to display null terminated 
00001E90                          1907                                ;string without CR, LF
00001E90  4E4F                    1908          TRAP    #15
00001E92                          1909          
00001E92  7000                    1910          MOVEQ.L #0,D0
00001E94  4E75                    1911          RTS
00001E96                          1912          
00001E96                          1913  handlebytedata:
00001E96                          1914  
00001E96  43F9 0000241A           1915          LEA     dataMessage,A1 ;move string for data info
00001E9C  103C 000E               1916          MOVE.B  #14,D0        ;set for task to display null terminated 
00001EA0                          1917                                ;string without CR, LF
00001EA0  4E4F                    1918          TRAP    #15
00001EA2                          1919          
00001EA2  E049                    1920          LSR.W   #8,D1 ;shift the word read into D1 by a byte
00001EA4                          1921          
00001EA4  143C 0010               1922          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001EA8  103C 000F               1923          MOVE.B  #15,D0
00001EAC  4E4F                    1924          TRAP    #15
00001EAE                          1925          
00001EAE  43F9 0000239E           1926          LEA     clearLine,A1  ;move string for a CR and LF
00001EB4  103C 000E               1927          MOVE.B  #14,D0        ;set for task to display null terminated 
00001EB8                          1928                                ;string without CR, LF
00001EB8  4E4F                    1929          TRAP    #15
00001EBA                          1930          
00001EBA  7000                    1931          MOVEQ.L #0,D0
00001EBC                          1932          
00001EBC  528B                    1933          ADDQ.L  #byte,A3
00001EBE  6000 F166               1934          BRA main_Loop
00001EC2                          1935  
00001EC2                          1936          
00001EC2                          1937          
00001EC2                          1938  fin
00001EC2                          1939  
00001EC2                          1940          
00001EC2                          1941          
00001EC2  FFFF FFFF               1942          simhalt
00001EC6                          1943          
00001EC6                          1944  
00001EC6                          1945  *******************************************************************************
00001EC6                          1946  *                            SUB ROUTINES
00001EC6                          1947  *******************************************************************************
00001EC6                          1948  
00001EC6                          1949  *******************************************************************************
00001EC6                          1950  *                          IO ROLE ROUTINES
00001EC6                          1951  *******************************************************************************
00001EC6                          1952  
00001EC6                          1953  *==========================================================================
00001EC6                          1954  *                   Enter / Validate beginning address 
00001EC6                          1955  *==========================================================================
00001EC6                          1956   
00001EC6                          1957  begin_address:
00001EC6                          1958  
00001EC6                          1959         
00001EC6  43F9 000021D6           1960          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00001ECC  2239 000021D6           1961          MOVE.L      slPrompt,D1         ;Load display length to D1
00001ED2  700E                    1962          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001ED4  4E4F                    1963          TRAP        #15                 ;Perform task 14 (display)
00001ED6                          1964          
00001ED6  43F9 00002452           1965          LEA         startLocation,A1    ;Load address to store user input
00001EDC  103C 0002               1966          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001EE0  4E4F                    1967          TRAP        #15                 ;Perform task 2 (input)
00001EE2                          1968          
00001EE2  0C11 001B               1969          CMP.B       #27,(A1)            ;Check for ESC entered
00001EE6  6700 004C               1970          BEQ         address_Exit        ;Exit condition 
00001EEA                          1971          
00001EEA  6100 0050               1972          BSR         enter_addr_edit_all
00001EEE  B67C FFFF               1973          CMP.W       #-1,D3              ;Did the edit pass?
00001EF2  67D2                    1974          BEQ         begin_address       ;No, loop and ask for correct input
00001EF4                          1975          
00001EF4  2643                    1976          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
00001EF6                          1977          
00001EF6  43F9 000022E3           1978          LEA         spc,A1              ;Load address for starting loaction prompt
00001EFC  1239 000022E4           1979          MOVE.B      spc_len,D1          ;Load empty line length
00001F02  7000                    1980          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
00001F04  4E4F                    1981          TRAP        #15                 ;Perform task 14 (display)
00001F06  6000 0002               1982          BRA         end_address
00001F0A                          1983  
00001F0A                          1984  *===========================================================================
00001F0A                          1985  *                   Enter / Validate ending address 
00001F0A                          1986  *===========================================================================
00001F0A                          1987  
00001F0A                          1988  end_address:
00001F0A                          1989          
00001F0A  43F9 00002207           1990          LEA         elPrompt,A1         ;Load address for ending loaction prompt
00001F10                          1991          ;MOVE.L     elPrompt,D1         ;Load display length to D1
00001F10  7250                    1992          MOVE.L      #80,D1       ;did not like previous command, do not know why, it should have worked
00001F12  700E                    1993          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001F14  4E4F                    1994          TRAP        #15                 ;Perform task 14 (display)
00001F16                          1995          
00001F16  103C 0002               1996          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001F1A  4E4F                    1997          TRAP        #15                 ;Perform task 2 (input)
00001F1C                          1998          
00001F1C  0C11 001B               1999          CMP.B       #27,(A1)            ;Check for ESC entered
00001F20  6700 0012               2000          BEQ         address_Exit        ;Exit condition 
00001F24                          2001          
00001F24  6100 0016               2002          BSR         enter_addr_edit_all
00001F28  B67C FFFF               2003          CMP.W       #-1,D3              ;Did the edit pass?
00001F2C  67DC                    2004          BEQ         end_address         ;No, loop and ask for correct input
00001F2E                          2005  
00001F2E  2843                    2006          MOVEA.L     D3,A4               ;Ending address gets stored in A4
00001F30  6000 0008               2007          BRA         address_done
00001F34                          2008  
00001F34                          2009  address_Exit:
00001F34                          2010  
00001F34  76FF                    2011          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001F36  6000 0002               2012          BRA         address_done
00001F3A                          2013          
00001F3A                          2014  address_done:
00001F3A                          2015  
00001F3A  4E75                    2016          RTS    
00001F3C                          2017  
00001F3C                          2018  *==============================================================================
00001F3C                          2019  * enter_addr_edit_all - Enter address edit check to edit all errors  
00001F3C                          2020  *                       using multiple different error checking routines.
00001F3C                          2021  *
00001F3C                          2022  * Parameters -
00001F3C                          2023  *   Input   A1      The data that needs checked.
00001F3C                          2024  *   Input   D1      The number of characters input     
00001F3C                          2025  *   Output  D3      Returns '-1' when there is an error.
00001F3C                          2026  *==============================================================================
00001F3C                          2027  
00001F3C                          2028  enter_addr_edit_all
00001F3C                          2029  
00001F3C                          2030  *------------------------------------------------------------------------------
00001F3C                          2031  * Test for odd number of characters entered, not allowed
00001F3C                          2032  *------------------------------------------------------------------------------
00001F3C                          2033         
00001F3C  6100 0024               2034          BSR         ck_boundry          ;check if the input is on a odd / even boundry
00001F40  B67C FFFF               2035          CMP.W       #-1,D3              ;Is the address odd?
00001F44  6700 001A               2036          BEQ         enter_addr_edit_all_exit     ;No, return
00001F48                          2037  
00001F48                          2038  *------------------------------------------------------------------------------
00001F48                          2039  * Ttest for character entered all being valid address characters
00001F48                          2040  * Note: lower case a-f, gets converted to upper case A-F in D3
00001F48                          2041  *------------------------------------------------------------------------------
00001F48                          2042          
00001F48  6100 0062               2043          BSR         parseHexString      ;check if the input contains valid Hex characters
00001F4C  B67C FFFF               2044          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
00001F50  6700 000E               2045          BEQ         enter_addr_edit_all_exit     ;No, return
00001F54                          2046  
00001F54                          2047  *------------------------------------------------------------------------------
00001F54                          2048  * Verify that the address entered is witin the range defined in the Equate
00001F54                          2049  *------------------------------------------------------------------------------        
00001F54                          2050          
00001F54  6100 00C8               2051          BSR         ck_addr_range       ;is address entered witin the range 
00001F58                          2052                                          ;   as defined in the Equate? 
00001F58  B67C FFFF               2053          CMP.W       #-1,D3              ;is the address  valid?
00001F5C  6700 0002               2054          BEQ         enter_addr_edit_all_exit     ;No, return
00001F60                          2055  
00001F60                          2056  enter_addr_edit_all_exit:
00001F60                          2057  
00001F60  4E75                    2058          RTS                             ;return
00001F62                          2059  
00001F62                          2060  *==============================================================================
00001F62                          2061  * ck_boundry - Check the size of the data characters input and determine
00001F62                          2062  *              if an odd number of characters was entered
00001F62                          2063  *
00001F62                          2064  * Parameters -
00001F62                          2065  *   Input   A1      The data that needs checked for odd length.
00001F62                          2066  *   Input   D1      The number of characters input     
00001F62                          2067  *   Output  D3      Returns '-1' when there is an odd length.
00001F62                          2068  *==============================================================================
00001F62                          2069  
00001F62                          2070  ck_boundry:
00001F62                          2071  
00001F62  4243                    2072          CLR.W       D3                  ;Clear the return
00001F64                          2073  
00001F64  B23C 0000               2074          CMP.B       #0,D1               ;Check for nothing entered
00001F68  6700 002E               2075          BEQ         ck_size_error       ;Number of characters entered must be 
00001F6C                          2076                                          ;greater than 0  
00001F6C                          2077          
00001F6C                          2078          
00001F6C                          2079          * The program will branch to ck_size_error if D1 is greater than #8        
00001F6C  B23C 0008               2080          CMP.B       #8,D1               ;Check for more than 8 characters entered
00001F70  6E00 0026               2081          BGT         ck_size_error       ;Number of characters entered must be less
00001F74                          2082                                          ;than 9
00001F74                          2083          
00001F74  7402                    2084          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
00001F76  82C2                    2085          DIVU        D2,D1               ;Divide address by 2
00001F78  4841                    2086          SWAP        D1                  ;get remainder
00001F7A  B23C 0001               2087          CMP.B       #$01,D1             ;Check for remainder of 1
00001F7E  6700 0004               2088          BEQ         ck_boundry_error    ;Number of characters entered must be an 
00001F82                          2089                                          ;even number   
00001F82                          2090    
00001F82  4E75                    2091          RTS                             ;return
00001F84                          2092  
00001F84                          2093  *------------------------------------------------------------------------------
00001F84                          2094  * ck_boundry_error - An odd number of characters was entered
00001F84                          2095  *                  - Load error message and display it
00001F84                          2096  *                  - Return error condition
00001F84                          2097  *------------------------------------------------------------------------------
00001F84                          2098          
00001F84                          2099  ck_boundry_error:
00001F84                          2100  
00001F84  43F9 000022C3           2101          LEA         even_msg,A1         ;Load odd error message into A1
00001F8A  2239 000022C3           2102          MOVE.L      even_msg,D1         ;Load error length to D1
00001F90                          2103          
00001F90  7000                    2104          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001F92                          2105                                          ; n is D1.W with CR, LF. 
00001F92  4E4F                    2106          TRAP #15                        ;Display the error message
00001F94  76FF                    2107          MOVE.L #-1,D3                   ;Load -1 into return parameter
00001F96  4E75                    2108          RTS                             ;Return
00001F98                          2109          
00001F98                          2110  *------------------------------------------------------------------------------
00001F98                          2111  * ck_size_error -   The number of characters entered must be more than zero
00001F98                          2112  *                  - Load error message and display it
00001F98                          2113  *                  - Return error condition
00001F98                          2114  *------------------------------------------------------------------------------
00001F98                          2115          
00001F98                          2116  ck_size_error:
00001F98                          2117  
00001F98  43F9 00002236           2118          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001F9E  2239 00002236           2119          MOVE.L      invalidMsg,D1       ;Load error length to D1
00001FA4                          2120          
00001FA4  7000                    2121          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001FA6                          2122                                          ; n is D1.W with CR, LF. 
00001FA6  4E4F                    2123          TRAP        #15                 ;Display the error message
00001FA8  76FF                    2124          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001FAA  4E75                    2125          RTS                             ;Return        
00001FAC                          2126  
00001FAC                          2127  
00001FAC                          2128  *==============================================================================
00001FAC                          2129  * parseHexString - Converts user input string into a valid memory address
00001FAC                          2130  *                - Stores parsed address data into D3
00001FAC                          2131  *                - Stores good/bad (1/0) data in D4 
00001FAC                          2132  *
00001FAC                          2133  * Hex values are stored as bytes in D2, the ASCII chart shows their value
00001FAC                          2134  *   The ASCII chart values we care about are in the ranges of: 
00001FAC                          2135  *                            Hex            Decimal
00001FAC                          2136  *       No Value           NULL = 0         0
00001FAC                          2137  *       Numeric Values:     0-9 = 30-39     48-57
00001FAC                          2138  *       Upper Case letters: A-F = 41-46     65-70
00001FAC                          2139  *       Lower Case letterc: a-f = 61-66     97-102
00001FAC                          2140  
00001FAC                          2141  * Parameters -
00001FAC                          2142  *   Input   A1      The data that needs checked for valid input.
00001FAC                          2143  *   Output  D3      The return value, '-1' for error
00001FAC                          2144  *==============================================================================
00001FAC                          2145  
00001FAC                          2146  parseHexString:
00001FAC                          2147  
00001FAC                          2148  * setup any initializing item that do not get looped through
00001FAC  4243                    2149          CLR.W       D3                  ;Clear the return
00001FAE                          2150  
00001FAE                          2151          
00001FAE                          2152  *------------------------------------------------------------------------------
00001FAE                          2153  * NextHex - Loop through all bytes and vaildate the input
00001FAE                          2154  * Parameters -
00001FAE                          2155  *   Input   A1      The data that needs checked for valid input.
00001FAE                          2156  *   Output  D3      The return value, '-1' for error
00001FAE                          2157  *------------------------------------------------------------------------------
00001FAE                          2158          
00001FAE                          2159  NextHex:
00001FAE                          2160  
00001FAE  1419                    2161          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00001FB0  B43C 0000               2162          CMP.B       #0,D2               ;Check character for null 
00001FB4  6700 0066               2163          BEQ         NextHexReturn       ;Character is null (end of input)
00001FB8                          2164          
00001FB8                          2165  *................................................................................
00001FB8                          2166  *  Check decimal values 0-9 by testing hexadecimal values 30-39
00001FB8                          2167  *................................................................................
00001FB8                          2168                  
00001FB8                          2169          * The program will branch to hex_range_error if D2 is less than #30
00001FB8  B43C 0030               2170          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
00001FBC  6D00 0048               2171          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001FC0                          2172                                          ;processing
00001FC0                          2173          
00001FC0                          2174          * The program will branch to UcaseHex if D2 is greater than #39
00001FC0  B43C 0039               2175          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
00001FC4  6E00 000A               2176          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
00001FC8                          2177          
00001FC8                          2178          *a valid number was found within this range
00001FC8  0402 0030               2179          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
00001FCC  6000 0032               2180          BRA         NextHexDone         ;Done parsing this byte
00001FD0                          2181  
00001FD0                          2182  
00001FD0                          2183  *..............................................................................
00001FD0                          2184  *  Check upper case values A-F by testing hexadecimal values 41-46
00001FD0                          2185  *..............................................................................
00001FD0                          2186  
00001FD0                          2187  UcaseHex:
00001FD0                          2188  
00001FD0                          2189          * The program will branch to hex_range_error if D2 is less than #41
00001FD0  B43C 0041               2190          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
00001FD4  6D00 0030               2191          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001FD8                          2192                                          ;processing
00001FD8                          2193          
00001FD8  B43C 0046               2194          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
00001FDC  6E00 000A               2195          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
00001FE0                          2196                                          ;processing
00001FE0                          2197          
00001FE0                          2198          *a valid number was found within this range
00001FE0  0402 0037               2199          SUBI.B      #55,D2              ;Change uppercase character to actual value
00001FE4  6000 001A               2200          BRA         NextHexDone         ;Done parsing this byte
00001FE8                          2201  
00001FE8                          2202  
00001FE8                          2203  *..............................................................................
00001FE8                          2204  *  Check lower case values a-f by testing hexadecimal values 61-66
00001FE8                          2205  *..............................................................................
00001FE8                          2206  
00001FE8                          2207  LcaseHex
00001FE8                          2208          
00001FE8                          2209          * The program will branch to hex_range_error if D2 is less than #61
00001FE8  B43C 0061               2210          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
00001FEC  6D00 0018               2211          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
00001FF0                          2212                                          ;processing
00001FF0                          2213  
00001FF0  B43C 0066               2214          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
00001FF4  6E00 0010               2215          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
00001FF8                          2216                                          ;processing
00001FF8                          2217  
00001FF8                          2218          *a valid number was found within this range
00001FF8  0402 0057               2219          SUBI.B      #87,D2              ;Change lowercase character to actual value
00001FFC  6000 0002               2220          BRA         NextHexDone         ;Done parsing this byte
00002000                          2221  
00002000                          2222  NextHexDone:
00002000                          2223  
00002000  E983                    2224          ASL.L       #4,D3               ; Make rooom for new byte in the return register
00002002  D602                    2225          ADD.B       D2,D3               ; Move the new byte into the return register
00002004  60A8                    2226          BRA         NextHex             ; We're ready to parse the next byte
00002006                          2227          
00002006                          2228  *-------------------------------------------------------------------------------------
00002006                          2229  * hex_range_error -  A character entered was within the valid range for a hex address
00002006                          2230  *                 -  Load error message and display it
00002006                          2231  *                 -  Return error condition
00002006                          2232  *-------------------------------------------------------------------------------------
00002006                          2233          
00002006                          2234  hex_range_error:
00002006                          2235  
00002006  43F9 0000227B           2236          LEA         invCharMsg,A1       ;Load invalid range message into A1
0000200C  2239 0000227B           2237          MOVE.L      invCharMsg,D1       ;Load error length to D1
00002012                          2238          
00002012  7000                    2239          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00002014                          2240                                          ; n is D1.W with CR, LF. 
00002014  4E4F                    2241          TRAP        #15                 ;Display the error message
00002016  76FF                    2242          MOVE.L      #-1,D3              ;Load -1 into return parameter
00002018  6000 0002               2243          BRA         NextHexReturn
0000201C                          2244          
0000201C                          2245  NextHexReturn:
0000201C                          2246          
0000201C  4E75                    2247          RTS                             ;Return      
0000201E                          2248  
0000201E                          2249  
0000201E                          2250  *===============================================================================
0000201E                          2251  * ck_addr_range - check the address input is within a valid memory address range
0000201E                          2252  *                - Parsed address data into D3
0000201E                          2253  *
0000201E                          2254  * Parameters -
0000201E                          2255  *   Input   A1      The data that needs checked for valid address.
0000201E                          2256  *   Output  D3      The return value, '-1' for error
0000201E                          2257  *===============================================================================
0000201E                          2258  
0000201E                          2259  
0000201E                          2260  ck_addr_range:   
0000201E                          2261  
0000201E                          2262  *------------------------------------------------------------------------------
0000201E                          2263  * Verify that the address entered is witin the 
0000201E                          2264  * beginning range ('begin') as defined in the Equate
0000201E                          2265  *------------------------------------------------------------------------------   
0000201E                          2266              
0000201E  2C3C 00005001           2267          MOVE.L      #begin,D6           * Load minimum starting address
00002024  B686                    2268          CMP.L       D6,D3               * Is input at or above minimum?
00002026  6D00 0012               2269          BLT         ck_addr_range_error 
0000202A                          2270          
0000202A                          2271  *------------------------------------------------------------------------------
0000202A                          2272  * Verify that the address entered is witin the 
0000202A                          2273  * ending range ('end') as defined in the Equate
0000202A                          2274  *------------------------------------------------------------------------------
0000202A                          2275          
0000202A  2C3C 00FFFFFE           2276          MOVE.L      #end,D6             * Load maximum starting address
00002030  B686                    2277          CMP.L       D6,D3               * Is input at or below maximum?
00002032  6E00 0006               2278          BGT         ck_addr_range_error 
00002036  6000 0012               2279          BRA         ck_addr_done        ;done checking
0000203A                          2280          
0000203A                          2281  *..............................................................................
0000203A                          2282  * ck_addr_range_error -  A address entered is not within the 
0000203A                          2283  *                        valid range for a hex address
0000203A                          2284  *..............................................................................
0000203A                          2285          
0000203A                          2286  ck_addr_range_error
0000203A                          2287  
0000203A  43F9 00002236           2288          LEA         invalidMsg,A1       ;Load invalid range message into A1
00002040                          2289          
00002040  700D                    2290          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
00002042                          2291                                          ;with CR, LF. 
00002042  4E4F                    2292          TRAP        #15                 ;Display the error message
00002044  76FF                    2293          MOVE.L      #-1,D3              ;Load -1 into return parameter
00002046  6000 0002               2294          BRA         ck_addr_done 
0000204A                          2295  
0000204A                          2296  ck_addr_done:
0000204A                          2297  
0000204A  4E75                    2298          RTS                             ;Return
0000204C                          2299  
0000204C                          2300  *******************************************************************************
0000204C                          2301  *                          OP CODE ROLE ROUTINES
0000204C                          2302  *******************************************************************************
0000204C                          2303  
0000204C                          2304  process_op_codes:
0000204C                          2305  
0000204C                          2306  
0000204C                          2307  
0000204C                          2308  process_op_codes_exit:
0000204C                          2309  
0000204C  4E75                    2310          RTS
0000204E                          2311  
0000204E                          2312  
0000204E                          2313  *******************************************************************************
0000204E                          2314  *                    Effective Addressing ROLE ROUTINES
0000204E                          2315  *******************************************************************************
0000204E                          2316  
0000204E                          2317  Get_Effective_Address:
0000204E                          2318  
0000204E  1C05                    2319          MOVE.B      D5,D6
00002050  E60E                    2320          LSR.B       #3,D6               ;mode
00002052  CA3C 0007               2321          And.B       #%00000111,D5       ;register
00002056                          2322          
00002056  BC3C 0000               2323          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
0000205A  6700 004A               2324          BEQ         Data_Reg_Direct
0000205E                          2325          
0000205E  BC3C 0001               2326          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
00002062  6700 005C               2327          BEQ         Addr_Reg_Direct
00002066                          2328          
00002066  BC3C 0002               2329          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
0000206A  6700 006E               2330          BEQ         Addr_Reg_Indirect
0000206E                          2331          
0000206E  BC3C 0003               2332          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
00002072  6700 0098               2333          BEQ         Addr_Reg_Indirect_Inc
00002076                          2334          
00002076  BC3C 0004               2335          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
0000207A  6700 00CE               2336          BEQ         Addr_Reg_Indirect_Dec
0000207E                          2337          
0000207E  BC3C 0007               2338          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
00002082  6700 0006               2339          BEQ         Get_Effective_Address_Other
00002086                          2340          
00002086  6000 0138               2341          BRA         invalidEA
0000208A                          2342          
0000208A                          2343  Get_Effective_Address_Other:        
0000208A                          2344          
0000208A  BA3C 0000               2345          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
0000208E  6700 00F8               2346          BEQ Addr_Abs_Short
00002092                          2347          
00002092  BA3C 0001               2348          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
00002096  6700 0104               2349          BEQ Addr_Abs_Long
0000209A                          2350          
0000209A  BA3C 0004               2351          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
0000209E  6700 0110               2352          BEQ Addr_Immediate_Data
000020A2                          2353          
000020A2  6000 011C               2354          BRA         invalidEA
000020A6                          2355          
000020A6                          2356  Data_Reg_Direct:                        ;case 0(0000)
000020A6                          2357  
000020A6  43F9 00002447           2358          LEA         letterD,A1          ;output 'D' for data register
000020AC  103C 000E               2359          MOVE.B      #14,D0              ;set for task to display null terminated 
000020B0  4E4F                    2360          TRAP        #15                 ;string without CR, LF
000020B2                          2361                          
000020B2  4281                    2362          CLR.L       D1
000020B4  1205                    2363          MOVE.B      D5,D1               ;move register number for display into D1
000020B6  103C 0003               2364          MOVE.B      #3,D0               ;set for task to display null terminated 
000020BA  4E4F                    2365          TRAP        #15                 ;string without CR, LF
000020BC                          2366                 
000020BC  6000 0102               2367          BRA         Get_Effective_Address_Exit  ;return
000020C0                          2368          
000020C0                          2369          
000020C0                          2370  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
000020C0                          2371        
000020C0  43F9 00002445           2372          LEA         letterA,A1          ;output 'A' for address register
000020C6  103C 000E               2373          MOVE.B      #14,D0              ;set for task to display null terminated 
000020CA  4E4F                    2374          TRAP        #15                 ;string without CR, LF
000020CC                          2375          
000020CC  4281                    2376          CLR.L       D1
000020CE  1205                    2377          MOVE.B      D5,D1               ;move register number for display into D1
000020D0  103C 0003               2378          MOVE.B      #3,D0               ;set for task to display null terminated 
000020D4  4E4F                    2379          TRAP        #15                 ;string without CR, LF
000020D6                          2380          
000020D6  6000 00E8               2381          BRA         Get_Effective_Address_Exit  ;return
000020DA                          2382  
000020DA                          2383  
000020DA                          2384  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
000020DA                          2385          
000020DA  43F9 0000244D           2386          LEA         lprn,A1             ;output 'D' for data register
000020E0  103C 000E               2387          MOVE.B      #14,D0              ;set for task to display null terminated 
000020E4  4E4F                    2388          TRAP        #15                 ;string without CR, LF
000020E6                          2389  
000020E6  43F9 00002445           2390          LEA         letterA,A1          ;output 'A' for address register
000020EC  103C 000E               2391          MOVE.B      #14,D0              ;set for task to display null terminated 
000020F0  4E4F                    2392          TRAP        #15                 ;string without CR, LF
000020F2                          2393          
000020F2  4281                    2394          CLR.L       D1
000020F4  1205                    2395          MOVE.B      D5,D1               ;move register number for display into D1
000020F6  103C 0003               2396          MOVE.B      #3,D0               ;set for task to display null terminated 
000020FA  4E4F                    2397          TRAP        #15                 ;string without CR, LF
000020FC                          2398  
000020FC  43F9 0000244F           2399          LEA         rprn,A1             ;output 'D' for data register
00002102  103C 000E               2400          MOVE.B      #14,D0              ;set for task to display null terminated 
00002106  4E4F                    2401          TRAP        #15                 ;string without CR, LF
00002108                          2402          
00002108  6000 00B6               2403          BRA         Get_Effective_Address_Exit  ;return
0000210C                          2404  
0000210C                          2405                 
0000210C                          2406  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
0000210C                          2407  
0000210C  43F9 0000244D           2408          LEA         lprn,A1             ;output 'D' for data register
00002112  103C 000E               2409          MOVE.B      #14,D0              ;set for task to display null terminated 
00002116  4E4F                    2410          TRAP        #15                 ;string without CR, LF
00002118                          2411  
00002118  43F9 00002445           2412          LEA         letterA,A1          ;output 'A' for address register
0000211E  103C 000E               2413          MOVE.B      #14,D0              ;set for task to display null terminated 
00002122  4E4F                    2414          TRAP        #15                 ;string without CR, LF
00002124                          2415          
00002124  4281                    2416          CLR.L       D1
00002126  1205                    2417          MOVE.B      D5,D1               ;move register number for display into D1
00002128  103C 0003               2418          MOVE.B      #3,D0               ;set for task to display null terminated 
0000212C  4E4F                    2419          TRAP        #15                 ;string without CR, LF
0000212E                          2420  
0000212E  43F9 0000244F           2421          LEA         rprn,A1             ;output 'D' for data register
00002134  103C 000E               2422          MOVE.B      #14,D0              ;set for task to display null terminated 
00002138  4E4F                    2423          TRAP        #15                 ;string without CR, LF
0000213A                          2424          
0000213A  43F9 00002449           2425          LEA         plus,A1             ;output 'D' for data register
00002140  103C 000E               2426          MOVE.B      #14,D0              ;set for task to display null terminated 
00002144  4E4F                    2427          TRAP        #15                 ;string without CR, LF
00002146                          2428          
00002146  6000 0078               2429          BRA         Get_Effective_Address_Exit  ;return
0000214A                          2430  
0000214A                          2431  Addr_Reg_Indirect_Dec                   ;4 = (An) - Address Register Indirect with Predecrement (100)
0000214A                          2432  
0000214A  43F9 0000244B           2433          LEA         minus,A1            ;output '-' for Predecrement
00002150  103C 000E               2434          MOVE.B      #14,D0              ;set for task to display null terminated 
00002154  4E4F                    2435          TRAP        #15                 ;string without CR, LF
00002156                          2436  
00002156  43F9 0000244D           2437          LEA         lprn,A1             ;output 'D' for data register
0000215C  103C 000E               2438          MOVE.B      #14,D0              ;set for task to display null terminated 
00002160  4E4F                    2439          TRAP        #15                 ;string without CR, LF
00002162                          2440  
00002162  43F9 00002445           2441          LEA         letterA,A1          ;output 'A' for address register
00002168  103C 000E               2442          MOVE.B      #14,D0              ;set for task to display null terminated 
0000216C  4E4F                    2443          TRAP        #15                 ;string without CR, LF
0000216E                          2444          
0000216E  4281                    2445          CLR.L       D1
00002170  1205                    2446          MOVE.B      D5,D1               ;move register number for display into D1
00002172  103C 0003               2447          MOVE.B      #3,D0               ;set for task to display null terminated 
00002176  4E4F                    2448          TRAP        #15                 ;string without CR, LF
00002178                          2449  
00002178  43F9 0000244F           2450          LEA         rprn,A1             ;output 'D' for data register
0000217E  103C 000E               2451          MOVE.B      #14,D0              ;set for task to display null terminated 
00002182  4E4F                    2452          TRAP        #15                 ;string without CR, LF
00002184                          2453          
00002184  6000 003A               2454          BRA         Get_Effective_Address_Exit  ;return
00002188                          2455          
00002188                          2456                         
00002188                          2457  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00002188                          2458          
00002188                          2459          
00002188  43F9 00002427           2460          LEA         xxxW,A1             ;output 'D' for data register
0000218E  103C 000E               2461          MOVE.B      #14,D0              ;set for task to display null terminated 
00002192  4E4F                    2462          TRAP        #15                 ;string without CR, LF
00002194                          2463  
00002194  548B                    2464          ADDA.L      #word,A3
00002196                          2465          
00002196                          2466          ;print word (A3)
00002196                          2467          ;MOVE.W      A3,(A1)
00002196                          2468          ;MOVE.B      #1,D0               ;set for task to display null terminated 
00002196                          2469          ;TRAP        #15                 ;string without CR, LF
00002196                          2470          
00002196  5487                    2471          ADDI.L      #word,D7 
00002198  6000 0026               2472          BRA         Get_Effective_Address_Exit  ;return
0000219C                          2473                         
0000219C                          2474  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
0000219C                          2475          
0000219C  43F9 00002431           2476          LEA         xxxL,A1             ;output 'D' for data register
000021A2  103C 000E               2477          MOVE.B      #14,D0              ;set for task to display null terminated 
000021A6  4E4F                    2478          TRAP        #15                 ;string without CR, LF
000021A8                          2479  
000021A8  548B                    2480          ADDA.L      #word,A3
000021AA                          2481          
000021AA                          2482          ;print long (A3)
000021AA                          2483          ;MOVE.L      A3,(A1)
000021AA                          2484          ;MOVE.B      #14,D0              ;set for task to display null terminated 
000021AA                          2485          ;TRAP        #15                 ;string without CR, LF
000021AA                          2486          
000021AA  5887                    2487          ADDI.L      #long,D7
000021AC  6000 0012               2488          BRA         Get_Effective_Address_Exit  ;return
000021B0                          2489                         
000021B0                          2490  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
000021B0                          2491  
000021B0  43F9 0000243B           2492          LEA         iData,A1            ;output 'D' for data register
000021B6  103C 000E               2493          MOVE.B      #14,D0              ;set for task to display null terminated 
000021BA  4E4F                    2494          TRAP        #15                 ;string without CR, LF
000021BC                          2495          
000021BC                          2496          *need another input param for size
000021BC  6000 0002               2497          BRA         Get_Effective_Address_Exit  ;return
000021C0                          2498  
000021C0                          2499  invalidEA:
000021C0                          2500  
000021C0                          2501          ;do something
000021C0                          2502   
000021C0                          2503  Get_Effective_Address_Exit:     
000021C0                          2504  
000021C0  4E75                    2505          RTS                             ;return
000021C2                          2506  
000021C2                          2507  switchModeAndReg:
000021C2                          2508  ***
000021C2                          2509  * Assumed in D2
000021C2                          2510  *
000021C2                          2511  * Assumed that they are in least significant byte:
000021C2                          2512  *
000021C2                          2513  *            _this_
000021C2                          2514  *           /      \
000021C2                          2515  *  ........ ........
000021C2                          2516  *  \                /
000021C2                          2517  *   -----word-------
000021C2                          2518  *
000021C2                          2519  *  and that in that byte they are ordered:
000021C2                          2520  *
000021C2                          2521  *       ........   
000021C2                          2522  *       \/\_/\_/
000021C2                          2523  *      /  /    \
000021C2                          2524  *    /   /      \
000021C2                          2525  * dont  one    other
000021C2                          2526  * care
000021C2                          2527  *
000021C2                          2528  * after they will be
000021C2                          2529  *
000021C2                          2530  *       ........   
000021C2                          2531  *       \/\_/\_/
000021C2                          2532  *      /  /    \
000021C2                          2533  *    /   /      \
000021C2                          2534  * dont other    one
000021C2                          2535  * care
000021C2                          2536  *** 
000021C2  0202 003F               2537          AndI.B #%00111111,D2 ;remove unwanted bits from D2
000021C6  0283 00000000           2538          ANDI.L #0,D3 ;clear D3
000021CC  1602                    2539          MOVE.B D2,D3 ;copy to D3
000021CE  E70B                    2540          LSL.B  #3,D3 
000021D0  E60A                    2541          LSR.B  #3,D2
000021D2  D403                    2542          ADD.B  D3,D2
000021D4  4E75                    2543          RTS
000021D6                          2544  
000021D6                          2545          
000021D6                          2546  *==============================================================================
000021D6                          2547  *                            variables and constants
000021D6                          2548  *==============================================================================
000021D6                          2549  
000021D6                          2550  
000021D6                          2551  ***initial user prompt stuff        
000021D6= 45 6E 74 65 72 20 ...   2552  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE: $',0
00002207= 45 6E 74 65 72 20 ...   2553  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE: $',0
00002236                          2554  
00002236= 20 41 64 64 72 65 ...   2555  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
0000227B= 20 41 20 43 68 61 ...   2556  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
000022C3                          2557  
000022C3= 20 59 6F 75 20 6D ...   2558  even_msg        DC.B    ' You must enter an even address!'
000022E3                          2559  
000022E3= 20                      2560  spc             DC.B    ' '
000022E4= 01                      2561  spc_len         DC.B    spc_len-spc
000022E5                          2562  ***
000022E5                          2563  
000022E5                          2564  
000022E5                          2565  
000022E5                          2566  ***list of OP codes
000022E5                          2567  
000022E5  =000041C0               2568  leaInstruction   EQU %0100000111000000
000022E5  =000081C0               2569  divsInstruction  EQU %1000000111000000
000022E5  =0000C1C0               2570  mulsInstruction  EQU %1100000111000000
000022E5  =0000E6C0               2571  rsrlweaInstruction  EQU %1110011011000000
000022E5  =0000E018               2572  rsrlregInstruction  EQU %1110000000011000
000022E5  =0000E0C0               2573  asrlweaInstruction  EQU %1110000011000000
000022E5  =0000E000               2574  asrlregInstruction  EQU %1110000000000000
000022E5  =0000E2C0               2575  lsrlweaInstruction  EQU %1110001011000000
000022E5  =0000E008               2576  lsrlregInstruction  EQU %1110000000001000
000022E5  =00005100               2577  subqInstruction  EQU %0101000100000000
000022E5  =00009000               2578  subInstruction   EQU %1001000000000000
000022E5  =0000D000               2579  addaInstruction  EQU %1101000000000000
000022E5  =0000D000               2580  addInstruction   EQU %1101000000000000
000022E5  =00004880               2581  movemInstruction EQU %0100100010000000
000022E5  =00000600               2582  addiInstruction  EQU %0000011000000000
000022E5  =00000000               2583  oriInstruction   EQU 0
000022E5  =00000C00               2584  cmpiInstruction  EQU %0000110000000000
000022E5  =00004E80               2585  jsrInstruction   EQU %0100111010000000
000022E5  =00004E75               2586  rtsInstruction   EQU %0100111001110101
000022E5  =00004E71               2587  NoOpInstruction  EQU %0100111001110001
000022E5  =00000000               2588  moveInstruction  EQU 0
000022E5  =00006000               2589  bccInstruction   EQU %0110000000000000
000022E5  =00004400               2590  negInstruction   EQU %0100010000000000
000022E5  =00000000               2591  dataInstruction  EQU 0
000022E5                          2592  
000022E5                          2593  ***
000022E5                          2594  
000022E5                          2595  ***list of OP masks
000022E5                          2596  
000022E5  =0000F1C0               2597  leaMask   EQU %1111000111000000
000022E5  =0000F1C0               2598  divsMask  EQU %1111000111000000
000022E5  =0000F1C0               2599  mulsMask  EQU %1111000111000000
000022E5  =0000FEC0               2600  rsrlweaMask  EQU %1111111011000000
000022E5  =0000F018               2601  rsrlregMask  EQU %1111000000011000
000022E5  =0000FEC0               2602  asrlweaMask  EQU %1111111011000000
000022E5  =0000F018               2603  asrlregMask  EQU %1111000000011000
000022E5  =0000FEC0               2604  lsrlweaMask  EQU %1111111011000000
000022E5  =0000F018               2605  lsrlregMask  EQU %1111000000011000
000022E5  =0000F100               2606  subqMask  EQU %1111000100000000
000022E5  =0000F000               2607  subMask   EQU %1111000000000000
000022E5  =0000F000               2608  addaMask  EQU %1111000000000000
000022E5  =0000F000               2609  addMask   EQU %1111000000000000
000022E5  =0000FB80               2610  movemMask EQU %1111101110000000
000022E5  =0000FF00               2611  addiMask  EQU %1111111100000000
000022E5  =0000FF00               2612  oriMask   EQU %1111111100000000
000022E5  =0000FF00               2613  cmpiMask  EQU %1111111100000000
000022E5  =0000FFC0               2614  jsrMask   EQU %1111111111000000
000022E5  =0000FFFF               2615  rtsMask   EQU $FFFF
000022E5  =0000FFFF               2616  NoOpMask  EQU $FFFF
000022E5  =0000C000               2617  moveMask  EQU $C000
000022E5  =0000F000               2618  bccMask   EQU $F000
000022E5  =0000FF00               2619  negMask   EQU $FF00
000022E5  =00000000               2620  dataMask  EQU 0
000022E5                          2621  ***
000022E5                          2622  
000022E5                          2623  ***Bcc Codes***
000022E5  =00000004               2624  CC EQU $04
000022E5  =00000005               2625  CS EQU $05
000022E5  =00000007               2626  EQ EQU $07
000022E5  =0000000C               2627  GE EQU $0C
000022E5  =0000000E               2628  GT EQU $0E
000022E5  =00000002               2629  HI EQU $02
000022E5  =0000000F               2630  LE EQU $0F
000022E5  =00000003               2631  LS EQU $03
000022E5  =0000000D               2632  LT EQU $0D
000022E5  =0000000B               2633  MI EQU $0B
000022E5  =00000006               2634  NE EQU $06
000022E5  =0000000A               2635  PL EQU $0A
000022E5  =00000008               2636  VC EQU $08
000022E5  =00000009               2637  VS EQU $09
000022E5  =00000000               2638  RA EQU $00 ;not really a Condition Code
000022E5  =00000001               2639  SR EQU $01 ;not really a Condition Code
000022E5                          2640  
000022E5= 43 43 20 00             2641  CCm DC.B 'CC ',0
000022E9= 43 53 20 00             2642  CSm DC.B 'CS ',0
000022ED= 45 51 20 00             2643  EQm DC.B 'EQ ',0
000022F1= 47 45 20 00             2644  GEm DC.B 'GE ',0
000022F5= 47 54 20 00             2645  GTm DC.B 'GT ',0
000022F9= 48 49 20 00             2646  HIm DC.B 'HI ',0
000022FD= 4C 45 20 00             2647  LEm DC.B 'LE ',0
00002301= 4C 53 20 00             2648  LSm DC.B 'LS ',0
00002305= 4C 54 20 00             2649  LTm DC.B 'LT ',0
00002309= 4D 49 20 00             2650  MIm DC.B 'MI ',0
0000230D= 4E 45 20 00             2651  NEm DC.B 'NE ',0
00002311= 50 4C 20 00             2652  PLm DC.B 'PL ',0
00002315= 56 43 20 00             2653  VCm DC.B 'VC ',0
00002319= 56 53 20 00             2654  VSm DC.B 'VS ',0
0000231D= 52 41 20 00             2655  RAm DC.B 'RA ',0
00002321= 53 52 20 00             2656  SRm DC.B 'SR ',0
00002325                          2657  
00002325= 01 04 05 07 0C 0E ...   2658  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
00002336= 00002321 000022E5 ...   2659  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
00002376                          2660  ***
00002376                          2661  
00002376= 45 6E 74 65 72 20 ...   2662  startLocationPrompt DC.B    'Enter start location',0
0000238B= 45 6E 74 65 72 20 ...   2663  endLocationPrompt   DC.B    'Enter end location',0
0000239E                          2664  
0000239E= 0D 0A 00                2665  clearLine  DC.B $0D,$0A,0
000023A1                          2666  
000023A1= 4C 45 41 20 00          2667  leaMessage      DC.B 'LEA ',0
000023A6= 44 49 56 53 20 00       2668  divsMessage     DC.B 'DIVS ',0
000023AC= 4D 55 4C 53 20 00       2669  mulsMessage     DC.B 'MULS ',0
000023B2= 52 4F 4C 20 00          2670  rslMessage      DC.B 'ROL ',0
000023B7= 52 4F 52 20 00          2671  rsrMessage      DC.B 'ROR ',0
000023BC= 41 53 4C 20 00          2672  aslMessage      DC.B 'ASL ',0
000023C1= 41 53 52 20 00          2673  asrMessage      DC.B 'ASR ',0
000023C6= 4C 53 4C 20 00          2674  lslMessage      DC.B 'LSL ',0
000023CB= 4C 53 52 20 00          2675  lsrMessage      DC.B 'LSR ',0
000023D0= 53 55 42 51 20 00       2676  subqMessage     DC.B 'SUBQ ',0
000023D6= 53 55 42 20 00          2677  subMessage      DC.B 'SUB ',0 
000023DB= 41 44 44 41 20 00       2678  addaMessage     DC.B 'ADDA ',0
000023E1= 41 44 44 20 00          2679  addMessage      DC.B 'ADD ',0
000023E6= 4D 4F 56 45 4D 20 00    2680  movemMessage    DC.B 'MOVEM ',0
000023ED= 41 44 44 49 20 00       2681  addiMessage     DC.B 'ADDI ',0
000023F3= 4F 52 49 20 00          2682  oriMessage      DC.B 'ORI ',0
000023F8= 43 4D 50 49 20 00       2683  cmpiMessage     DC.B 'CMPI ',0
000023FE= 4A 53 52 20 00          2684  jsrMessage      DC.B 'JSR ',0
00002403= 52 54 53 20 00          2685  rtsMessage      DC.B 'RTS ',0
00002408= 4E 4F 50 20 00          2686  nopMessage      DC.B 'NOP ',0 
0000240D= 4D 4F 56 45 20 00       2687  moveMessage     DC.B 'MOVE ',0
00002413= 42 00                   2688  bccMessage      DC.B 'B',0
00002415= 4E 45 47 20 00          2689  negMessage      DC.B 'NEG ',0
0000241A= 44 41 54 41 20 00       2690  dataMessage     DC.B 'DATA ',0
00002420= 4D 4F 56 45 41 20 00    2691  moveaMessage    DC.B 'MOVEA ',0
00002427                          2692  
00002427= 28 78 78 78 29 2E ...   2693  xxxW            DC.B '(xxx).W: ',0
00002431= 28 78 78 78 29 2E ...   2694  xxxL            DC.B '(xxx).L: ',0
0000243B= 23 28 64 61 74 61 ...   2695  iData           DC.B '#(data): ',0
00002445                          2696  
00002445= 41 00                   2697  letterA         DC.B 'A', 0
00002447= 44 00                   2698  letterD         DC.B 'D', 0
00002449                          2699  
00002449= 2B 00                   2700  plus            DC.B '+', 0
0000244B= 2D 00                   2701  minus           DC.B '-', 0
0000244D= 28 00                   2702  lPrn            DC.B '(', 0
0000244F= 29 00                   2703  rPrn            DC.B ')', 0
00002451                          2704  
00002451                          2705  
00002452= 00000000                2706  startLocation       DC.L    0
00002456= 00000000                2707  endLocation         DC.L    0
0000245A                          2708  
0000245A                          2709  
0000245A                          2710     
0000245A                          2711      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 1876
ADDA                17D8
ADDABODY            1820
ADDAINSTRUCTION     D000
ADDAMASK            F000
ADDAMESSAGE         23DB
ADDDEST             193A
ADDDESTEA           186A
ADDDESTEAMASKS      1870
ADDI                1AA8
ADDIBODY            1AD4
ADDIDONE            1B12
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         23ED
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          23E1
ADDRESS_DONE        1F3A
ADDRESS_EXIT        1F34
ADDR_ABS_LONG       219C
ADDR_ABS_SHORT      2188
ADDR_IMMEDIATE_DATA  21B0
ADDR_REG_DIRECT     20C0
ADDR_REG_INDIRECT   20DA
ADDR_REG_INDIRECT_DEC  214A
ADDR_REG_INDIRECT_INC  210C
ADDSOURCE           18F2
ASLEA               1442
ASLMESSAGE          23BC
ASLREG              1488
ASREA               1432
ASRLREG             1452
ASRLREGINSTRUCTION  E000
ASRLREGMASK         F018
ASRLWEA             13F2
ASRLWEACHECKDIRECTION  141E
ASRLWEAINSTRUCTION  E0C0
ASRLWEAMASK         FEC0
ASRMESSAGE          23C1
ASRREG              1478
BCC                 1DEE
BCCBYTE             1E40
BCCDONE             1E56
BCCINSTRUCTION      6000
BCCLIST             2325
BCCLONG             1E4E
BCCMASK             F000
BCCMESSAGE          2413
BCCWORD             1E46
BEGIN               5001
BEGIN_ADDRESS       1EC6
BYTE                1
CC                  4
CCM                 22E5
CHECKCC             1E04
CHECKMOVEADEST      1D9A
CHECKMOVEDEST       1CE8
CHECKOPCODE         1050
CK_ADDR_DONE        204A
CK_ADDR_RANGE       201E
CK_ADDR_RANGE_ERROR  203A
CK_BOUNDRY          1F62
CK_BOUNDRY_ERROR    1F84
CK_SIZE_ERROR       1F98
CLEARLINE           239E
CMPI                1BAA
CMPIBODY            1BD2
CMPIDONE            1C10
CMPIEA              1B9C
CMPIEAMASKS         1BA3
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         23F8
CONDITIONCODEMESSAGE  2336
CS                  5
CSM                 22E9
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         241A
DATA_REG_DIRECT     20A6
DIVS                1258
DIVSBODY            1284
DIVSINSTRUCTION     81C0
DIVSMASK            F1C0
DIVSMESSAGE         23A6
ELPROMPT            2207
END                 FFFFFE
ENDLOCATION         2456
ENDLOCATIONPROMPT   238B
END_ADDRESS         1F0A
ENTER_ADDR_EDIT_ALL  1F3C
ENTER_ADDR_EDIT_ALL_EXIT  1F60
EQ                  7
EQM                 22ED
EVEN_MSG            22C3
FALSEPOSITIVE       1070
FARLABEL            FFE
FIN                 1EC2
FOUNDCC             1E16
GE                  C
GEM                 22F1
GET_EFFECTIVE_ADDRESS  204E
GET_EFFECTIVE_ADDRESS_EXIT  21C0
GET_EFFECTIVE_ADDRESS_OTHER  208A
GT                  E
GTM                 22F5
HANDLEBYTEDATA      1E96
HEX_RANGE_ERROR     2006
HI                  2
HIM                 22F9
IDATA               243B
INSTLABELLIST       10F6
INSTLABELLIST2      10FE
INSTMASKLIST        10C6
INSTOPLIST          1096
INSTOPLIST2         10A8
INVALIDEA           21C0
INVALIDMSG          2236
INVCHARMSG          227B
JSR                 1C28
JSRBODY             1C50
JSRDONE             1C70
JSREA               1C20
JSREAMASKS          1C24
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          23FE
LCASEHEX            1FE8
LE                  F
LEA                 11E6
LEABODY             120E
LEAEA               11DE
LEAEAMASKS          11E2
LEAINSTRUCTION      41C0
LEAMASK             F1C0
LEAMESSAGE          23A1
LEM                 22FD
LETTERA             2445
LETTERD             2447
LONG                4
LPRN                244D
LS                  3
LSLEA               14F0
LSLMESSAGE          23C6
LSLREG              155A
LSM                 2301
LSREA               14E0
LSRLCHECKI          15C2
LSRLCHECKIR         15AC
LSRLCHECKIRRETURN   15C0
LSRLCHECKR          15F6
LSRLEA              1498
LSRLEAMASKS         149E
LSRLREG             1524
LSRLREGBODY         156A
LSRLREGINSTRUCTION  E008
LSRLREGMASK         F018
LSRLWEA             14A4
LSRLWEABODY         1500
LSRLWEACHECKDIRECTION  14CC
LSRLWEAINSTRUCTION  E2C0
LSRLWEAMASK         FEC0
LSRMESSAGE          23CB
LSRREG              154A
LT                  D
LTM                 2305
MAIN_LOOP           1026
MATCH               1076
MI                  B
MIM                 2309
MINUS               244B
MOVE                1CC0
MOVEA               1D72
MOVEABODY           1DC8
MOVEADESTEA         1D6E
MOVEADESTEAMASKS    1D70
MOVEAMESSAGE        2420
MOVEBODY            1D16
MOVEDESTEA          1CB2
MOVEDESTEAMASKS     1CB9
MOVEINSTRUCTION     0
MOVEM               1996
MOVEMASK            C000
MOVEMBODY           1A00
MOVEMESSAGE         240D
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     198C
MOVEMMEMTOREGEAMASKS  1991
MOVEMMESSAGE        23E6
MOVEMREGTOMEMEA     1982
MOVEMREGTOMEMEAMASKS  1987
MOVESOURCEEA        1CA0
MOVESOURCEEAMASKS   1CA9
MULS                12DC
MULSBODY            1304
MULSEA              12CC
MULSEAMASKS         12D4
MULSINSTRUCTION     C1C0
MULSMASK            F1C0
MULSMESSAGE         23AC
NE                  6
NEG                 1A42
NEGBODY             1A6A
NEGDONE             1A98
NEGEA               1A32
NEGEAMASKS          1A3A
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          2415
NEM                 230D
NEXTHEX             1FAE
NEXTHEXDONE         2000
NEXTHEXRETURN       201C
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 1C80
NOPMESSAGE          2408
ORI                 1B22
ORIBODY             1B4E
ORIDONE             1B8C
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          23F3
PARSEHEXSTRING      1FAC
PL                  A
PLM                 2311
PLUS                2449
PRGORG              1000
PROCESS_OP_CODES    204C
PROCESS_OP_CODES_EXIT  204C
PROMPT_USER         1014
RA                  0
RAM                 231D
RPRN                244F
RSLEA               139C
RSLMESSAGE          23B2
RSLREG              13E2
RSREA               138C
RSRLREG             13AC
RSRLREGINSTRUCTION  E018
RSRLREGMASK         F018
RSRLWEA             134C
RSRLWEACHECKDIRECTION  1378
RSRLWEAINSTRUCTION  E6C0
RSRLWEAMASK         FEC0
RSRMESSAGE          23B7
RSRREG              13D2
RTS                 1C90
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          2403
SLPROMPT            21D6
SNIPPET             1156
SNIPPETEND          11DA
SPC                 22E3
SPC_LEN             22E4
SR                  1
SRM                 2321
STACK               5000
START               1000
STARTLOCATION       2452
STARTLOCATIONPROMPT  2376
SUB                 16C8
SUBDEST             1790
SUBINSTRUCTION      9000
SUBMASK             F000
SUBMESSAGE          23D6
SUBQ                1620
SUBQBODY            1658
SUBQEA              1610
SUBQEAMASKS         1618
SUBQINSTRUCTION     5100
SUBQMASK            F100
SUBQMESSAGE         23D0
SUBSOURCE           1748
SWITCHMODEANDREG    21C2
TOEIGHT             16C4
UCASEHEX            1FD0
UNKNOWNOPCODE       1E70
VALIDADDA           17F6
VALIDADDDESTEA      18C6
VALIDADDIMODES      1AAA
VALIDADDSOURCEEA    189C
VALIDASRL           13F4
VALIDCMPIMODES      1BAC
VALIDDIVSMODES      125A
VALIDJSRMODES       1C2A
VALIDLEAMODES       11E8
VALIDLSRL           14A6
VALIDMEMTOREG       19D2
VALIDMOVEADESTMODES  1D9C
VALIDMOVEASOURCEMODES  1D74
VALIDMOVEDESTMODES  1CEA
VALIDMOVESOURCEMODES  1CC2
VALIDMULSMODES      12DE
VALIDNEGMODES       1A44
VALIDORIMODES       1B24
VALIDREGTOMEM       19AC
VALIDRSRL           134E
VALIDSUBDESTEA      1718
VALIDSUBQ           1632
VALIDSUBSOURCEEA    16EE
VC                  8
VCM                 2315
VS                  9
VSM                 2319
WORD                2
XXXL                2431
XXXW                2427
ZEROTOEIGHT         16BA
ZEROTOEIGHTRETURN   16C2

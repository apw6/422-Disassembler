00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/1/2014 1:55:11 PM

00000000                             1  *##########################################################################
00000000                             2  * Title      : 
00000000                             3  * Written by : Andrew Watson
00000000                             4  *            : Elaine Keller
00000000                             5  *            : Robert Anderson
00000000                             6  * Date       : 11/14/2014
00000000                             7  * Description: 
00000000                             8  *##########################################################################
00000000                             9  
00000000                            10  ***************************************************************************
00000000                            11  *                   Variable/Data Definitions
00000000                            12  ***************************************************************************
00000000                            13  
00000000  =00005000                 14  stack   EQU   $00005000
00000000  =00005001                 15  begin   EQU   $00005001
00000000  =00FFFFFE                 16  end     EQU   $00FFFFFE
00000000  =00000001                 17  byte    EQU   1
00000000  =00000002                 18  word    EQU   2
00000000  =00000004                 19  long    EQU   4
00000000  =00001000                 20  prgorg  EQU   $1000
00000000                            21  
00000FFE                            22      ORG $00000FFE
00000FFE                            23  FarLabel:
00001000                            24      ORG    prgorg
00001000                            25  start:
00001000  4FF8 5000                 26          LEA stack, SP ;initialize stack
00001004                            27  
00001000                            28      ORG    prgorg
00001000                            29  
00001000                            30  ******************************************************************************
00001000                            31  *                   Begin processing active code
00001000                            32  ******************************************************************************
00001000                            33      
00001000                            34  start:
00001000                            35  
00001000  4FF8 5000                 36          LEA         stack, SP           ;Initialize stack
00001004  6000 0002                 37          BRA         begin_address
00001008                            38  
00001008                            39  *==========================================================================
00001008                            40  *                   Enter / Validate beginning address 
00001008                            41  *==========================================================================
00001008                            42   
00001008                            43  begin_address:
00001008                            44  
00001008                            45  *.............................................................................
00001008                            46  * Debug Mode - Comment out when done
00001008  267C 00001108             47          MOVE.L      #snippet,A3
0000100E  287C 00001124             48          MOVE.L      #snippetEnd,A4
00001014  6000 0060                 49          BRA         main_Loop
00001018                            50  * Debug Mode - Comment out when done
00001018                            51  *.............................................................................
00001018                            52         
00001018  43F9 000015C2             53          LEA         slPrompt,A1         ;Load address for starting loaction prompt
0000101E  2239 000015C2             54          MOVE.L      slPrompt,D1         ;Load display length to D1
00001024  700E                      55          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001026  4E4F                      56          TRAP        #15                 ;Perform task 14 (display)
00001028                            57          
00001028  43F9 000017E0             58          LEA         startLocation,A1    ;Load address to store user input
0000102E  103C 0002                 59          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001032  4E4F                      60          TRAP        #15                 ;Perform task 2 (input)
00001034                            61          
00001034  6100 02EC                 62          BSR         enter_addr_edit_all
00001038  B67C FFFF                 63          CMP.W       #-1,D3              ;Did the edit pass?
0000103C  67CA                      64          BEQ         begin_address       ;No, loop and ask for correct input
0000103E                            65          
0000103E  2643                      66          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
00001040                            67          
00001040  43F9 000016CF             68          LEA         spc,A1              ;Load address for starting loaction prompt
00001046  1239 000016D0             69          MOVE.B      spc_len,D1          ;Load empty line length
0000104C  7000                      70          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
0000104E  4E4F                      71          TRAP        #15                 ;Perform task 14 (display)
00001050  6000 0002                 72          BRA         end_address
00001054                            73  
00001054                            74  *===========================================================================
00001054                            75  *                   Enter / Validate ending address 
00001054                            76  *===========================================================================
00001054                            77  
00001054                            78  end_address:
00001054                            79          
00001054  43F9 000015F3             80          LEA         elPrompt,A1         ;Load address for ending loaction prompt
0000105A                            81          ;MOVE.L     elPrompt,D1         ;Load display length to D1
0000105A  7250                      82          MOVE.L      #80,D1       ;did not like previous command, do not know why, it should have worked
0000105C  700E                      83          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
0000105E  4E4F                      84          TRAP        #15                 ;Perform task 14 (display)
00001060                            85          
00001060  103C 0002                 86          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001064  4E4F                      87          TRAP        #15                 ;Perform task 2 (input)
00001066                            88          
00001066  6100 02BA                 89          BSR         enter_addr_edit_all
0000106A  B67C FFFF                 90          CMP.W       #-1,D3              ;Did the edit pass?
0000106E  67E4                      91          BEQ         end_address         ;No, loop and ask for correct input
00001070                            92  
00001070  2843                      93          MOVEA.L     D3,A4               ;Ending address gets stored in A4
00001072  6000 0002                 94          BRA         main_Loop
00001076                            95  
00001076                            96  
00001076                            97  ******************************************************************************
00001076                            98  *                   Begin processing OP Codes
00001076                            99  ******************************************************************************
00001076                           100   
00001076                           101  main_Loop:
00001076                           102  
00001076  B9CB                     103          CMPA.L A3,A4 ;check end of prog
00001078  6700 02A4                104          BEQ fin
0000107C                           105          
0000107C  3213                     106          MOVE.W (A3),D1 ;copy word from other prog to analyze as instruction
0000107E                           107          
0000107E  7600                     108          MOVEQ.L #0,D3
00001080                           109          
00001080                           110          ***things to save A3,A4,D1(?)***
00001080  48E7 0018                111          MOVEM.L A3-A4,-(SP)
00001084  6100 000C                112          BSR checkOPcode
00001088  4CDF 1800                113          MOVEM.L (SP)+,A3-A4
0000108C  D7C7                     114          ADDA.L  D7,A3 ;look past data that was part of the instruction
0000108E                           115          
0000108E  548B                     116          ADDQ.L  #word,A3
00001090  60E4                     117          BRA     main_Loop 
00001092                           118          
00001092                           119  checkOPcode:
00001092                           120  
00001092                           121  
00001092  7E00                     122          MOVEQ.L #0,D7
00001094                           123          
00001094  41F9 000010D8            124          LEA     instOPList,A0 ;get instruction signitrue list in A0
0000109A  D1C3                     125          ADDA.L  D3,A0 ;get correct sig         
0000109C                           126          
0000109C  43F9 000010E4            127          LEA     instMaskList,A1 ;get instruction mask in A1
000010A2  D3C3                     128          ADDA.L  D3,A1  ;get correct mast
000010A4                           129          
000010A4  3401                     130          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
000010A6                           131          
000010A6  C451                     132          AND.W   (A1),D2 ;mask instruction
000010A8                           133          
000010A8                           134          
000010A8                           135          
000010A8                           136          
000010A8  B450                     137          CMP.W   (A0),D2 ;compare to sig
000010AA  6700 000C                138          BEQ     match ;if sig matches branch
000010AE  5483                     139          ADDQ.L  #word,D3 ;add to D3 to check for next instruction
000010B0  60E0                     140          BRA checkOPcode
000010B2                           141          
000010B2                           142  falsePositive:
000010B2                           143          
000010B2  103C 00FF                144          MOVE.B #-1,D0
000010B6  4E75                     145          RTS
000010B8                           146  
000010B8                           147  match:
000010B8                           148          
000010B8  43F9 000010F0            149          LEA     instLabelList,A1 ;get instruction code label
000010BE  D3C3                     150          ADDA.L  D3,A1 ;get correct label
000010C0  D3C3                     151          ADDA.L  D3,A1
000010C2  5483                     152          ADDQ.L  #word,D3 ;add to D3 incase false positive
000010C4  2251                     153          MOVEA.L (A1),A1
000010C6  48E7 1000                154          MOVEM.L D3,-(SP) ; save D3
000010CA  4E91                     155          JSR     (A1)
000010CC  4CDF 0008                156          MOVEM.L (SP)+,D3 ;restore D3
000010D0  B03C 00FF                157          CMP.B   #-1,D0
000010D4  67BC                     158          BEQ     checkOPcode
000010D6  4E75                     159          RTS
000010D8                           160          
000010D8                           161  
000010D8= 4735 4400 4E71 0...      162  instOPList DC.W rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruction         
000010E4= FFFF FF00 FFFF C...      163  instMaskList DC.W rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
000010F0= 00001198 00001138 ...    164  instLabelList DC.L RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
00001108                           165  
00001108                           166  snippet:
00001108  4E71                     167           NOP
0000110A  60FC                     168           BRA snippet
0000110C  6000 FEF0                169           BRA FarLabel
00001110  67F6                     170           BEQ snippet
00001112  6E00 0024                171           BGT NEG
00001116  61F0                     172           BSR snippet
00001118  4441                     173           NEG D1
0000111A  3239 00008500            174           MOVE.W $8500,D1
00001120  0645 001E                175           ADDI.W #30,D5
00001124                           176           
00001124                           177  snippetEnd:
00001124  FFFF FFFF                178           SIMHALT
00001128                           179          
00001128= 00 10 18 20 28 38 ...    180  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
00001130= 38 38 38 38 38 3F ...    181  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
00001138                           182     
00001138                           183  NEG:            
00001138                           184       
00001138  7000                     185          MOVEQ.L #0, D0 ;clear D0
0000113A                           186          
0000113A                           187  validNegModes:
0000113A                           188          
0000113A  43F8 1130                189          LEA NegEAmasks,A1 ;load the list of masks
0000113E  D3C0                     190          ADDA.L D0,A1 ;displace to a specific mask
00001140  1A11                     191          MOVE.B (A1),D5 ;move the mask to D5
00001142                           192          
00001142  0C05 0000                193          CMPI.B #0,D5 ;check if the mask is 0
00001146  6700 FF6A                194          BEQ falsePositive ;branch if it is
0000114A                           195          
0000114A  1401                     196          MOVE.B D1,D2 ;copy instruction to D2
0000114C  C405                     197          AND.B D5,D2  ;mask D2
0000114E  43F8 1128                198          LEA NegEA,A1 ;load the list of valid modes
00001152  D3C0                     199          ADDA.L D0,A1 ;displace to a specific mode
00001154  1811                     200          MOVE.B (A1),D4 ;move mode to D4
00001156  B404                     201          CMP.B D4,D2 ;compare mode to masked value
00001158  6700 0006                202          BEQ NegBody ;if its match, its a valid mode and we can procede
0000115C                           203          
0000115C  5280                     204          ADDQ.L #1,D0 ;add one to displacement
0000115E  60DA                     205          BRA validNegModes ;check for next mode
00001160                           206          
00001160                           207  NegBody:
00001160                           208  
00001160                           209  
00001160  43F9 000017A0            210          LEA     negMessage,A1  ;move string for NEG info
00001166  103C 000E                211          MOVE.B  #14,D0        ;set for task to display null terminated 
0000116A                           212                                ;string without CR, LF
0000116A  4E4F                     213          TRAP    #15
0000116C                           214          
0000116C  3401                     215          MOVE.W D1,D2
0000116E  C47C 003F                216          AND #%000000000111111,D2
00001172  1A02                     217          MOVE.B D2,D5
00001174                           218          
00001174  6100 02BC                219          BSR     Effective_Address
00001178                           220          
00001178                           221                
00001178                           222          
00001178                           223  NEGdone:
00001178                           224  
00001178  43F9 0000178A            225          LEA     clearLine,A1  ;move string for a CR and LF
0000117E  103C 000E                226          MOVE.B  #14,D0        ;set for task to display null terminated 
00001182                           227                                ;string without CR, LF
00001182  4E4F                     228          TRAP    #15
00001184  7000                     229          MOVEQ.L #0,D0
00001186  4E75                     230          RTS
00001188                           231          
00001188                           232  
00001188                           233  
00001188                           234          
00001188                           235  NOP:
00001188                           236  
00001188  43F9 00001791            237          LEA     nopMessage,A1  ;move string for NOP info
0000118E  103C 000D                238          MOVE.B  #13,D0        ;set for task to display null terminated 
00001192                           239                                ;string with CR, LF
00001192  4E4F                     240          TRAP    #15
00001194                           241          
00001194  7000                     242          MOVEQ.L #0,D0
00001196  4E75                     243          RTS
00001198                           244          
00001198                           245  RTS:
00001198                           246          
00001198  43F9 0000178D            247          LEA     rtsMessage,A1  ;move string for rts info
0000119E  103C 000D                248          MOVE.B  #13,D0        ;set for task to display null terminated 
000011A2                           249                                ;string with CR, LF
000011A2  4E4F                     250          TRAP    #15  
000011A4                           251     
000011A4  7000                     252          MOVEQ.L #0,D0
000011A6  4E75                     253          RTS   
000011A8                           254  
000011A8= 3C 08 00 10 18 20 ...    255  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
000011B1= 3F 38 38 38 38 38 ...    256  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
000011BA                           257  
000011BA= 00 10 18 20 38 39 00     258  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
000011C1= 38 38 38 38 3F 3F 00     259  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
000011C8                           260  
000011C8                           261  MOVE:
000011C8                           262          
000011C8                           263  
000011C8                           264          
000011C8  7000                     265          MOVEQ.L #0, D0 ;clear D0
000011CA                           266          
000011CA                           267  validMoveSourceModes:
000011CA                           268          
000011CA  43F8 11B1                269          LEA moveSourceEAmasks,A1 ;load the list of masks
000011CE  D3C0                     270          ADDA.L D0,A1 ;displace to a specific mask
000011D0  1A11                     271          MOVE.B (A1),D5 ;move the mask to D5
000011D2                           272          
000011D2  0C05 0000                273          CMPI.B #0,D5 ;check if the mask is 0
000011D6  6700 FEDA                274          BEQ falsePositive ;branch if it is
000011DA                           275          
000011DA  1401                     276          MOVE.B D1,D2 ;copy instruction to D2
000011DC  C405                     277          AND.B D5,D2  ;mask D2
000011DE                           278          
000011DE  43F8 11A8                279          LEA moveSourceEA,A1 ;load the list of valid modes
000011E2  D3C0                     280          ADDA.L D0,A1 ;displace to a specific mode
000011E4  1811                     281          MOVE.B (A1),D4 ;move mode to D4
000011E6  B404                     282          CMP.B D4,D2 ;compare mode to masked value
000011E8  6700 0006                283          BEQ  checkMoveDest ;if its match, its a valid mode and we can procede
000011EC                           284          
000011EC  5280                     285          ADDQ.L #1,D0 ;add one to displacement
000011EE  60DA                     286          BRA validMoveSourceModes ;check for next mode
000011F0                           287          
000011F0                           288  checkMoveDest:
000011F0  7000                     289          MOVEQ.L #0, D0 ;clear D0
000011F2                           290          
000011F2                           291  validMoveDestModes:
000011F2                           292          
000011F2  43F8 11C1                293          LEA moveDestEAmasks,A1 ;load the list of masks
000011F6  D3C0                     294          ADDA.L D0,A1 ;displace to a specific mask
000011F8  1A11                     295          MOVE.B (A1),D5 ;move the mask to D5
000011FA                           296          
000011FA  0C05 0000                297          CMPI.B #0,D5 ;check if the mask is 0
000011FE  6700 FEB2                298          BEQ falsePositive ;branch if it is
00001202                           299          
00001202  3401                     300          MOVE.W D1,D2 ;copy instruction to D2
00001204  EA4A                     301          LSR.W #5,D2  ;move mode
00001206  6100 03AA                302          BSR switchModeAndReg ;switch register and mode
0000120A  C405                     303          AND.B D5,D2  ;mask D2
0000120C                           304          
0000120C  43F8 11BA                305          LEA moveDestEA,A1 ;load the list of valid modes
00001210  D3C0                     306          ADDA.L D0,A1 ;displace to a specific mode
00001212  1811                     307          MOVE.B (A1),D4 ;move mode to D4
00001214  B404                     308          CMP.B D4,D2 ;compare mode to masked value
00001216  6700 0006                309          BEQ moveBody ;if its match, its a valid mode and we can procede
0000121A                           310          
0000121A  5280                     311          ADDQ.L #1,D0 ;add one to displacement
0000121C  60D4                     312          BRA validMoveDestModes ;check for next mode
0000121E                           313          
0000121E                           314  moveBody
0000121E  3401                     315          MOVE.W  D1,D2 ;copy inst to D2
00001220  C47C 0600                316          AND.W  #%0011000000000,D2 ;mask word for size
00001224  0C42 0000                317          CMPI.W #0,D2 ;0 is the only non valid size
00001228  6700 FE88                318          BEQ falsePositive ; if zero, this is not move
0000122C                           319  
0000122C  3401                     320          MOVE.W  D1,D2
0000122E  EC4A                     321          LSR     #6,D2
00001230  C43C 0007                322          AND.B   #%00000111,D2
00001234                           323          
00001234  0C02 0001                324          CMPI.B  #1,D2
00001238  6700 002C                325          BEQ     MOVEA
0000123C                           326          
0000123C  3401                     327          MOVE.W  D1,D2 ;check source mode
0000123E  E64A                     328          LSR     #3,D2   
00001240  C47C 0007                329          AND.W   #$0007,D2
00001244                           330          
00001244  3401                     331          MOVE.W  D1,D2 ;check source reg
00001246  C47C 0007                332          AND.W   #$0007,D2
0000124A                           333          
0000124A  43F9 00001797            334          LEA     moveMessage,A1  ;move string for MOVE
00001250  103C 000E                335          MOVE.B  #14,D0        ;set for task to display null terminated 
00001254                           336                                ;string with CR, LF
00001254  4E4F                     337          TRAP    #15
00001256                           338          
00001256  43F9 0000178A            339          LEA     clearLine,A1  ;move string for a CR and LF
0000125C  103C 000E                340          MOVE.B  #14,D0        ;set for task to display null terminated 
00001260                           341                                ;string without CR, LF
00001260  4E4F                     342          TRAP    #15
00001262                           343  
00001262  7000                     344          MOVEQ.L #0,D0
00001264  4E75                     345          RTS
00001266                           346          
00001266                           347  MOVEA:
00001266  43F9 000017AD            348          LEA     moveAMessage,A1  ;move string for MOVE
0000126C  103C 000D                349          MOVE.B  #13,D0        ;set for task to display null terminated 
00001270                           350                                ;string with CR, LF
00001270  4E4F                     351          TRAP    #15
00001272                           352  
00001272  7000                     353          MOVEQ.L #0,D0
00001274  4E75                     354          RTS
00001276                           355  
00001276                           356             
00001276                           357  Bcc:
00001276                           358  
00001276  43F9 0000179E            359          LEA     bccMessage,A1  ;move string for BRA info
0000127C  103C 000E                360          MOVE.B  #14,D0        ;set for task to display null terminated 
00001280                           361                                ;string without CR, LF
00001280  4E4F                     362          TRAP    #15
00001282                           363          
00001282  7000                     364          MOVEQ.L #0,D0 ;clear D0
00001284  3401                     365          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001286  E04A                     366          LSR.W   #8,D2
00001288  C47C 000F                367          AND.W   #$0F,D2 ;mask instruction
0000128C                           368          
0000128C                           369  checkCC:        
0000128C  41F9 00001711            370          LEA     bccList,A0 ;get condition code signature list in A0
00001292  D1C0                     371          ADDA.L  D0,A0 ;get correct sig         
00001294  B410                     372          CMP.B   (A0),D2 ;compare to sig
00001296  6700 0006                373          BEQ     foundCC ;if sig matches branch
0000129A  5200                     374          ADDQ.B  #byte,D0
0000129C  60EE                     375          BRA     checkCC
0000129E                           376  foundCC:
0000129E  43F9 00001722            377          LEA     conditionCodeMessage,A1 ;get condition code message in A1
000012A4  C0FC 0004                378          MULU.W  #long,D0 ;adjust size of D0 for a long
000012A8  D3C0                     379          ADDA.L  D0,A1 ;get correct message location
000012AA  2251                     380          MOVEA.L (A1),A1 ;get correct message
000012AC                           381          
000012AC  103C 000E                382          MOVE.B  #14,D0        ;set for task to display null terminated 
000012B0                           383                                ;string without CR, LF
000012B0  4E4F                     384          TRAP    #15
000012B2                           385  
000012B2                           386          
000012B2                           387          
000012B2  548B                     388          ADDQ.L  #word,A3 ;move past instruction in case long displacement
000012B4  C27C 00FF                389          AND.W   #$00FF,D1   ;check for word sized displacement
000012B8                           390          
000012B8  B23C 0000                391          CMP.B   #$0,D1
000012BC  6700 0010                392          BEQ     BccWord
000012C0                           393          
000012C0  B23C 00FF                394          CMP.B   #$FF,D1 check for long sized displacement
000012C4  6700 0010                395          BEQ     BccLong
000012C8                           396          
000012C8                           397  BccByte:
000012C8                           398          
000012C8  7E00                     399          MOVEQ.L #0,D7 ;pass back no extra data followed
000012CA  6000 0012                400          BRA     BccDone
000012CE                           401  BccWord:
000012CE  3213                     402          MOVE.W  (A3),D1
000012D0                           403          
000012D0  7E02                     404          MOVEQ.L #word,D7 ;pass back an extra word followed
000012D2  6000 000A                405          BRA     BccDone
000012D6                           406  BccLong:
000012D6  2213                     407          MOVE.L  (A3),D1
000012D8                           408          
000012D8  7E04                     409          MOVEQ.L #long,D7 ;pass back an extra long followed
000012DA  6000 0002                410          BRA     BccDone
000012DE                           411  BccDone:
000012DE                           412  
000012DE  343C 0010                413          MOVE.W  #16,D2 ;put base in D2
000012E2  303C 000F                414          MOVE.W  #15,D0  ;put task #15 in D0
000012E6  4E4F                     415          TRAP    #15
000012E8                           416          
000012E8  43F9 0000178A            417          LEA     clearLine,A1  ;move string for a CR and LF
000012EE  103C 000E                418          MOVE.B  #14,D0        ;set for task to display null terminated 
000012F2                           419                                ;string without CR, LF
000012F2  4E4F                     420          TRAP    #15
000012F4                           421  
000012F4  7000                     422          MOVEQ.L #0,D0
000012F6  4E75                     423          RTS
000012F8                           424          
000012F8                           425          
000012F8                           426  unknownOpCode:
000012F8  43F9 000017A6            427          LEA     dataMessage,A1 ;move string for data info
000012FE  103C 000E                428          MOVE.B  #14,D0        ;set for task to display null terminated 
00001302                           429                                ;string without CR, LF
00001302  4E4F                     430          TRAP    #15
00001304                           431          
00001304  143C 0010                432          MOVE.B  #16,D2        ;set for displaying a base16(hex) number
00001308  103C 000F                433          MOVE.B  #15,D0
0000130C  4E4F                     434          TRAP    #15
0000130E  43F9 0000178A            435          LEA     clearLine,A1  ;move string for a CR and LF
00001314  103C 000E                436          MOVE.B  #14,D0        ;set for task to display null terminated 
00001318                           437                                ;string without CR, LF
00001318  4E4F                     438          TRAP    #15
0000131A                           439          
0000131A  7000                     440          MOVEQ.L #0,D0
0000131C  4E75                     441          RTS
0000131E                           442          
0000131E                           443  
0000131E                           444  
0000131E                           445          
0000131E                           446          
0000131E                           447  fin
0000131E                           448  
0000131E                           449          
0000131E                           450          
0000131E  FFFF FFFF                451          simhalt
00001322                           452          
00001322                           453  
00001322                           454  *******************************************************************************
00001322                           455  *                            SUB ROUTINES
00001322                           456  *******************************************************************************
00001322                           457  *==============================================================================
00001322                           458  * enter_addr_edit_all - Enter address edit check to edit all errors  
00001322                           459  *                       using multiple different error checking routines.
00001322                           460  *
00001322                           461  * Parameters -
00001322                           462  *   Input   A1      The data that needs checked.
00001322                           463  *   Input   D1      The number of characters input     
00001322                           464  *   Output  D3      Returns '-1' when there is an error.
00001322                           465  *==============================================================================
00001322                           466  
00001322                           467  enter_addr_edit_all
00001322                           468  
00001322                           469  *------------------------------------------------------------------------------
00001322                           470  * Test for odd number of characters entered, not allowed
00001322                           471  *------------------------------------------------------------------------------
00001322                           472         
00001322  6100 0024                473          BSR         ck_boundry          ;check if the input is on a odd / even boundry
00001326  B67C FFFF                474          CMP.W       #-1,D3              ;Is the address odd?
0000132A  6700 001A                475          BEQ         enter_addr_edit_all_exit     ;No, return
0000132E                           476  
0000132E                           477  *------------------------------------------------------------------------------
0000132E                           478  * Ttest for character entered all being valid address characters
0000132E                           479  * Note: lower case a-f, gets converted to upper case A-F in D3
0000132E                           480  *------------------------------------------------------------------------------
0000132E                           481          
0000132E  6100 0062                482          BSR         parseHexString      ;check if the input contains valid Hex characters
00001332  B67C FFFF                483          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
00001336  6700 000E                484          BEQ         enter_addr_edit_all_exit     ;No, return
0000133A                           485  
0000133A                           486  *------------------------------------------------------------------------------
0000133A                           487  * Verify that the address entered is witin the range defined in the Equate
0000133A                           488  *------------------------------------------------------------------------------        
0000133A                           489          
0000133A  6100 00C8                490          BSR         ck_addr_range       ;is address entered witin the range 
0000133E                           491                                          ;   as defined in the Equate? 
0000133E  B67C FFFF                492          CMP.W       #-1,D3              ;is the address  valid?
00001342  6700 0002                493          BEQ         enter_addr_edit_all_exit     ;No, return
00001346                           494  
00001346                           495  enter_addr_edit_all_exit:
00001346                           496  
00001346  4E75                     497          RTS                             ;return
00001348                           498  
00001348                           499  *==============================================================================
00001348                           500  * ck_boundry - Check the size of the data characters input and determine
00001348                           501  *              if an odd number of characters was entered
00001348                           502  *
00001348                           503  * Parameters -
00001348                           504  *   Input   A1      The data that needs checked for odd length.
00001348                           505  *   Input   D1      The number of characters input     
00001348                           506  *   Output  D3      Returns '-1' when there is an odd length.
00001348                           507  *==============================================================================
00001348                           508  
00001348                           509  ck_boundry:
00001348                           510  
00001348  4243                     511          CLR.W       D3                  ;Clear the return
0000134A                           512  
0000134A  B23C 0000                513          CMP.B       #0,D1               ;Check for nothing entered
0000134E  6700 002E                514          BEQ         ck_size_error       ;Number of characters entered must be 
00001352                           515                                          ;greater than 0  
00001352                           516          
00001352                           517          
00001352                           518          * The program will branch to ck_size_error if D1 is greater than #8        
00001352  B23C 0008                519          CMP.B       #8,D1               ;Check for more than 8 characters entered
00001356  6E00 0026                520          BGT         ck_size_error       ;Number of characters entered must be less
0000135A                           521                                          ;than 9
0000135A                           522          
0000135A  7402                     523          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
0000135C  82C2                     524          DIVU        D2,D1               ;Divide address by 2
0000135E  4841                     525          SWAP        D1                  ;get remainder
00001360  B23C 0001                526          CMP.B       #$01,D1             ;Check for remainder of 1
00001364  6700 0004                527          BEQ         ck_boundry_error    ;Number of characters entered must be an 
00001368                           528                                          ;even number   
00001368                           529    
00001368  4E75                     530          RTS                             ;return
0000136A                           531  
0000136A                           532  *------------------------------------------------------------------------------
0000136A                           533  * ck_boundry_error - An odd number of characters was entered
0000136A                           534  *                  - Load error message and display it
0000136A                           535  *                  - Return error condition
0000136A                           536  *------------------------------------------------------------------------------
0000136A                           537          
0000136A                           538  ck_boundry_error:
0000136A                           539  
0000136A  43F9 000016AF            540          LEA         even_msg,A1         ;Load odd error message into A1
00001370  2239 000016AF            541          MOVE.L      even_msg,D1         ;Load error length to D1
00001376                           542          
00001376  7000                     543          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001378                           544                                          ; n is D1.W with CR, LF. 
00001378  4E4F                     545          TRAP #15                        ;Display the error message
0000137A  76FF                     546          MOVE.L #-1,D3                   ;Load -1 into return parameter
0000137C  4E75                     547          RTS                             ;Return
0000137E                           548          
0000137E                           549  *------------------------------------------------------------------------------
0000137E                           550  * ck_size_error -   The number of characters entered must be more than zero
0000137E                           551  *                  - Load error message and display it
0000137E                           552  *                  - Return error condition
0000137E                           553  *------------------------------------------------------------------------------
0000137E                           554          
0000137E                           555  ck_size_error:
0000137E                           556  
0000137E  43F9 00001622            557          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001384  2239 00001622            558          MOVE.L      invalidMsg,D1       ;Load error length to D1
0000138A                           559          
0000138A  7000                     560          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
0000138C                           561                                          ; n is D1.W with CR, LF. 
0000138C  4E4F                     562          TRAP        #15                 ;Display the error message
0000138E  76FF                     563          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001390  4E75                     564          RTS                             ;Return        
00001392                           565  
00001392                           566  
00001392                           567  *==============================================================================
00001392                           568  * parseHexString - Converts user input string into a valid memory address
00001392                           569  *                - Stores parsed address data into D3
00001392                           570  *                - Stores good/bad (1/0) data in D4 
00001392                           571  *
00001392                           572  * Hex values are stored as bytes in D2, the ASCII chart shows their value
00001392                           573  *   The ASCII chart values we care about are in the ranges of: 
00001392                           574  *                            Hex            Decimal
00001392                           575  *       No Value           NULL = 0         0
00001392                           576  *       Numeric Values:     0-9 = 30-39     48-57
00001392                           577  *       Upper Case letters: A-F = 41-46     65-70
00001392                           578  *       Lower Case letterc: a-f = 61-66     97-102
00001392                           579  
00001392                           580  * Parameters -
00001392                           581  *   Input   A1      The data that needs checked for valid input.
00001392                           582  *   Output  D3      The return value, '-1' for error
00001392                           583  *==============================================================================
00001392                           584  
00001392                           585  parseHexString:
00001392                           586  
00001392                           587  * setup any initializing item that do not get looped through
00001392  4243                     588          CLR.W       D3                  ;Clear the return
00001394                           589  
00001394                           590          
00001394                           591  *------------------------------------------------------------------------------
00001394                           592  * NextHex - Loop through all bytes and vaildate the input
00001394                           593  * Parameters -
00001394                           594  *   Input   A1      The data that needs checked for valid input.
00001394                           595  *   Output  D3      The return value, '-1' for error
00001394                           596  *------------------------------------------------------------------------------
00001394                           597          
00001394                           598  NextHex:
00001394                           599  
00001394  1419                     600          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00001396  B43C 0000                601          CMP.B       #0,D2               ;Check character for null 
0000139A  6700 0066                602          BEQ         NextHexReturn       ;Character is null (end of input)
0000139E                           603          
0000139E                           604  *................................................................................
0000139E                           605  *  Check decimal values 0-9 by testing hexadecimal values 30-39
0000139E                           606  *................................................................................
0000139E                           607                  
0000139E                           608          * The program will branch to hex_range_error if D2 is less than #30
0000139E  B43C 0030                609          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
000013A2  6D00 0048                610          BLT         hex_range_error     ;Branch to handle range error hexidecimal
000013A6                           611                                          ;processing
000013A6                           612          
000013A6                           613          * The program will branch to UcaseHex if D2 is greater than #39
000013A6  B43C 0039                614          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
000013AA  6E00 000A                615          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
000013AE                           616          
000013AE                           617          *a valid number was found within this range
000013AE  0402 0030                618          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
000013B2  6000 0032                619          BRA         NextHexDone         ;Done parsing this byte
000013B6                           620  
000013B6                           621  
000013B6                           622  *..............................................................................
000013B6                           623  *  Check upper case values A-F by testing hexadecimal values 41-46
000013B6                           624  *..............................................................................
000013B6                           625  
000013B6                           626  UcaseHex:
000013B6                           627  
000013B6                           628          * The program will branch to hex_range_error if D2 is less than #41
000013B6  B43C 0041                629          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
000013BA  6D00 0030                630          BLT         hex_range_error     ;Branch to handle range error hexidecimal
000013BE                           631                                          ;processing
000013BE                           632          
000013BE  B43C 0046                633          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
000013C2  6E00 000A                634          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
000013C6                           635                                          ;processing
000013C6                           636          
000013C6                           637          *a valid number was found within this range
000013C6  0402 0037                638          SUBI.B      #55,D2              ;Change uppercase character to actual value
000013CA  6000 001A                639          BRA         NextHexDone         ;Done parsing this byte
000013CE                           640  
000013CE                           641  
000013CE                           642  *..............................................................................
000013CE                           643  *  Check lower case values a-f by testing hexadecimal values 61-66
000013CE                           644  *..............................................................................
000013CE                           645  
000013CE                           646  LcaseHex
000013CE                           647          
000013CE                           648          * The program will branch to hex_range_error if D2 is less than #61
000013CE  B43C 0061                649          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
000013D2  6D00 0018                650          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
000013D6                           651                                          ;processing
000013D6                           652  
000013D6  B43C 0066                653          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
000013DA  6E00 0010                654          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
000013DE                           655                                          ;processing
000013DE                           656  
000013DE                           657          *a valid number was found within this range
000013DE  0402 0057                658          SUBI.B      #87,D2              ;Change lowercase character to actual value
000013E2  6000 0002                659          BRA         NextHexDone         ;Done parsing this byte
000013E6                           660  
000013E6                           661  NextHexDone:
000013E6                           662  
000013E6  E983                     663          ASL.L       #4,D3               ; Make rooom for new byte in the return register
000013E8  D602                     664          ADD.B       D2,D3               ; Move the new byte into the return register
000013EA  60A8                     665          BRA         NextHex             ; We're ready to parse the next byte
000013EC                           666          
000013EC                           667  *-------------------------------------------------------------------------------------
000013EC                           668  * hex_range_error -  A character entered was within the valid range for a hex address
000013EC                           669  *                 -  Load error message and display it
000013EC                           670  *                 -  Return error condition
000013EC                           671  *-------------------------------------------------------------------------------------
000013EC                           672          
000013EC                           673  hex_range_error:
000013EC                           674  
000013EC  43F9 00001667            675          LEA         invCharMsg,A1       ;Load invalid range message into A1
000013F2  2239 00001667            676          MOVE.L      invCharMsg,D1       ;Load error length to D1
000013F8                           677          
000013F8  7000                     678          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
000013FA                           679                                          ; n is D1.W with CR, LF. 
000013FA  4E4F                     680          TRAP        #15                 ;Display the error message
000013FC  76FF                     681          MOVE.L      #-1,D3              ;Load -1 into return parameter
000013FE  6000 0002                682          BRA         NextHexReturn
00001402                           683          
00001402                           684  NextHexReturn:
00001402                           685          
00001402  4E75                     686          RTS                             ;Return      
00001404                           687  
00001404                           688  
00001404                           689  *===============================================================================
00001404                           690  * ck_addr_range - check the address input is within a valid memory address range
00001404                           691  *                - Parsed address data into D3
00001404                           692  *
00001404                           693  * Parameters -
00001404                           694  *   Input   A1      The data that needs checked for valid address.
00001404                           695  *   Output  D3      The return value, '-1' for error
00001404                           696  *===============================================================================
00001404                           697  
00001404                           698  
00001404                           699  ck_addr_range:   
00001404                           700  
00001404                           701  *------------------------------------------------------------------------------
00001404                           702  * Verify that the address entered is witin the 
00001404                           703  * beginning range ('begin') as defined in the Equate
00001404                           704  *------------------------------------------------------------------------------   
00001404                           705              
00001404  2C3C 00005001            706          MOVE.L      #begin,D6           * Load minimum starting address
0000140A  B686                     707          CMP.L       D6,D3               * Is input at or above minimum?
0000140C  6D00 0012                708          BLT         ck_addr_range_error 
00001410                           709          
00001410                           710  *------------------------------------------------------------------------------
00001410                           711  * Verify that the address entered is witin the 
00001410                           712  * ending range ('end') as defined in the Equate
00001410                           713  *------------------------------------------------------------------------------
00001410                           714          
00001410  2C3C 00FFFFFE            715          MOVE.L      #end,D6             * Load maximum starting address
00001416  B686                     716          CMP.L       D6,D3               * Is input at or below maximum?
00001418  6E00 0006                717          BGT         ck_addr_range_error 
0000141C  6000 0012                718          BRA         ck_addr_done        ;done checking
00001420                           719          
00001420                           720  *..............................................................................
00001420                           721  * ck_addr_range_error -  A address entered is not within the 
00001420                           722  *                        valid range for a hex address
00001420                           723  *..............................................................................
00001420                           724          
00001420                           725  ck_addr_range_error
00001420                           726  
00001420  43F9 00001622            727          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001426                           728          
00001426  700D                     729          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
00001428                           730                                          ;with CR, LF. 
00001428  4E4F                     731          TRAP        #15                 ;Display the error message
0000142A  76FF                     732          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000142C  6000 0002                733          BRA         ck_addr_done 
00001430                           734  
00001430                           735  ck_addr_done:
00001430                           736  
00001430  4E75                     737          RTS                             ;Return
00001432                           738  
00001432                           739  *******************************************************************************
00001432                           740  *                            Effective Addressing
00001432                           741  *******************************************************************************
00001432                           742  
00001432                           743  Effective_Address:
00001432                           744  
00001432  1C05                     745          MOVE.B      D5,D6
00001434  E60E                     746          LSR.B       #3,D6               ;mode
00001436  CA3C 0007                747          And.B       #%00000111,D5       ;register
0000143A                           748          
0000143A  BC3C 0000                749          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
0000143E  6700 004A                750          BEQ         Data_Reg_Direct
00001442                           751          
00001442  BC3C 0001                752          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
00001446  6700 0076                753          BEQ         Addr_Reg_Indirect
0000144A                           754          
0000144A  BC3C 0002                755          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
0000144E  6700 006E                756          BEQ         Addr_Reg_Indirect
00001452                           757          
00001452  BC3C 0003                758          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
00001456  6700 0098                759          BEQ         Addr_Reg_Indirect_Inc
0000145A                           760          
0000145A  BC3C 0004                761          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
0000145E  6700 00CE                762          BEQ         Addr_Reg_Indirect_Dec
00001462                           763          
00001462  BC3C 0007                764          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
00001466  6700 0006                765          BEQ         Effective_Address_Other
0000146A                           766          
0000146A  6000 0144                767          BRA         invalidEA
0000146E                           768          
0000146E                           769  Effective_Address_Other:        
0000146E                           770          
0000146E  BA3C 0000                771          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00001472  6700 00F8                772          BEQ Addr_Abs_Short
00001476                           773          
00001476  BA3C 0001                774          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
0000147A  6700 010A                775          BEQ Addr_Abs_Long
0000147E                           776          
0000147E  BA3C 0001                777          CMP.B       #1,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
00001482  6700 011C                778          BEQ Addr_Immediate_Data
00001486                           779          
00001486  6000 0128                780          BRA         invalidEA
0000148A                           781          
0000148A                           782  Data_Reg_Direct:                        ;case 0(0000)
0000148A                           783  
0000148A                           784          ;MOVE.B      D0,D5               ;print D5 (register number)
0000148A                           785          
0000148A                           786          
0000148A                           787          
0000148A                           788          ;LEA         clearLine,A1        ;move string for a CR and LF
0000148A                           789   
0000148A  43F9 000017D5            790          LEA         letterD,A1          ;output 'D' for data register
00001490  103C 000E                791          MOVE.B      #14,D0              ;set for task to display null terminated 
00001494  4E4F                     792          TRAP        #15                 ;string without CR, LF
00001496                           793                          
00001496  4281                     794          CLR.L       D1
00001498  1205                     795          MOVE.B      D5,D1               ;move register number for display into D1
0000149A  103C 0003                796          MOVE.B      #3,D0               ;set for task to display null terminated 
0000149E  4E4F                     797          TRAP        #15                 ;string without CR, LF
000014A0                           798          
000014A0                           799  *how to do offset???
000014A0                           800          
000014A0  6000 010E                801          BRA         Effective_Address_Exit  ;return
000014A4                           802          
000014A4                           803          
000014A4                           804  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
000014A4                           805        
000014A4  43F9 000017D3            806          LEA         letterA,A1          ;output 'A' for address register
000014AA  103C 000E                807          MOVE.B      #14,D0              ;set for task to display null terminated 
000014AE  4E4F                     808          TRAP        #15                 ;string without CR, LF
000014B0                           809          
000014B0  4281                     810          CLR.L       D1
000014B2  1205                     811          MOVE.B      D5,D1               ;move register number for display into D1
000014B4  103C 0003                812          MOVE.B      #3,D0               ;set for task to display null terminated 
000014B8  4E4F                     813          TRAP        #15                 ;string without CR, LF
000014BA                           814          
000014BA  6000 00F4                815          BRA         Effective_Address_Exit  ;return
000014BE                           816  
000014BE                           817  
000014BE                           818  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
000014BE                           819          
000014BE  43F9 000017DB            820          LEA         lprn,A1             ;output 'D' for data register
000014C4  103C 000E                821          MOVE.B      #14,D0              ;set for task to display null terminated 
000014C8  4E4F                     822          TRAP        #15                 ;string without CR, LF
000014CA                           823  
000014CA  43F9 000017D3            824          LEA         letterA,A1          ;output 'A' for address register
000014D0  103C 000E                825          MOVE.B      #14,D0              ;set for task to display null terminated 
000014D4  4E4F                     826          TRAP        #15                 ;string without CR, LF
000014D6                           827          
000014D6  4281                     828          CLR.L       D1
000014D8  1205                     829          MOVE.B      D5,D1               ;move register number for display into D1
000014DA  103C 0003                830          MOVE.B      #3,D0               ;set for task to display null terminated 
000014DE  4E4F                     831          TRAP        #15                 ;string without CR, LF
000014E0                           832  
000014E0  43F9 000017DD            833          LEA         rprn,A1             ;output 'D' for data register
000014E6  103C 000E                834          MOVE.B      #14,D0              ;set for task to display null terminated 
000014EA  4E4F                     835          TRAP        #15                 ;string without CR, LF
000014EC                           836          
000014EC  6000 00C2                837          BRA         Effective_Address_Exit  ;return
000014F0                           838  
000014F0                           839                 
000014F0                           840  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
000014F0                           841  
000014F0  43F9 000017DB            842          LEA         lprn,A1             ;output 'D' for data register
000014F6  103C 000E                843          MOVE.B      #14,D0              ;set for task to display null terminated 
000014FA  4E4F                     844          TRAP        #15                 ;string without CR, LF
000014FC                           845  
000014FC  43F9 000017D3            846          LEA         letterA,A1          ;output 'A' for address register
00001502  103C 000E                847          MOVE.B      #14,D0              ;set for task to display null terminated 
00001506  4E4F                     848          TRAP        #15                 ;string without CR, LF
00001508                           849          
00001508  4281                     850          CLR.L       D1
0000150A  1205                     851          MOVE.B      D5,D1               ;move register number for display into D1
0000150C  103C 0003                852          MOVE.B      #3,D0               ;set for task to display null terminated 
00001510  4E4F                     853          TRAP        #15                 ;string without CR, LF
00001512                           854  
00001512  43F9 000017DD            855          LEA         rprn,A1             ;output 'D' for data register
00001518  103C 000E                856          MOVE.B      #14,D0              ;set for task to display null terminated 
0000151C  4E4F                     857          TRAP        #15                 ;string without CR, LF
0000151E                           858          
0000151E  43F9 000017D7            859          LEA         plus,A1             ;output 'D' for data register
00001524  103C 000E                860          MOVE.B      #14,D0              ;set for task to display null terminated 
00001528  4E4F                     861          TRAP        #15                 ;string without CR, LF
0000152A                           862          
0000152A  6000 0084                863          BRA         Effective_Address_Exit  ;return
0000152E                           864  
0000152E                           865  Addr_Reg_Indirect_Dec                   ;4 = (An) - Address Register Indirect with Predecrement (100)
0000152E                           866  
0000152E  43F9 000017D9            867          LEA         minus,A1            ;output '-' for Predecrement
00001534  103C 000E                868          MOVE.B      #14,D0              ;set for task to display null terminated 
00001538  4E4F                     869          TRAP        #15                 ;string without CR, LF
0000153A                           870  
0000153A  43F9 000017DB            871          LEA         lprn,A1             ;output 'D' for data register
00001540  103C 000E                872          MOVE.B      #14,D0              ;set for task to display null terminated 
00001544  4E4F                     873          TRAP        #15                 ;string without CR, LF
00001546                           874  
00001546  43F9 000017D3            875          LEA         letterA,A1          ;output 'A' for address register
0000154C  103C 000E                876          MOVE.B      #14,D0              ;set for task to display null terminated 
00001550  4E4F                     877          TRAP        #15                 ;string without CR, LF
00001552                           878          
00001552  4281                     879          CLR.L       D1
00001554  1205                     880          MOVE.B      D5,D1               ;move register number for display into D1
00001556  103C 0003                881          MOVE.B      #3,D0               ;set for task to display null terminated 
0000155A  4E4F                     882          TRAP        #15                 ;string without CR, LF
0000155C                           883  
0000155C  43F9 000017DD            884          LEA         rprn,A1             ;output 'D' for data register
00001562  103C 000E                885          MOVE.B      #14,D0              ;set for task to display null terminated 
00001566  4E4F                     886          TRAP        #15                 ;string without CR, LF
00001568                           887          
00001568  6000 0046                888          BRA         Effective_Address_Exit  ;return
0000156C                           889  
0000156C                           890          
0000156C                           891                         
0000156C                           892  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
0000156C                           893          
0000156C                           894          
0000156C  43F9 000017B5            895          LEA         xxxW,A1             ;output 'D' for data register
00001572  103C 000E                896          MOVE.B      #14,D0              ;set for task to display null terminated 
00001576  4E4F                     897          TRAP        #15                 ;string without CR, LF
00001578                           898  
00001578  548B                     899          ADDA.L      #word,A3
0000157A                           900          
0000157A                           901          ;print word (A3)
0000157A  103C 000E                902          MOVE.B      #14,D0              ;set for task to display null terminated 
0000157E  4E4F                     903          TRAP        #15                 ;string without CR, LF
00001580                           904          
00001580  5487                     905          ADDI.L      #word,D7 
00001582  6000 002C                906          BRA         Effective_Address_Exit  ;return
00001586                           907                         
00001586                           908  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
00001586                           909          
00001586  43F9 000017BF            910          LEA         xxxL,A1             ;output 'D' for data register
0000158C  103C 000E                911          MOVE.B      #14,D0              ;set for task to display null terminated 
00001590  4E4F                     912          TRAP        #15                 ;string without CR, LF
00001592                           913  
00001592  548B                     914          ADDA.L      #word,A3
00001594                           915          ;print long (A3)
00001594  103C 000E                916          MOVE.B      #14,D0              ;set for task to display null terminated 
00001598  4E4F                     917          TRAP        #15                 ;string without CR, LF
0000159A                           918          
0000159A  5887                     919          ADDI.L      #long,D7
0000159C  6000 0012                920          BRA         Effective_Address_Exit  ;return
000015A0                           921                         
000015A0                           922  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
000015A0                           923  
000015A0  43F9 000017C9            924          LEA         iData,A1            ;output 'D' for data register
000015A6  103C 000E                925          MOVE.B      #14,D0              ;set for task to display null terminated 
000015AA  4E4F                     926          TRAP        #15                 ;string without CR, LF
000015AC                           927          
000015AC                           928          *need another input param for size
000015AC  6000 0002                929          BRA         Effective_Address_Exit  ;return
000015B0                           930  
000015B0                           931  invalidEA:
000015B0                           932  
000015B0                           933          ;do something
000015B0                           934   
000015B0                           935  Effective_Address_Exit:     
000015B0                           936  
000015B0  4E75                     937          RTS                             ;return
000015B2                           938  
000015B2                           939  switchModeAndReg:
000015B2                           940  ***
000015B2                           941  * Assumed in D2
000015B2                           942  *
000015B2                           943  * Assumed that they are in least significant byte:
000015B2                           944  *
000015B2                           945  *            _this_
000015B2                           946  *           /      \
000015B2                           947  *  ........ ........
000015B2                           948  *  \                /
000015B2                           949  *   -----word-------
000015B2                           950  *
000015B2                           951  *  and that in that byte they are ordered:
000015B2                           952  *
000015B2                           953  *       ........   
000015B2                           954  *       \/\_/\_/
000015B2                           955  *      /  /    \
000015B2                           956  *    /   /      \
000015B2                           957  * dont  one    other
000015B2                           958  * care
000015B2                           959  *
000015B2                           960  * after they will be
000015B2                           961  *
000015B2                           962  *       ........   
000015B2                           963  *       \/\_/\_/
000015B2                           964  *      /  /    \
000015B2                           965  *    /   /      \
000015B2                           966  * dont other    one
000015B2                           967  * care
000015B2                           968  *** 
000015B2  0283 00000000            969          ANDI.L #0,D3 ;clear D3
000015B8  1602                     970          MOVE.B D2,D3 ;copy to D3
000015BA  E70B                     971          LSL.B  #3,D3 
000015BC  E60A                     972          LSR.B  #3,D2
000015BE  D403                     973          ADD.B  D3,D2
000015C0  4E75                     974          RTS
000015C2                           975  
000015C2                           976          
000015C2                           977  *==============================================================================
000015C2                           978  *                            variables and constants
000015C2                           979  *==============================================================================
000015C2                           980  
000015C2                           981  
000015C2                           982  ***initial user prompt stuff        
000015C2= 45 6E 74 65 72 20 ...    983  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE: $',0
000015F3= 45 6E 74 65 72 20 ...    984  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE: $',0
00001622                           985  
00001622= 20 41 64 64 72 65 ...    986  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
00001667= 20 41 20 43 68 61 ...    987  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
000016AF                           988  
000016AF= 20 59 6F 75 20 6D ...    989  even_msg        DC.B    ' You must enter an even address!'
000016CF                           990  
000016CF= 20                       991  spc             DC.B    ' '
000016D0= 01                       992  spc_len         DC.B    spc_len-spc
000016D1                           993  ***
000016D1                           994  
000016D1                           995  
000016D1                           996  
000016D1                           997  ***list of OP codes
000016D1                           998  
000016D1  =00004735                999  rtsInstruction   EQU %0100011100110101
000016D1  =00004E71               1000  NoOpInstruction  EQU %0100111001110001
000016D1  =00000000               1001  moveInstruction  EQU 0
000016D1  =00006000               1002  bccInstruction   EQU %0110000000000000
000016D1  =00004400               1003  negInstruction   EQU %0100010000000000
000016D1  =00000000               1004  dataInstruction  EQU 0
000016D1                          1005  
000016D1                          1006  ***
000016D1                          1007  
000016D1                          1008  ***list of OP masks
000016D1  =0000FFFF               1009  rtsMask   EQU $FFFF
000016D1  =0000FFFF               1010  NoOpMask  EQU $FFFF
000016D1  =0000C000               1011  moveMask  EQU $C000
000016D1  =0000F000               1012  bccMask   EQU $F000
000016D1  =0000FF00               1013  negMask   EQU $FF00
000016D1  =00000000               1014  dataMask  EQU 0
000016D1                          1015  ***
000016D1                          1016  
000016D1                          1017  ***Bcc Codes***
000016D1  =00000004               1018  CC EQU $04
000016D1  =00000005               1019  CS EQU $05
000016D1  =00000007               1020  EQ EQU $07
000016D1  =0000000C               1021  GE EQU $0C
000016D1  =0000000E               1022  GT EQU $0E
000016D1  =00000002               1023  HI EQU $02
000016D1  =0000000F               1024  LE EQU $0F
000016D1  =00000003               1025  LS EQU $03
000016D1  =0000000D               1026  LT EQU $0D
000016D1  =0000000B               1027  MI EQU $0B
000016D1  =00000006               1028  NE EQU $06
000016D1  =0000000A               1029  PL EQU $0A
000016D1  =00000008               1030  VC EQU $08
000016D1  =00000009               1031  VS EQU $09
000016D1  =00000000               1032  RA EQU $00 ;not really a Condition Code
000016D1  =00000001               1033  SR EQU $01 ;not really a Condition Code
000016D1                          1034  
000016D1= 43 43 20 00             1035  CCm DC.B 'CC ',0
000016D5= 43 53 20 00             1036  CSm DC.B 'CS ',0
000016D9= 45 51 20 00             1037  EQm DC.B 'EQ ',0
000016DD= 47 45 20 00             1038  GEm DC.B 'GE ',0
000016E1= 47 54 20 00             1039  GTm DC.B 'GT ',0
000016E5= 48 49 20 00             1040  HIm DC.B 'HI ',0
000016E9= 4C 45 20 00             1041  LEm DC.B 'LE ',0
000016ED= 4C 53 20 00             1042  LSm DC.B 'LS ',0
000016F1= 4C 54 20 00             1043  LTm DC.B 'LT ',0
000016F5= 4D 49 20 00             1044  MIm DC.B 'MI ',0
000016F9= 4E 45 20 00             1045  NEm DC.B 'NE ',0
000016FD= 50 4C 20 00             1046  PLm DC.B 'PL ',0
00001701= 56 43 20 00             1047  VCm DC.B 'VC ',0
00001705= 56 53 20 00             1048  VSm DC.B 'VS ',0
00001709= 52 41 20 00             1049  RAm DC.B 'RA ',0
0000170D= 53 52 20 00             1050  SRm DC.B 'SR ',0
00001711                          1051  
00001711= 01 04 05 07 0C 0E ...   1052  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
00001722= 0000170D 000016D1 ...   1053  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
00001762                          1054  ***
00001762                          1055  
00001762= 45 6E 74 65 72 20 ...   1056  startLocationPrompt DC.B    'Enter start location',0
00001777= 45 6E 74 65 72 20 ...   1057  endLocationPrompt   DC.B    'Enter end location',0
0000178A                          1058  
0000178A= 0D 0A 00                1059  clearLine  DC.B $0D,$0A,0
0000178D                          1060  
0000178D= 52 54 53 00             1061  rtsMessage      DC.B 'RTS',0
00001791= 4E 4F 50 3A 20 00       1062  nopMessage      DC.B 'NOP: ',0 
00001797= 4D 4F 56 45 3A 20 00    1063  moveMessage     DC.B 'MOVE: ',0
0000179E= 42 00                   1064  bccMessage      DC.B 'B',0
000017A0= 4E 45 47 3A 20 00       1065  negMessage      DC.B 'NEG: ',0
000017A6= 44 41 54 41 3A 20 00    1066  dataMessage     DC.B 'DATA: ',0
000017AD                          1067  
000017AD= 4D 4F 56 45 41 3A ...   1068  moveaMessage    DC.B 'MOVEA: ',0
000017B5                          1069  
000017B5= 28 78 78 78 29 2E ...   1070  xxxW            DC.B '(xxx).W: ',0
000017BF= 28 78 78 78 29 2E ...   1071  xxxL            DC.B '(xxx).L: ',0
000017C9= 23 28 64 61 74 61 ...   1072  iData           DC.B '#(data): ',0
000017D3                          1073  
000017D3= 41 00                   1074  letterA         DC.B 'A', 0
000017D5= 44 00                   1075  letterD         DC.B 'D', 0
000017D7                          1076  
000017D7= 2B 00                   1077  plus            DC.B '+', 0
000017D9= 2D 00                   1078  minus           DC.B '-', 0
000017DB= 28 00                   1079  lPrn            DC.B '(', 0
000017DD= 29 00                   1080  rPrn            DC.B ')', 0
000017DF                          1081  
000017DF                          1082  
000017E0= 00000000                1083  startLocation       DC.L    0
000017E4= 00000000                1084  endLocation         DC.L    0
000017E8                          1085  
000017E8                          1086  
000017E8                          1087     
000017E8                          1088      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDR_ABS_LONG       1586
ADDR_ABS_SHORT      156C
ADDR_IMMEDIATE_DATA  15A0
ADDR_REG_DIRECT     14A4
ADDR_REG_INDIRECT   14BE
ADDR_REG_INDIRECT_DEC  152E
ADDR_REG_INDIRECT_INC  14F0
BCC                 1276
BCCBYTE             12C8
BCCDONE             12DE
BCCINSTRUCTION      6000
BCCLIST             1711
BCCLONG             12D6
BCCMASK             F000
BCCMESSAGE          179E
BCCWORD             12CE
BEGIN               5001
BEGIN_ADDRESS       1008
BYTE                1
CC                  4
CCM                 16D1
CHECKCC             128C
CHECKMOVEDEST       11F0
CHECKOPCODE         1092
CK_ADDR_DONE        1430
CK_ADDR_RANGE       1404
CK_ADDR_RANGE_ERROR  1420
CK_BOUNDRY          1348
CK_BOUNDRY_ERROR    136A
CK_SIZE_ERROR       137E
CLEARLINE           178A
CONDITIONCODEMESSAGE  1722
CS                  5
CSM                 16D5
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         17A6
DATA_REG_DIRECT     148A
EFFECTIVE_ADDRESS   1432
EFFECTIVE_ADDRESS_EXIT  15B0
EFFECTIVE_ADDRESS_OTHER  146E
ELPROMPT            15F3
END                 FFFFFE
ENDLOCATION         17E4
ENDLOCATIONPROMPT   1777
END_ADDRESS         1054
ENTER_ADDR_EDIT_ALL  1322
ENTER_ADDR_EDIT_ALL_EXIT  1346
EQ                  7
EQM                 16D9
EVEN_MSG            16AF
FALSEPOSITIVE       10B2
FARLABEL            FFE
FIN                 131E
FOUNDCC             129E
GE                  C
GEM                 16DD
GT                  E
GTM                 16E1
HEX_RANGE_ERROR     13EC
HI                  2
HIM                 16E5
IDATA               17C9
INSTLABELLIST       10F0
INSTMASKLIST        10E4
INSTOPLIST          10D8
INVALIDEA           15B0
INVALIDMSG          1622
INVCHARMSG          1667
LCASEHEX            13CE
LE                  F
LEM                 16E9
LETTERA             17D3
LETTERD             17D5
LONG                4
LPRN                17DB
LS                  3
LSM                 16ED
LT                  D
LTM                 16F1
MAIN_LOOP           1076
MATCH               10B8
MI                  B
MIM                 16F5
MINUS               17D9
MOVE                11C8
MOVEA               1266
MOVEAMESSAGE        17AD
MOVEBODY            121E
MOVEDESTEA          11BA
MOVEDESTEAMASKS     11C1
MOVEINSTRUCTION     0
MOVEMASK            C000
MOVEMESSAGE         1797
MOVESOURCEEA        11A8
MOVESOURCEEAMASKS   11B1
NE                  6
NEG                 1138
NEGBODY             1160
NEGDONE             1178
NEGEA               1128
NEGEAMASKS          1130
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          17A0
NEM                 16F9
NEXTHEX             1394
NEXTHEXDONE         13E6
NEXTHEXRETURN       1402
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 1188
NOPMESSAGE          1791
PARSEHEXSTRING      1392
PL                  A
PLM                 16FD
PLUS                17D7
PRGORG              1000
RA                  0
RAM                 1709
RPRN                17DD
RTS                 1198
RTSINSTRUCTION      4735
RTSMASK             FFFF
RTSMESSAGE          178D
SLPROMPT            15C2
SNIPPET             1108
SNIPPETEND          1124
SPC                 16CF
SPC_LEN             16D0
SR                  1
SRM                 170D
STACK               5000
START               1000
STARTLOCATION       17E0
STARTLOCATIONPROMPT  1762
SWITCHMODEANDREG    15B2
UCASEHEX            13B6
UNKNOWNOPCODE       12F8
VALIDMOVEDESTMODES  11F2
VALIDMOVESOURCEMODES  11CA
VALIDNEGMODES       113A
VC                  8
VCM                 1701
VS                  9
VSM                 1705
WORD                2
XXXL                17BF
XXXW                17B5

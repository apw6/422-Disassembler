00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/10/2014 4:05:07 PM

00000000                             1  *##########################################################################
00000000                             2  * Title      : 
00000000                             3  * Written by : Andrew Watson
00000000                             4  *            : Elaine Keller
00000000                             5  *            : Robert Anderson
00000000                             6  * Date       : 11/14/2014
00000000                             7  * Description: 
00000000                             8  *##########################################################################
00000000                             9  
00000000                            10  ***Possible Bug***
00000000                            11  *can not tell data from an
00000000                            12  *unidentified instruction that is an actual
00000000                            13  *instruction therefore causing errors.
00000000                            14  *may not actually be a bug because data
00000000                            15  *is data to the machine, and if you modify
00000000                            16  *the instructions in memory for a program
00000000                            17  *by moivng data, you can modify the instuctions
00000000                            18  *executed.
00000000                            19  
00000000                            20  
00000000                            21  ***************************************************************************
00000000                            22  *                   Variable/Data Definitions
00000000                            23  ***************************************************************************
00000000                            24  
00000000  =00005000                 25  stack   EQU   $00005000
00000000  =00005001                 26  begin   EQU   $00005001
00000000  =00FFFFFE                 27  end     EQU   $00FFFFFE
00000000  =00000001                 28  byte    EQU   1
00000000  =00000002                 29  word    EQU   2
00000000  =00000004                 30  long    EQU   4
00000000  =00001000                 31  prgorg  EQU   $1000
00000000                            32  
00000FFE                            33      ORG $00000FFE
00000FFE                            34  FarLabel:
00001000                            35      ORG    prgorg
00001000                            36  start:
00001000  4FF8 5000                 37          LEA stack, SP ;initialize stack
00001004                            38  
00001000                            39      ORG    prgorg
00001000                            40  
00001000                            41  ******************************************************************************
00001000                            42  *                   Begin processing active code
00001000                            43  ******************************************************************************
00001000                            44      
00001000                            45  start:
00001000                            46  
00001000  4FF8 5000                 47          LEA         stack, SP           ;Initialize stack
00001004                            48          
00001004                            49  *.............................................................................
00001004                            50  * Debug Mode - Comment out when done
00001004  267C 00001178             51          MOVE.L      #snippet,A3
0000100A  287C 00001202             52          MOVE.L      #snippetEnd,A4
00001010  6000 0014                 53          BRA         main_Loop
00001014                            54  * Debug Mode - Comment out when done
00001014                            55  *.............................................................................        
00001014                            56          
00001014                            57  prompt_user:
00001014                            58  
00001014  6100 0ED8                 59          BSR         begin_address
00001018  B67C FFFF                 60          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000101C  6700 0ECC                 61          BEQ         fin                 ;Yes, then exit
00001020                            62          
00001020  6000 0004                 63          BRA         main_Loop
00001024                            64          ;BSR         process_op_codes
00001024  60EE                      65          BRA         prompt_user
00001026                            66                  
00001026                            67  ******************************************************************************
00001026                            68  *                   Begin processing OP Codes
00001026                            69  ******************************************************************************
00001026                            70   
00001026                            71  main_Loop:
00001026                            72  
00001026  B9CB                      73          CMPA.L A3,A4 ;check end of prog
00001028  6F00 0EC0                 74          BLE fin
0000102C                            75          
0000102C                            76          ;print memory location
0000102C  48E7 1200                 77          MOVEM.L D3/D6,-(SP)
00001030  7C02                      78          MOVEQ.L #2,D6 ;set as long hex string
00001032  260B                      79          MOVE.L  A3,D3 ;put hex in D3
00001034  6100 11C6                 80          BSR outputHex
00001038  4CDF 0048                 81          MOVEM.L (SP)+,D3/D6
0000103C                            82          
0000103C                            83          ;print ' '
0000103C  48E7 4000                 84          MOVEM.L D1,-(SP) ;save D1 to the stack
00001040  123C 0020                 85          MOVE.B #' ',D1 ;put ascii value of char in D1
00001044  103C 0006                 86          MOVE.B #6,D0 ;move task 6 into D0
00001048  4E4F                      87          TRAP #15 ;prin char
0000104A  4CDF 0002                 88          MOVEM.L (SP)+,D1 ;pull D1 off the stack
0000104E                            89          
0000104E  3213                      90          MOVE.W (A3),D1 ;copy word from other prog to analyze as instruction
00001050                            91          
00001050                            92          ;handle an odd memory access(instructions will never be misaligned)
00001050  240B                      93          MOVE.L A3,D2 ; copy address to D2
00001052  0202 0001                 94          ANDI.B #%00000001,D2 ;mask everything except the least significant bit
00001056  0C02 0001                 95          CMPI.B #1,D2 ;compare the least sig bit of the address to one
0000105A  6700 0E62                 96          BEQ handlebytedata ;the least sig bit will only be one if the insrtuction
0000105E                            97                             ;is odd(misaligned) and therefore not an instruction
0000105E                            98          
0000105E  7600                      99          MOVEQ.L #0,D3
00001060                           100          
00001060                           101          ***things to save A3,A4,D1(?)***
00001060  48E7 0018                102          MOVEM.L A3-A4,-(SP)
00001064  6100 000C                103          BSR checkOPcode
00001068  4CDF 1800                104          MOVEM.L (SP)+,A3-A4
0000106C  D7C7                     105          ADDA.L  D7,A3 ;look past data that was part of the instruction
0000106E                           106          
0000106E  548B                     107          ADDQ.L  #word,A3
00001070  60B4                     108          BRA     main_Loop 
00001072                           109          
00001072                           110  checkOPcode:
00001072                           111  
00001072                           112  
00001072  7E00                     113          MOVEQ.L #0,D7
00001074                           114          
00001074  41F9 000010B8            115          LEA     instOPList,A0 ;get instruction signitrue list in A0
0000107A  D1C3                     116          ADDA.L  D3,A0 ;get correct sig         
0000107C                           117          
0000107C  43F9 000010E8            118          LEA     instMaskList,A1 ;get instruction mask in A1
00001082  D3C3                     119          ADDA.L  D3,A1  ;get correct mast
00001084                           120          
00001084  3401                     121          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001086                           122          
00001086  C451                     123          AND.W   (A1),D2 ;mask instruction
00001088                           124          
00001088                           125          
00001088                           126          
00001088                           127          
00001088  B450                     128          CMP.W   (A0),D2 ;compare to sig
0000108A  6700 000C                129          BEQ     match ;if sig matches branch
0000108E  5483                     130          ADDQ.L  #word,D3 ;add to D3 to check for next instruction
00001090  60E0                     131          BRA checkOPcode
00001092                           132          
00001092                           133  falsePositive:
00001092                           134          
00001092  103C 00FF                135          MOVE.B #-1,D0
00001096  4E75                     136          RTS
00001098                           137  
00001098                           138  match:
00001098                           139          
00001098  43F9 00001118            140          LEA     instLabelList,A1 ;get instruction code label
0000109E  D3C3                     141          ADDA.L  D3,A1 ;get correct label
000010A0  D3C3                     142          ADDA.L  D3,A1
000010A2  5483                     143          ADDQ.L  #word,D3 ;add to D3 incase false positive
000010A4  2251                     144          MOVEA.L (A1),A1
000010A6  48E7 1000                145          MOVEM.L D3,-(SP) ; save D3
000010AA  4E91                     146          JSR     (A1)
000010AC  4CDF 0008                147          MOVEM.L (SP)+,D3 ;restore D3
000010B0  B03C 00FF                148          CMP.B   #-1,D0
000010B4  67BC                     149          BEQ     checkOPcode
000010B6  4E75                     150          RTS
000010B8                           151          
000010B8                           152  
000010B8= 41C0 81C0 C1C0 E...      153  instOPList  DC.W leaInstruction,divsInstruction,mulsInstruction,rsrlweaInstruction,rsrlregInstruction,asrlweaInstruction,asrlregInstruction,lsrlweaInstruction,lsrlregInstruction
000010CA= 5100 9000 D000 D...      154  instOPList2 DC.W subqInstruction,subInstruction,addaInstruction,addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruct
000010E8                           155      
000010E8= F1C0 F1C0 F1C0 F...      156  instMaskList DC.W leaMask,divsMask,mulsMask,rsrlweaMask,rsrlregMask,asrlweaMask,asrlregMask,lsrlweaMask,lsrlregMask,subqMask,subMask,addaMask,addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask   
00001118= 0000120E 00001280        157  instLabelList  DC.L LEA,DIVS
00001120= 00001304 00001374 ...    158  instLabelList2 DC.L MULS,RSRLWEA,RSRLREG,ASRLWEA,ASRLREG,LSRLWEA,LSRLREG,SUBQ,SUB,ADDA,ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
00001178                           159  
00001178                           160  snippet:
00001178  4E71                     161           NOP
0000117A  60FC                     162           BRA snippet
0000117C  6000 FE80                163           BRA FarLabel
00001180  67F6                     164           BEQ snippet
00001182  6E00 08E6                165           BGT NEG
00001186  61F0                     166           BSR snippet
00001188  4441                     167           NEG D1
0000118A  3239 00008500            168           MOVE.W $8500,D1
00001190  0645 001E                169           ADDI.W #30,D5
00001194  4E75                     170           RTS
00001196  4EB8 0054                171           JSR $54
0000119A  0C41 0003                172           CMPI #3,D1
0000119E  0041 0003                173           ORI  #3,D1
000011A2  48E7 0018                174           MOVEM.L A3-A4,-(SP)
000011A6  D401                     175           ADD.B D1,D2
000011A8  0603 000A                176           ADD.B #10,D3
000011AC  D7FC 00000463            177           ADDA.L #1123,A3
000011B2  9A43                     178           SUB.W D3,D5
000011B4  5105                     179           SUBQ.B #8,D5
000011B6  5305                     180           SUBQ.B #1,D5
000011B8  E64B                     181           LSR #3,D3
000011BA  E74C                     182           LSL #3,D4
000011BC  E369                     183           LSL D1,D1
000011BE  E66F                     184           LSR D3,D7
000011C0  E2F8 3563                185           LSR $3563
000011C4  E3F9 00486412            186           LSL $486412
000011CA  E643                     187           ASR #3,D3
000011CC  E744                     188           ASL #3,D4
000011CE  E361                     189           ASL D1,D1
000011D0  E667                     190           ASR D3,D7
000011D2  E0F8 3563                191           ASR $3563
000011D6  E1F9 00486412            192           ASL $486412
000011DC  E65B                     193           ROR #3,D3
000011DE  E75C                     194           ROL #3,D4
000011E0  E379                     195           ROL D1,D1
000011E2  E67F                     196           ROR D3,D7
000011E4  E6F8 3563                197           ROR $3563
000011E8  E7F9 00486412            198           ROL $486412
000011EE  C5FC 4562                199           MULS #$4562,D2
000011F2  85FC 4562                200           DIVS #$4562,D2
000011F6  43F9 0000120A            201           LEA leaEAmasks,A1
000011FC  0384                     202           BCLR D1,D4
000011FE  0885 0014                203           BCLR #20,D5
00001202                           204  
00001202                           205           
00001202                           206  snippetEnd:
00001202  FFFF FFFF                207           SIMHALT
00001206                           208  
00001206= 10 38 39 00              209  leaEA        DC.B %010000,%111000,%111001,0
0000120A= 38 3F 3F 00              210  leaEAmasks   DC.B %111000,%111111,%111111,0
0000120E                           211          
0000120E                           212  LEA:
0000120E                           213  
0000120E  7000                     214          MOVEQ.L #0, D0 ;clear D0
00001210                           215          
00001210                           216  validLeaModes:
00001210                           217          
00001210  43F8 120A                218          LEA leaEAmasks,A1 ;load the list of masks
00001214  D3C0                     219          ADDA.L D0,A1 ;displace to a specific mask
00001216  1A11                     220          MOVE.B (A1),D5 ;move the mask to D5
00001218                           221          
00001218  0C05 0000                222          CMPI.B #0,D5 ;check if the mask is 0
0000121C  6700 FE74                223          BEQ falsePositive ;branch if it is
00001220                           224          
00001220  1401                     225          MOVE.B D1,D2 ;copy instruction to D2
00001222  C405                     226          AND.B D5,D2  ;mask D2
00001224                           227          
00001224  43F8 1206                228          LEA leaEA,A1 ;load the list of valid modes
00001228  D3C0                     229          ADDA.L D0,A1 ;displace to a specific mode
0000122A  1811                     230          MOVE.B (A1),D4 ;move mode to D4
0000122C  B404                     231          CMP.B D4,D2 ;compare mode to masked value
0000122E  6700 0006                232          BEQ  leaBody ;if its match, its a valid mode and we can procede
00001232                           233          
00001232  5280                     234          ADDQ.L #1,D0 ;add one to displacement
00001234  60DA                     235          BRA validLeaModes ;check for next mode
00001236                           236          
00001236                           237  leaBody:
00001236                           238          
00001236                           239  
00001236                           240  
00001236  43F9 00002487            241          LEA     leaMessage,A1  ;move string for MOVE
0000123C  103C 000E                242          MOVE.B  #14,D0        ;set for task to display null terminated 
00001240                           243                                ;string without CR, LF
00001240  4E4F                     244          TRAP    #15
00001242                           245  
00001242                           246          ;do source EA
00001242  3401                     247          MOVE.W  D1,D2 ;check mode
00001244  C43C 003F                248          AND.B   #%00111111,D2
00001248  1A02                     249          MOVE.B  D2,D5
0000124A  48E7 4000                250          MOVEM.L D1,-(SP)
0000124E  6100 0E26                251          BSR     Get_Effective_Address
00001252  4CDF 0002                252          MOVEM.L (SP)+,D1
00001256                           253  
00001256                           254          ;print separator
00001256                           255          
00001256                           256          ;do dest addr reg
00001256  3401                     257          MOVE.W  D1,D2 ;check mode
00001258  E04A                     258          LSR.W #8,D2 ;shift reg over
0000125A  E20A                     259          LSR.B #1,D2
0000125C  C43C 0007                260          AND.B   #%00000111,D2 ;force recognition as a An
00001260  5002                     261          ADDQ.B #%1000,D2
00001262  1A02                     262          MOVE.B  D2,D5
00001264  48E7 4000                263          MOVEM.L D1,-(SP)
00001268  6100 0E0C                264          BSR     Get_Effective_Address
0000126C  4CDF 0002                265          MOVEM.L (SP)+,D1
00001270                           266          
00001270  43F9 00002484            267          LEA     clearLine,A1  ;move string for a CR and LF
00001276  103C 000E                268          MOVE.B  #14,D0        ;set for task to display null terminated 
0000127A                           269                                ;string without CR, LF
0000127A  4E4F                     270          TRAP    #15
0000127C                           271  
0000127C  7000                     272          MOVEQ.L #0,D0
0000127E  4E75                     273          RTS
00001280                           274  
00001280                           275  
00001280                           276  
00001280                           277  DIVS:
00001280                           278  
00001280  7000                     279          MOVEQ.L #0, D0 ;clear D0
00001282                           280          
00001282                           281  validDivsModes:
00001282                           282          
00001282  43F9 000012FC            283          LEA mulsEAmasks,A1 ;load the list of masks
00001288  D3C0                     284          ADDA.L D0,A1 ;displace to a specific mask
0000128A  1A11                     285          MOVE.B (A1),D5 ;move the mask to D5
0000128C                           286          
0000128C  0C05 0000                287          CMPI.B #0,D5 ;check if the mask is 0
00001290  6700 FE00                288          BEQ falsePositive ;branch if it is
00001294                           289          
00001294  1401                     290          MOVE.B D1,D2 ;copy instruction to D2
00001296  C405                     291          AND.B D5,D2  ;mask D2
00001298                           292          
00001298  43F9 000012F4            293          LEA mulsEA,A1 ;load the list of valid modes
0000129E  D3C0                     294          ADDA.L D0,A1 ;displace to a specific mode
000012A0  1811                     295          MOVE.B (A1),D4 ;move mode to D4
000012A2  B404                     296          CMP.B D4,D2 ;compare mode to masked value
000012A4  6700 0006                297          BEQ  divsBody ;if its match, its a valid mode and we can procede
000012A8                           298          
000012A8  5280                     299          ADDQ.L #1,D0 ;add one to displacement
000012AA  60D6                     300          BRA validDivsModes ;check for next mode
000012AC                           301          
000012AC                           302  divsBody:
000012AC                           303          
000012AC                           304  
000012AC                           305  
000012AC  43F9 0000248C            306          LEA     divsMessage,A1  ;move string for MOVE
000012B2  103C 000E                307          MOVE.B  #14,D0        ;set for task to display null terminated 
000012B6                           308                                ;string without CR, LF
000012B6  4E4F                     309          TRAP    #15
000012B8                           310  
000012B8                           311          ;do source EA
000012B8  3401                     312          MOVE.W  D1,D2 ;check mode
000012BA  C43C 003F                313          AND.B   #%00111111,D2
000012BE  1A02                     314          MOVE.B  D2,D5
000012C0  48E7 4000                315          MOVEM.L D1,-(SP)
000012C4  6100 0DB0                316          BSR     Get_Effective_Address
000012C8  4CDF 0002                317          MOVEM.L (SP)+,D1
000012CC                           318  
000012CC                           319          ;print separator
000012CC                           320          
000012CC                           321          ;do dest data reg
000012CC  3401                     322          MOVE.W  D1,D2 ;check mode
000012CE  E04A                     323          LSR.W #8,D2 ;shift reg over
000012D0  E20A                     324          LSR.B #1,D2
000012D2  C43C 0007                325          AND.B   #%00000111,D2 ;force recognition as a Dn
000012D6  1A02                     326          MOVE.B  D2,D5
000012D8  48E7 4000                327          MOVEM.L D1,-(SP)
000012DC  6100 0D98                328          BSR     Get_Effective_Address
000012E0  4CDF 0002                329          MOVEM.L (SP)+,D1
000012E4                           330          
000012E4  43F9 00002484            331          LEA     clearLine,A1  ;move string for a CR and LF
000012EA  103C 000E                332          MOVE.B  #14,D0        ;set for task to display null terminated 
000012EE                           333                                ;string without CR, LF
000012EE  4E4F                     334          TRAP    #15
000012F0                           335  
000012F0  7000                     336          MOVEQ.L #0,D0
000012F2  4E75                     337          RTS
000012F4                           338  
000012F4                           339  
000012F4                           340  
000012F4                           341  
000012F4= 00 10 18 20 38 39 ...    342  mulsEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,%111100,0
000012FC= 38 38 38 38 3F 3F ...    343  mulsEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,%111111,0
00001304                           344          
00001304                           345  MULS:
00001304                           346  
00001304  7000                     347          MOVEQ.L #0, D0 ;clear D0
00001306                           348          
00001306                           349  validMulsModes:
00001306                           350          
00001306  43F8 12FC                351          LEA mulsEAmasks,A1 ;load the list of masks
0000130A  D3C0                     352          ADDA.L D0,A1 ;displace to a specific mask
0000130C  1A11                     353          MOVE.B (A1),D5 ;move the mask to D5
0000130E                           354          
0000130E  0C05 0000                355          CMPI.B #0,D5 ;check if the mask is 0
00001312  6700 FD7E                356          BEQ falsePositive ;branch if it is
00001316                           357          
00001316  1401                     358          MOVE.B D1,D2 ;copy instruction to D2
00001318  C405                     359          AND.B D5,D2  ;mask D2
0000131A                           360          
0000131A  43F8 12F4                361          LEA mulsEA,A1 ;load the list of valid modes
0000131E  D3C0                     362          ADDA.L D0,A1 ;displace to a specific mode
00001320  1811                     363          MOVE.B (A1),D4 ;move mode to D4
00001322  B404                     364          CMP.B D4,D2 ;compare mode to masked value
00001324  6700 0006                365          BEQ  mulsBody ;if its match, its a valid mode and we can procede
00001328                           366          
00001328  5280                     367          ADDQ.L #1,D0 ;add one to displacement
0000132A  60DA                     368          BRA validMulsModes ;check for next mode
0000132C                           369          
0000132C                           370  mulsBody:
0000132C                           371          
0000132C                           372  
0000132C                           373  
0000132C  43F9 00002492            374          LEA     mulsMessage,A1  ;move string for MOVE
00001332  103C 000E                375          MOVE.B  #14,D0        ;set for task to display null terminated 
00001336                           376                                ;string without CR, LF
00001336  4E4F                     377          TRAP    #15
00001338                           378  
00001338                           379          ;do source EA
00001338  3401                     380          MOVE.W  D1,D2 ;check mode
0000133A  C43C 003F                381          AND.B   #%00111111,D2
0000133E  1A02                     382          MOVE.B  D2,D5
00001340  48E7 4000                383          MOVEM.L D1,-(SP)
00001344  6100 0D30                384          BSR     Get_Effective_Address
00001348  4CDF 0002                385          MOVEM.L (SP)+,D1
0000134C                           386  
0000134C                           387          ;print separator
0000134C                           388          
0000134C                           389          ;do dest data reg
0000134C  3401                     390          MOVE.W  D1,D2 ;check mode
0000134E  E04A                     391          LSR.W #8,D2 ;shift reg over
00001350  E20A                     392          LSR.B #1,D2
00001352  C43C 0007                393          AND.B   #%00000111,D2 ;force recognition as a Dn
00001356  1A02                     394          MOVE.B  D2,D5
00001358  48E7 4000                395          MOVEM.L D1,-(SP)
0000135C  6100 0D18                396          BSR     Get_Effective_Address
00001360  4CDF 0002                397          MOVEM.L (SP)+,D1
00001364                           398          
00001364  43F9 00002484            399          LEA     clearLine,A1  ;move string for a CR and LF
0000136A  103C 000E                400          MOVE.B  #14,D0        ;set for task to display null terminated 
0000136E                           401                                ;string without CR, LF
0000136E  4E4F                     402          TRAP    #15
00001370                           403  
00001370  7000                     404          MOVEQ.L #0,D0
00001372  4E75                     405          RTS
00001374                           406  
00001374                           407  
00001374                           408  
00001374                           409  RSRLWEA:
00001374                           410          
00001374                           411  
00001374                           412          
00001374  7000                     413          MOVEQ.L #0, D0 ;clear D0
00001376                           414          
00001376                           415  validRSRL:
00001376                           416          
00001376  43F9 000014C6            417          LEA lsrlEAmasks,A1 ;load the list of masks
0000137C  D3C0                     418          ADDA.L D0,A1 ;displace to a specific mask
0000137E  1A11                     419          MOVE.B (A1),D5 ;move the mask to D5
00001380                           420          
00001380  0C05 0000                421          CMPI.B #0,D5 ;check if the mask is 0
00001384  6700 FD0C                422          BEQ falsePositive ;branch if it is
00001388                           423          
00001388  1401                     424          MOVE.B D1,D2 ;copy instruction to D2
0000138A  C405                     425          AND.B D5,D2  ;mask D2
0000138C                           426          
0000138C  43F9 000014C0            427          LEA lsrlEA,A1 ;load the list of valid modes
00001392  D3C0                     428          ADDA.L D0,A1 ;displace to a specific mode
00001394  1811                     429          MOVE.B (A1),D4 ;move mode to D4
00001396  B404                     430          CMP.B D4,D2 ;compare mode to masked value
00001398  6700 0006                431          BEQ  rsrlweaCheckDirection ;if its match, its a valid mode and we can procede
0000139C                           432          
0000139C  5280                     433          ADDQ.L #1,D0 ;add one to displacement
0000139E  60D6                     434          BRA validRSRL ;check for next mode
000013A0                           435  
000013A0                           436  rsrlweaCheckDirection:
000013A0                           437          ;Figure out which direction we are going
000013A0  3401                     438          MOVE.W D1,D2 ;copy inst to D2
000013A2  E04A                     439          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000013A4  0202 0001                440          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000013A8  0C02 0000                441          CMPI.B #0,D2 ;compare bit to zero
000013AC  6700 0006                442          BEQ RSREA ;if zero, right
000013B0  6000 0012                443          BRA RSLEA ;else, its left
000013B4                           444  
000013B4                           445  RSREA:
000013B4                           446  
000013B4  43F9 0000249D            447          LEA     rsrMessage,A1  ;move string for MOVE
000013BA  103C 000E                448          MOVE.B  #14,D0        ;set for task to display null terminated 
000013BE                           449                                ;string with CR, LF
000013BE  4E4F                     450          TRAP    #15
000013C0  6000 0166                451          BRA lsrlweaBody
000013C4                           452          
000013C4                           453  RSLEA:
000013C4                           454          
000013C4  43F9 00002498            455          LEA     rslMessage,A1  ;move string for MOVE
000013CA  103C 000E                456          MOVE.B  #14,D0        ;set for task to display null terminated 
000013CE                           457                                ;string with CR, LF
000013CE  4E4F                     458          TRAP    #15
000013D0  6000 0156                459          BRA lsrlweaBody        
000013D4                           460          
000013D4                           461  
000013D4                           462  
000013D4                           463  RSRLREG:
000013D4                           464          
000013D4                           465  
000013D4                           466          
000013D4  7000                     467          MOVEQ.L #0, D0 ;clear D0
000013D6                           468          
000013D6                           469          ;check valid size field
000013D6  3401                     470          MOVE.W D1,D2 ;copy inst to D2
000013D8  EC4A                     471          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
000013DA  0202 0003                472          ANDI.B #%00000011,D2 ;mask out rest of byte
000013DE  0C02 0003                473          CMPI.B #%11,D2 ;compare to 3
000013E2  6700 FCAE                474          BEQ falsePositive ;invalid size
000013E6                           475  
000013E6                           476          
000013E6                           477          ;Figure out which direction we are going
000013E6  3401                     478          MOVE.W D1,D2 ;copy inst to D2
000013E8  E04A                     479          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000013EA  0202 0001                480          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000013EE  0C02 0000                481          CMPI.B #0,D2 ;compare bit to zero
000013F2  6700 0006                482          BEQ RSRreg ;if zero, right
000013F6  6000 0012                483          BRA RSLreg ;else, its left        
000013FA                           484          
000013FA                           485  RSRreg:
000013FA                           486  
000013FA  43F9 0000249D            487          LEA     rsrMessage,A1  ;move string for MOVE
00001400  103C 000E                488          MOVE.B  #14,D0        ;set for task to display null terminated 
00001404                           489                                ;string with CR, LF
00001404  4E4F                     490          TRAP    #15
00001406  6000 018A                491          BRA LSRLregBody
0000140A                           492          
0000140A                           493  RSLreg:
0000140A                           494          
0000140A  43F9 00002498            495          LEA     rslMessage,A1  ;move string for MOVE
00001410  103C 000E                496          MOVE.B  #14,D0        ;set for task to display null terminated 
00001414                           497                                ;string with CR, LF
00001414  4E4F                     498          TRAP    #15
00001416  6000 017A                499          BRA LSRLregBody
0000141A                           500  
0000141A                           501       
0000141A                           502  
0000141A                           503  ASRLWEA:
0000141A                           504          
0000141A                           505  
0000141A                           506          
0000141A  7000                     507          MOVEQ.L #0, D0 ;clear D0
0000141C                           508          
0000141C                           509  validASRL:
0000141C                           510          
0000141C  43F9 000014C6            511          LEA lsrlEAmasks,A1 ;load the list of masks
00001422  D3C0                     512          ADDA.L D0,A1 ;displace to a specific mask
00001424  1A11                     513          MOVE.B (A1),D5 ;move the mask to D5
00001426                           514          
00001426  0C05 0000                515          CMPI.B #0,D5 ;check if the mask is 0
0000142A  6700 FC66                516          BEQ falsePositive ;branch if it is
0000142E                           517          
0000142E  1401                     518          MOVE.B D1,D2 ;copy instruction to D2
00001430  C405                     519          AND.B D5,D2  ;mask D2
00001432                           520          
00001432  43F9 000014C0            521          LEA lsrlEA,A1 ;load the list of valid modes
00001438  D3C0                     522          ADDA.L D0,A1 ;displace to a specific mode
0000143A  1811                     523          MOVE.B (A1),D4 ;move mode to D4
0000143C  B404                     524          CMP.B D4,D2 ;compare mode to masked value
0000143E  6700 0006                525          BEQ  asrlweaCheckDirection ;if its match, its a valid mode and we can procede
00001442                           526          
00001442  5280                     527          ADDQ.L #1,D0 ;add one to displacement
00001444  60D6                     528          BRA validASRL ;check for next mode
00001446                           529  
00001446                           530  asrlweaCheckDirection:
00001446                           531          ;Figure out which direction we are going
00001446  3401                     532          MOVE.W D1,D2 ;copy inst to D2
00001448  E04A                     533          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
0000144A  0202 0001                534          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
0000144E  0C02 0000                535          CMPI.B #0,D2 ;compare bit to zero
00001452  6700 0006                536          BEQ ASREA ;if zero, right
00001456  6000 0012                537          BRA ASLEA ;else, its left
0000145A                           538  
0000145A                           539  ASREA:
0000145A                           540  
0000145A  43F9 000024A7            541          LEA     asrMessage,A1  ;move string for MOVE
00001460  103C 000E                542          MOVE.B  #14,D0        ;set for task to display null terminated 
00001464                           543                                ;string with CR, LF
00001464  4E4F                     544          TRAP    #15
00001466  6000 00C0                545          BRA lsrlweaBody
0000146A                           546          
0000146A                           547  ASLEA:
0000146A                           548          
0000146A  43F9 000024A2            549          LEA     aslMessage,A1  ;move string for MOVE
00001470  103C 000E                550          MOVE.B  #14,D0        ;set for task to display null terminated 
00001474                           551                                ;string with CR, LF
00001474  4E4F                     552          TRAP    #15
00001476  6000 00B0                553          BRA lsrlweaBody        
0000147A                           554          
0000147A                           555  
0000147A                           556  
0000147A                           557  ASRLREG:
0000147A                           558          
0000147A                           559  
0000147A                           560          
0000147A  7000                     561          MOVEQ.L #0, D0 ;clear D0
0000147C                           562          
0000147C                           563          ;check valid size field
0000147C  3401                     564          MOVE.W D1,D2 ;copy inst to D2
0000147E  EC4A                     565          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
00001480  0202 0003                566          ANDI.B #%00000011,D2 ;mask out rest of byte
00001484  0C02 0003                567          CMPI.B #%11,D2 ;compare to 3
00001488  6700 FC08                568          BEQ falsePositive ;invalid size
0000148C                           569  
0000148C                           570          
0000148C                           571          ;Figure out which direction we are going
0000148C  3401                     572          MOVE.W D1,D2 ;copy inst to D2
0000148E  E04A                     573          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
00001490  0202 0001                574          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
00001494  0C02 0000                575          CMPI.B #0,D2 ;compare bit to zero
00001498  6700 0006                576          BEQ ASRreg ;if zero, right
0000149C  6000 0012                577          BRA ASLreg ;else, its left        
000014A0                           578          
000014A0                           579  ASRreg:
000014A0                           580  
000014A0  43F9 000024A7            581          LEA     asrMessage,A1  ;move string for MOVE
000014A6  103C 000E                582          MOVE.B  #14,D0        ;set for task to display null terminated 
000014AA                           583                                ;string with CR, LF
000014AA  4E4F                     584          TRAP    #15
000014AC  6000 00E4                585          BRA LSRLregBody
000014B0                           586          
000014B0                           587  ASLreg:
000014B0                           588          
000014B0  43F9 000024A2            589          LEA     aslMessage,A1  ;move string for MOVE
000014B6  103C 000E                590          MOVE.B  #14,D0        ;set for task to display null terminated 
000014BA                           591                                ;string with CR, LF
000014BA  4E4F                     592          TRAP    #15
000014BC  6000 00D4                593          BRA LSRLregBody
000014C0                           594  
000014C0                           595  
000014C0= 10 18 20 38 39 00        596  lsrlEA        DC.B %010000,%011000,%100000,%111000,%111001,0
000014C6= 38 38 38 3F 3F 00        597  lsrlEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0       
000014CC                           598  
000014CC                           599  LSRLWEA:
000014CC                           600          
000014CC                           601  
000014CC                           602          
000014CC  7000                     603          MOVEQ.L #0, D0 ;clear D0
000014CE                           604          
000014CE                           605  validLSRL:
000014CE                           606          
000014CE  43F8 14C6                607          LEA lsrlEAmasks,A1 ;load the list of masks
000014D2  D3C0                     608          ADDA.L D0,A1 ;displace to a specific mask
000014D4  1A11                     609          MOVE.B (A1),D5 ;move the mask to D5
000014D6                           610          
000014D6  0C05 0000                611          CMPI.B #0,D5 ;check if the mask is 0
000014DA  6700 FBB6                612          BEQ falsePositive ;branch if it is
000014DE                           613          
000014DE  1401                     614          MOVE.B D1,D2 ;copy instruction to D2
000014E0  C405                     615          AND.B D5,D2  ;mask D2
000014E2                           616          
000014E2  43F8 14C0                617          LEA lsrlEA,A1 ;load the list of valid modes
000014E6  D3C0                     618          ADDA.L D0,A1 ;displace to a specific mode
000014E8  1811                     619          MOVE.B (A1),D4 ;move mode to D4
000014EA  B404                     620          CMP.B D4,D2 ;compare mode to masked value
000014EC  6700 0006                621          BEQ  lsrlweaCheckDirection ;if its match, its a valid mode and we can procede
000014F0                           622          
000014F0  5280                     623          ADDQ.L #1,D0 ;add one to displacement
000014F2  60DA                     624          BRA validLSRL ;check for next mode
000014F4                           625  
000014F4                           626  lsrlweaCheckDirection:
000014F4                           627          ;Figure out which direction we are going
000014F4  3401                     628          MOVE.W D1,D2 ;copy inst to D2
000014F6  E04A                     629          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000014F8  0202 0001                630          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000014FC  0C02 0000                631          CMPI.B #0,D2 ;compare bit to zero
00001500  6700 0006                632          BEQ LSREA ;if zero, right
00001504  6000 0012                633          BRA LSLEA ;else, its left
00001508                           634  
00001508                           635  LSREA:
00001508                           636  
00001508  43F9 000024B1            637          LEA     lsrMessage,A1  ;move string for MOVE
0000150E  103C 000E                638          MOVE.B  #14,D0        ;set for task to display null terminated 
00001512                           639                                ;string with CR, LF
00001512  4E4F                     640          TRAP    #15
00001514  6000 0012                641          BRA lsrlweaBody
00001518                           642          
00001518                           643  LSLEA:
00001518                           644          
00001518  43F9 000024AC            645          LEA     lslMessage,A1  ;move string for MOVE
0000151E  103C 000E                646          MOVE.B  #14,D0        ;set for task to display null terminated 
00001522                           647                                ;string with CR, LF
00001522  4E4F                     648          TRAP    #15
00001524  6000 0002                649          BRA lsrlweaBody        
00001528                           650          
00001528                           651  lsrlweaBody:
00001528                           652  
00001528                           653          
00001528  3401                     654          MOVE.W  D1,D2 ;check mode
0000152A  C43C 003F                655          AND.B   #%00111111,D2
0000152E  1A02                     656          MOVE.B  D2,D5
00001530  48E7 4000                657          MOVEM.L D1,-(SP)
00001534  6100 0B40                658          BSR     Get_Effective_Address
00001538  4CDF 0002                659          MOVEM.L (SP)+,D1
0000153C                           660          
0000153C                           661          
0000153C  43F9 00002484            662          LEA     clearLine,A1  ;move string for a CR and LF
00001542  103C 000E                663          MOVE.B  #14,D0        ;set for task to display null terminated 
00001546                           664                                ;string without CR, LF
00001546  4E4F                     665          TRAP    #15
00001548                           666  
00001548  7000                     667          MOVEQ.L #0,D0
0000154A  4E75                     668          RTS
0000154C                           669  
0000154C                           670  
0000154C                           671  LSRLREG:
0000154C                           672          
0000154C                           673  
0000154C                           674          
0000154C  7000                     675          MOVEQ.L #0, D0 ;clear D0
0000154E                           676          
0000154E                           677          ;check valid size field
0000154E  3401                     678          MOVE.W D1,D2 ;copy inst to D2
00001550  EC4A                     679          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
00001552  0202 0003                680          ANDI.B #%00000011,D2 ;mask out rest of byte
00001556  0C02 0003                681          CMPI.B #%11,D2 ;compare to 3
0000155A  6700 FB36                682          BEQ falsePositive ;invalid size
0000155E                           683  
0000155E                           684          
0000155E                           685          ;Figure out which direction we are going
0000155E  3401                     686          MOVE.W D1,D2 ;copy inst to D2
00001560  E04A                     687          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
00001562  0202 0001                688          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
00001566  0C02 0000                689          CMPI.B #0,D2 ;compare bit to zero
0000156A  6700 0006                690          BEQ LSRreg ;if zero, right
0000156E  6000 0012                691          BRA LSLreg ;else, its left        
00001572                           692          
00001572                           693  LSRreg:
00001572                           694  
00001572  43F9 000024B1            695          LEA     lsrMessage,A1  ;move string for MOVE
00001578  103C 000E                696          MOVE.B  #14,D0        ;set for task to display null terminated 
0000157C                           697                                ;string with CR, LF
0000157C  4E4F                     698          TRAP    #15
0000157E  6000 0012                699          BRA LSRLregBody
00001582                           700          
00001582                           701  LSLreg:
00001582                           702          
00001582  43F9 000024AC            703          LEA     lslMessage,A1  ;move string for MOVE
00001588  103C 000E                704          MOVE.B  #14,D0        ;set for task to display null terminated 
0000158C                           705                                ;string with CR, LF
0000158C  4E4F                     706          TRAP    #15
0000158E  6000 0002                707          BRA LSRLregBody
00001592                           708          
00001592                           709  LSRLregBody:
00001592                           710                      
00001592                           711          ;check i/r
00001592  48E7 4000                712          MOVEM.L D1,-(SP)
00001596  6100 003C                713          BSR LSRLcheckIR
0000159A  4CDF 0002                714          MOVEM.L (SP)+,D1
0000159E                           715          
0000159E                           716          ;print ','
0000159E  48E7 4000                717          MOVEM.L D1,-(SP) ;save D1 to the stack
000015A2  123C 002C                718          MOVE.B #',',D1 ;put ascii value of char in D1
000015A6  103C 0006                719          MOVE.B #6,D0 ;move task 6 into D0
000015AA  4E4F                     720          TRAP #15 ;prin char
000015AC  4CDF 0002                721          MOVEM.L (SP)+,D1 ;pull D1 off the stack
000015B0                           722          
000015B0  3401                     723          MOVE.W  D1,D2 ;check mode
000015B2  C43C 0007                724          AND.B   #%00000111,D2
000015B6  1A02                     725          MOVE.B  D2,D5
000015B8  48E7 4000                726          MOVEM.L D1,-(SP)
000015BC  6100 0AB8                727          BSR     Get_Effective_Address
000015C0  4CDF 0002                728          MOVEM.L (SP)+,D1
000015C4                           729          
000015C4                           730          
000015C4  43F9 00002484            731          LEA     clearLine,A1  ;move string for a CR and LF
000015CA  103C 000E                732          MOVE.B  #14,D0        ;set for task to display null terminated 
000015CE                           733                                ;string without CR, LF
000015CE  4E4F                     734          TRAP    #15
000015D0                           735  
000015D0  7000                     736          MOVEQ.L #0,D0
000015D2  4E75                     737          RTS
000015D4                           738  
000015D4                           739  LSRLcheckIR:
000015D4                           740  
000015D4  1401                     741          MOVE.B D1,D2 ;move inst to D2
000015D6  EA0A                     742          LSR.B  #5,D2
000015D8  C43C 0001                743          AND.B  #%00000001,D2
000015DC  0C02 0000                744          CMPI.B #0,D2
000015E0  6700 0008                745          BEQ  LSRLcheckI
000015E4  6000 0038                746          BRA  LSRLcheckR
000015E8                           747  LSRLcheckIRreturn:
000015E8  4E75                     748          RTS
000015EA                           749          
000015EA                           750  LSRLcheckI:
000015EA                           751          ;print '#'
000015EA  48E7 4000                752          MOVEM.L D1,-(SP) ;save D1 to the stack
000015EE  123C 0023                753          MOVE.B #'#',D1 ;put ascii value of '#' in D1
000015F2  103C 0006                754          MOVE.B #6,D0 ;move task 6 into D0
000015F6  4E4F                     755          TRAP #15 ;prin char
000015F8  4CDF 0002                756          MOVEM.L (SP)+,D1 ;pull D1 off the stack
000015FC                           757          
000015FC                           758          
000015FC                           759          ;print number
000015FC  48E7 4000                760          MOVEM.L D1,-(SP)
00001600  3401                     761          MOVE.W D1,D2 ;copy inst to d2
00001602  E04A                     762          LSR.W #8,D2 ;shift data section
00001604  E20A                     763          LSR.B #1,D2
00001606  C43C 0007                764          AND.B #%00000111,D2 ;mask out rest of data
0000160A  6100 00D6                765          BSR ZeroToEight ;handle zero
0000160E  7200                     766          MOVEQ.L #0,D1 ;clear D1
00001610  1202                     767          MOVE.B D2,D1 ;move number to display into D1
00001612  103C 0003                768          MOVE.B #3,D0 ;move task 3 to D0
00001616  4E4F                     769          TRAP #15
00001618  4CDF 0002                770          MOVEM.L (SP)+,D1
0000161C  60CA                     771          BRA LSRLcheckIRreturn
0000161E                           772          
0000161E                           773  LSRLcheckR:
0000161E  3401                     774          MOVE.W D1,D2 ;copy inst to d2
00001620  E04A                     775          LSR.W #8,D2 ;shift data section
00001622  E20A                     776          LSR.B #1,D2
00001624  C43C 0007                777          AND.B #%00000111,D2 ;mask out rest of data
00001628  1A02                     778          MOVE.B D2,D5 ;force Dn
0000162A  48E7 4000                779          MOVEM.L D1,-(SP)
0000162E  6100 0A46                780          BSR     Get_Effective_Address
00001632  4CDF 0002                781          MOVEM.L (SP)+,D1
00001636  60B0                     782          BRA LSRLcheckIRreturn
00001638                           783          
00001638= 00 08 10 18 20 38 ...    784  subqEA        DC.B %000000,%001000,%010000,%011000,%100000,%111000,%111001,0
00001640= 38 38 38 38 38 3F ...    785  subqEAmasks   DC.B %111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001648                           786  
00001648                           787  SUBQ:
00001648                           788          
00001648                           789  
00001648                           790          
00001648  7000                     791          MOVEQ.L #0, D0 ;clear D0
0000164A                           792          
0000164A                           793          ;check valid size field
0000164A  3401                     794          MOVE.W D1,D2 ;copy inst to D2
0000164C  EC4A                     795          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
0000164E  0202 0003                796          ANDI.B #%00000011,D2 ;mask out rest of byte
00001652  0C02 0003                797          CMPI.B #%11,D2 ;compare to 3
00001656  6700 FA3A                798          BEQ falsePositive ;invalid size
0000165A                           799          
0000165A                           800  validSubq:
0000165A                           801          
0000165A  43F8 1640                802          LEA subqEAmasks,A1 ;load the list of masks
0000165E  D3C0                     803          ADDA.L D0,A1 ;displace to a specific mask
00001660  1A11                     804          MOVE.B (A1),D5 ;move the mask to D5
00001662                           805          
00001662  0C05 0000                806          CMPI.B #0,D5 ;check if the mask is 0
00001666  6700 FA2A                807          BEQ falsePositive ;branch if it is
0000166A                           808          
0000166A  1401                     809          MOVE.B D1,D2 ;copy instruction to D2
0000166C  C405                     810          AND.B D5,D2  ;mask D2
0000166E                           811          
0000166E  43F8 1638                812          LEA subqEA,A1 ;load the list of valid modes
00001672  D3C0                     813          ADDA.L D0,A1 ;displace to a specific mode
00001674  1811                     814          MOVE.B (A1),D4 ;move mode to D4
00001676  B404                     815          CMP.B D4,D2 ;compare mode to masked value
00001678  6700 0006                816          BEQ  subqBody ;if its match, its a valid mode and we can procede
0000167C                           817          
0000167C  5280                     818          ADDQ.L #1,D0 ;add one to displacement
0000167E  60DA                     819          BRA validSubq ;check for next mode
00001680                           820          
00001680                           821          
00001680                           822  subqBody
00001680                           823  
00001680  43F9 000024B6            824          LEA     subqMessage,A1  ;move string for MOVE
00001686  103C 000E                825          MOVE.B  #14,D0        ;set for task to display null terminated 
0000168A                           826                                ;string with CR, LF
0000168A  4E4F                     827          TRAP    #15
0000168C                           828          
0000168C                           829          ;immediate data
0000168C                           830          
0000168C                           831          ;print '#'
0000168C  48E7 4000                832          MOVEM.L D1,-(SP) ;save D1 to the stack
00001690  123C 0023                833          MOVE.B #'#',D1 ;put ascii value of '#' in D1
00001694  103C 0006                834          MOVE.B #6,D0 ;move task 6 into D0
00001698  4E4F                     835          TRAP #15 ;prin char
0000169A  4CDF 0002                836          MOVEM.L (SP)+,D1 ;pull D1 off the stack
0000169E                           837          
0000169E                           838          ;print number
0000169E  48E7 4000                839          MOVEM.L D1,-(SP)
000016A2  3401                     840          MOVE.W D1,D2 ;copy inst to d2
000016A4  E04A                     841          LSR.W #8,D2 ;shift data section
000016A6  E20A                     842          LSR.B #1,D2
000016A8  C43C 0007                843          AND.B #%00000111,D2 ;mask out rest of data
000016AC  6100 0034                844          BSR ZeroToEight ;handle zero
000016B0  7200                     845          MOVEQ.L #0,D1 ;clear D1
000016B2  1202                     846          MOVE.B D2,D1 ;move number to display into D1
000016B4  103C 0003                847          MOVE.B #3,D0 ;move task 3 to D0
000016B8  4E4F                     848          TRAP #15
000016BA  4CDF 0002                849          MOVEM.L (SP)+,D1
000016BE                           850          
000016BE                           851          ;print separator
000016BE                           852          
000016BE                           853          ;Then do EA
000016BE                           854          
000016BE  3401                     855          MOVE.W  D1,D2 ;check mode
000016C0  C43C 003F                856          AND.B   #%00111111,D2
000016C4  1A02                     857          MOVE.B  D2,D5
000016C6  48E7 4000                858          MOVEM.L D1,-(SP)
000016CA  6100 09AA                859          BSR     Get_Effective_Address
000016CE  4CDF 0002                860          MOVEM.L (SP)+,D1
000016D2                           861          
000016D2  43F9 00002484            862          LEA     clearLine,A1  ;move string for a CR and LF
000016D8  103C 000E                863          MOVE.B  #14,D0        ;set for task to display null terminated 
000016DC                           864                                ;string without CR, LF
000016DC  4E4F                     865          TRAP    #15
000016DE                           866  
000016DE  7000                     867          MOVEQ.L #0,D0
000016E0  4E75                     868          RTS
000016E2                           869          
000016E2                           870  ZeroToEight:
000016E2                           871          
000016E2  0C02 0000                872          CMPI.B #0,D2
000016E6  6700 0004                873          BEQ toEight
000016EA                           874  ZeroToEightReturn:
000016EA                           875          
000016EA  4E75                     876          RTS
000016EC                           877  toEight:
000016EC                           878          
000016EC  5002                     879          ADDQ.B #8,D2
000016EE  60FA                     880          BRA ZeroToEightReturn
000016F0                           881  
000016F0                           882      
000016F0                           883  SUB:
000016F0                           884          
000016F0                           885  
000016F0                           886          
000016F0  7000                     887          MOVEQ.L #0, D0 ;clear D0
000016F2                           888          
000016F2                           889          ;Figure out if EA is source or destination
000016F2  3401                     890          MOVE.W D1,D2 ;copy inst to D2
000016F4  EC4A                     891          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
000016F6  0202 0007                892          ANDI.B #%00000111,D2 ;mask out rest of byte
000016FA  0C02 0002                893          CMPI.B #2,D2 ;compare to 2
000016FE  6F00 0016                894          BLE validSubSourceEA ;2 or less is EA is source
00001702                           895          
00001702  0C02 0007                896          CMPI.B #%111,D2 ;compare to 7
00001706  6700 F98A                897          BEQ falsePositive ;thats not valid
0000170A  0C02 0003                898          CMPI.B #%11,D2 ;compare to 3
0000170E  6700 F982                899          BEQ falsePositive ;also not valid
00001712  6000 002C                900          BRA validSubDestEA ;all thats left is valid EA as Dest 
00001716                           901          
00001716                           902  validSubSourceEA:
00001716                           903          
00001716  43F9 00001CD1            904          LEA moveSourceEAmasks,A1 ;load the list of masks
0000171C  D3C0                     905          ADDA.L D0,A1 ;displace to a specific mask
0000171E  1A11                     906          MOVE.B (A1),D5 ;move the mask to D5
00001720                           907          
00001720  0C05 0000                908          CMPI.B #0,D5 ;check if the mask is 0
00001724  6700 F96C                909          BEQ falsePositive ;branch if it is
00001728                           910          
00001728  1401                     911          MOVE.B D1,D2 ;copy instruction to D2
0000172A  C405                     912          AND.B D5,D2  ;mask D2
0000172C                           913          
0000172C  43F9 00001CC8            914          LEA moveSourceEA,A1 ;load the list of valid modes
00001732  D3C0                     915          ADDA.L D0,A1 ;displace to a specific mode
00001734  1811                     916          MOVE.B (A1),D4 ;move mode to D4
00001736  B404                     917          CMP.B D4,D2 ;compare mode to masked value
00001738  6700 0036                918          BEQ  subSource ;if its match, its a valid mode and we can procede
0000173C                           919          
0000173C  5280                     920          ADDQ.L #1,D0 ;add one to displacement
0000173E  60D6                     921          BRA validSubSourceEA ;check for next mode
00001740                           922          
00001740                           923          
00001740                           924  validSubDestEA:
00001740                           925          
00001740  43F9 00001898            926          LEA addDestEAmasks,A1 ;load the list of masks
00001746  D3C0                     927          ADDA.L D0,A1 ;displace to a specific mask
00001748  1A11                     928          MOVE.B (A1),D5 ;move the mask to D5
0000174A                           929          
0000174A  0C05 0000                930          CMPI.B #0,D5 ;check if the mask is 0
0000174E  6700 F942                931          BEQ falsePositive ;branch if it is
00001752                           932          
00001752  3401                     933          MOVE.W D1,D2 ;copy instruction to D2
00001754  EC4A                     934          LSR.W #6,D2  ;move mode
00001756  6100 0B50                935          BSR switchModeAndReg ;switch register and mode
0000175A  C405                     936          AND.B D5,D2  ;mask D2
0000175C                           937          
0000175C  43F9 00001892            938          LEA addDestEA,A1 ;load the list of valid modes
00001762  D3C0                     939          ADDA.L D0,A1 ;displace to a specific mode
00001764  1811                     940          MOVE.B (A1),D4 ;move mode to D4
00001766  B404                     941          CMP.B D4,D2 ;compare mode to masked value
00001768  6700 004E                942          BEQ subDest ;if its match, its a valid mode and we can procede
0000176C                           943          
0000176C  5280                     944          ADDQ.L #1,D0 ;add one to displacement
0000176E  60D0                     945          BRA validSubDestEA ;check for next mode
00001770                           946          
00001770                           947  subSource
00001770                           948  
00001770  43F9 000024BC            949          LEA     subMessage,A1  ;move string for MOVE
00001776  103C 000E                950          MOVE.B  #14,D0        ;set for task to display null terminated 
0000177A                           951                                ;string with CR, LF
0000177A  4E4F                     952          TRAP    #15
0000177C                           953          
0000177C                           954          ;do EA
0000177C                           955          
0000177C  3401                     956          MOVE.W  D1,D2 ;check mode
0000177E  C43C 003F                957          AND.B   #%00111111,D2
00001782  1A02                     958          MOVE.B  D2,D5
00001784  48E7 4000                959          MOVEM.L D1,-(SP)
00001788  6100 08EC                960          BSR     Get_Effective_Address
0000178C  4CDF 0002                961          MOVEM.L (SP)+,D1
00001790                           962          
00001790                           963          ;print separator
00001790                           964          
00001790                           965          ;Then do Dn
00001790                           966          
00001790  3401                     967          MOVE.W  D1,D2
00001792  E04A                     968          LSR.W   #8,D2 ;move reg into first byte
00001794  E20A                     969          LSR.B   #1,D2 ;line it up to least sig bit
00001796  C43C 0007                970          AND.B   #%00000111,D2 ;force mode to Dn
0000179A  1A02                     971          MOVE.B  D2,D5
0000179C  48E7 4000                972          MOVEM.L D1,-(SP)
000017A0  6100 08D4                973          BSR     Get_Effective_Address
000017A4  4CDF 0002                974          MOVEM.L (SP)+,D1
000017A8                           975          
000017A8  43F9 00002484            976          LEA     clearLine,A1  ;move string for a CR and LF
000017AE  103C 000E                977          MOVE.B  #14,D0        ;set for task to display null terminated 
000017B2                           978                                ;string without CR, LF
000017B2  4E4F                     979          TRAP    #15
000017B4                           980  
000017B4  7000                     981          MOVEQ.L #0,D0
000017B6  4E75                     982          RTS
000017B8                           983  
000017B8                           984  subDest
000017B8                           985  
000017B8  43F9 000024BC            986          LEA     subMessage,A1  ;move string for MOVE
000017BE  103C 000E                987          MOVE.B  #14,D0        ;set for task to display null terminated 
000017C2                           988                                ;string with CR, LF
000017C2  4E4F                     989          TRAP    #15
000017C4                           990          
000017C4                           991          ;Do Dn
000017C4                           992          
000017C4  3401                     993          MOVE.W  D1,D2
000017C6  E04A                     994          LSR.W   #8,D2 ;move reg into first byte
000017C8  E20A                     995          LSR.B   #1,D2 ;line it up to least sig bit
000017CA  C43C 0007                996          AND.B   #%00000111,D2 ;force mode to Dn
000017CE  1A02                     997          MOVE.B  D2,D5
000017D0  48E7 4000                998          MOVEM.L D1,-(SP)
000017D4  6100 08A0                999          BSR     Get_Effective_Address
000017D8  4CDF 0002               1000          MOVEM.L (SP)+,D1
000017DC                          1001          
000017DC                          1002          
000017DC                          1003          ;print separator
000017DC                          1004          
000017DC                          1005          ;Then do EA
000017DC                          1006          
000017DC  3401                    1007          MOVE.W  D1,D2 ;check mode
000017DE  C43C 003F               1008          AND.B   #%00111111,D2
000017E2  1A02                    1009          MOVE.B  D2,D5
000017E4  48E7 4000               1010          MOVEM.L D1,-(SP)
000017E8  6100 088C               1011          BSR     Get_Effective_Address
000017EC  4CDF 0002               1012          MOVEM.L (SP)+,D1
000017F0                          1013          
000017F0                          1014          
000017F0  43F9 00002484           1015          LEA     clearLine,A1  ;move string for a CR and LF
000017F6  103C 000E               1016          MOVE.B  #14,D0        ;set for task to display null terminated 
000017FA                          1017                                ;string without CR, LF
000017FA  4E4F                    1018          TRAP    #15
000017FC                          1019  
000017FC  7000                    1020          MOVEQ.L #0,D0
000017FE  4E75                    1021          RTS
00001800                          1022  
00001800                          1023  
00001800                          1024  ADDA:
00001800                          1025          
00001800                          1026  
00001800                          1027          
00001800  7000                    1028          MOVEQ.L #0, D0 ;clear D0
00001802                          1029          
00001802                          1030          ;check opmode field
00001802  3401                    1031          MOVE.W D1,D2 ;copy inst to D2
00001804  EC4A                    1032          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
00001806  0202 0007               1033          ANDI.B #%00000111,D2 ;mask out rest of byte
0000180A  0C02 0007               1034          CMPI.B #%111,D2 ;compare to 7
0000180E  6700 000E               1035          BEQ validAdda ;thats valid
00001812  0C02 0003               1036          CMPI.B #%11,D2 ;compare to 3
00001816  6700 0006               1037          BEQ validAdda ;also valid
0000181A  6000 F876               1038          BRA falsePositive ;all thats left is invalid 
0000181E                          1039          
0000181E                          1040  validAdda:
0000181E                          1041          
0000181E  43F9 00001CD1           1042          LEA moveSourceEAmasks,A1 ;load the list of masks
00001824  D3C0                    1043          ADDA.L D0,A1 ;displace to a specific mask
00001826  1A11                    1044          MOVE.B (A1),D5 ;move the mask to D5
00001828                          1045          
00001828  0C05 0000               1046          CMPI.B #0,D5 ;check if the mask is 0
0000182C  6700 F864               1047          BEQ falsePositive ;branch if it is
00001830                          1048          
00001830  1401                    1049          MOVE.B D1,D2 ;copy instruction to D2
00001832  C405                    1050          AND.B D5,D2  ;mask D2
00001834                          1051          
00001834  43F9 00001CC8           1052          LEA moveSourceEA,A1 ;load the list of valid modes
0000183A  D3C0                    1053          ADDA.L D0,A1 ;displace to a specific mode
0000183C  1811                    1054          MOVE.B (A1),D4 ;move mode to D4
0000183E  B404                    1055          CMP.B D4,D2 ;compare mode to masked value
00001840  6700 0006               1056          BEQ  addaBody ;if its match, its a valid mode and we can procede
00001844                          1057          
00001844  5280                    1058          ADDQ.L #1,D0 ;add one to displacement
00001846  60D6                    1059          BRA validAdda ;check for next mode
00001848                          1060          
00001848                          1061          
00001848                          1062  addaBody
00001848                          1063  
00001848  43F9 000024C1           1064          LEA     addaMessage,A1  ;move string for MOVE
0000184E  103C 000E               1065          MOVE.B  #14,D0        ;set for task to display null terminated 
00001852                          1066                                ;string with CR, LF
00001852  4E4F                    1067          TRAP    #15
00001854                          1068          
00001854                          1069          ;do EA
00001854                          1070          
00001854  3401                    1071          MOVE.W  D1,D2 ;check mode
00001856  C43C 003F               1072          AND.B   #%00111111,D2
0000185A  1A02                    1073          MOVE.B  D2,D5
0000185C  48E7 4000               1074          MOVEM.L D1,-(SP)
00001860  6100 0814               1075          BSR     Get_Effective_Address
00001864  4CDF 0002               1076          MOVEM.L (SP)+,D1
00001868                          1077          
00001868                          1078          ;print separator
00001868                          1079          
00001868                          1080          ;Then do Dn
00001868                          1081          
00001868  3401                    1082          MOVE.W  D1,D2
0000186A  E04A                    1083          LSR.W   #8,D2 ;move reg into first byte
0000186C  E20A                    1084          LSR.B   #1,D2 ;line it up to least sig bit
0000186E  C43C 0007               1085          AND.B   #%00000111,D2 ;force mode to An
00001872  5002                    1086          ADDI.B  #%00001000,D2 
00001874  1A02                    1087          MOVE.B  D2,D5
00001876  48E7 4000               1088          MOVEM.L D1,-(SP)
0000187A  6100 07FA               1089          BSR     Get_Effective_Address
0000187E  4CDF 0002               1090          MOVEM.L (SP)+,D1
00001882                          1091          
00001882  43F9 00002484           1092          LEA     clearLine,A1  ;move string for a CR and LF
00001888  103C 000E               1093          MOVE.B  #14,D0        ;set for task to display null terminated 
0000188C                          1094                                ;string without CR, LF
0000188C  4E4F                    1095          TRAP    #15
0000188E                          1096  
0000188E  7000                    1097          MOVEQ.L #0,D0
00001890  4E75                    1098          RTS
00001892                          1099  
00001892                          1100  
00001892                          1101      
00001892= 10 18 20 38 39 00       1102  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
00001898= 38 38 38 3F 3F 00       1103  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
0000189E                          1104  
0000189E                          1105  ADD:
0000189E                          1106          
0000189E                          1107  
0000189E                          1108          
0000189E  7000                    1109          MOVEQ.L #0, D0 ;clear D0
000018A0                          1110          
000018A0                          1111          ;Figure out if EA is source or destination
000018A0  3401                    1112          MOVE.W D1,D2 ;copy inst to D2
000018A2  EC4A                    1113          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
000018A4  0202 0007               1114          ANDI.B #%00000111,D2 ;mask out rest of byte
000018A8  0C02 0002               1115          CMPI.B #2,D2 ;compare to 2
000018AC  6F00 0016               1116          BLE validAddSourceEA ;2 or less is EA is source
000018B0                          1117          
000018B0  0C02 0007               1118          CMPI.B #%111,D2 ;compare to 7
000018B4  6700 F7DC               1119          BEQ falsePositive ;thats not valid
000018B8  0C02 0003               1120          CMPI.B #%11,D2 ;compare to 3
000018BC  6700 F7D4               1121          BEQ falsePositive ;also not valid
000018C0  6000 002C               1122          BRA validAddDestEA ;all thats left is valid EA as Dest 
000018C4                          1123          
000018C4                          1124  validAddSourceEA:
000018C4                          1125          
000018C4  43F9 00001CD1           1126          LEA moveSourceEAmasks,A1 ;load the list of masks
000018CA  D3C0                    1127          ADDA.L D0,A1 ;displace to a specific mask
000018CC  1A11                    1128          MOVE.B (A1),D5 ;move the mask to D5
000018CE                          1129          
000018CE  0C05 0000               1130          CMPI.B #0,D5 ;check if the mask is 0
000018D2  6700 F7BE               1131          BEQ falsePositive ;branch if it is
000018D6                          1132          
000018D6  1401                    1133          MOVE.B D1,D2 ;copy instruction to D2
000018D8  C405                    1134          AND.B D5,D2  ;mask D2
000018DA                          1135          
000018DA  43F9 00001CC8           1136          LEA moveSourceEA,A1 ;load the list of valid modes
000018E0  D3C0                    1137          ADDA.L D0,A1 ;displace to a specific mode
000018E2  1811                    1138          MOVE.B (A1),D4 ;move mode to D4
000018E4  B404                    1139          CMP.B D4,D2 ;compare mode to masked value
000018E6  6700 0032               1140          BEQ  addSource ;if its match, its a valid mode and we can procede
000018EA                          1141          
000018EA  5280                    1142          ADDQ.L #1,D0 ;add one to displacement
000018EC  60D6                    1143          BRA validAddSourceEA ;check for next mode
000018EE                          1144          
000018EE                          1145          
000018EE                          1146  validAddDestEA:
000018EE                          1147          
000018EE  43F8 1898               1148          LEA addDestEAmasks,A1 ;load the list of masks
000018F2  D3C0                    1149          ADDA.L D0,A1 ;displace to a specific mask
000018F4  1A11                    1150          MOVE.B (A1),D5 ;move the mask to D5
000018F6                          1151          
000018F6  0C05 0000               1152          CMPI.B #0,D5 ;check if the mask is 0
000018FA  6700 F796               1153          BEQ falsePositive ;branch if it is
000018FE                          1154          
000018FE  3401                    1155          MOVE.W D1,D2 ;copy instruction to D2
00001900  EC4A                    1156          LSR.W #6,D2  ;move mode
00001902  6100 09A4               1157          BSR switchModeAndReg ;switch register and mode
00001906  C405                    1158          AND.B D5,D2  ;mask D2
00001908                          1159          
00001908  43F8 1892               1160          LEA addDestEA,A1 ;load the list of valid modes
0000190C  D3C0                    1161          ADDA.L D0,A1 ;displace to a specific mode
0000190E  1811                    1162          MOVE.B (A1),D4 ;move mode to D4
00001910  B404                    1163          CMP.B D4,D2 ;compare mode to masked value
00001912  6700 004E               1164          BEQ addDest ;if its match, its a valid mode and we can procede
00001916                          1165          
00001916  5280                    1166          ADDQ.L #1,D0 ;add one to displacement
00001918  60D4                    1167          BRA validAddDestEA ;check for next mode
0000191A                          1168          
0000191A                          1169  addSource
0000191A                          1170  
0000191A  43F9 000024C7           1171          LEA     addMessage,A1  ;move string for MOVE
00001920  103C 000E               1172          MOVE.B  #14,D0        ;set for task to display null terminated 
00001924                          1173                                ;string with CR, LF
00001924  4E4F                    1174          TRAP    #15
00001926                          1175          
00001926                          1176          ;do EA
00001926                          1177          
00001926  3401                    1178          MOVE.W  D1,D2 ;check mode
00001928  C43C 003F               1179          AND.B   #%00111111,D2
0000192C  1A02                    1180          MOVE.B  D2,D5
0000192E  48E7 4000               1181          MOVEM.L D1,-(SP)
00001932  6100 0742               1182          BSR     Get_Effective_Address
00001936  4CDF 0002               1183          MOVEM.L (SP)+,D1
0000193A                          1184          
0000193A                          1185          ;print separator
0000193A                          1186          
0000193A                          1187          ;Then do Dn
0000193A                          1188          
0000193A  3401                    1189          MOVE.W  D1,D2
0000193C  E04A                    1190          LSR.W   #8,D2 ;move reg into first byte
0000193E  E20A                    1191          LSR.B   #1,D2 ;line it up to least sig bit
00001940  C43C 0007               1192          AND.B   #%00000111,D2 ;force mode to Dn
00001944  1A02                    1193          MOVE.B  D2,D5
00001946  48E7 4000               1194          MOVEM.L D1,-(SP)
0000194A  6100 072A               1195          BSR     Get_Effective_Address
0000194E  4CDF 0002               1196          MOVEM.L (SP)+,D1
00001952                          1197          
00001952  43F9 00002484           1198          LEA     clearLine,A1  ;move string for a CR and LF
00001958  103C 000E               1199          MOVE.B  #14,D0        ;set for task to display null terminated 
0000195C                          1200                                ;string without CR, LF
0000195C  4E4F                    1201          TRAP    #15
0000195E                          1202  
0000195E  7000                    1203          MOVEQ.L #0,D0
00001960  4E75                    1204          RTS
00001962                          1205  
00001962                          1206  addDest
00001962                          1207  
00001962  43F9 000024C7           1208          LEA     addMessage,A1  ;move string for MOVE
00001968  103C 000E               1209          MOVE.B  #14,D0        ;set for task to display null terminated 
0000196C                          1210                                ;string with CR, LF
0000196C  4E4F                    1211          TRAP    #15
0000196E                          1212          
0000196E                          1213          ;Do Dn
0000196E                          1214          
0000196E  3401                    1215          MOVE.W  D1,D2
00001970  E04A                    1216          LSR.W   #8,D2 ;move reg into first byte
00001972  E20A                    1217          LSR.B   #1,D2 ;line it up to least sig bit
00001974  C43C 0007               1218          AND.B   #%00000111,D2 ;force mode to Dn
00001978  1A02                    1219          MOVE.B  D2,D5
0000197A  48E7 4000               1220          MOVEM.L D1,-(SP)
0000197E  6100 06F6               1221          BSR     Get_Effective_Address
00001982  4CDF 0002               1222          MOVEM.L (SP)+,D1
00001986                          1223          
00001986                          1224          
00001986                          1225          ;print separator
00001986                          1226          
00001986                          1227          ;Then do EA
00001986                          1228          
00001986  3401                    1229          MOVE.W  D1,D2 ;check mode
00001988  C43C 003F               1230          AND.B   #%00111111,D2
0000198C  1A02                    1231          MOVE.B  D2,D5
0000198E  48E7 4000               1232          MOVEM.L D1,-(SP)
00001992  6100 06E2               1233          BSR     Get_Effective_Address
00001996  4CDF 0002               1234          MOVEM.L (SP)+,D1
0000199A                          1235          
0000199A                          1236          
0000199A  43F9 00002484           1237          LEA     clearLine,A1  ;move string for a CR and LF
000019A0  103C 000E               1238          MOVE.B  #14,D0        ;set for task to display null terminated 
000019A4                          1239                                ;string without CR, LF
000019A4  4E4F                    1240          TRAP    #15
000019A6                          1241  
000019A6  7000                    1242          MOVEQ.L #0,D0
000019A8  4E75                    1243          RTS
000019AA                          1244  
000019AA                          1245  
000019AA= 10 20 38 39 00          1246  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
000019AF= 38 38 3F 3F 00          1247  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
000019B4                          1248  
000019B4= 10 18 38 39 00          1249  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
000019B9= 38 38 3F 3F 00          1250  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
000019BE                          1251  
000019BE                          1252  MOVEM:
000019BE                          1253          
000019BE                          1254  
000019BE                          1255          
000019BE  7000                    1256          MOVEQ.L #0, D0 ;clear D0
000019C0                          1257          
000019C0                          1258          ;Figure out which direction we are going
000019C0  3401                    1259          MOVE.W D1,D2 ;copy inst to D2
000019C2  E64A                    1260          LSR.W #3,D2 ;shift direction bit into most sig bit of first byte
000019C4  0202 0080               1261          ANDI.B #%10000000,D2 ;mask out everything but direction bit in first byte
000019C8  0C02 0000               1262          CMPI.B #0,D2 ;compare bit to zero
000019CC  6700 0006               1263          BEQ validRegToMem ;if zero, reg to mem
000019D0  6000 0028               1264          BRA validMemToReg ;else, its mem to reg
000019D4                          1265          
000019D4                          1266  validRegToMem:
000019D4                          1267          
000019D4  43F8 19AF               1268          LEA movemRegToMemEAmasks,A1 ;load the list of masks
000019D8  D3C0                    1269          ADDA.L D0,A1 ;displace to a specific mask
000019DA  1A11                    1270          MOVE.B (A1),D5 ;move the mask to D5
000019DC                          1271          
000019DC  0C05 0000               1272          CMPI.B #0,D5 ;check if the mask is 0
000019E0  6700 F6B0               1273          BEQ falsePositive ;branch if it is
000019E4                          1274          
000019E4  1401                    1275          MOVE.B D1,D2 ;copy instruction to D2
000019E6  C405                    1276          AND.B D5,D2  ;mask D2
000019E8                          1277          
000019E8  43F8 19AA               1278          LEA movemRegToMemEA,A1 ;load the list of valid modes
000019EC  D3C0                    1279          ADDA.L D0,A1 ;displace to a specific mode
000019EE  1811                    1280          MOVE.B (A1),D4 ;move mode to D4
000019F0  B404                    1281          CMP.B D4,D2 ;compare mode to masked value
000019F2  6700 0034               1282          BEQ  movemBody ;if its match, its a valid mode and we can procede
000019F6                          1283          
000019F6  5280                    1284          ADDQ.L #1,D0 ;add one to displacement
000019F8  60DA                    1285          BRA validRegToMem ;check for next mode
000019FA                          1286          
000019FA                          1287          
000019FA                          1288  validMemToReg:
000019FA                          1289          
000019FA  43F8 19B9               1290          LEA movemMemToRegEAmasks,A1 ;load the list of masks
000019FE  D3C0                    1291          ADDA.L D0,A1 ;displace to a specific mask
00001A00  1A11                    1292          MOVE.B (A1),D5 ;move the mask to D5
00001A02                          1293          
00001A02  0C05 0000               1294          CMPI.B #0,D5 ;check if the mask is 0
00001A06  6700 F68A               1295          BEQ falsePositive ;branch if it is
00001A0A                          1296          
00001A0A  3401                    1297          MOVE.W D1,D2 ;copy instruction to D2
00001A0C  EC4A                    1298          LSR.W #6,D2  ;move mode
00001A0E  6100 0898               1299          BSR switchModeAndReg ;switch register and mode
00001A12  C405                    1300          AND.B D5,D2  ;mask D2
00001A14                          1301          
00001A14  43F8 19B4               1302          LEA movemMemToRegEA,A1 ;load the list of valid modes
00001A18  D3C0                    1303          ADDA.L D0,A1 ;displace to a specific mode
00001A1A  1811                    1304          MOVE.B (A1),D4 ;move mode to D4
00001A1C  B404                    1305          CMP.B D4,D2 ;compare mode to masked value
00001A1E  6700 0008               1306          BEQ movemBody ;if its match, its a valid mode and we can procede
00001A22                          1307          
00001A22  5280                    1308          ADDQ.L #1,D0 ;add one to displacement
00001A24  6000 02EC               1309          BRA validMoveDestModes ;check for next mode
00001A28                          1310          
00001A28                          1311  movemBody
00001A28                          1312  
00001A28  43F9 000024CC           1313          LEA     movemMessage,A1  ;move string for MOVE
00001A2E  103C 000E               1314          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A32                          1315                                ;string with CR, LF
00001A32  4E4F                    1316          TRAP    #15
00001A34                          1317          
00001A34                          1318          ;show list
00001A34                          1319          
00001A34  5487                    1320          ADDQ.L #word,D7 ;read past the register list mask(word) following
00001A36                          1321                          ;the instruction
00001A36                          1322          
00001A36                          1323          ;print separator
00001A36                          1324          
00001A36  3401                    1325          MOVE.W  D1,D2 ;check mode
00001A38  C43C 003F               1326          AND.B   #%00111111,D2
00001A3C  1A02                    1327          MOVE.B  D2,D5
00001A3E  48E7 4000               1328          MOVEM.L D1,-(SP)
00001A42  6100 0632               1329          BSR     Get_Effective_Address
00001A46  4CDF 0002               1330          MOVEM.L (SP)+,D1
00001A4A                          1331          
00001A4A                          1332          
00001A4A  43F9 00002484           1333          LEA     clearLine,A1  ;move string for a CR and LF
00001A50  103C 000E               1334          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A54                          1335                                ;string without CR, LF
00001A54  4E4F                    1336          TRAP    #15
00001A56                          1337  
00001A56  7000                    1338          MOVEQ.L #0,D0
00001A58  4E75                    1339          RTS
00001A5A                          1340  
00001A5A                          1341  
00001A5A                          1342      
00001A5A= 00 10 18 20 28 38 ...   1343  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
00001A62= 38 38 38 38 38 3F ...   1344  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
00001A6A                          1345     
00001A6A                          1346  NEG:            
00001A6A                          1347       
00001A6A  7000                    1348          MOVEQ.L #0, D0 ;clear D0
00001A6C                          1349          
00001A6C                          1350  validNegModes:
00001A6C                          1351          
00001A6C  43F8 1A62               1352          LEA NegEAmasks,A1 ;load the list of masks
00001A70  D3C0                    1353          ADDA.L D0,A1 ;displace to a specific mask
00001A72  1A11                    1354          MOVE.B (A1),D5 ;move the mask to D5
00001A74                          1355          
00001A74  0C05 0000               1356          CMPI.B #0,D5 ;check if the mask is 0
00001A78  6700 F618               1357          BEQ falsePositive ;branch if it is
00001A7C                          1358          
00001A7C  1401                    1359          MOVE.B D1,D2 ;copy instruction to D2
00001A7E  C405                    1360          AND.B D5,D2  ;mask D2
00001A80  43F8 1A5A               1361          LEA NegEA,A1 ;load the list of valid modes
00001A84  D3C0                    1362          ADDA.L D0,A1 ;displace to a specific mode
00001A86  1811                    1363          MOVE.B (A1),D4 ;move mode to D4
00001A88  B404                    1364          CMP.B D4,D2 ;compare mode to masked value
00001A8A  6700 0006               1365          BEQ NegBody ;if its match, its a valid mode and we can procede
00001A8E                          1366          
00001A8E  5280                    1367          ADDQ.L #1,D0 ;add one to displacement
00001A90  60DA                    1368          BRA validNegModes ;check for next mode
00001A92                          1369          
00001A92                          1370  NegBody:
00001A92                          1371  
00001A92                          1372  
00001A92  3401                    1373          MOVE.W  D1,D2 ;copy inst to D2
00001A94  C47C 0600               1374          AND.W  #%0011000000000,D2 ;mask word for size
00001A98  0C42 0000               1375          CMPI.W #0,D2 ;0 is the only non valid size
00001A9C  6700 F5F4               1376          BEQ falsePositive ; zero is not valid
00001AA0                          1377  
00001AA0  43F9 000024FB           1378          LEA     negMessage,A1  ;move string for NEG info
00001AA6  103C 000E               1379          MOVE.B  #14,D0        ;set for task to display null terminated 
00001AAA                          1380                                ;string without CR, LF
00001AAA  4E4F                    1381          TRAP    #15
00001AAC                          1382          
00001AAC  3401                    1383          MOVE.W D1,D2
00001AAE  C47C 003F               1384          AND #%000000000111111,D2
00001AB2  1A02                    1385          MOVE.B D2,D5
00001AB4                          1386          
00001AB4  48E7 4000               1387          MOVEM.L D1,-(SP)
00001AB8  6100 05BC               1388          BSR     Get_Effective_Address
00001ABC  4CDF 0002               1389          MOVEM.L (SP)+,D1
00001AC0                          1390          
00001AC0                          1391                
00001AC0                          1392          
00001AC0                          1393  NEGdone:
00001AC0                          1394  
00001AC0  43F9 00002484           1395          LEA     clearLine,A1  ;move string for a CR and LF
00001AC6  103C 000E               1396          MOVE.B  #14,D0        ;set for task to display null terminated 
00001ACA                          1397                                ;string without CR, LF
00001ACA  4E4F                    1398          TRAP    #15
00001ACC  7000                    1399          MOVEQ.L #0,D0
00001ACE  4E75                    1400          RTS
00001AD0                          1401          
00001AD0                          1402   ADDI:            
00001AD0                          1403       
00001AD0  7000                    1404          MOVEQ.L #0, D0 ;clear D0
00001AD2                          1405          
00001AD2                          1406  validAddiModes:
00001AD2                          1407          
00001AD2                          1408          
00001AD2  43F9 00001BCB           1409          LEA cmpiEAmasks,A1 ;load the list of masks
00001AD8  D3C0                    1410          ADDA.L D0,A1 ;displace to a specific mask
00001ADA  1A11                    1411          MOVE.B (A1),D5 ;move the mask to D5
00001ADC                          1412          
00001ADC  0C05 0000               1413          CMPI.B #0,D5 ;check if the mask is 0
00001AE0  6700 F5B0               1414          BEQ falsePositive ;branch if it is
00001AE4                          1415          
00001AE4  1401                    1416          MOVE.B D1,D2 ;copy instruction to D2
00001AE6  C405                    1417          AND.B D5,D2  ;mask D2
00001AE8  43F9 00001BC4           1418          LEA cmpiEA,A1 ;load the list of valid modes
00001AEE  D3C0                    1419          ADDA.L D0,A1 ;displace to a specific mode
00001AF0  1811                    1420          MOVE.B (A1),D4 ;move mode to D4
00001AF2  B404                    1421          CMP.B D4,D2 ;compare mode to masked value
00001AF4  6700 0006               1422          BEQ addiBody ;if its match, its a valid mode and we can procede
00001AF8                          1423          
00001AF8  5280                    1424          ADDQ.L #1,D0 ;add one to displacement
00001AFA  60D6                    1425          BRA validAddiModes ;check for next mode
00001AFC                          1426          
00001AFC                          1427  addiBody:
00001AFC                          1428  
00001AFC                          1429  
00001AFC  3401                    1430          MOVE.W  D1,D2 ;copy inst to D2
00001AFE  C47C 00C0               1431          AND.W  #%0000000011000000,D2 ;mask word for size
00001B02  0C42 00C0               1432          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001B06  6700 F58A               1433          BEQ falsePositive
00001B0A                          1434  
00001B0A  43F9 000024D3           1435          LEA     addiMessage,A1  ;move string for NEG info
00001B10  103C 000E               1436          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B14                          1437                                ;string without CR, LF
00001B14  4E4F                    1438          TRAP    #15
00001B16                          1439          
00001B16                          1440          ;go to Effective_Address for immediate data
00001B16  143C 003C               1441          MOVE.B #%00111100,D2
00001B1A  48E7 4000               1442          MOVEM.L D1,-(SP)
00001B1E  6100 0556               1443          BSR     Get_Effective_Address
00001B22  4CDF 0002               1444          MOVEM.L (SP)+,D1
00001B26                          1445          
00001B26  3401                    1446          MOVE.W D1,D2 ;copy inst to D2
00001B28  C47C 003F               1447          AND #%000000000111111,D2 ;and out everything but modes and regs
00001B2C  1A02                    1448          MOVE.B D2,D5 ; copy to D5 for following BSR
00001B2E                          1449          
00001B2E  48E7 4000               1450          MOVEM.L D1,-(SP)
00001B32  6100 0542               1451          BSR     Get_Effective_Address
00001B36  4CDF 0002               1452          MOVEM.L (SP)+,D1
00001B3A                          1453          
00001B3A                          1454                
00001B3A                          1455          
00001B3A                          1456  addidone:
00001B3A                          1457  
00001B3A  43F9 00002484           1458          LEA     clearLine,A1  ;move string for a CR and LF
00001B40  103C 000E               1459          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B44                          1460                                ;string without CR, LF
00001B44  4E4F                    1461          TRAP    #15
00001B46  7000                    1462          MOVEQ.L #0,D0
00001B48  4E75                    1463          RTS
00001B4A                          1464    
00001B4A                          1465  ORI:            
00001B4A                          1466       
00001B4A  7000                    1467          MOVEQ.L #0, D0 ;clear D0
00001B4C                          1468          
00001B4C                          1469  validOriModes:
00001B4C                          1470          
00001B4C                          1471          
00001B4C  43F9 00001BCB           1472          LEA cmpiEAmasks,A1 ;load the list of masks
00001B52  D3C0                    1473          ADDA.L D0,A1 ;displace to a specific mask
00001B54  1A11                    1474          MOVE.B (A1),D5 ;move the mask to D5
00001B56                          1475          
00001B56  0C05 0000               1476          CMPI.B #0,D5 ;check if the mask is 0
00001B5A  6700 F536               1477          BEQ falsePositive ;branch if it is
00001B5E                          1478          
00001B5E  1401                    1479          MOVE.B D1,D2 ;copy instruction to D2
00001B60  C405                    1480          AND.B D5,D2  ;mask D2
00001B62  43F9 00001BC4           1481          LEA cmpiEA,A1 ;load the list of valid modes
00001B68  D3C0                    1482          ADDA.L D0,A1 ;displace to a specific mode
00001B6A  1811                    1483          MOVE.B (A1),D4 ;move mode to D4
00001B6C  B404                    1484          CMP.B D4,D2 ;compare mode to masked value
00001B6E  6700 0006               1485          BEQ oriBody ;if its match, its a valid mode and we can procede
00001B72                          1486          
00001B72  5280                    1487          ADDQ.L #1,D0 ;add one to displacement
00001B74  60D6                    1488          BRA validOriModes ;check for next mode
00001B76                          1489          
00001B76                          1490  oriBody:
00001B76                          1491  
00001B76                          1492  
00001B76  3401                    1493          MOVE.W  D1,D2 ;copy inst to D2
00001B78  C47C 00C0               1494          AND.W  #%0000000011000000,D2 ;mask word for size
00001B7C  0C42 00C0               1495          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001B80  6700 F510               1496          BEQ falsePositive
00001B84                          1497  
00001B84  43F9 000024D9           1498          LEA     oriMessage,A1  ;move string for NEG info
00001B8A  103C 000E               1499          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B8E                          1500                                ;string without CR, LF
00001B8E  4E4F                    1501          TRAP    #15
00001B90                          1502          
00001B90                          1503          ;go to Effective_Address for immediate data
00001B90  143C 003C               1504          MOVE.B #%00111100,D2
00001B94  48E7 4000               1505          MOVEM.L D1,-(SP)
00001B98  6100 04DC               1506          BSR     Get_Effective_Address
00001B9C  4CDF 0002               1507          MOVEM.L (SP)+,D1
00001BA0                          1508          
00001BA0  3401                    1509          MOVE.W D1,D2 ;copy inst to D2
00001BA2  C47C 003F               1510          AND #%000000000111111,D2 ;and out everything but modes and regs
00001BA6  1A02                    1511          MOVE.B D2,D5 ; copy to D5 for following BSR
00001BA8                          1512          
00001BA8  48E7 4000               1513          MOVEM.L D1,-(SP)
00001BAC  6100 04C8               1514          BSR     Get_Effective_Address
00001BB0  4CDF 0002               1515          MOVEM.L (SP)+,D1
00001BB4                          1516          
00001BB4                          1517                
00001BB4                          1518          
00001BB4                          1519  oridone:
00001BB4                          1520  
00001BB4  43F9 00002484           1521          LEA     clearLine,A1  ;move string for a CR and LF
00001BBA  103C 000E               1522          MOVE.B  #14,D0        ;set for task to display null terminated 
00001BBE                          1523                                ;string without CR, LF
00001BBE  4E4F                    1524          TRAP    #15
00001BC0  7000                    1525          MOVEQ.L #0,D0
00001BC2  4E75                    1526          RTS
00001BC4                          1527  
00001BC4                          1528          
00001BC4                          1529          
00001BC4= 20 18 00 10 38 39 00    1530  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
00001BCB= 38 38 38 38 3F 3F 00    1531  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
00001BD2                          1532     
00001BD2                          1533  CMPI:            
00001BD2                          1534       
00001BD2  7000                    1535          MOVEQ.L #0, D0 ;clear D0
00001BD4                          1536          
00001BD4                          1537  validCmpiModes:
00001BD4                          1538          
00001BD4                          1539          
00001BD4  43F8 1BCB               1540          LEA cmpiEAmasks,A1 ;load the list of masks
00001BD8  D3C0                    1541          ADDA.L D0,A1 ;displace to a specific mask
00001BDA  1A11                    1542          MOVE.B (A1),D5 ;move the mask to D5
00001BDC                          1543          
00001BDC  0C05 0000               1544          CMPI.B #0,D5 ;check if the mask is 0
00001BE0  6700 F4B0               1545          BEQ falsePositive ;branch if it is
00001BE4                          1546          
00001BE4  1401                    1547          MOVE.B D1,D2 ;copy instruction to D2
00001BE6  C405                    1548          AND.B D5,D2  ;mask D2
00001BE8  43F8 1BC4               1549          LEA cmpiEA,A1 ;load the list of valid modes
00001BEC  D3C0                    1550          ADDA.L D0,A1 ;displace to a specific mode
00001BEE  1811                    1551          MOVE.B (A1),D4 ;move mode to D4
00001BF0  B404                    1552          CMP.B D4,D2 ;compare mode to masked value
00001BF2  6700 0006               1553          BEQ CMPIBody ;if its match, its a valid mode and we can procede
00001BF6                          1554          
00001BF6  5280                    1555          ADDQ.L #1,D0 ;add one to displacement
00001BF8  60DA                    1556          BRA validCmpiModes ;check for next mode
00001BFA                          1557          
00001BFA                          1558  CMPIBody:
00001BFA                          1559  
00001BFA                          1560  
00001BFA  3401                    1561          MOVE.W  D1,D2 ;copy inst to D2
00001BFC  C47C 00C0               1562          AND.W  #%0000000011000000,D2 ;mask word for size
00001C00  0C42 00C0               1563          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001C04  6700 F48C               1564          BEQ falsePositive
00001C08                          1565  
00001C08  43F9 000024DE           1566          LEA     cmpiMessage,A1  ;move string for NEG info
00001C0E  103C 000E               1567          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C12                          1568                                ;string without CR, LF
00001C12  4E4F                    1569          TRAP    #15
00001C14                          1570          
00001C14                          1571          ;go to Effective_Address for immediate data
00001C14  143C 003C               1572          MOVE.B #%00111100,D2
00001C18  48E7 4000               1573          MOVEM.L D1,-(SP)
00001C1C  6100 0458               1574          BSR     Get_Effective_Address
00001C20  4CDF 0002               1575          MOVEM.L (SP)+,D1
00001C24                          1576          
00001C24  3401                    1577          MOVE.W D1,D2 ;copy inst to D2
00001C26  C47C 003F               1578          AND #%000000000111111,D2 ;and out everything but modes and regs
00001C2A  1A02                    1579          MOVE.B D2,D5 ; copy to D5 for following BSR
00001C2C                          1580          
00001C2C  48E7 4000               1581          MOVEM.L D1,-(SP)
00001C30  6100 0444               1582          BSR     Get_Effective_Address
00001C34  4CDF 0002               1583          MOVEM.L (SP)+,D1
00001C38                          1584          
00001C38                          1585                
00001C38                          1586          
00001C38                          1587  CMPidone:
00001C38                          1588  
00001C38  43F9 00002484           1589          LEA     clearLine,A1  ;move string for a CR and LF
00001C3E  103C 000E               1590          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C42                          1591                                ;string without CR, LF
00001C42  4E4F                    1592          TRAP    #15
00001C44  7000                    1593          MOVEQ.L #0,D0
00001C46  4E75                    1594          RTS
00001C48                          1595  
00001C48                          1596          
00001C48= 10 38 39 00             1597  JsrEA        DC.B %010000, %111000, %111001,0
00001C4C= 38 3F 3F 00             1598  JsrEAmasks   DC.B %111000, %111111, %111111,0
00001C50                          1599     
00001C50                          1600  JSR:            
00001C50                          1601       
00001C50  7000                    1602          MOVEQ.L #0, D0 ;clear D0
00001C52                          1603          
00001C52                          1604  validJsrModes:
00001C52                          1605          
00001C52  43F8 1C4C               1606          LEA JsrEAmasks,A1 ;load the list of masks
00001C56  D3C0                    1607          ADDA.L D0,A1 ;displace to a specific mask
00001C58  1A11                    1608          MOVE.B (A1),D5 ;move the mask to D5
00001C5A                          1609          
00001C5A  0C05 0000               1610          CMPI.B #0,D5 ;check if the mask is 0
00001C5E  6700 F432               1611          BEQ falsePositive ;branch if it is
00001C62                          1612          
00001C62  1401                    1613          MOVE.B D1,D2 ;copy instruction to D2
00001C64  C405                    1614          AND.B D5,D2  ;mask D2
00001C66  43F8 1C48               1615          LEA JsrEA,A1 ;load the list of valid modes
00001C6A  D3C0                    1616          ADDA.L D0,A1 ;displace to a specific mode
00001C6C  1811                    1617          MOVE.B (A1),D4 ;move mode to D4
00001C6E  B404                    1618          CMP.B D4,D2 ;compare mode to masked value
00001C70  6700 0006               1619          BEQ JsrBody ;if its match, its a valid mode and we can procede
00001C74                          1620          
00001C74  5280                    1621          ADDQ.L #1,D0 ;add one to displacement
00001C76  60DA                    1622          BRA validJsrModes ;check for next mode
00001C78                          1623          
00001C78                          1624  JsrBody:
00001C78                          1625  
00001C78                          1626  
00001C78  43F9 000024E4           1627          LEA     jsrMessage,A1  ;move string for NEG info
00001C7E  103C 000E               1628          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C82                          1629                                ;string without CR, LF
00001C82  4E4F                    1630          TRAP    #15
00001C84                          1631          
00001C84  3401                    1632          MOVE.W D1,D2 ;copy inst to D2
00001C86  C47C 003F               1633          AND #%000000000111111,D2 ;and out everything but modes and regs
00001C8A  1A02                    1634          MOVE.B D2,D5 ; copy to D5 for following BSR
00001C8C                          1635          
00001C8C  48E7 4000               1636          MOVEM.L D1,-(SP)
00001C90  6100 03E4               1637          BSR     Get_Effective_Address
00001C94  4CDF 0002               1638          MOVEM.L (SP)+,D1
00001C98                          1639          
00001C98                          1640                
00001C98                          1641          
00001C98                          1642  Jsrdone:
00001C98                          1643  
00001C98  43F9 00002484           1644          LEA     clearLine,A1  ;move string for a CR and LF
00001C9E  103C 000E               1645          MOVE.B  #14,D0        ;set for task to display null terminated 
00001CA2                          1646                                ;string without CR, LF
00001CA2  4E4F                    1647          TRAP    #15
00001CA4  7000                    1648          MOVEQ.L #0,D0
00001CA6  4E75                    1649          RTS
00001CA8                          1650  
00001CA8                          1651  
00001CA8                          1652          
00001CA8                          1653  NOP:
00001CA8                          1654  
00001CA8  43F9 000024EE           1655          LEA     nopMessage,A1 ;move string for NOP info
00001CAE  103C 000D               1656          MOVE.B  #13,D0        ;set for task to display null terminated 
00001CB2                          1657                                ;string with CR, LF
00001CB2  4E4F                    1658          TRAP    #15
00001CB4                          1659          
00001CB4  7000                    1660          MOVEQ.L #0,D0
00001CB6  4E75                    1661          RTS
00001CB8                          1662          
00001CB8                          1663  RTS:
00001CB8                          1664          
00001CB8  43F9 000024E9           1665          LEA     rtsMessage,A1  ;move string for rts info
00001CBE  103C 000D               1666          MOVE.B  #13,D0        ;set for task to display null terminated 
00001CC2                          1667                                ;string with CR, LF
00001CC2  4E4F                    1668          TRAP    #15  
00001CC4                          1669     
00001CC4  7000                    1670          MOVEQ.L #0,D0
00001CC6  4E75                    1671          RTS   
00001CC8                          1672  
00001CC8= 3C 08 00 10 18 20 ...   1673  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
00001CD1= 3F 38 38 38 38 38 ...   1674  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001CDA                          1675  
00001CDA= 00 10 18 20 38 39 00    1676  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
00001CE1= 38 38 38 38 3F 3F 00    1677  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
00001CE8                          1678  
00001CE8                          1679  MOVE:
00001CE8                          1680          
00001CE8                          1681  
00001CE8                          1682          
00001CE8  7000                    1683          MOVEQ.L #0, D0 ;clear D0
00001CEA                          1684          
00001CEA                          1685  validMoveSourceModes:
00001CEA                          1686          
00001CEA  43F8 1CD1               1687          LEA moveSourceEAmasks,A1 ;load the list of masks
00001CEE  D3C0                    1688          ADDA.L D0,A1 ;displace to a specific mask
00001CF0  1A11                    1689          MOVE.B (A1),D5 ;move the mask to D5
00001CF2                          1690          
00001CF2  0C05 0000               1691          CMPI.B #0,D5 ;check if the mask is 0
00001CF6  6700 F39A               1692          BEQ falsePositive ;branch if it is
00001CFA                          1693          
00001CFA  1401                    1694          MOVE.B D1,D2 ;copy instruction to D2
00001CFC  C405                    1695          AND.B D5,D2  ;mask D2
00001CFE                          1696          
00001CFE  43F8 1CC8               1697          LEA moveSourceEA,A1 ;load the list of valid modes
00001D02  D3C0                    1698          ADDA.L D0,A1 ;displace to a specific mode
00001D04  1811                    1699          MOVE.B (A1),D4 ;move mode to D4
00001D06  B404                    1700          CMP.B D4,D2 ;compare mode to masked value
00001D08  6700 0006               1701          BEQ  checkMoveDest ;if its match, its a valid mode and we can procede
00001D0C                          1702          
00001D0C  5280                    1703          ADDQ.L #1,D0 ;add one to displacement
00001D0E  60DA                    1704          BRA validMoveSourceModes ;check for next mode
00001D10                          1705          
00001D10                          1706  checkMoveDest:
00001D10  7000                    1707          MOVEQ.L #0, D0 ;clear D0
00001D12                          1708          
00001D12                          1709  validMoveDestModes:
00001D12                          1710          
00001D12  43F8 1CE1               1711          LEA moveDestEAmasks,A1 ;load the list of masks
00001D16  D3C0                    1712          ADDA.L D0,A1 ;displace to a specific mask
00001D18  1A11                    1713          MOVE.B (A1),D5 ;move the mask to D5
00001D1A                          1714          
00001D1A  0C05 0000               1715          CMPI.B #0,D5 ;check if the mask is 0
00001D1E  6700 F372               1716          BEQ falsePositive ;branch if it is
00001D22                          1717          
00001D22  3401                    1718          MOVE.W D1,D2 ;copy instruction to D2
00001D24  EC4A                    1719          LSR.W #6,D2  ;move mode
00001D26  6100 0580               1720          BSR switchModeAndReg ;switch register and mode
00001D2A  C405                    1721          AND.B D5,D2  ;mask D2
00001D2C                          1722          
00001D2C  43F8 1CDA               1723          LEA moveDestEA,A1 ;load the list of valid modes
00001D30  D3C0                    1724          ADDA.L D0,A1 ;displace to a specific mode
00001D32  1811                    1725          MOVE.B (A1),D4 ;move mode to D4
00001D34  B404                    1726          CMP.B D4,D2 ;compare mode to masked value
00001D36  6700 0006               1727          BEQ moveBody ;if its match, its a valid mode and we can procede
00001D3A                          1728          
00001D3A  5280                    1729          ADDQ.L #1,D0 ;add one to displacement
00001D3C  60D4                    1730          BRA validMoveDestModes ;check for next mode
00001D3E                          1731          
00001D3E                          1732  moveBody
00001D3E  3401                    1733          MOVE.W  D1,D2 ;copy inst to D2
00001D40  C47C 3000               1734          AND.W  #%0011000000000000,D2 ;mask word for size
00001D44  0C42 0000               1735          CMPI.W #0,D2 ;0 is the only non valid size
00001D48  6700 F348               1736          BEQ falsePositive ; if zero, this is not move
00001D4C                          1737  
00001D4C  43F9 000024F3           1738          LEA     moveMessage,A1  ;move string for MOVE
00001D52  103C 000E               1739          MOVE.B  #14,D0        ;set for task to display null terminated 
00001D56                          1740                                ;string with CR, LF
00001D56  4E4F                    1741          TRAP    #15
00001D58                          1742          
00001D58                          1743          
00001D58  3401                    1744          MOVE.W  D1,D2 ;check source mode
00001D5A  C43C 003F               1745          AND.B   #%00111111,D2
00001D5E  1A02                    1746          MOVE.B  D2,D5
00001D60  48E7 4000               1747          MOVEM.L D1,-(SP)
00001D64  6100 0310               1748          BSR     Get_Effective_Address
00001D68  4CDF 0002               1749          MOVEM.L (SP)+,D1
00001D6C                          1750          
00001D6C                          1751          ;print separator
00001D6C                          1752          
00001D6C  3401                    1753          MOVE.W  D1,D2 ;check dest mode
00001D6E  EC4A                    1754          LSR.W   #6,D2
00001D70  6100 0536               1755          BSR  switchModeAndReg
00001D74  C43C 003F               1756          AND.B   #%00111111,D2
00001D78  1A02                    1757          MOVE.B  D2,D5
00001D7A  48E7 4000               1758          MOVEM.L D1,-(SP)
00001D7E  6100 02F6               1759          BSR     Get_Effective_Address
00001D82  4CDF 0002               1760          MOVEM.L (SP)+,D1
00001D86                          1761          
00001D86                          1762          
00001D86                          1763          
00001D86  43F9 00002484           1764          LEA     clearLine,A1  ;move string for a CR and LF
00001D8C  103C 000E               1765          MOVE.B  #14,D0        ;set for task to display null terminated 
00001D90                          1766                                ;string without CR, LF
00001D90  4E4F                    1767          TRAP    #15
00001D92                          1768  
00001D92  7000                    1769          MOVEQ.L #0,D0
00001D94  4E75                    1770          RTS
00001D96                          1771          
00001D96= 08 00                   1772  moveADestEA        DC.B %001000,0
00001D98= 38 00                   1773  moveADestEAmasks   DC.B %111000,0
00001D9A                          1774          
00001D9A                          1775  MOVEA:
00001D9A                          1776  
00001D9A  7000                    1777          MOVEQ.L #0, D0 ;clear D0
00001D9C                          1778          
00001D9C                          1779  validMoveASourceModes:
00001D9C                          1780          
00001D9C  43F8 1CD1               1781          LEA moveSourceEAmasks,A1 ;load the list of masks
00001DA0  D3C0                    1782          ADDA.L D0,A1 ;displace to a specific mask
00001DA2  1A11                    1783          MOVE.B (A1),D5 ;move the mask to D5
00001DA4                          1784          
00001DA4  0C05 0000               1785          CMPI.B #0,D5 ;check if the mask is 0
00001DA8  6700 F2E8               1786          BEQ falsePositive ;branch if it is
00001DAC                          1787          
00001DAC  1401                    1788          MOVE.B D1,D2 ;copy instruction to D2
00001DAE  C405                    1789          AND.B D5,D2  ;mask D2
00001DB0                          1790          
00001DB0  43F8 1CC8               1791          LEA moveSourceEA,A1 ;load the list of valid modes
00001DB4  D3C0                    1792          ADDA.L D0,A1 ;displace to a specific mode
00001DB6  1811                    1793          MOVE.B (A1),D4 ;move mode to D4
00001DB8  B404                    1794          CMP.B D4,D2 ;compare mode to masked value
00001DBA  6700 0006               1795          BEQ  checkMoveADest ;if its match, its a valid mode and we can procede
00001DBE                          1796          
00001DBE  5280                    1797          ADDQ.L #1,D0 ;add one to displacement
00001DC0  60DA                    1798          BRA validMoveASourceModes ;check for next mode
00001DC2                          1799          
00001DC2                          1800  checkMoveADest:
00001DC2  7000                    1801          MOVEQ.L #0, D0 ;clear D0
00001DC4                          1802  validMoveADestModes:
00001DC4                          1803          
00001DC4  43F8 1D98               1804          LEA moveADestEAmasks,A1 ;load the list of masks
00001DC8  D3C0                    1805          ADDA.L D0,A1 ;displace to a specific mask
00001DCA  1A11                    1806          MOVE.B (A1),D5 ;move the mask to D5
00001DCC                          1807          
00001DCC  0C05 0000               1808          CMPI.B #0,D5 ;check if the mask is 0
00001DD0  6700 F2C0               1809          BEQ falsePositive ;branch if it is
00001DD4                          1810          
00001DD4  3401                    1811          MOVE.W D1,D2 ;copy instruction to D2
00001DD6  EA4A                    1812          LSR.W #5,D2  ;move mode
00001DD8  6100 04CE               1813          BSR switchModeAndReg ;switch register and mode
00001DDC  C405                    1814          AND.B D5,D2  ;mask D2
00001DDE                          1815          
00001DDE  43F8 1D96               1816          LEA moveADestEA,A1 ;load the list of valid modes
00001DE2  D3C0                    1817          ADDA.L D0,A1 ;displace to a specific mode
00001DE4  1811                    1818          MOVE.B (A1),D4 ;move mode to D4
00001DE6  B404                    1819          CMP.B D4,D2 ;compare mode to masked value
00001DE8  6700 0006               1820          BEQ moveABody ;if its match, its a valid mode and we can procede
00001DEC                          1821          
00001DEC  5280                    1822          ADDQ.L #1,D0 ;add one to displacement
00001DEE  60D4                    1823          BRA validMoveADestModes ;check for next mode
00001DF0                          1824  moveABody:
00001DF0  3401                    1825          MOVE.W  D1,D2 ;copy inst to D2
00001DF2  C47C 3000               1826          AND.W  #%0011000000000000,D2 ;mask word for size
00001DF6  0C42 0000               1827          CMPI.W #0,D2 ;0 is the non valid size
00001DFA  6700 F296               1828          BEQ falsePositive ; if zero, this is not move
00001DFE  0C42 1000               1829          CMPI.W #%0001000000000000,D2
00001E02  6700 F28E               1830          BEQ falsePositive ; if byte, this is not movea
00001E06                          1831  
00001E06                          1832  
00001E06  43F9 00002506           1833          LEA     moveAMessage,A1  ;move string for MOVE
00001E0C  103C 000D               1834          MOVE.B  #13,D0        ;set for task to display null terminated 
00001E10                          1835                                ;string with CR, LF
00001E10  4E4F                    1836          TRAP    #15
00001E12                          1837  
00001E12  7000                    1838          MOVEQ.L #0,D0
00001E14  4E75                    1839          RTS
00001E16                          1840  
00001E16                          1841             
00001E16                          1842  Bcc:
00001E16                          1843  
00001E16  43F9 000024F9           1844          LEA     bccMessage,A1  ;move string for BRA info
00001E1C  103C 000E               1845          MOVE.B  #14,D0        ;set for task to display null terminated 
00001E20                          1846                                ;string without CR, LF
00001E20  4E4F                    1847          TRAP    #15
00001E22                          1848          
00001E22  7000                    1849          MOVEQ.L #0,D0 ;clear D0
00001E24  3401                    1850          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001E26  E04A                    1851          LSR.W   #8,D2
00001E28  C47C 000F               1852          AND.W   #$0F,D2 ;mask instruction
00001E2C                          1853          
00001E2C                          1854  checkCC:        
00001E2C  41F9 0000240B           1855          LEA     bccList,A0 ;get condition code signature list in A0
00001E32  D1C0                    1856          ADDA.L  D0,A0 ;get correct sig         
00001E34  B410                    1857          CMP.B   (A0),D2 ;compare to sig
00001E36  6700 0006               1858          BEQ     foundCC ;if sig matches branch
00001E3A  5200                    1859          ADDQ.B  #byte,D0
00001E3C  60EE                    1860          BRA     checkCC
00001E3E                          1861  foundCC:
00001E3E  43F9 0000241C           1862          LEA     conditionCodeMessage,A1 ;get condition code message in A1
00001E44  C0FC 0004               1863          MULU.W  #long,D0 ;adjust size of D0 for a long
00001E48  D3C0                    1864          ADDA.L  D0,A1 ;get correct message location
00001E4A  2251                    1865          MOVEA.L (A1),A1 ;get correct message
00001E4C                          1866          
00001E4C  103C 000E               1867          MOVE.B  #14,D0        ;set for task to display null terminated 
00001E50                          1868                                ;string without CR, LF
00001E50  4E4F                    1869          TRAP    #15
00001E52                          1870  
00001E52                          1871          
00001E52                          1872          
00001E52  548B                    1873          ADDQ.L  #word,A3 ;move past instruction in case long displacement
00001E54  C27C 00FF               1874          AND.W   #$00FF,D1   ;check for word sized displacement
00001E58                          1875          
00001E58  B23C 0000               1876          CMP.B   #$0,D1
00001E5C  6700 0010               1877          BEQ     BccWord
00001E60                          1878          
00001E60  B23C 00FF               1879          CMP.B   #$FF,D1 check for long sized displacement
00001E64  6700 0010               1880          BEQ     BccLong
00001E68                          1881          
00001E68                          1882  BccByte:
00001E68                          1883          
00001E68  7E00                    1884          MOVEQ.L #0,D7 ;pass back no extra data followed
00001E6A  6000 0012               1885          BRA     BccDone
00001E6E                          1886  BccWord:
00001E6E  3213                    1887          MOVE.W  (A3),D1
00001E70                          1888          
00001E70  7E02                    1889          MOVEQ.L #word,D7 ;pass back an extra word followed
00001E72  6000 000A               1890          BRA     BccDone
00001E76                          1891  BccLong:
00001E76  2213                    1892          MOVE.L  (A3),D1
00001E78                          1893          
00001E78  7E04                    1894          MOVEQ.L #long,D7 ;pass back an extra long followed
00001E7A  6000 0002               1895          BRA     BccDone
00001E7E                          1896  BccDone:
00001E7E                          1897  
00001E7E  343C 0010               1898          MOVE.W  #16,D2 ;put base in D2
00001E82  303C 000F               1899          MOVE.W  #15,D0  ;put task #15 in D0
00001E86  4E4F                    1900          TRAP    #15
00001E88                          1901          
00001E88  43F9 00002484           1902          LEA     clearLine,A1  ;move string for a CR and LF
00001E8E  103C 000E               1903          MOVE.B  #14,D0        ;set for task to display null terminated 
00001E92                          1904                                ;string without CR, LF
00001E92  4E4F                    1905          TRAP    #15
00001E94                          1906  
00001E94  7000                    1907          MOVEQ.L #0,D0
00001E96  4E75                    1908          RTS
00001E98                          1909          
00001E98                          1910          
00001E98                          1911  unknownOpCode:
00001E98  43F9 00002500           1912          LEA     dataMessage,A1 ;move string for data info
00001E9E  103C 000E               1913          MOVE.B  #14,D0        ;set for task to display null terminated 
00001EA2                          1914                                ;string without CR, LF
00001EA2  4E4F                    1915          TRAP    #15
00001EA4                          1916          
00001EA4  143C 0010               1917          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001EA8  103C 000F               1918          MOVE.B  #15,D0
00001EAC  4E4F                    1919          TRAP    #15
00001EAE                          1920          
00001EAE  43F9 00002484           1921          LEA     clearLine,A1  ;move string for a CR and LF
00001EB4  103C 000E               1922          MOVE.B  #14,D0        ;set for task to display null terminated 
00001EB8                          1923                                ;string without CR, LF
00001EB8  4E4F                    1924          TRAP    #15
00001EBA                          1925          
00001EBA  7000                    1926          MOVEQ.L #0,D0
00001EBC  4E75                    1927          RTS
00001EBE                          1928          
00001EBE                          1929  handlebytedata:
00001EBE                          1930  
00001EBE  43F9 00002500           1931          LEA     dataMessage,A1 ;move string for data info
00001EC4  103C 000E               1932          MOVE.B  #14,D0        ;set for task to display null terminated 
00001EC8                          1933                                ;string without CR, LF
00001EC8  4E4F                    1934          TRAP    #15
00001ECA                          1935          
00001ECA  E049                    1936          LSR.W   #8,D1 ;shift the word read into D1 by a byte
00001ECC                          1937          
00001ECC  143C 0010               1938          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001ED0  103C 000F               1939          MOVE.B  #15,D0
00001ED4  4E4F                    1940          TRAP    #15
00001ED6                          1941          
00001ED6  43F9 00002484           1942          LEA     clearLine,A1  ;move string for a CR and LF
00001EDC  103C 000E               1943          MOVE.B  #14,D0        ;set for task to display null terminated 
00001EE0                          1944                                ;string without CR, LF
00001EE0  4E4F                    1945          TRAP    #15
00001EE2                          1946          
00001EE2  7000                    1947          MOVEQ.L #0,D0
00001EE4                          1948          
00001EE4  528B                    1949          ADDQ.L  #byte,A3
00001EE6  6000 F13E               1950          BRA main_Loop
00001EEA                          1951  
00001EEA                          1952          
00001EEA                          1953          
00001EEA                          1954  fin
00001EEA                          1955  
00001EEA                          1956          
00001EEA                          1957          
00001EEA  FFFF FFFF               1958          simhalt
00001EEE                          1959          
00001EEE                          1960  
00001EEE                          1961  *******************************************************************************
00001EEE                          1962  *                            SUB ROUTINES
00001EEE                          1963  *******************************************************************************
00001EEE                          1964  
00001EEE                          1965  *******************************************************************************
00001EEE                          1966  *                          IO ROLE ROUTINES
00001EEE                          1967  *******************************************************************************
00001EEE                          1968  
00001EEE                          1969  *==========================================================================
00001EEE                          1970  *                   Enter / Validate beginning address 
00001EEE                          1971  *==========================================================================
00001EEE                          1972   
00001EEE                          1973  begin_address:
00001EEE                          1974  
00001EEE                          1975         
00001EEE  43F9 000022BC           1976          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00001EF4  2239 000022BC           1977          MOVE.L      slPrompt,D1         ;Load display length to D1
00001EFA  700E                    1978          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001EFC  4E4F                    1979          TRAP        #15                 ;Perform task 14 (display)
00001EFE                          1980          
00001EFE  43F9 00002538           1981          LEA         startLocation,A1    ;Load address to store user input
00001F04  103C 0002               1982          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001F08  4E4F                    1983          TRAP        #15                 ;Perform task 2 (input)
00001F0A                          1984          
00001F0A  0C11 001B               1985          CMP.B       #27,(A1)            ;Check for ESC entered
00001F0E  6700 004C               1986          BEQ         address_Exit        ;Exit condition 
00001F12                          1987          
00001F12  6100 0050               1988          BSR         enter_addr_edit_all
00001F16  B67C FFFF               1989          CMP.W       #-1,D3              ;Did the edit pass?
00001F1A  67D2                    1990          BEQ         begin_address       ;No, loop and ask for correct input
00001F1C                          1991          
00001F1C  2643                    1992          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
00001F1E                          1993          
00001F1E  43F9 000023C9           1994          LEA         spc,A1              ;Load address for starting loaction prompt
00001F24  1239 000023CA           1995          MOVE.B      spc_len,D1          ;Load empty line length
00001F2A  7000                    1996          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
00001F2C  4E4F                    1997          TRAP        #15                 ;Perform task 14 (display)
00001F2E  6000 0002               1998          BRA         end_address
00001F32                          1999  
00001F32                          2000  *===========================================================================
00001F32                          2001  *                   Enter / Validate ending address 
00001F32                          2002  *===========================================================================
00001F32                          2003  
00001F32                          2004  end_address:
00001F32                          2005          
00001F32  43F9 000022ED           2006          LEA         elPrompt,A1         ;Load address for ending loaction prompt
00001F38                          2007          ;MOVE.L     elPrompt,D1         ;Load display length to D1
00001F38  7250                    2008          MOVE.L      #80,D1       ;did not like previous command, do not know why, it should have worked
00001F3A  700E                    2009          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001F3C  4E4F                    2010          TRAP        #15                 ;Perform task 14 (display)
00001F3E                          2011          
00001F3E  103C 0002               2012          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001F42  4E4F                    2013          TRAP        #15                 ;Perform task 2 (input)
00001F44                          2014          
00001F44  0C11 001B               2015          CMP.B       #27,(A1)            ;Check for ESC entered
00001F48  6700 0012               2016          BEQ         address_Exit        ;Exit condition 
00001F4C                          2017          
00001F4C  6100 0016               2018          BSR         enter_addr_edit_all
00001F50  B67C FFFF               2019          CMP.W       #-1,D3              ;Did the edit pass?
00001F54  67DC                    2020          BEQ         end_address         ;No, loop and ask for correct input
00001F56                          2021  
00001F56  2843                    2022          MOVEA.L     D3,A4               ;Ending address gets stored in A4
00001F58  6000 0008               2023          BRA         address_done
00001F5C                          2024  
00001F5C                          2025  address_Exit:
00001F5C                          2026  
00001F5C  76FF                    2027          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001F5E  6000 0002               2028          BRA         address_done
00001F62                          2029          
00001F62                          2030  address_done:
00001F62                          2031  
00001F62  4E75                    2032          RTS    
00001F64                          2033  
00001F64                          2034  *==============================================================================
00001F64                          2035  * enter_addr_edit_all - Enter address edit check to edit all errors  
00001F64                          2036  *                       using multiple different error checking routines.
00001F64                          2037  *
00001F64                          2038  * Parameters -
00001F64                          2039  *   Input   A1      The data that needs checked.
00001F64                          2040  *   Input   D1      The number of characters input     
00001F64                          2041  *   Output  D3      Returns '-1' when there is an error.
00001F64                          2042  *==============================================================================
00001F64                          2043  
00001F64                          2044  enter_addr_edit_all
00001F64                          2045  
00001F64                          2046  *------------------------------------------------------------------------------
00001F64                          2047  * Test for odd number of characters entered, not allowed
00001F64                          2048  *------------------------------------------------------------------------------
00001F64                          2049         
00001F64  6100 0024               2050          BSR         ck_boundry          ;check if the input is on a odd / even boundry
00001F68  B67C FFFF               2051          CMP.W       #-1,D3              ;Is the address odd?
00001F6C  6700 001A               2052          BEQ         enter_addr_edit_all_exit     ;No, return
00001F70                          2053  
00001F70                          2054  *------------------------------------------------------------------------------
00001F70                          2055  * Ttest for character entered all being valid address characters
00001F70                          2056  * Note: lower case a-f, gets converted to upper case A-F in D3
00001F70                          2057  *------------------------------------------------------------------------------
00001F70                          2058          
00001F70  6100 0062               2059          BSR         parseHexString      ;check if the input contains valid Hex characters
00001F74  B67C FFFF               2060          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
00001F78  6700 000E               2061          BEQ         enter_addr_edit_all_exit     ;No, return
00001F7C                          2062  
00001F7C                          2063  *------------------------------------------------------------------------------
00001F7C                          2064  * Verify that the address entered is witin the range defined in the Equate
00001F7C                          2065  *------------------------------------------------------------------------------        
00001F7C                          2066          
00001F7C  6100 00C8               2067          BSR         ck_addr_range       ;is address entered witin the range 
00001F80                          2068                                          ;   as defined in the Equate? 
00001F80  B67C FFFF               2069          CMP.W       #-1,D3              ;is the address  valid?
00001F84  6700 0002               2070          BEQ         enter_addr_edit_all_exit     ;No, return
00001F88                          2071  
00001F88                          2072  enter_addr_edit_all_exit:
00001F88                          2073  
00001F88  4E75                    2074          RTS                             ;return
00001F8A                          2075  
00001F8A                          2076  *==============================================================================
00001F8A                          2077  * ck_boundry - Check the size of the data characters input and determine
00001F8A                          2078  *              if an odd number of characters was entered
00001F8A                          2079  *
00001F8A                          2080  * Parameters -
00001F8A                          2081  *   Input   A1      The data that needs checked for odd length.
00001F8A                          2082  *   Input   D1      The number of characters input     
00001F8A                          2083  *   Output  D3      Returns '-1' when there is an odd length.
00001F8A                          2084  *==============================================================================
00001F8A                          2085  
00001F8A                          2086  ck_boundry:
00001F8A                          2087  
00001F8A  4243                    2088          CLR.W       D3                  ;Clear the return
00001F8C                          2089  
00001F8C  B23C 0000               2090          CMP.B       #0,D1               ;Check for nothing entered
00001F90  6700 002E               2091          BEQ         ck_size_error       ;Number of characters entered must be 
00001F94                          2092                                          ;greater than 0  
00001F94                          2093          
00001F94                          2094          
00001F94                          2095          * The program will branch to ck_size_error if D1 is greater than #8        
00001F94  B23C 0008               2096          CMP.B       #8,D1               ;Check for more than 8 characters entered
00001F98  6E00 0026               2097          BGT         ck_size_error       ;Number of characters entered must be less
00001F9C                          2098                                          ;than 9
00001F9C                          2099          
00001F9C  7402                    2100          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
00001F9E  82C2                    2101          DIVU        D2,D1               ;Divide address by 2
00001FA0  4841                    2102          SWAP        D1                  ;get remainder
00001FA2  B23C 0001               2103          CMP.B       #$01,D1             ;Check for remainder of 1
00001FA6  6700 0004               2104          BEQ         ck_boundry_error    ;Number of characters entered must be an 
00001FAA                          2105                                          ;even number   
00001FAA                          2106    
00001FAA  4E75                    2107          RTS                             ;return
00001FAC                          2108  
00001FAC                          2109  *------------------------------------------------------------------------------
00001FAC                          2110  * ck_boundry_error - An odd number of characters was entered
00001FAC                          2111  *                  - Load error message and display it
00001FAC                          2112  *                  - Return error condition
00001FAC                          2113  *------------------------------------------------------------------------------
00001FAC                          2114          
00001FAC                          2115  ck_boundry_error:
00001FAC                          2116  
00001FAC  43F9 000023A9           2117          LEA         even_msg,A1         ;Load odd error message into A1
00001FB2  2239 000023A9           2118          MOVE.L      even_msg,D1         ;Load error length to D1
00001FB8                          2119          
00001FB8  7000                    2120          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001FBA                          2121                                          ; n is D1.W with CR, LF. 
00001FBA  4E4F                    2122          TRAP #15                        ;Display the error message
00001FBC  76FF                    2123          MOVE.L #-1,D3                   ;Load -1 into return parameter
00001FBE  4E75                    2124          RTS                             ;Return
00001FC0                          2125          
00001FC0                          2126  *------------------------------------------------------------------------------
00001FC0                          2127  * ck_size_error -   The number of characters entered must be more than zero
00001FC0                          2128  *                  - Load error message and display it
00001FC0                          2129  *                  - Return error condition
00001FC0                          2130  *------------------------------------------------------------------------------
00001FC0                          2131          
00001FC0                          2132  ck_size_error:
00001FC0                          2133  
00001FC0  43F9 0000231C           2134          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001FC6  2239 0000231C           2135          MOVE.L      invalidMsg,D1       ;Load error length to D1
00001FCC                          2136          
00001FCC  7000                    2137          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001FCE                          2138                                          ; n is D1.W with CR, LF. 
00001FCE  4E4F                    2139          TRAP        #15                 ;Display the error message
00001FD0  76FF                    2140          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001FD2  4E75                    2141          RTS                             ;Return        
00001FD4                          2142  
00001FD4                          2143  
00001FD4                          2144  *==============================================================================
00001FD4                          2145  * parseHexString - Converts user input string into a valid memory address
00001FD4                          2146  *                - Stores parsed address data into D3
00001FD4                          2147  *                - Stores good/bad (1/0) data in D4 
00001FD4                          2148  *
00001FD4                          2149  * Hex values are stored as bytes in D2, the ASCII chart shows their value
00001FD4                          2150  *   The ASCII chart values we care about are in the ranges of: 
00001FD4                          2151  *                            Hex            Decimal
00001FD4                          2152  *       No Value           NULL = 0         0
00001FD4                          2153  *       Numeric Values:     0-9 = 30-39     48-57
00001FD4                          2154  *       Upper Case letters: A-F = 41-46     65-70
00001FD4                          2155  *       Lower Case letterc: a-f = 61-66     97-102
00001FD4                          2156  
00001FD4                          2157  * Parameters -
00001FD4                          2158  *   Input   A1      The data that needs checked for valid input.
00001FD4                          2159  *   Output  D3      The return value, '-1' for error
00001FD4                          2160  *==============================================================================
00001FD4                          2161  
00001FD4                          2162  parseHexString:
00001FD4                          2163  
00001FD4                          2164  * setup any initializing item that do not get looped through
00001FD4  4243                    2165          CLR.W       D3                  ;Clear the return
00001FD6                          2166  
00001FD6                          2167          
00001FD6                          2168  *------------------------------------------------------------------------------
00001FD6                          2169  * NextHex - Loop through all bytes and vaildate the input
00001FD6                          2170  * Parameters -
00001FD6                          2171  *   Input   A1      The data that needs checked for valid input.
00001FD6                          2172  *   Output  D3      The return value, '-1' for error
00001FD6                          2173  *------------------------------------------------------------------------------
00001FD6                          2174          
00001FD6                          2175  NextHex:
00001FD6                          2176  
00001FD6  1419                    2177          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00001FD8  B43C 0000               2178          CMP.B       #0,D2               ;Check character for null 
00001FDC  6700 0066               2179          BEQ         NextHexReturn       ;Character is null (end of input)
00001FE0                          2180          
00001FE0                          2181  *................................................................................
00001FE0                          2182  *  Check decimal values 0-9 by testing hexadecimal values 30-39
00001FE0                          2183  *................................................................................
00001FE0                          2184                  
00001FE0                          2185          * The program will branch to hex_range_error if D2 is less than #30
00001FE0  B43C 0030               2186          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
00001FE4  6D00 0048               2187          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001FE8                          2188                                          ;processing
00001FE8                          2189          
00001FE8                          2190          * The program will branch to UcaseHex if D2 is greater than #39
00001FE8  B43C 0039               2191          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
00001FEC  6E00 000A               2192          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
00001FF0                          2193          
00001FF0                          2194          *a valid number was found within this range
00001FF0  0402 0030               2195          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
00001FF4  6000 0032               2196          BRA         NextHexDone         ;Done parsing this byte
00001FF8                          2197  
00001FF8                          2198  
00001FF8                          2199  *..............................................................................
00001FF8                          2200  *  Check upper case values A-F by testing hexadecimal values 41-46
00001FF8                          2201  *..............................................................................
00001FF8                          2202  
00001FF8                          2203  UcaseHex:
00001FF8                          2204  
00001FF8                          2205          * The program will branch to hex_range_error if D2 is less than #41
00001FF8  B43C 0041               2206          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
00001FFC  6D00 0030               2207          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00002000                          2208                                          ;processing
00002000                          2209          
00002000  B43C 0046               2210          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
00002004  6E00 000A               2211          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
00002008                          2212                                          ;processing
00002008                          2213          
00002008                          2214          *a valid number was found within this range
00002008  0402 0037               2215          SUBI.B      #55,D2              ;Change uppercase character to actual value
0000200C  6000 001A               2216          BRA         NextHexDone         ;Done parsing this byte
00002010                          2217  
00002010                          2218  
00002010                          2219  *..............................................................................
00002010                          2220  *  Check lower case values a-f by testing hexadecimal values 61-66
00002010                          2221  *..............................................................................
00002010                          2222  
00002010                          2223  LcaseHex
00002010                          2224          
00002010                          2225          * The program will branch to hex_range_error if D2 is less than #61
00002010  B43C 0061               2226          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
00002014  6D00 0018               2227          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
00002018                          2228                                          ;processing
00002018                          2229  
00002018  B43C 0066               2230          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
0000201C  6E00 0010               2231          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
00002020                          2232                                          ;processing
00002020                          2233  
00002020                          2234          *a valid number was found within this range
00002020  0402 0057               2235          SUBI.B      #87,D2              ;Change lowercase character to actual value
00002024  6000 0002               2236          BRA         NextHexDone         ;Done parsing this byte
00002028                          2237  
00002028                          2238  NextHexDone:
00002028                          2239  
00002028  E983                    2240          ASL.L       #4,D3               ; Make rooom for new byte in the return register
0000202A  D602                    2241          ADD.B       D2,D3               ; Move the new byte into the return register
0000202C  60A8                    2242          BRA         NextHex             ; We're ready to parse the next byte
0000202E                          2243          
0000202E                          2244  *-------------------------------------------------------------------------------------
0000202E                          2245  * hex_range_error -  A character entered was within the valid range for a hex address
0000202E                          2246  *                 -  Load error message and display it
0000202E                          2247  *                 -  Return error condition
0000202E                          2248  *-------------------------------------------------------------------------------------
0000202E                          2249          
0000202E                          2250  hex_range_error:
0000202E                          2251  
0000202E  43F9 00002361           2252          LEA         invCharMsg,A1       ;Load invalid range message into A1
00002034  2239 00002361           2253          MOVE.L      invCharMsg,D1       ;Load error length to D1
0000203A                          2254          
0000203A  7000                    2255          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
0000203C                          2256                                          ; n is D1.W with CR, LF. 
0000203C  4E4F                    2257          TRAP        #15                 ;Display the error message
0000203E  76FF                    2258          MOVE.L      #-1,D3              ;Load -1 into return parameter
00002040  6000 0002               2259          BRA         NextHexReturn
00002044                          2260          
00002044                          2261  NextHexReturn:
00002044                          2262          
00002044  4E75                    2263          RTS                             ;Return      
00002046                          2264  
00002046                          2265  
00002046                          2266  *===============================================================================
00002046                          2267  * ck_addr_range - check the address input is within a valid memory address range
00002046                          2268  *                - Parsed address data into D3
00002046                          2269  *
00002046                          2270  * Parameters -
00002046                          2271  *   Input   A1      The data that needs checked for valid address.
00002046                          2272  *   Output  D3      The return value, '-1' for error
00002046                          2273  *===============================================================================
00002046                          2274  
00002046                          2275  
00002046                          2276  ck_addr_range:   
00002046                          2277  
00002046                          2278  *------------------------------------------------------------------------------
00002046                          2279  * Verify that the address entered is witin the 
00002046                          2280  * beginning range ('begin') as defined in the Equate
00002046                          2281  *------------------------------------------------------------------------------   
00002046                          2282              
00002046  2C3C 00005001           2283          MOVE.L      #begin,D6           * Load minimum starting address
0000204C  B686                    2284          CMP.L       D6,D3               * Is input at or above minimum?
0000204E  6D00 0012               2285          BLT         ck_addr_range_error 
00002052                          2286          
00002052                          2287  *------------------------------------------------------------------------------
00002052                          2288  * Verify that the address entered is witin the 
00002052                          2289  * ending range ('end') as defined in the Equate
00002052                          2290  *------------------------------------------------------------------------------
00002052                          2291          
00002052  2C3C 00FFFFFE           2292          MOVE.L      #end,D6             * Load maximum starting address
00002058  B686                    2293          CMP.L       D6,D3               * Is input at or below maximum?
0000205A  6E00 0006               2294          BGT         ck_addr_range_error 
0000205E  6000 0012               2295          BRA         ck_addr_done        ;done checking
00002062                          2296          
00002062                          2297  *..............................................................................
00002062                          2298  * ck_addr_range_error -  A address entered is not within the 
00002062                          2299  *                        valid range for a hex address
00002062                          2300  *..............................................................................
00002062                          2301          
00002062                          2302  ck_addr_range_error
00002062                          2303  
00002062  43F9 0000231C           2304          LEA         invalidMsg,A1       ;Load invalid range message into A1
00002068                          2305          
00002068  700D                    2306          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
0000206A                          2307                                          ;with CR, LF. 
0000206A  4E4F                    2308          TRAP        #15                 ;Display the error message
0000206C  76FF                    2309          MOVE.L      #-1,D3              ;Load -1 into return parameter
0000206E  6000 0002               2310          BRA         ck_addr_done 
00002072                          2311  
00002072                          2312  ck_addr_done:
00002072                          2313  
00002072  4E75                    2314          RTS                             ;Return
00002074                          2315  
00002074                          2316  *******************************************************************************
00002074                          2317  *                          OP CODE ROLE ROUTINES
00002074                          2318  *******************************************************************************
00002074                          2319  
00002074                          2320  process_op_codes:
00002074                          2321  
00002074                          2322  
00002074                          2323  
00002074                          2324  process_op_codes_exit:
00002074                          2325  
00002074  4E75                    2326          RTS
00002076                          2327  
00002076                          2328  
00002076                          2329  *******************************************************************************
00002076                          2330  *                    Effective Addressing ROLE ROUTINES
00002076                          2331  *******************************************************************************
00002076                          2332  
00002076                          2333  Get_Effective_Address:
00002076                          2334  
00002076  1C05                    2335          MOVE.B      D5,D6
00002078  E60E                    2336          LSR.B       #3,D6               ;mode
0000207A  CA3C 0007               2337          And.B       #%00000111,D5       ;register
0000207E                          2338          
0000207E  BC3C 0000               2339          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
00002082  6700 004A               2340          BEQ         Data_Reg_Direct
00002086                          2341          
00002086  BC3C 0001               2342          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
0000208A  6700 005C               2343          BEQ         Addr_Reg_Direct
0000208E                          2344          
0000208E  BC3C 0002               2345          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
00002092  6700 006E               2346          BEQ         Addr_Reg_Indirect
00002096                          2347          
00002096  BC3C 0003               2348          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
0000209A  6700 0098               2349          BEQ         Addr_Reg_Indirect_Inc
0000209E                          2350          
0000209E  BC3C 0004               2351          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
000020A2  6700 00CE               2352          BEQ         Addr_Reg_Indirect_Dec
000020A6                          2353          
000020A6  BC3C 0007               2354          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
000020AA  6700 0006               2355          BEQ         Get_Effective_Address_Other
000020AE                          2356          
000020AE  6000 013E               2357          BRA         invalidEA
000020B2                          2358          
000020B2                          2359  Get_Effective_Address_Other:        
000020B2                          2360          
000020B2  BA3C 0000               2361          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
000020B6  6700 00F8               2362          BEQ Addr_Abs_Short
000020BA                          2363          
000020BA  BA3C 0001               2364          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
000020BE  6700 010A               2365          BEQ Addr_Abs_Long
000020C2                          2366          
000020C2  BA3C 0004               2367          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
000020C6  6700 0116               2368          BEQ Addr_Immediate_Data
000020CA                          2369          
000020CA  6000 0122               2370          BRA         invalidEA
000020CE                          2371          
000020CE                          2372  Data_Reg_Direct:                        ;case 0(0000)
000020CE                          2373  
000020CE  43F9 0000252D           2374          LEA         letterD,A1          ;output 'D' for data register
000020D4  103C 000E               2375          MOVE.B      #14,D0              ;set for task to display null terminated 
000020D8  4E4F                    2376          TRAP        #15                 ;string without CR, LF
000020DA                          2377                          
000020DA  4281                    2378          CLR.L       D1
000020DC  1205                    2379          MOVE.B      D5,D1               ;move register number for display into D1
000020DE  103C 0003               2380          MOVE.B      #3,D0               ;set for task to display null terminated 
000020E2  4E4F                    2381          TRAP        #15                 ;string without CR, LF
000020E4                          2382                 
000020E4  6000 0108               2383          BRA         Get_Effective_Address_Exit  ;return
000020E8                          2384          
000020E8                          2385          
000020E8                          2386  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
000020E8                          2387        
000020E8  43F9 0000252B           2388          LEA         letterA,A1          ;output 'A' for address register
000020EE  103C 000E               2389          MOVE.B      #14,D0              ;set for task to display null terminated 
000020F2  4E4F                    2390          TRAP        #15                 ;string without CR, LF
000020F4                          2391          
000020F4  4281                    2392          CLR.L       D1
000020F6  1205                    2393          MOVE.B      D5,D1               ;move register number for display into D1
000020F8  103C 0003               2394          MOVE.B      #3,D0               ;set for task to display null terminated 
000020FC  4E4F                    2395          TRAP        #15                 ;string without CR, LF
000020FE                          2396          
000020FE  6000 00EE               2397          BRA         Get_Effective_Address_Exit  ;return
00002102                          2398  
00002102                          2399  
00002102                          2400  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
00002102                          2401          
00002102  43F9 00002533           2402          LEA         lprn,A1             ;output 'D' for data register
00002108  103C 000E               2403          MOVE.B      #14,D0              ;set for task to display null terminated 
0000210C  4E4F                    2404          TRAP        #15                 ;string without CR, LF
0000210E                          2405  
0000210E  43F9 0000252B           2406          LEA         letterA,A1          ;output 'A' for address register
00002114  103C 000E               2407          MOVE.B      #14,D0              ;set for task to display null terminated 
00002118  4E4F                    2408          TRAP        #15                 ;string without CR, LF
0000211A                          2409          
0000211A  4281                    2410          CLR.L       D1
0000211C  1205                    2411          MOVE.B      D5,D1               ;move register number for display into D1
0000211E  103C 0003               2412          MOVE.B      #3,D0               ;set for task to display null terminated 
00002122  4E4F                    2413          TRAP        #15                 ;string without CR, LF
00002124                          2414  
00002124  43F9 00002535           2415          LEA         rprn,A1             ;output 'D' for data register
0000212A  103C 000E               2416          MOVE.B      #14,D0              ;set for task to display null terminated 
0000212E  4E4F                    2417          TRAP        #15                 ;string without CR, LF
00002130                          2418          
00002130  6000 00BC               2419          BRA         Get_Effective_Address_Exit  ;return
00002134                          2420  
00002134                          2421                 
00002134                          2422  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
00002134                          2423  
00002134  43F9 00002533           2424          LEA         lprn,A1             ;output 'D' for data register
0000213A  103C 000E               2425          MOVE.B      #14,D0              ;set for task to display null terminated 
0000213E  4E4F                    2426          TRAP        #15                 ;string without CR, LF
00002140                          2427  
00002140  43F9 0000252B           2428          LEA         letterA,A1          ;output 'A' for address register
00002146  103C 000E               2429          MOVE.B      #14,D0              ;set for task to display null terminated 
0000214A  4E4F                    2430          TRAP        #15                 ;string without CR, LF
0000214C                          2431          
0000214C  4281                    2432          CLR.L       D1
0000214E  1205                    2433          MOVE.B      D5,D1               ;move register number for display into D1
00002150  103C 0003               2434          MOVE.B      #3,D0               ;set for task to display null terminated 
00002154  4E4F                    2435          TRAP        #15                 ;string without CR, LF
00002156                          2436  
00002156  43F9 00002535           2437          LEA         rprn,A1             ;output 'D' for data register
0000215C  103C 000E               2438          MOVE.B      #14,D0              ;set for task to display null terminated 
00002160  4E4F                    2439          TRAP        #15                 ;string without CR, LF
00002162                          2440          
00002162  43F9 0000252F           2441          LEA         plus,A1             ;output 'D' for data register
00002168  103C 000E               2442          MOVE.B      #14,D0              ;set for task to display null terminated 
0000216C  4E4F                    2443          TRAP        #15                 ;string without CR, LF
0000216E                          2444          
0000216E  6000 007E               2445          BRA         Get_Effective_Address_Exit  ;return
00002172                          2446  
00002172                          2447  Addr_Reg_Indirect_Dec                   ;4 = (An) - Address Register Indirect with Predecrement (100)
00002172                          2448  
00002172  43F9 00002531           2449          LEA         minus,A1            ;output '-' for Predecrement
00002178  103C 000E               2450          MOVE.B      #14,D0              ;set for task to display null terminated 
0000217C  4E4F                    2451          TRAP        #15                 ;string without CR, LF
0000217E                          2452  
0000217E  43F9 00002533           2453          LEA         lprn,A1             ;output 'D' for data register
00002184  103C 000E               2454          MOVE.B      #14,D0              ;set for task to display null terminated 
00002188  4E4F                    2455          TRAP        #15                 ;string without CR, LF
0000218A                          2456  
0000218A  43F9 0000252B           2457          LEA         letterA,A1          ;output 'A' for address register
00002190  103C 000E               2458          MOVE.B      #14,D0              ;set for task to display null terminated 
00002194  4E4F                    2459          TRAP        #15                 ;string without CR, LF
00002196                          2460          
00002196  4281                    2461          CLR.L       D1
00002198  1205                    2462          MOVE.B      D5,D1               ;move register number for display into D1
0000219A  103C 0003               2463          MOVE.B      #3,D0               ;set for task to display null terminated 
0000219E  4E4F                    2464          TRAP        #15                 ;string without CR, LF
000021A0                          2465  
000021A0  43F9 00002535           2466          LEA         rprn,A1             ;output 'D' for data register
000021A6  103C 000E               2467          MOVE.B      #14,D0              ;set for task to display null terminated 
000021AA  4E4F                    2468          TRAP        #15                 ;string without CR, LF
000021AC                          2469          
000021AC  6000 0040               2470          BRA         Get_Effective_Address_Exit  ;return
000021B0                          2471          
000021B0                          2472                         
000021B0                          2473  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
000021B0                          2474          
000021B0                          2475          
000021B0  548B                    2476          ADDA.L      #word,A3 ;move past instruction
000021B2                          2477          
000021B2                          2478          ;print word (A3)
000021B2  48E7 1200               2479          MOVEM.L D6/D3,-(SP)
000021B6  1C3C 0001               2480          MOVE.B #1,D6 ;put size of word in D6
000021BA  3613                    2481          MOVE.W (A3),D3 ;move data at (A3) to D3
000021BC  6100 003E               2482          BSR outputHex
000021C0  4CDF 0048               2483          MOVEM.L (SP)+,D6/D3
000021C4                          2484          
000021C4  5487                    2485          ADDI.L      #word,D7 
000021C6  6000 0026               2486          BRA         Get_Effective_Address_Exit  ;return
000021CA                          2487                         
000021CA                          2488  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
000021CA                          2489          
000021CA  43F9 00002517           2490          LEA         xxxL,A1             ;output 'D' for data register
000021D0  103C 000E               2491          MOVE.B      #14,D0              ;set for task to display null terminated 
000021D4  4E4F                    2492          TRAP        #15                 ;string without CR, LF
000021D6                          2493  
000021D6  548B                    2494          ADDA.L      #word,A3
000021D8                          2495          
000021D8                          2496          ;print long (A3)
000021D8                          2497          ;MOVE.L      A3,(A1)
000021D8                          2498          ;MOVE.B      #14,D0              ;set for task to display null terminated 
000021D8                          2499          ;TRAP        #15                 ;string without CR, LF
000021D8                          2500          
000021D8  5887                    2501          ADDI.L      #long,D7
000021DA  6000 0012               2502          BRA         Get_Effective_Address_Exit  ;return
000021DE                          2503                         
000021DE                          2504  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
000021DE                          2505  
000021DE  43F9 00002521           2506          LEA         iData,A1            ;output 'D' for data register
000021E4  103C 000E               2507          MOVE.B      #14,D0              ;set for task to display null terminated 
000021E8  4E4F                    2508          TRAP        #15                 ;string without CR, LF
000021EA                          2509          
000021EA                          2510          *need another input param for size
000021EA  6000 0002               2511          BRA         Get_Effective_Address_Exit  ;return
000021EE                          2512  
000021EE                          2513  invalidEA:
000021EE                          2514  
000021EE                          2515          ;do something
000021EE                          2516   
000021EE                          2517  Get_Effective_Address_Exit:     
000021EE                          2518  
000021EE  4E75                    2519          RTS                             ;return
000021F0                          2520  
000021F0                          2521  
000021F0                          2522  ***assume hex to print is in D3***
000021F0                          2523  ***assume size in D6. 00 = byte, 01 = word, 10 = long
000021F0                          2524  
000021F0= 00000000 00000000 ...   2525  hexoutputbuffer DC.L 0,0,0
000021FC                          2526  
000021FC                          2527  outputHex:
000021FC  48E7 B248               2528          MOVEM.L D0/D2/D3/D6/A1/A4,-(SP)
00002200  49F8 21F0               2529          LEA hexoutputbuffer,A4
00002204  0C06 0001               2530          CMPI.B #1,D6
00002208  6D00 006A               2531          BLT hexByte
0000220C  6700 004C               2532          BEQ hexWord
00002210  6E00 0016               2533          BGT hexLong
00002214                          2534  outputHexDone:
00002214  18BC 0000               2535          MOVE.B #0,(A4)
00002218                          2536          
00002218                          2537          ;output string of hex
00002218  103C 000E               2538          MOVE.B #14,D0
0000221C  43F8 21F0               2539          LEA hexoutputbuffer,A1
00002220  4E4F                    2540          TRAP #15
00002222  4CDF 124D               2541          MOVEM.L (SP)+ ,D0/D2/D3/D6/A1/A4
00002226  4E75                    2542          RTS
00002228                          2543          
00002228                          2544  hexLong:
00002228  E99B                    2545          ROL.L #4,D3
0000222A  6100 0056               2546          BSR convertHexToASCII
0000222E  E99B                    2547          ROL.L #4,D3
00002230  6100 0050               2548          BSR convertHexToASCII
00002234  E99B                    2549          ROL.L #4,D3
00002236  6100 004A               2550          BSR convertHexToASCII
0000223A  E99B                    2551          ROL.L #4,D3
0000223C  6100 0044               2552          BSR convertHexToASCII
00002240  E99B                    2553          ROL.L #4,D3
00002242  6100 003E               2554          BSR convertHexToASCII
00002246  E99B                    2555          ROL.L #4,D3
00002248  6100 0038               2556          BSR convertHexToASCII
0000224C  E99B                    2557          ROL.L #4,D3
0000224E  6100 0032               2558          BSR convertHexToASCII
00002252  E99B                    2559          ROL.L #4,D3
00002254  6100 002C               2560          BSR convertHexToASCII
00002258                          2561          
00002258  60BA                    2562          BRA outputHexDone
0000225A                          2563          
0000225A                          2564  hexWord:
0000225A  E95B                    2565          ROL.W #4,D3
0000225C  6100 0024               2566          BSR convertHexToASCII
00002260  E95B                    2567          ROL.W #4,D3
00002262  6100 001E               2568          BSR convertHexToASCII
00002266  E95B                    2569          ROL.W #4,D3
00002268  6100 0018               2570          BSR convertHexToASCII
0000226C  E95B                    2571          ROL.W #4,D3
0000226E  6100 0012               2572          BSR convertHexToASCII
00002272                          2573  
00002272  60A0                    2574          BRA outputHexDone
00002274                          2575          
00002274                          2576  hexByte:
00002274  E91B                    2577          ROL.B #4,D3
00002276  6100 000A               2578          BSR convertHexToASCII
0000227A  E91B                    2579          ROL.B #4,D3
0000227C  6100 0004               2580          BSR convertHexToASCII
00002280                          2581          
00002280  6092                    2582          BRA outputHexDone
00002282                          2583          
00002282                          2584  convertHexToASCII:
00002282  1403                    2585          MOVE.B D3,D2
00002284  0202 000F               2586          ANDI.B #%00001111,D2 ;mask out all but hex at least significant nyb
00002288  0C02 0009               2587          CMPI.B #9,D2
0000228C  6F00 0006               2588          BLE Number
00002290  6000 000A               2589          BRA Letter       
00002294                          2590  
00002294                          2591  Number:
00002294  0602 0030               2592          ADDI.B #'0',D2
00002298  18C2                    2593          MOVE.B D2,(A4)+
0000229A  4E75                    2594          RTS
0000229C                          2595          
0000229C                          2596  Letter:
0000229C  0402 000A               2597          SUBI.B #$A,D2
000022A0  0602 0041               2598          ADDI.B #'A',D2
000022A4  18C2                    2599          MOVE.B D2,(A4)+
000022A6  4E75                    2600          RTS
000022A8                          2601  
000022A8                          2602  
000022A8                          2603  
000022A8                          2604  switchModeAndReg:
000022A8                          2605  ***
000022A8                          2606  * Assumed in D2
000022A8                          2607  *
000022A8                          2608  * Assumed that they are in least significant byte:
000022A8                          2609  *
000022A8                          2610  *            _this_
000022A8                          2611  *           /      \
000022A8                          2612  *  ........ ........
000022A8                          2613  *  \                /
000022A8                          2614  *   -----word-------
000022A8                          2615  *
000022A8                          2616  *  and that in that byte they are ordered:
000022A8                          2617  *
000022A8                          2618  *       ........   
000022A8                          2619  *       \/\_/\_/
000022A8                          2620  *      /  /    \
000022A8                          2621  *    /   /      \
000022A8                          2622  * dont  one    other
000022A8                          2623  * care
000022A8                          2624  *
000022A8                          2625  * after they will be
000022A8                          2626  *
000022A8                          2627  *       ........   
000022A8                          2628  *       \/\_/\_/
000022A8                          2629  *      /  /    \
000022A8                          2630  *    /   /      \
000022A8                          2631  * dont other    one
000022A8                          2632  * care
000022A8                          2633  *** 
000022A8  0202 003F               2634          AndI.B #%00111111,D2 ;remove unwanted bits from D2
000022AC  0283 00000000           2635          ANDI.L #0,D3 ;clear D3
000022B2  1602                    2636          MOVE.B D2,D3 ;copy to D3
000022B4  E70B                    2637          LSL.B  #3,D3 
000022B6  E60A                    2638          LSR.B  #3,D2
000022B8  D403                    2639          ADD.B  D3,D2
000022BA  4E75                    2640          RTS
000022BC                          2641  
000022BC                          2642          
000022BC                          2643  *==============================================================================
000022BC                          2644  *                            variables and constants
000022BC                          2645  *==============================================================================
000022BC                          2646  
000022BC                          2647  
000022BC                          2648  ***initial user prompt stuff        
000022BC= 45 6E 74 65 72 20 ...   2649  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE: $',0
000022ED= 45 6E 74 65 72 20 ...   2650  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE: $',0
0000231C                          2651  
0000231C= 20 41 64 64 72 65 ...   2652  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
00002361= 20 41 20 43 68 61 ...   2653  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
000023A9                          2654  
000023A9= 20 59 6F 75 20 6D ...   2655  even_msg        DC.B    ' You must enter an even address!'
000023C9                          2656  
000023C9= 20                      2657  spc             DC.B    ' '
000023CA= 01                      2658  spc_len         DC.B    spc_len-spc
000023CB                          2659  ***
000023CB                          2660  
000023CB                          2661  
000023CB                          2662  
000023CB                          2663  ***list of OP codes
000023CB                          2664  
000023CB  =000041C0               2665  leaInstruction   EQU %0100000111000000
000023CB  =000081C0               2666  divsInstruction  EQU %1000000111000000
000023CB  =0000C1C0               2667  mulsInstruction  EQU %1100000111000000
000023CB  =0000E6C0               2668  rsrlweaInstruction  EQU %1110011011000000
000023CB  =0000E018               2669  rsrlregInstruction  EQU %1110000000011000
000023CB  =0000E0C0               2670  asrlweaInstruction  EQU %1110000011000000
000023CB  =0000E000               2671  asrlregInstruction  EQU %1110000000000000
000023CB  =0000E2C0               2672  lsrlweaInstruction  EQU %1110001011000000
000023CB  =0000E008               2673  lsrlregInstruction  EQU %1110000000001000
000023CB  =00005100               2674  subqInstruction  EQU %0101000100000000
000023CB  =00009000               2675  subInstruction   EQU %1001000000000000
000023CB  =0000D000               2676  addaInstruction  EQU %1101000000000000
000023CB  =0000D000               2677  addInstruction   EQU %1101000000000000
000023CB  =00004880               2678  movemInstruction EQU %0100100010000000
000023CB  =00000600               2679  addiInstruction  EQU %0000011000000000
000023CB  =00000000               2680  oriInstruction   EQU 0
000023CB  =00000C00               2681  cmpiInstruction  EQU %0000110000000000
000023CB  =00004E80               2682  jsrInstruction   EQU %0100111010000000
000023CB  =00004E75               2683  rtsInstruction   EQU %0100111001110101
000023CB  =00004E71               2684  NoOpInstruction  EQU %0100111001110001
000023CB  =00000000               2685  moveInstruction  EQU 0
000023CB  =00006000               2686  bccInstruction   EQU %0110000000000000
000023CB  =00004400               2687  negInstruction   EQU %0100010000000000
000023CB  =00000000               2688  dataInstruction  EQU 0
000023CB                          2689  
000023CB                          2690  ***
000023CB                          2691  
000023CB                          2692  ***list of OP masks
000023CB                          2693  
000023CB  =0000F1C0               2694  leaMask   EQU %1111000111000000
000023CB  =0000F1C0               2695  divsMask  EQU %1111000111000000
000023CB  =0000F1C0               2696  mulsMask  EQU %1111000111000000
000023CB  =0000FEC0               2697  rsrlweaMask  EQU %1111111011000000
000023CB  =0000F018               2698  rsrlregMask  EQU %1111000000011000
000023CB  =0000FEC0               2699  asrlweaMask  EQU %1111111011000000
000023CB  =0000F018               2700  asrlregMask  EQU %1111000000011000
000023CB  =0000FEC0               2701  lsrlweaMask  EQU %1111111011000000
000023CB  =0000F018               2702  lsrlregMask  EQU %1111000000011000
000023CB  =0000F100               2703  subqMask  EQU %1111000100000000
000023CB  =0000F000               2704  subMask   EQU %1111000000000000
000023CB  =0000F000               2705  addaMask  EQU %1111000000000000
000023CB  =0000F000               2706  addMask   EQU %1111000000000000
000023CB  =0000FB80               2707  movemMask EQU %1111101110000000
000023CB  =0000FF00               2708  addiMask  EQU %1111111100000000
000023CB  =0000FF00               2709  oriMask   EQU %1111111100000000
000023CB  =0000FF00               2710  cmpiMask  EQU %1111111100000000
000023CB  =0000FFC0               2711  jsrMask   EQU %1111111111000000
000023CB  =0000FFFF               2712  rtsMask   EQU $FFFF
000023CB  =0000FFFF               2713  NoOpMask  EQU $FFFF
000023CB  =0000C000               2714  moveMask  EQU $C000
000023CB  =0000F000               2715  bccMask   EQU $F000
000023CB  =0000FF00               2716  negMask   EQU $FF00
000023CB  =00000000               2717  dataMask  EQU 0
000023CB                          2718  ***
000023CB                          2719  
000023CB                          2720  ***Bcc Codes***
000023CB  =00000004               2721  CC EQU $04
000023CB  =00000005               2722  CS EQU $05
000023CB  =00000007               2723  EQ EQU $07
000023CB  =0000000C               2724  GE EQU $0C
000023CB  =0000000E               2725  GT EQU $0E
000023CB  =00000002               2726  HI EQU $02
000023CB  =0000000F               2727  LE EQU $0F
000023CB  =00000003               2728  LS EQU $03
000023CB  =0000000D               2729  LT EQU $0D
000023CB  =0000000B               2730  MI EQU $0B
000023CB  =00000006               2731  NE EQU $06
000023CB  =0000000A               2732  PL EQU $0A
000023CB  =00000008               2733  VC EQU $08
000023CB  =00000009               2734  VS EQU $09
000023CB  =00000000               2735  RA EQU $00 ;not really a Condition Code
000023CB  =00000001               2736  SR EQU $01 ;not really a Condition Code
000023CB                          2737  
000023CB= 43 43 20 00             2738  CCm DC.B 'CC ',0
000023CF= 43 53 20 00             2739  CSm DC.B 'CS ',0
000023D3= 45 51 20 00             2740  EQm DC.B 'EQ ',0
000023D7= 47 45 20 00             2741  GEm DC.B 'GE ',0
000023DB= 47 54 20 00             2742  GTm DC.B 'GT ',0
000023DF= 48 49 20 00             2743  HIm DC.B 'HI ',0
000023E3= 4C 45 20 00             2744  LEm DC.B 'LE ',0
000023E7= 4C 53 20 00             2745  LSm DC.B 'LS ',0
000023EB= 4C 54 20 00             2746  LTm DC.B 'LT ',0
000023EF= 4D 49 20 00             2747  MIm DC.B 'MI ',0
000023F3= 4E 45 20 00             2748  NEm DC.B 'NE ',0
000023F7= 50 4C 20 00             2749  PLm DC.B 'PL ',0
000023FB= 56 43 20 00             2750  VCm DC.B 'VC ',0
000023FF= 56 53 20 00             2751  VSm DC.B 'VS ',0
00002403= 52 41 20 00             2752  RAm DC.B 'RA ',0
00002407= 53 52 20 00             2753  SRm DC.B 'SR ',0
0000240B                          2754  
0000240B= 01 04 05 07 0C 0E ...   2755  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
0000241C= 00002407 000023CB ...   2756  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
0000245C                          2757  ***
0000245C                          2758  
0000245C= 45 6E 74 65 72 20 ...   2759  startLocationPrompt DC.B    'Enter start location',0
00002471= 45 6E 74 65 72 20 ...   2760  endLocationPrompt   DC.B    'Enter end location',0
00002484                          2761  
00002484= 0D 0A 00                2762  clearLine  DC.B $0D,$0A,0
00002487                          2763  
00002487= 4C 45 41 20 00          2764  leaMessage      DC.B 'LEA ',0
0000248C= 44 49 56 53 20 00       2765  divsMessage     DC.B 'DIVS ',0
00002492= 4D 55 4C 53 20 00       2766  mulsMessage     DC.B 'MULS ',0
00002498= 52 4F 4C 20 00          2767  rslMessage      DC.B 'ROL ',0
0000249D= 52 4F 52 20 00          2768  rsrMessage      DC.B 'ROR ',0
000024A2= 41 53 4C 20 00          2769  aslMessage      DC.B 'ASL ',0
000024A7= 41 53 52 20 00          2770  asrMessage      DC.B 'ASR ',0
000024AC= 4C 53 4C 20 00          2771  lslMessage      DC.B 'LSL ',0
000024B1= 4C 53 52 20 00          2772  lsrMessage      DC.B 'LSR ',0
000024B6= 53 55 42 51 20 00       2773  subqMessage     DC.B 'SUBQ ',0
000024BC= 53 55 42 20 00          2774  subMessage      DC.B 'SUB ',0 
000024C1= 41 44 44 41 20 00       2775  addaMessage     DC.B 'ADDA ',0
000024C7= 41 44 44 20 00          2776  addMessage      DC.B 'ADD ',0
000024CC= 4D 4F 56 45 4D 20 00    2777  movemMessage    DC.B 'MOVEM ',0
000024D3= 41 44 44 49 20 00       2778  addiMessage     DC.B 'ADDI ',0
000024D9= 4F 52 49 20 00          2779  oriMessage      DC.B 'ORI ',0
000024DE= 43 4D 50 49 20 00       2780  cmpiMessage     DC.B 'CMPI ',0
000024E4= 4A 53 52 20 00          2781  jsrMessage      DC.B 'JSR ',0
000024E9= 52 54 53 20 00          2782  rtsMessage      DC.B 'RTS ',0
000024EE= 4E 4F 50 20 00          2783  nopMessage      DC.B 'NOP ',0 
000024F3= 4D 4F 56 45 20 00       2784  moveMessage     DC.B 'MOVE ',0
000024F9= 42 00                   2785  bccMessage      DC.B 'B',0
000024FB= 4E 45 47 20 00          2786  negMessage      DC.B 'NEG ',0
00002500= 44 41 54 41 20 00       2787  dataMessage     DC.B 'DATA ',0
00002506= 4D 4F 56 45 41 20 00    2788  moveaMessage    DC.B 'MOVEA ',0
0000250D                          2789  
0000250D= 28 78 78 78 29 2E ...   2790  xxxW            DC.B '(xxx).W: ',0
00002517= 28 78 78 78 29 2E ...   2791  xxxL            DC.B '(xxx).L: ',0
00002521= 23 28 64 61 74 61 ...   2792  iData           DC.B '#(data): ',0
0000252B                          2793  
0000252B= 41 00                   2794  letterA         DC.B 'A', 0
0000252D= 44 00                   2795  letterD         DC.B 'D', 0
0000252F                          2796  
0000252F= 2B 00                   2797  plus            DC.B '+', 0
00002531= 2D 00                   2798  minus           DC.B '-', 0
00002533= 28 00                   2799  lPrn            DC.B '(', 0
00002535= 29 00                   2800  rPrn            DC.B ')', 0
00002537                          2801  
00002537                          2802  
00002538= 00000000                2803  startLocation       DC.L    0
0000253C= 00000000                2804  endLocation         DC.L    0
00002540                          2805  
00002540                          2806  
00002540                          2807     
00002540                          2808      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 189E
ADDA                1800
ADDABODY            1848
ADDAINSTRUCTION     D000
ADDAMASK            F000
ADDAMESSAGE         24C1
ADDDEST             1962
ADDDESTEA           1892
ADDDESTEAMASKS      1898
ADDI                1AD0
ADDIBODY            1AFC
ADDIDONE            1B3A
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         24D3
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          24C7
ADDRESS_DONE        1F62
ADDRESS_EXIT        1F5C
ADDR_ABS_LONG       21CA
ADDR_ABS_SHORT      21B0
ADDR_IMMEDIATE_DATA  21DE
ADDR_REG_DIRECT     20E8
ADDR_REG_INDIRECT   2102
ADDR_REG_INDIRECT_DEC  2172
ADDR_REG_INDIRECT_INC  2134
ADDSOURCE           191A
ASLEA               146A
ASLMESSAGE          24A2
ASLREG              14B0
ASREA               145A
ASRLREG             147A
ASRLREGINSTRUCTION  E000
ASRLREGMASK         F018
ASRLWEA             141A
ASRLWEACHECKDIRECTION  1446
ASRLWEAINSTRUCTION  E0C0
ASRLWEAMASK         FEC0
ASRMESSAGE          24A7
ASRREG              14A0
BCC                 1E16
BCCBYTE             1E68
BCCDONE             1E7E
BCCINSTRUCTION      6000
BCCLIST             240B
BCCLONG             1E76
BCCMASK             F000
BCCMESSAGE          24F9
BCCWORD             1E6E
BEGIN               5001
BEGIN_ADDRESS       1EEE
BYTE                1
CC                  4
CCM                 23CB
CHECKCC             1E2C
CHECKMOVEADEST      1DC2
CHECKMOVEDEST       1D10
CHECKOPCODE         1072
CK_ADDR_DONE        2072
CK_ADDR_RANGE       2046
CK_ADDR_RANGE_ERROR  2062
CK_BOUNDRY          1F8A
CK_BOUNDRY_ERROR    1FAC
CK_SIZE_ERROR       1FC0
CLEARLINE           2484
CMPI                1BD2
CMPIBODY            1BFA
CMPIDONE            1C38
CMPIEA              1BC4
CMPIEAMASKS         1BCB
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         24DE
CONDITIONCODEMESSAGE  241C
CONVERTHEXTOASCII   2282
CS                  5
CSM                 23CF
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         2500
DATA_REG_DIRECT     20CE
DIVS                1280
DIVSBODY            12AC
DIVSINSTRUCTION     81C0
DIVSMASK            F1C0
DIVSMESSAGE         248C
ELPROMPT            22ED
END                 FFFFFE
ENDLOCATION         253C
ENDLOCATIONPROMPT   2471
END_ADDRESS         1F32
ENTER_ADDR_EDIT_ALL  1F64
ENTER_ADDR_EDIT_ALL_EXIT  1F88
EQ                  7
EQM                 23D3
EVEN_MSG            23A9
FALSEPOSITIVE       1092
FARLABEL            FFE
FIN                 1EEA
FOUNDCC             1E3E
GE                  C
GEM                 23D7
GET_EFFECTIVE_ADDRESS  2076
GET_EFFECTIVE_ADDRESS_EXIT  21EE
GET_EFFECTIVE_ADDRESS_OTHER  20B2
GT                  E
GTM                 23DB
HANDLEBYTEDATA      1EBE
HEXBYTE             2274
HEXLONG             2228
HEXOUTPUTBUFFER     21F0
HEXWORD             225A
HEX_RANGE_ERROR     202E
HI                  2
HIM                 23DF
IDATA               2521
INSTLABELLIST       1118
INSTLABELLIST2      1120
INSTMASKLIST        10E8
INSTOPLIST          10B8
INSTOPLIST2         10CA
INVALIDEA           21EE
INVALIDMSG          231C
INVCHARMSG          2361
JSR                 1C50
JSRBODY             1C78
JSRDONE             1C98
JSREA               1C48
JSREAMASKS          1C4C
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          24E4
LCASEHEX            2010
LE                  F
LEA                 120E
LEABODY             1236
LEAEA               1206
LEAEAMASKS          120A
LEAINSTRUCTION      41C0
LEAMASK             F1C0
LEAMESSAGE          2487
LEM                 23E3
LETTER              229C
LETTERA             252B
LETTERD             252D
LONG                4
LPRN                2533
LS                  3
LSLEA               1518
LSLMESSAGE          24AC
LSLREG              1582
LSM                 23E7
LSREA               1508
LSRLCHECKI          15EA
LSRLCHECKIR         15D4
LSRLCHECKIRRETURN   15E8
LSRLCHECKR          161E
LSRLEA              14C0
LSRLEAMASKS         14C6
LSRLREG             154C
LSRLREGBODY         1592
LSRLREGINSTRUCTION  E008
LSRLREGMASK         F018
LSRLWEA             14CC
LSRLWEABODY         1528
LSRLWEACHECKDIRECTION  14F4
LSRLWEAINSTRUCTION  E2C0
LSRLWEAMASK         FEC0
LSRMESSAGE          24B1
LSRREG              1572
LT                  D
LTM                 23EB
MAIN_LOOP           1026
MATCH               1098
MI                  B
MIM                 23EF
MINUS               2531
MOVE                1CE8
MOVEA               1D9A
MOVEABODY           1DF0
MOVEADESTEA         1D96
MOVEADESTEAMASKS    1D98
MOVEAMESSAGE        2506
MOVEBODY            1D3E
MOVEDESTEA          1CDA
MOVEDESTEAMASKS     1CE1
MOVEINSTRUCTION     0
MOVEM               19BE
MOVEMASK            C000
MOVEMBODY           1A28
MOVEMESSAGE         24F3
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     19B4
MOVEMMEMTOREGEAMASKS  19B9
MOVEMMESSAGE        24CC
MOVEMREGTOMEMEA     19AA
MOVEMREGTOMEMEAMASKS  19AF
MOVESOURCEEA        1CC8
MOVESOURCEEAMASKS   1CD1
MULS                1304
MULSBODY            132C
MULSEA              12F4
MULSEAMASKS         12FC
MULSINSTRUCTION     C1C0
MULSMASK            F1C0
MULSMESSAGE         2492
NE                  6
NEG                 1A6A
NEGBODY             1A92
NEGDONE             1AC0
NEGEA               1A5A
NEGEAMASKS          1A62
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          24FB
NEM                 23F3
NEXTHEX             1FD6
NEXTHEXDONE         2028
NEXTHEXRETURN       2044
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 1CA8
NOPMESSAGE          24EE
NUMBER              2294
ORI                 1B4A
ORIBODY             1B76
ORIDONE             1BB4
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          24D9
OUTPUTHEX           21FC
OUTPUTHEXDONE       2214
PARSEHEXSTRING      1FD4
PL                  A
PLM                 23F7
PLUS                252F
PRGORG              1000
PROCESS_OP_CODES    2074
PROCESS_OP_CODES_EXIT  2074
PROMPT_USER         1014
RA                  0
RAM                 2403
RPRN                2535
RSLEA               13C4
RSLMESSAGE          2498
RSLREG              140A
RSREA               13B4
RSRLREG             13D4
RSRLREGINSTRUCTION  E018
RSRLREGMASK         F018
RSRLWEA             1374
RSRLWEACHECKDIRECTION  13A0
RSRLWEAINSTRUCTION  E6C0
RSRLWEAMASK         FEC0
RSRMESSAGE          249D
RSRREG              13FA
RTS                 1CB8
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          24E9
SLPROMPT            22BC
SNIPPET             1178
SNIPPETEND          1202
SPC                 23C9
SPC_LEN             23CA
SR                  1
SRM                 2407
STACK               5000
START               1000
STARTLOCATION       2538
STARTLOCATIONPROMPT  245C
SUB                 16F0
SUBDEST             17B8
SUBINSTRUCTION      9000
SUBMASK             F000
SUBMESSAGE          24BC
SUBQ                1648
SUBQBODY            1680
SUBQEA              1638
SUBQEAMASKS         1640
SUBQINSTRUCTION     5100
SUBQMASK            F100
SUBQMESSAGE         24B6
SUBSOURCE           1770
SWITCHMODEANDREG    22A8
TOEIGHT             16EC
UCASEHEX            1FF8
UNKNOWNOPCODE       1E98
VALIDADDA           181E
VALIDADDDESTEA      18EE
VALIDADDIMODES      1AD2
VALIDADDSOURCEEA    18C4
VALIDASRL           141C
VALIDCMPIMODES      1BD4
VALIDDIVSMODES      1282
VALIDJSRMODES       1C52
VALIDLEAMODES       1210
VALIDLSRL           14CE
VALIDMEMTOREG       19FA
VALIDMOVEADESTMODES  1DC4
VALIDMOVEASOURCEMODES  1D9C
VALIDMOVEDESTMODES  1D12
VALIDMOVESOURCEMODES  1CEA
VALIDMULSMODES      1306
VALIDNEGMODES       1A6C
VALIDORIMODES       1B4C
VALIDREGTOMEM       19D4
VALIDRSRL           1376
VALIDSUBDESTEA      1740
VALIDSUBQ           165A
VALIDSUBSOURCEEA    1716
VC                  8
VCM                 23FB
VS                  9
VSM                 23FF
WORD                2
XXXL                2517
XXXW                250D
ZEROTOEIGHT         16E2
ZEROTOEIGHTRETURN   16EA

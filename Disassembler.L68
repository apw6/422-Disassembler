00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/8/2014 12:52:44 PM

00000000                             1  *##########################################################################
00000000                             2  * Title      : 
00000000                             3  * Written by : Andrew Watson
00000000                             4  *            : Elaine Keller
00000000                             5  *            : Robert Anderson
00000000                             6  * Date       : 11/14/2014
00000000                             7  * Description: 
00000000                             8  *##########################################################################
00000000                             9  
00000000                            10  ***Possible Bug***
00000000                            11  *can not tell data from an
00000000                            12  *unidentified instruction from an actual
00000000                            13  *instruction therefore causing errors.
00000000                            14  *may not actually be a bug because data
00000000                            15  *is data to the machine, and if you modify
00000000                            16  *the instructions in memory for a program
00000000                            17  *by moivng data, you can modify the instuctions
00000000                            18  *executed.
00000000                            19  
00000000                            20  
00000000                            21  ***************************************************************************
00000000                            22  *                   Variable/Data Definitions
00000000                            23  ***************************************************************************
00000000                            24  
00000000  =00005000                 25  stack   EQU   $00005000
00000000  =00005001                 26  begin   EQU   $00005001
00000000  =00FFFFFE                 27  end     EQU   $00FFFFFE
00000000  =00000001                 28  byte    EQU   1
00000000  =00000002                 29  word    EQU   2
00000000  =00000004                 30  long    EQU   4
00000000  =00001000                 31  prgorg  EQU   $1000
00000000                            32  
00000FFE                            33      ORG $00000FFE
00000FFE                            34  FarLabel:
00001000                            35      ORG    prgorg
00001000                            36  start:
00001000  4FF8 5000                 37          LEA stack, SP ;initialize stack
00001004                            38  
00001000                            39      ORG    prgorg
00001000                            40  
00001000                            41  ******************************************************************************
00001000                            42  *                   Begin processing active code
00001000                            43  ******************************************************************************
00001000                            44      
00001000                            45  start:
00001000                            46  
00001000  4FF8 5000                 47          LEA         stack, SP           ;Initialize stack
00001004                            48          
00001004                            49  *.............................................................................
00001004                            50  * Debug Mode - Comment out when done
00001004  267C 0000110E             51          MOVE.L      #snippet,A3
0000100A  287C 0000114E             52          MOVE.L      #snippetEnd,A4
00001010  6000 0014                 53          BRA         main_Loop
00001014                            54  * Debug Mode - Comment out when done
00001014                            55  *.............................................................................        
00001014                            56          
00001014                            57  prompt_user:
00001014                            58  
00001014  6100 09F2                 59          BSR         begin_address
00001018  B67C FFFF                 60          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000101C  6700 09E6                 61          BEQ         fin                 ;Yes, then exit
00001020                            62          
00001020  6000 0004                 63          BRA         main_Loop
00001024                            64          ;BSR         process_op_codes
00001024  60EE                      65          BRA         prompt_user
00001026                            66                  
00001026                            67  ******************************************************************************
00001026                            68  *                   Begin processing OP Codes
00001026                            69  ******************************************************************************
00001026                            70   
00001026                            71  main_Loop:
00001026                            72  
00001026  B9CB                      73          CMPA.L A3,A4 ;check end of prog
00001028  6700 09DA                 74          BEQ fin
0000102C                            75          
0000102C  3213                      76          MOVE.W (A3),D1 ;copy word from other prog to analyze as instruction
0000102E                            77          
0000102E                            78          ;handle an odd memory access(instructions will never be misaligned)
0000102E  240B                      79          MOVE.L A3,D2 ; copy address to D2
00001030  0202 0001                 80          ANDI.B #%00000001,D2 ;mask everything except the least significant bit
00001034  0C02 0001                 81          CMPI.B #1,D2 ;compare the least sig bit of the address to one
00001038  6700 099E                 82          BEQ handlebytedata ;the least sig bit will only be one if the insrtuction
0000103C                            83                             ;is odd(misaligned) and therefore not an instruction
0000103C                            84          
0000103C  7600                      85          MOVEQ.L #0,D3
0000103E                            86          
0000103E                            87          ***things to save A3,A4,D1(?)***
0000103E  48E7 0018                 88          MOVEM.L A3-A4,-(SP)
00001042  6100 000C                 89          BSR checkOPcode
00001046  4CDF 1800                 90          MOVEM.L (SP)+,A3-A4
0000104A  D7C7                      91          ADDA.L  D7,A3 ;look past data that was part of the instruction
0000104C                            92          
0000104C  548B                      93          ADDQ.L  #word,A3
0000104E  60D6                      94          BRA     main_Loop 
00001050                            95          
00001050                            96  checkOPcode:
00001050                            97  
00001050                            98  
00001050  7E00                      99          MOVEQ.L #0,D7
00001052                           100          
00001052  41F9 00001096            101          LEA     instOPList,A0 ;get instruction signitrue list in A0
00001058  D1C3                     102          ADDA.L  D3,A0 ;get correct sig         
0000105A                           103          
0000105A  43F9 000010B4            104          LEA     instMaskList,A1 ;get instruction mask in A1
00001060  D3C3                     105          ADDA.L  D3,A1  ;get correct mast
00001062                           106          
00001062  3401                     107          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001064                           108          
00001064  C451                     109          AND.W   (A1),D2 ;mask instruction
00001066                           110          
00001066                           111          
00001066                           112          
00001066                           113          
00001066  B450                     114          CMP.W   (A0),D2 ;compare to sig
00001068  6700 000C                115          BEQ     match ;if sig matches branch
0000106C  5483                     116          ADDQ.L  #word,D3 ;add to D3 to check for next instruction
0000106E  60E0                     117          BRA checkOPcode
00001070                           118          
00001070                           119  falsePositive:
00001070                           120          
00001070  103C 00FF                121          MOVE.B #-1,D0
00001074  4E75                     122          RTS
00001076                           123  
00001076                           124  match:
00001076                           125          
00001076  43F9 000010D2            126          LEA     instLabelList,A1 ;get instruction code label
0000107C  D3C3                     127          ADDA.L  D3,A1 ;get correct label
0000107E  D3C3                     128          ADDA.L  D3,A1
00001080  5483                     129          ADDQ.L  #word,D3 ;add to D3 incase false positive
00001082  2251                     130          MOVEA.L (A1),A1
00001084  48E7 1000                131          MOVEM.L D3,-(SP) ; save D3
00001088  4E91                     132          JSR     (A1)
0000108A  4CDF 0008                133          MOVEM.L (SP)+,D3 ;restore D3
0000108E  B03C 00FF                134          CMP.B   #-1,D0
00001092  67BC                     135          BEQ     checkOPcode
00001094  4E75                     136          RTS
00001096                           137          
00001096                           138  
00001096= 5100 9000 D000 D...      139  instOPList DC.W subqInstruction,subInstruction,addaInstruction,addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstructi
000010B4                           140     
000010B4= F100 F000 F000 F...      141  instMaskList DC.W subqMask,subMask,addaMask,addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
000010D2= 00001162 0000120A ...    142  instLabelList DC.L SUBQ,SUB,ADDA,ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
0000110E                           143  
0000110E                           144  snippet:
0000110E  4E71                     145           NOP
00001110  60FC                     146           BRA snippet
00001112  6000 FEEA                147           BRA FarLabel
00001116  67F6                     148           BEQ snippet
00001118  6E00 046A                149           BGT NEG
0000111C  61F0                     150           BSR snippet
0000111E  4441                     151           NEG D1
00001120  3239 00008500            152           MOVE.W $8500,D1
00001126  0645 001E                153           ADDI.W #30,D5
0000112A  4E75                     154           RTS
0000112C  4EB8 0054                155           JSR $54
00001130  0C41 0003                156           CMPI #3,D1
00001134  0041 0003                157           ORI  #3,D1
00001138  48E7 0018                158           MOVEM.L A3-A4,-(SP)
0000113C  D401                     159           ADD.B D1,D2
0000113E  0603 000A                160           ADD.B #10,D3
00001142  D7FC 00000463            161           ADDA.L #1123,A3
00001148  9A43                     162           SUB.W D3,D5
0000114A  5105                     163           SUBQ.B #8,D5
0000114C  5305                     164           SUBQ.B #1,D5
0000114E                           165  
0000114E                           166           
0000114E                           167  snippetEnd:
0000114E  FFFF FFFF                168           SIMHALT
00001152                           169  
00001152= 00 08 10 18 20 38 ...    170  subqEA        DC.B %000000,%001000,%010000,%011000,%100000,%111000,%111001,0
0000115A= 38 38 38 38 38 3F ...    171  subqEAmasks   DC.B %111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001162                           172  
00001162                           173  SUBQ:
00001162                           174          
00001162                           175  
00001162                           176          
00001162  7000                     177          MOVEQ.L #0, D0 ;clear D0
00001164                           178          
00001164                           179          ;check valid size field
00001164  3401                     180          MOVE.W D1,D2 ;copy inst to D2
00001166  EC4A                     181          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
00001168  0202 0003                182          ANDI.B #%00000011,D2 ;mask out rest of byte
0000116C  0C02 0003                183          CMPI.B #%11,D2 ;compare to 3
00001170  6700 FEFE                184          BEQ falsePositive ;invalid size
00001174                           185          
00001174                           186  validSubq:
00001174                           187          
00001174  43F8 115A                188          LEA subqEAmasks,A1 ;load the list of masks
00001178  D3C0                     189          ADDA.L D0,A1 ;displace to a specific mask
0000117A  1A11                     190          MOVE.B (A1),D5 ;move the mask to D5
0000117C                           191          
0000117C  0C05 0000                192          CMPI.B #0,D5 ;check if the mask is 0
00001180  6700 FEEE                193          BEQ falsePositive ;branch if it is
00001184                           194          
00001184  1401                     195          MOVE.B D1,D2 ;copy instruction to D2
00001186  C405                     196          AND.B D5,D2  ;mask D2
00001188                           197          
00001188  43F8 1152                198          LEA subqEA,A1 ;load the list of valid modes
0000118C  D3C0                     199          ADDA.L D0,A1 ;displace to a specific mode
0000118E  1811                     200          MOVE.B (A1),D4 ;move mode to D4
00001190  B404                     201          CMP.B D4,D2 ;compare mode to masked value
00001192  6700 0006                202          BEQ  subqBody ;if its match, its a valid mode and we can procede
00001196                           203          
00001196  5280                     204          ADDQ.L #1,D0 ;add one to displacement
00001198  60DA                     205          BRA validSubq ;check for next mode
0000119A                           206          
0000119A                           207          
0000119A                           208  subqBody
0000119A                           209  
0000119A  43F9 00001EE3            210          LEA     subqMessage,A1  ;move string for MOVE
000011A0  103C 000E                211          MOVE.B  #14,D0        ;set for task to display null terminated 
000011A4                           212                                ;string with CR, LF
000011A4  4E4F                     213          TRAP    #15
000011A6                           214          
000011A6                           215          ;immediate data
000011A6                           216          
000011A6                           217          ;print '#'
000011A6  48E7 4000                218          MOVEM.L D1,-(SP) ;save D1 to the stack
000011AA  123C 0023                219          MOVE.B #'#',D1 ;put ascii value of '#' in D1
000011AE  103C 0006                220          MOVE.B #6,D0 ;move task 6 into D0
000011B2  4E4F                     221          TRAP #15 ;prin char
000011B4  4CDF 0002                222          MOVEM.L (SP)+,D1 ;pull D1 off the stack
000011B8                           223          
000011B8                           224          ;print number
000011B8  48E7 4000                225          MOVEM.L D1,-(SP)
000011BC  3401                     226          MOVE.W D1,D2 ;copy inst to d2
000011BE  E04A                     227          LSR.W #8,D2 ;shift data section
000011C0  E20A                     228          LSR.B #1,D2
000011C2  C43C 0007                229          AND.B #%00000111,D2 ;mask out rest of data
000011C6  6100 0034                230          BSR ZeroToEight ;handle zero
000011CA  7200                     231          MOVEQ.L #0,D1 ;clear D1
000011CC  1202                     232          MOVE.B D2,D1 ;move number to display into D1
000011CE  103C 0003                233          MOVE.B #3,D0 ;move task 3 to D0
000011D2  4E4F                     234          TRAP #15
000011D4  4CDF 0002                235          MOVEM.L (SP)+,D1
000011D8                           236          
000011D8                           237          ;print separator
000011D8                           238          
000011D8                           239          ;Then do EA
000011D8                           240          
000011D8  3401                     241          MOVE.W  D1,D2 ;check mode
000011DA  C43C 003F                242          AND.B   #%00111111,D2
000011DE  1A02                     243          MOVE.B  D2,D5
000011E0  48E7 4000                244          MOVEM.L D1,-(SP)
000011E4  6100 09AA                245          BSR     Get_Effective_Address
000011E8  4CDF 0002                246          MOVEM.L (SP)+,D1
000011EC                           247          
000011EC  43F9 00001EE0            248          LEA     clearLine,A1  ;move string for a CR and LF
000011F2  103C 000E                249          MOVE.B  #14,D0        ;set for task to display null terminated 
000011F6                           250                                ;string without CR, LF
000011F6  4E4F                     251          TRAP    #15
000011F8                           252  
000011F8  7000                     253          MOVEQ.L #0,D0
000011FA  4E75                     254          RTS
000011FC                           255          
000011FC                           256  ZeroToEight:
000011FC                           257          
000011FC  0C02 0000                258          CMPI.B #0,D2
00001200  6700 0004                259          BEQ toEight
00001204                           260  ZeroToEightReturn:
00001204                           261          
00001204  4E75                     262          RTS
00001206                           263  toEight:
00001206                           264          
00001206  5002                     265          ADDQ.B #8,D2
00001208  60FA                     266          BRA ZeroToEightReturn
0000120A                           267  
0000120A                           268      
0000120A                           269  SUB:
0000120A                           270          
0000120A                           271  
0000120A                           272          
0000120A  7000                     273          MOVEQ.L #0, D0 ;clear D0
0000120C                           274          
0000120C                           275          ;Figure out if EA is source or destination
0000120C  3401                     276          MOVE.W D1,D2 ;copy inst to D2
0000120E  EC4A                     277          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
00001210  0202 0007                278          ANDI.B #%00000111,D2 ;mask out rest of byte
00001214  0C02 0002                279          CMPI.B #2,D2 ;compare to 2
00001218  6F00 0016                280          BLE validSubSourceEA ;2 or less is EA is source
0000121C                           281          
0000121C  0C02 0007                282          CMPI.B #%111,D2 ;compare to 7
00001220  6700 FE4E                283          BEQ falsePositive ;thats not valid
00001224  0C02 0003                284          CMPI.B #%11,D2 ;compare to 3
00001228  6700 FE46                285          BEQ falsePositive ;also not valid
0000122C  6000 002C                286          BRA validSubDestEA ;all thats left is valid EA as Dest 
00001230                           287          
00001230                           288  validSubSourceEA:
00001230                           289          
00001230  43F9 000017EB            290          LEA moveSourceEAmasks,A1 ;load the list of masks
00001236  D3C0                     291          ADDA.L D0,A1 ;displace to a specific mask
00001238  1A11                     292          MOVE.B (A1),D5 ;move the mask to D5
0000123A                           293          
0000123A  0C05 0000                294          CMPI.B #0,D5 ;check if the mask is 0
0000123E  6700 FE30                295          BEQ falsePositive ;branch if it is
00001242                           296          
00001242  1401                     297          MOVE.B D1,D2 ;copy instruction to D2
00001244  C405                     298          AND.B D5,D2  ;mask D2
00001246                           299          
00001246  43F9 000017E2            300          LEA moveSourceEA,A1 ;load the list of valid modes
0000124C  D3C0                     301          ADDA.L D0,A1 ;displace to a specific mode
0000124E  1811                     302          MOVE.B (A1),D4 ;move mode to D4
00001250  B404                     303          CMP.B D4,D2 ;compare mode to masked value
00001252  6700 0036                304          BEQ  subSource ;if its match, its a valid mode and we can procede
00001256                           305          
00001256  5280                     306          ADDQ.L #1,D0 ;add one to displacement
00001258  60D6                     307          BRA validSubSourceEA ;check for next mode
0000125A                           308          
0000125A                           309          
0000125A                           310  validSubDestEA:
0000125A                           311          
0000125A  43F9 000013B2            312          LEA addDestEAmasks,A1 ;load the list of masks
00001260  D3C0                     313          ADDA.L D0,A1 ;displace to a specific mask
00001262  1A11                     314          MOVE.B (A1),D5 ;move the mask to D5
00001264                           315          
00001264  0C05 0000                316          CMPI.B #0,D5 ;check if the mask is 0
00001268  6700 FE06                317          BEQ falsePositive ;branch if it is
0000126C                           318          
0000126C  3401                     319          MOVE.W D1,D2 ;copy instruction to D2
0000126E  EC4A                     320          LSR.W #6,D2  ;move mode
00001270  6100 0A92                321          BSR switchModeAndReg ;switch register and mode
00001274  C405                     322          AND.B D5,D2  ;mask D2
00001276                           323          
00001276  43F9 000013AC            324          LEA addDestEA,A1 ;load the list of valid modes
0000127C  D3C0                     325          ADDA.L D0,A1 ;displace to a specific mode
0000127E  1811                     326          MOVE.B (A1),D4 ;move mode to D4
00001280  B404                     327          CMP.B D4,D2 ;compare mode to masked value
00001282  6700 004E                328          BEQ subDest ;if its match, its a valid mode and we can procede
00001286                           329          
00001286  5280                     330          ADDQ.L #1,D0 ;add one to displacement
00001288  60D0                     331          BRA validSubDestEA ;check for next mode
0000128A                           332          
0000128A                           333  subSource
0000128A                           334  
0000128A  43F9 00001EE9            335          LEA     subMessage,A1  ;move string for MOVE
00001290  103C 000E                336          MOVE.B  #14,D0        ;set for task to display null terminated 
00001294                           337                                ;string with CR, LF
00001294  4E4F                     338          TRAP    #15
00001296                           339          
00001296                           340          ;do EA
00001296                           341          
00001296  3401                     342          MOVE.W  D1,D2 ;check mode
00001298  C43C 003F                343          AND.B   #%00111111,D2
0000129C  1A02                     344          MOVE.B  D2,D5
0000129E  48E7 4000                345          MOVEM.L D1,-(SP)
000012A2  6100 08EC                346          BSR     Get_Effective_Address
000012A6  4CDF 0002                347          MOVEM.L (SP)+,D1
000012AA                           348          
000012AA                           349          ;print separator
000012AA                           350          
000012AA                           351          ;Then do Dn
000012AA                           352          
000012AA  3401                     353          MOVE.W  D1,D2
000012AC  E04A                     354          LSR.W   #8,D2 ;move reg into first byte
000012AE  E20A                     355          LSR.B   #1,D2 ;line it up to least sig bit
000012B0  C43C 0007                356          AND.B   #%00000111,D2 ;force mode to Dn
000012B4  1A02                     357          MOVE.B  D2,D5
000012B6  48E7 4000                358          MOVEM.L D1,-(SP)
000012BA  6100 08D4                359          BSR     Get_Effective_Address
000012BE  4CDF 0002                360          MOVEM.L (SP)+,D1
000012C2                           361          
000012C2  43F9 00001EE0            362          LEA     clearLine,A1  ;move string for a CR and LF
000012C8  103C 000E                363          MOVE.B  #14,D0        ;set for task to display null terminated 
000012CC                           364                                ;string without CR, LF
000012CC  4E4F                     365          TRAP    #15
000012CE                           366  
000012CE  7000                     367          MOVEQ.L #0,D0
000012D0  4E75                     368          RTS
000012D2                           369  
000012D2                           370  subDest
000012D2                           371  
000012D2  43F9 00001EE9            372          LEA     subMessage,A1  ;move string for MOVE
000012D8  103C 000E                373          MOVE.B  #14,D0        ;set for task to display null terminated 
000012DC                           374                                ;string with CR, LF
000012DC  4E4F                     375          TRAP    #15
000012DE                           376          
000012DE                           377          ;Do Dn
000012DE                           378          
000012DE  3401                     379          MOVE.W  D1,D2
000012E0  E04A                     380          LSR.W   #8,D2 ;move reg into first byte
000012E2  E20A                     381          LSR.B   #1,D2 ;line it up to least sig bit
000012E4  C43C 0007                382          AND.B   #%00000111,D2 ;force mode to Dn
000012E8  1A02                     383          MOVE.B  D2,D5
000012EA  48E7 4000                384          MOVEM.L D1,-(SP)
000012EE  6100 08A0                385          BSR     Get_Effective_Address
000012F2  4CDF 0002                386          MOVEM.L (SP)+,D1
000012F6                           387          
000012F6                           388          
000012F6                           389          ;print separator
000012F6                           390          
000012F6                           391          ;Then do EA
000012F6                           392          
000012F6  3401                     393          MOVE.W  D1,D2 ;check mode
000012F8  C43C 003F                394          AND.B   #%00111111,D2
000012FC  1A02                     395          MOVE.B  D2,D5
000012FE  48E7 4000                396          MOVEM.L D1,-(SP)
00001302  6100 088C                397          BSR     Get_Effective_Address
00001306  4CDF 0002                398          MOVEM.L (SP)+,D1
0000130A                           399          
0000130A                           400          
0000130A  43F9 00001EE0            401          LEA     clearLine,A1  ;move string for a CR and LF
00001310  103C 000E                402          MOVE.B  #14,D0        ;set for task to display null terminated 
00001314                           403                                ;string without CR, LF
00001314  4E4F                     404          TRAP    #15
00001316                           405  
00001316  7000                     406          MOVEQ.L #0,D0
00001318  4E75                     407          RTS
0000131A                           408  
0000131A                           409  
0000131A                           410  ADDA:
0000131A                           411          
0000131A                           412  
0000131A                           413          
0000131A  7000                     414          MOVEQ.L #0, D0 ;clear D0
0000131C                           415          
0000131C                           416          ;check opmode field
0000131C  3401                     417          MOVE.W D1,D2 ;copy inst to D2
0000131E  EC4A                     418          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
00001320  0202 0007                419          ANDI.B #%00000111,D2 ;mask out rest of byte
00001324  0C02 0007                420          CMPI.B #%111,D2 ;compare to 7
00001328  6700 000E                421          BEQ validAdda ;thats valid
0000132C  0C02 0003                422          CMPI.B #%11,D2 ;compare to 3
00001330  6700 0006                423          BEQ validAdda ;also valid
00001334  6000 FD3A                424          BRA falsePositive ;all thats left is invalid 
00001338                           425          
00001338                           426  validAdda:
00001338                           427          
00001338  43F9 000017EB            428          LEA moveSourceEAmasks,A1 ;load the list of masks
0000133E  D3C0                     429          ADDA.L D0,A1 ;displace to a specific mask
00001340  1A11                     430          MOVE.B (A1),D5 ;move the mask to D5
00001342                           431          
00001342  0C05 0000                432          CMPI.B #0,D5 ;check if the mask is 0
00001346  6700 FD28                433          BEQ falsePositive ;branch if it is
0000134A                           434          
0000134A  1401                     435          MOVE.B D1,D2 ;copy instruction to D2
0000134C  C405                     436          AND.B D5,D2  ;mask D2
0000134E                           437          
0000134E  43F9 000017E2            438          LEA moveSourceEA,A1 ;load the list of valid modes
00001354  D3C0                     439          ADDA.L D0,A1 ;displace to a specific mode
00001356  1811                     440          MOVE.B (A1),D4 ;move mode to D4
00001358  B404                     441          CMP.B D4,D2 ;compare mode to masked value
0000135A  6700 0006                442          BEQ  addaBody ;if its match, its a valid mode and we can procede
0000135E                           443          
0000135E  5280                     444          ADDQ.L #1,D0 ;add one to displacement
00001360  60D6                     445          BRA validAdda ;check for next mode
00001362                           446          
00001362                           447          
00001362                           448  addaBody
00001362                           449  
00001362  43F9 00001EEE            450          LEA     addaMessage,A1  ;move string for MOVE
00001368  103C 000E                451          MOVE.B  #14,D0        ;set for task to display null terminated 
0000136C                           452                                ;string with CR, LF
0000136C  4E4F                     453          TRAP    #15
0000136E                           454          
0000136E                           455          ;do EA
0000136E                           456          
0000136E  3401                     457          MOVE.W  D1,D2 ;check mode
00001370  C43C 003F                458          AND.B   #%00111111,D2
00001374  1A02                     459          MOVE.B  D2,D5
00001376  48E7 4000                460          MOVEM.L D1,-(SP)
0000137A  6100 0814                461          BSR     Get_Effective_Address
0000137E  4CDF 0002                462          MOVEM.L (SP)+,D1
00001382                           463          
00001382                           464          ;print separator
00001382                           465          
00001382                           466          ;Then do Dn
00001382                           467          
00001382  3401                     468          MOVE.W  D1,D2
00001384  E04A                     469          LSR.W   #8,D2 ;move reg into first byte
00001386  E20A                     470          LSR.B   #1,D2 ;line it up to least sig bit
00001388  C43C 0007                471          AND.B   #%00000111,D2 ;force mode to An
0000138C  5002                     472          ADDI.B  #%00001000,D2 
0000138E  1A02                     473          MOVE.B  D2,D5
00001390  48E7 4000                474          MOVEM.L D1,-(SP)
00001394  6100 07FA                475          BSR     Get_Effective_Address
00001398  4CDF 0002                476          MOVEM.L (SP)+,D1
0000139C                           477          
0000139C  43F9 00001EE0            478          LEA     clearLine,A1  ;move string for a CR and LF
000013A2  103C 000E                479          MOVE.B  #14,D0        ;set for task to display null terminated 
000013A6                           480                                ;string without CR, LF
000013A6  4E4F                     481          TRAP    #15
000013A8                           482  
000013A8  7000                     483          MOVEQ.L #0,D0
000013AA  4E75                     484          RTS
000013AC                           485  
000013AC                           486  
000013AC                           487      
000013AC= 10 18 20 38 39 00        488  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
000013B2= 38 38 38 3F 3F 00        489  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
000013B8                           490  
000013B8                           491  ADD:
000013B8                           492          
000013B8                           493  
000013B8                           494          
000013B8  7000                     495          MOVEQ.L #0, D0 ;clear D0
000013BA                           496          
000013BA                           497          ;Figure out if EA is source or destination
000013BA  3401                     498          MOVE.W D1,D2 ;copy inst to D2
000013BC  EC4A                     499          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
000013BE  0202 0007                500          ANDI.B #%00000111,D2 ;mask out rest of byte
000013C2  0C02 0002                501          CMPI.B #2,D2 ;compare to 2
000013C6  6F00 0016                502          BLE validAddSourceEA ;2 or less is EA is source
000013CA                           503          
000013CA  0C02 0007                504          CMPI.B #%111,D2 ;compare to 7
000013CE  6700 FCA0                505          BEQ falsePositive ;thats not valid
000013D2  0C02 0003                506          CMPI.B #%11,D2 ;compare to 3
000013D6  6700 FC98                507          BEQ falsePositive ;also not valid
000013DA  6000 002C                508          BRA validAddDestEA ;all thats left is valid EA as Dest 
000013DE                           509          
000013DE                           510  validAddSourceEA:
000013DE                           511          
000013DE  43F9 000017EB            512          LEA moveSourceEAmasks,A1 ;load the list of masks
000013E4  D3C0                     513          ADDA.L D0,A1 ;displace to a specific mask
000013E6  1A11                     514          MOVE.B (A1),D5 ;move the mask to D5
000013E8                           515          
000013E8  0C05 0000                516          CMPI.B #0,D5 ;check if the mask is 0
000013EC  6700 FC82                517          BEQ falsePositive ;branch if it is
000013F0                           518          
000013F0  1401                     519          MOVE.B D1,D2 ;copy instruction to D2
000013F2  C405                     520          AND.B D5,D2  ;mask D2
000013F4                           521          
000013F4  43F9 000017E2            522          LEA moveSourceEA,A1 ;load the list of valid modes
000013FA  D3C0                     523          ADDA.L D0,A1 ;displace to a specific mode
000013FC  1811                     524          MOVE.B (A1),D4 ;move mode to D4
000013FE  B404                     525          CMP.B D4,D2 ;compare mode to masked value
00001400  6700 0032                526          BEQ  addSource ;if its match, its a valid mode and we can procede
00001404                           527          
00001404  5280                     528          ADDQ.L #1,D0 ;add one to displacement
00001406  60D6                     529          BRA validAddSourceEA ;check for next mode
00001408                           530          
00001408                           531          
00001408                           532  validAddDestEA:
00001408                           533          
00001408  43F8 13B2                534          LEA addDestEAmasks,A1 ;load the list of masks
0000140C  D3C0                     535          ADDA.L D0,A1 ;displace to a specific mask
0000140E  1A11                     536          MOVE.B (A1),D5 ;move the mask to D5
00001410                           537          
00001410  0C05 0000                538          CMPI.B #0,D5 ;check if the mask is 0
00001414  6700 FC5A                539          BEQ falsePositive ;branch if it is
00001418                           540          
00001418  3401                     541          MOVE.W D1,D2 ;copy instruction to D2
0000141A  EC4A                     542          LSR.W #6,D2  ;move mode
0000141C  6100 08E6                543          BSR switchModeAndReg ;switch register and mode
00001420  C405                     544          AND.B D5,D2  ;mask D2
00001422                           545          
00001422  43F8 13AC                546          LEA addDestEA,A1 ;load the list of valid modes
00001426  D3C0                     547          ADDA.L D0,A1 ;displace to a specific mode
00001428  1811                     548          MOVE.B (A1),D4 ;move mode to D4
0000142A  B404                     549          CMP.B D4,D2 ;compare mode to masked value
0000142C  6700 004E                550          BEQ addDest ;if its match, its a valid mode and we can procede
00001430                           551          
00001430  5280                     552          ADDQ.L #1,D0 ;add one to displacement
00001432  60D4                     553          BRA validAddDestEA ;check for next mode
00001434                           554          
00001434                           555  addSource
00001434                           556  
00001434  43F9 00001EF4            557          LEA     addMessage,A1  ;move string for MOVE
0000143A  103C 000E                558          MOVE.B  #14,D0        ;set for task to display null terminated 
0000143E                           559                                ;string with CR, LF
0000143E  4E4F                     560          TRAP    #15
00001440                           561          
00001440                           562          ;do EA
00001440                           563          
00001440  3401                     564          MOVE.W  D1,D2 ;check mode
00001442  C43C 003F                565          AND.B   #%00111111,D2
00001446  1A02                     566          MOVE.B  D2,D5
00001448  48E7 4000                567          MOVEM.L D1,-(SP)
0000144C  6100 0742                568          BSR     Get_Effective_Address
00001450  4CDF 0002                569          MOVEM.L (SP)+,D1
00001454                           570          
00001454                           571          ;print separator
00001454                           572          
00001454                           573          ;Then do Dn
00001454                           574          
00001454  3401                     575          MOVE.W  D1,D2
00001456  E04A                     576          LSR.W   #8,D2 ;move reg into first byte
00001458  E20A                     577          LSR.B   #1,D2 ;line it up to least sig bit
0000145A  C43C 0007                578          AND.B   #%00000111,D2 ;force mode to Dn
0000145E  1A02                     579          MOVE.B  D2,D5
00001460  48E7 4000                580          MOVEM.L D1,-(SP)
00001464  6100 072A                581          BSR     Get_Effective_Address
00001468  4CDF 0002                582          MOVEM.L (SP)+,D1
0000146C                           583          
0000146C  43F9 00001EE0            584          LEA     clearLine,A1  ;move string for a CR and LF
00001472  103C 000E                585          MOVE.B  #14,D0        ;set for task to display null terminated 
00001476                           586                                ;string without CR, LF
00001476  4E4F                     587          TRAP    #15
00001478                           588  
00001478  7000                     589          MOVEQ.L #0,D0
0000147A  4E75                     590          RTS
0000147C                           591  
0000147C                           592  addDest
0000147C                           593  
0000147C  43F9 00001EF4            594          LEA     addMessage,A1  ;move string for MOVE
00001482  103C 000E                595          MOVE.B  #14,D0        ;set for task to display null terminated 
00001486                           596                                ;string with CR, LF
00001486  4E4F                     597          TRAP    #15
00001488                           598          
00001488                           599          ;Do Dn
00001488                           600          
00001488  3401                     601          MOVE.W  D1,D2
0000148A  E04A                     602          LSR.W   #8,D2 ;move reg into first byte
0000148C  E20A                     603          LSR.B   #1,D2 ;line it up to least sig bit
0000148E  C43C 0007                604          AND.B   #%00000111,D2 ;force mode to Dn
00001492  1A02                     605          MOVE.B  D2,D5
00001494  48E7 4000                606          MOVEM.L D1,-(SP)
00001498  6100 06F6                607          BSR     Get_Effective_Address
0000149C  4CDF 0002                608          MOVEM.L (SP)+,D1
000014A0                           609          
000014A0                           610          
000014A0                           611          ;print separator
000014A0                           612          
000014A0                           613          ;Then do EA
000014A0                           614          
000014A0  3401                     615          MOVE.W  D1,D2 ;check mode
000014A2  C43C 003F                616          AND.B   #%00111111,D2
000014A6  1A02                     617          MOVE.B  D2,D5
000014A8  48E7 4000                618          MOVEM.L D1,-(SP)
000014AC  6100 06E2                619          BSR     Get_Effective_Address
000014B0  4CDF 0002                620          MOVEM.L (SP)+,D1
000014B4                           621          
000014B4                           622          
000014B4  43F9 00001EE0            623          LEA     clearLine,A1  ;move string for a CR and LF
000014BA  103C 000E                624          MOVE.B  #14,D0        ;set for task to display null terminated 
000014BE                           625                                ;string without CR, LF
000014BE  4E4F                     626          TRAP    #15
000014C0                           627  
000014C0  7000                     628          MOVEQ.L #0,D0
000014C2  4E75                     629          RTS
000014C4                           630  
000014C4                           631  
000014C4= 10 20 38 39 00           632  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
000014C9= 38 38 3F 3F 00           633  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
000014CE                           634  
000014CE= 10 18 38 39 00           635  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
000014D3= 38 38 3F 3F 00           636  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
000014D8                           637  
000014D8                           638  MOVEM:
000014D8                           639          
000014D8                           640  
000014D8                           641          
000014D8  7000                     642          MOVEQ.L #0, D0 ;clear D0
000014DA                           643          
000014DA                           644          ;Figure out which direction we are going
000014DA  3401                     645          MOVE.W D1,D2 ;copy inst to D2
000014DC  E64A                     646          LSR.W #3,D2 ;shift direction bit into most sig bit of first byte
000014DE  0202 0080                647          ANDI.B #%10000000,D2 ;mask out everything but direction bit in first byte
000014E2  0C02 0000                648          CMPI.B #0,D2 ;compare bit to zero
000014E6  6700 0006                649          BEQ validRegToMem ;if zero, reg to mem
000014EA  6000 0028                650          BRA validMemToReg ;else, its mem to reg
000014EE                           651          
000014EE                           652  validRegToMem:
000014EE                           653          
000014EE  43F8 14C9                654          LEA movemRegToMemEAmasks,A1 ;load the list of masks
000014F2  D3C0                     655          ADDA.L D0,A1 ;displace to a specific mask
000014F4  1A11                     656          MOVE.B (A1),D5 ;move the mask to D5
000014F6                           657          
000014F6  0C05 0000                658          CMPI.B #0,D5 ;check if the mask is 0
000014FA  6700 FB74                659          BEQ falsePositive ;branch if it is
000014FE                           660          
000014FE  1401                     661          MOVE.B D1,D2 ;copy instruction to D2
00001500  C405                     662          AND.B D5,D2  ;mask D2
00001502                           663          
00001502  43F8 14C4                664          LEA movemRegToMemEA,A1 ;load the list of valid modes
00001506  D3C0                     665          ADDA.L D0,A1 ;displace to a specific mode
00001508  1811                     666          MOVE.B (A1),D4 ;move mode to D4
0000150A  B404                     667          CMP.B D4,D2 ;compare mode to masked value
0000150C  6700 0034                668          BEQ  movemBody ;if its match, its a valid mode and we can procede
00001510                           669          
00001510  5280                     670          ADDQ.L #1,D0 ;add one to displacement
00001512  60DA                     671          BRA validRegToMem ;check for next mode
00001514                           672          
00001514                           673          
00001514                           674  validMemToReg:
00001514                           675          
00001514  43F8 14D3                676          LEA movemMemToRegEAmasks,A1 ;load the list of masks
00001518  D3C0                     677          ADDA.L D0,A1 ;displace to a specific mask
0000151A  1A11                     678          MOVE.B (A1),D5 ;move the mask to D5
0000151C                           679          
0000151C  0C05 0000                680          CMPI.B #0,D5 ;check if the mask is 0
00001520  6700 FB4E                681          BEQ falsePositive ;branch if it is
00001524                           682          
00001524  3401                     683          MOVE.W D1,D2 ;copy instruction to D2
00001526  EC4A                     684          LSR.W #6,D2  ;move mode
00001528  6100 07DA                685          BSR switchModeAndReg ;switch register and mode
0000152C  C405                     686          AND.B D5,D2  ;mask D2
0000152E                           687          
0000152E  43F8 14CE                688          LEA movemMemToRegEA,A1 ;load the list of valid modes
00001532  D3C0                     689          ADDA.L D0,A1 ;displace to a specific mode
00001534  1811                     690          MOVE.B (A1),D4 ;move mode to D4
00001536  B404                     691          CMP.B D4,D2 ;compare mode to masked value
00001538  6700 0008                692          BEQ movemBody ;if its match, its a valid mode and we can procede
0000153C                           693          
0000153C  5280                     694          ADDQ.L #1,D0 ;add one to displacement
0000153E  6000 02EC                695          BRA validMoveDestModes ;check for next mode
00001542                           696          
00001542                           697  movemBody
00001542                           698  
00001542  43F9 00001EF9            699          LEA     movemMessage,A1  ;move string for MOVE
00001548  103C 000E                700          MOVE.B  #14,D0        ;set for task to display null terminated 
0000154C                           701                                ;string with CR, LF
0000154C  4E4F                     702          TRAP    #15
0000154E                           703          
0000154E                           704          ;show list
0000154E                           705          
0000154E  5487                     706          ADDQ.L #word,D7 ;read past the register list mask(word) following
00001550                           707                          ;the instruction
00001550                           708          
00001550                           709          ;print separator
00001550                           710          
00001550  3401                     711          MOVE.W  D1,D2 ;check mode
00001552  C43C 003F                712          AND.B   #%00111111,D2
00001556  1A02                     713          MOVE.B  D2,D5
00001558  48E7 4000                714          MOVEM.L D1,-(SP)
0000155C  6100 0632                715          BSR     Get_Effective_Address
00001560  4CDF 0002                716          MOVEM.L (SP)+,D1
00001564                           717          
00001564                           718          
00001564  43F9 00001EE0            719          LEA     clearLine,A1  ;move string for a CR and LF
0000156A  103C 000E                720          MOVE.B  #14,D0        ;set for task to display null terminated 
0000156E                           721                                ;string without CR, LF
0000156E  4E4F                     722          TRAP    #15
00001570                           723  
00001570  7000                     724          MOVEQ.L #0,D0
00001572  4E75                     725          RTS
00001574                           726  
00001574                           727  
00001574                           728      
00001574= 00 10 18 20 28 38 ...    729  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
0000157C= 38 38 38 38 38 3F ...    730  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
00001584                           731     
00001584                           732  NEG:            
00001584                           733       
00001584  7000                     734          MOVEQ.L #0, D0 ;clear D0
00001586                           735          
00001586                           736  validNegModes:
00001586                           737          
00001586  43F8 157C                738          LEA NegEAmasks,A1 ;load the list of masks
0000158A  D3C0                     739          ADDA.L D0,A1 ;displace to a specific mask
0000158C  1A11                     740          MOVE.B (A1),D5 ;move the mask to D5
0000158E                           741          
0000158E  0C05 0000                742          CMPI.B #0,D5 ;check if the mask is 0
00001592  6700 FADC                743          BEQ falsePositive ;branch if it is
00001596                           744          
00001596  1401                     745          MOVE.B D1,D2 ;copy instruction to D2
00001598  C405                     746          AND.B D5,D2  ;mask D2
0000159A  43F8 1574                747          LEA NegEA,A1 ;load the list of valid modes
0000159E  D3C0                     748          ADDA.L D0,A1 ;displace to a specific mode
000015A0  1811                     749          MOVE.B (A1),D4 ;move mode to D4
000015A2  B404                     750          CMP.B D4,D2 ;compare mode to masked value
000015A4  6700 0006                751          BEQ NegBody ;if its match, its a valid mode and we can procede
000015A8                           752          
000015A8  5280                     753          ADDQ.L #1,D0 ;add one to displacement
000015AA  60DA                     754          BRA validNegModes ;check for next mode
000015AC                           755          
000015AC                           756  NegBody:
000015AC                           757  
000015AC                           758  
000015AC  3401                     759          MOVE.W  D1,D2 ;copy inst to D2
000015AE  C47C 0600                760          AND.W  #%0011000000000,D2 ;mask word for size
000015B2  0C42 0000                761          CMPI.W #0,D2 ;0 is the only non valid size
000015B6  6700 FAB8                762          BEQ falsePositive ; zero is not valid
000015BA                           763  
000015BA  43F9 00001F28            764          LEA     negMessage,A1  ;move string for NEG info
000015C0  103C 000E                765          MOVE.B  #14,D0        ;set for task to display null terminated 
000015C4                           766                                ;string without CR, LF
000015C4  4E4F                     767          TRAP    #15
000015C6                           768          
000015C6  3401                     769          MOVE.W D1,D2
000015C8  C47C 003F                770          AND #%000000000111111,D2
000015CC  1A02                     771          MOVE.B D2,D5
000015CE                           772          
000015CE  48E7 4000                773          MOVEM.L D1,-(SP)
000015D2  6100 05BC                774          BSR     Get_Effective_Address
000015D6  4CDF 0002                775          MOVEM.L (SP)+,D1
000015DA                           776          
000015DA                           777                
000015DA                           778          
000015DA                           779  NEGdone:
000015DA                           780  
000015DA  43F9 00001EE0            781          LEA     clearLine,A1  ;move string for a CR and LF
000015E0  103C 000E                782          MOVE.B  #14,D0        ;set for task to display null terminated 
000015E4                           783                                ;string without CR, LF
000015E4  4E4F                     784          TRAP    #15
000015E6  7000                     785          MOVEQ.L #0,D0
000015E8  4E75                     786          RTS
000015EA                           787          
000015EA                           788   ADDI:            
000015EA                           789       
000015EA  7000                     790          MOVEQ.L #0, D0 ;clear D0
000015EC                           791          
000015EC                           792  validAddiModes:
000015EC                           793          
000015EC                           794          
000015EC  43F9 000016E5            795          LEA cmpiEAmasks,A1 ;load the list of masks
000015F2  D3C0                     796          ADDA.L D0,A1 ;displace to a specific mask
000015F4  1A11                     797          MOVE.B (A1),D5 ;move the mask to D5
000015F6                           798          
000015F6  0C05 0000                799          CMPI.B #0,D5 ;check if the mask is 0
000015FA  6700 FA74                800          BEQ falsePositive ;branch if it is
000015FE                           801          
000015FE  1401                     802          MOVE.B D1,D2 ;copy instruction to D2
00001600  C405                     803          AND.B D5,D2  ;mask D2
00001602  43F9 000016DE            804          LEA cmpiEA,A1 ;load the list of valid modes
00001608  D3C0                     805          ADDA.L D0,A1 ;displace to a specific mode
0000160A  1811                     806          MOVE.B (A1),D4 ;move mode to D4
0000160C  B404                     807          CMP.B D4,D2 ;compare mode to masked value
0000160E  6700 0006                808          BEQ addiBody ;if its match, its a valid mode and we can procede
00001612                           809          
00001612  5280                     810          ADDQ.L #1,D0 ;add one to displacement
00001614  60D6                     811          BRA validAddiModes ;check for next mode
00001616                           812          
00001616                           813  addiBody:
00001616                           814  
00001616                           815  
00001616  3401                     816          MOVE.W  D1,D2 ;copy inst to D2
00001618  C47C 00C0                817          AND.W  #%0000000011000000,D2 ;mask word for size
0000161C  0C42 00C0                818          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001620  6700 FA4E                819          BEQ falsePositive
00001624                           820  
00001624  43F9 00001F00            821          LEA     addiMessage,A1  ;move string for NEG info
0000162A  103C 000E                822          MOVE.B  #14,D0        ;set for task to display null terminated 
0000162E                           823                                ;string without CR, LF
0000162E  4E4F                     824          TRAP    #15
00001630                           825          
00001630                           826          ;go to Effective_Address for immediate data
00001630  143C 003C                827          MOVE.B #%00111100,D2
00001634  48E7 4000                828          MOVEM.L D1,-(SP)
00001638  6100 0556                829          BSR     Get_Effective_Address
0000163C  4CDF 0002                830          MOVEM.L (SP)+,D1
00001640                           831          
00001640  3401                     832          MOVE.W D1,D2 ;copy inst to D2
00001642  C47C 003F                833          AND #%000000000111111,D2 ;and out everything but modes and regs
00001646  1A02                     834          MOVE.B D2,D5 ; copy to D5 for following BSR
00001648                           835          
00001648  48E7 4000                836          MOVEM.L D1,-(SP)
0000164C  6100 0542                837          BSR     Get_Effective_Address
00001650  4CDF 0002                838          MOVEM.L (SP)+,D1
00001654                           839          
00001654                           840                
00001654                           841          
00001654                           842  addidone:
00001654                           843  
00001654  43F9 00001EE0            844          LEA     clearLine,A1  ;move string for a CR and LF
0000165A  103C 000E                845          MOVE.B  #14,D0        ;set for task to display null terminated 
0000165E                           846                                ;string without CR, LF
0000165E  4E4F                     847          TRAP    #15
00001660  7000                     848          MOVEQ.L #0,D0
00001662  4E75                     849          RTS
00001664                           850    
00001664                           851  ORI:            
00001664                           852       
00001664  7000                     853          MOVEQ.L #0, D0 ;clear D0
00001666                           854          
00001666                           855  validOriModes:
00001666                           856          
00001666                           857          
00001666  43F9 000016E5            858          LEA cmpiEAmasks,A1 ;load the list of masks
0000166C  D3C0                     859          ADDA.L D0,A1 ;displace to a specific mask
0000166E  1A11                     860          MOVE.B (A1),D5 ;move the mask to D5
00001670                           861          
00001670  0C05 0000                862          CMPI.B #0,D5 ;check if the mask is 0
00001674  6700 F9FA                863          BEQ falsePositive ;branch if it is
00001678                           864          
00001678  1401                     865          MOVE.B D1,D2 ;copy instruction to D2
0000167A  C405                     866          AND.B D5,D2  ;mask D2
0000167C  43F9 000016DE            867          LEA cmpiEA,A1 ;load the list of valid modes
00001682  D3C0                     868          ADDA.L D0,A1 ;displace to a specific mode
00001684  1811                     869          MOVE.B (A1),D4 ;move mode to D4
00001686  B404                     870          CMP.B D4,D2 ;compare mode to masked value
00001688  6700 0006                871          BEQ oriBody ;if its match, its a valid mode and we can procede
0000168C                           872          
0000168C  5280                     873          ADDQ.L #1,D0 ;add one to displacement
0000168E  60D6                     874          BRA validOriModes ;check for next mode
00001690                           875          
00001690                           876  oriBody:
00001690                           877  
00001690                           878  
00001690  3401                     879          MOVE.W  D1,D2 ;copy inst to D2
00001692  C47C 00C0                880          AND.W  #%0000000011000000,D2 ;mask word for size
00001696  0C42 00C0                881          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
0000169A  6700 F9D4                882          BEQ falsePositive
0000169E                           883  
0000169E  43F9 00001F06            884          LEA     oriMessage,A1  ;move string for NEG info
000016A4  103C 000E                885          MOVE.B  #14,D0        ;set for task to display null terminated 
000016A8                           886                                ;string without CR, LF
000016A8  4E4F                     887          TRAP    #15
000016AA                           888          
000016AA                           889          ;go to Effective_Address for immediate data
000016AA  143C 003C                890          MOVE.B #%00111100,D2
000016AE  48E7 4000                891          MOVEM.L D1,-(SP)
000016B2  6100 04DC                892          BSR     Get_Effective_Address
000016B6  4CDF 0002                893          MOVEM.L (SP)+,D1
000016BA                           894          
000016BA  3401                     895          MOVE.W D1,D2 ;copy inst to D2
000016BC  C47C 003F                896          AND #%000000000111111,D2 ;and out everything but modes and regs
000016C0  1A02                     897          MOVE.B D2,D5 ; copy to D5 for following BSR
000016C2                           898          
000016C2  48E7 4000                899          MOVEM.L D1,-(SP)
000016C6  6100 04C8                900          BSR     Get_Effective_Address
000016CA  4CDF 0002                901          MOVEM.L (SP)+,D1
000016CE                           902          
000016CE                           903                
000016CE                           904          
000016CE                           905  oridone:
000016CE                           906  
000016CE  43F9 00001EE0            907          LEA     clearLine,A1  ;move string for a CR and LF
000016D4  103C 000E                908          MOVE.B  #14,D0        ;set for task to display null terminated 
000016D8                           909                                ;string without CR, LF
000016D8  4E4F                     910          TRAP    #15
000016DA  7000                     911          MOVEQ.L #0,D0
000016DC  4E75                     912          RTS
000016DE                           913  
000016DE                           914          
000016DE                           915          
000016DE= 20 18 00 10 38 39 00     916  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
000016E5= 38 38 38 38 3F 3F 00     917  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
000016EC                           918     
000016EC                           919  CMPI:            
000016EC                           920       
000016EC  7000                     921          MOVEQ.L #0, D0 ;clear D0
000016EE                           922          
000016EE                           923  validCmpiModes:
000016EE                           924          
000016EE                           925          
000016EE  43F8 16E5                926          LEA cmpiEAmasks,A1 ;load the list of masks
000016F2  D3C0                     927          ADDA.L D0,A1 ;displace to a specific mask
000016F4  1A11                     928          MOVE.B (A1),D5 ;move the mask to D5
000016F6                           929          
000016F6  0C05 0000                930          CMPI.B #0,D5 ;check if the mask is 0
000016FA  6700 F974                931          BEQ falsePositive ;branch if it is
000016FE                           932          
000016FE  1401                     933          MOVE.B D1,D2 ;copy instruction to D2
00001700  C405                     934          AND.B D5,D2  ;mask D2
00001702  43F8 16DE                935          LEA cmpiEA,A1 ;load the list of valid modes
00001706  D3C0                     936          ADDA.L D0,A1 ;displace to a specific mode
00001708  1811                     937          MOVE.B (A1),D4 ;move mode to D4
0000170A  B404                     938          CMP.B D4,D2 ;compare mode to masked value
0000170C  6700 0006                939          BEQ CMPIBody ;if its match, its a valid mode and we can procede
00001710                           940          
00001710  5280                     941          ADDQ.L #1,D0 ;add one to displacement
00001712  60DA                     942          BRA validCmpiModes ;check for next mode
00001714                           943          
00001714                           944  CMPIBody:
00001714                           945  
00001714                           946  
00001714  3401                     947          MOVE.W  D1,D2 ;copy inst to D2
00001716  C47C 00C0                948          AND.W  #%0000000011000000,D2 ;mask word for size
0000171A  0C42 00C0                949          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
0000171E  6700 F950                950          BEQ falsePositive
00001722                           951  
00001722  43F9 00001F0B            952          LEA     cmpiMessage,A1  ;move string for NEG info
00001728  103C 000E                953          MOVE.B  #14,D0        ;set for task to display null terminated 
0000172C                           954                                ;string without CR, LF
0000172C  4E4F                     955          TRAP    #15
0000172E                           956          
0000172E                           957          ;go to Effective_Address for immediate data
0000172E  143C 003C                958          MOVE.B #%00111100,D2
00001732  48E7 4000                959          MOVEM.L D1,-(SP)
00001736  6100 0458                960          BSR     Get_Effective_Address
0000173A  4CDF 0002                961          MOVEM.L (SP)+,D1
0000173E                           962          
0000173E  3401                     963          MOVE.W D1,D2 ;copy inst to D2
00001740  C47C 003F                964          AND #%000000000111111,D2 ;and out everything but modes and regs
00001744  1A02                     965          MOVE.B D2,D5 ; copy to D5 for following BSR
00001746                           966          
00001746  48E7 4000                967          MOVEM.L D1,-(SP)
0000174A  6100 0444                968          BSR     Get_Effective_Address
0000174E  4CDF 0002                969          MOVEM.L (SP)+,D1
00001752                           970          
00001752                           971                
00001752                           972          
00001752                           973  CMPidone:
00001752                           974  
00001752  43F9 00001EE0            975          LEA     clearLine,A1  ;move string for a CR and LF
00001758  103C 000E                976          MOVE.B  #14,D0        ;set for task to display null terminated 
0000175C                           977                                ;string without CR, LF
0000175C  4E4F                     978          TRAP    #15
0000175E  7000                     979          MOVEQ.L #0,D0
00001760  4E75                     980          RTS
00001762                           981  
00001762                           982          
00001762= 10 38 39 00              983  JsrEA        DC.B %010000, %111000, %111001,0
00001766= 38 3F 3F 00              984  JsrEAmasks   DC.B %111000, %111111, %111111,0
0000176A                           985     
0000176A                           986  JSR:            
0000176A                           987       
0000176A  7000                     988          MOVEQ.L #0, D0 ;clear D0
0000176C                           989          
0000176C                           990  validJsrModes:
0000176C                           991          
0000176C  43F8 1766                992          LEA JsrEAmasks,A1 ;load the list of masks
00001770  D3C0                     993          ADDA.L D0,A1 ;displace to a specific mask
00001772  1A11                     994          MOVE.B (A1),D5 ;move the mask to D5
00001774                           995          
00001774  0C05 0000                996          CMPI.B #0,D5 ;check if the mask is 0
00001778  6700 F8F6                997          BEQ falsePositive ;branch if it is
0000177C                           998          
0000177C  1401                     999          MOVE.B D1,D2 ;copy instruction to D2
0000177E  C405                    1000          AND.B D5,D2  ;mask D2
00001780  43F8 1762               1001          LEA JsrEA,A1 ;load the list of valid modes
00001784  D3C0                    1002          ADDA.L D0,A1 ;displace to a specific mode
00001786  1811                    1003          MOVE.B (A1),D4 ;move mode to D4
00001788  B404                    1004          CMP.B D4,D2 ;compare mode to masked value
0000178A  6700 0006               1005          BEQ JsrBody ;if its match, its a valid mode and we can procede
0000178E                          1006          
0000178E  5280                    1007          ADDQ.L #1,D0 ;add one to displacement
00001790  60DA                    1008          BRA validJsrModes ;check for next mode
00001792                          1009          
00001792                          1010  JsrBody:
00001792                          1011  
00001792                          1012  
00001792  43F9 00001F11           1013          LEA     jsrMessage,A1  ;move string for NEG info
00001798  103C 000E               1014          MOVE.B  #14,D0        ;set for task to display null terminated 
0000179C                          1015                                ;string without CR, LF
0000179C  4E4F                    1016          TRAP    #15
0000179E                          1017          
0000179E  3401                    1018          MOVE.W D1,D2 ;copy inst to D2
000017A0  C47C 003F               1019          AND #%000000000111111,D2 ;and out everything but modes and regs
000017A4  1A02                    1020          MOVE.B D2,D5 ; copy to D5 for following BSR
000017A6                          1021          
000017A6  48E7 4000               1022          MOVEM.L D1,-(SP)
000017AA  6100 03E4               1023          BSR     Get_Effective_Address
000017AE  4CDF 0002               1024          MOVEM.L (SP)+,D1
000017B2                          1025          
000017B2                          1026                
000017B2                          1027          
000017B2                          1028  Jsrdone:
000017B2                          1029  
000017B2  43F9 00001EE0           1030          LEA     clearLine,A1  ;move string for a CR and LF
000017B8  103C 000E               1031          MOVE.B  #14,D0        ;set for task to display null terminated 
000017BC                          1032                                ;string without CR, LF
000017BC  4E4F                    1033          TRAP    #15
000017BE  7000                    1034          MOVEQ.L #0,D0
000017C0  4E75                    1035          RTS
000017C2                          1036  
000017C2                          1037  
000017C2                          1038          
000017C2                          1039  NOP:
000017C2                          1040  
000017C2  43F9 00001F1B           1041          LEA     nopMessage,A1 ;move string for NOP info
000017C8  103C 000D               1042          MOVE.B  #13,D0        ;set for task to display null terminated 
000017CC                          1043                                ;string with CR, LF
000017CC  4E4F                    1044          TRAP    #15
000017CE                          1045          
000017CE  7000                    1046          MOVEQ.L #0,D0
000017D0  4E75                    1047          RTS
000017D2                          1048          
000017D2                          1049  RTS:
000017D2                          1050          
000017D2  43F9 00001F16           1051          LEA     rtsMessage,A1  ;move string for rts info
000017D8  103C 000D               1052          MOVE.B  #13,D0        ;set for task to display null terminated 
000017DC                          1053                                ;string with CR, LF
000017DC  4E4F                    1054          TRAP    #15  
000017DE                          1055     
000017DE  7000                    1056          MOVEQ.L #0,D0
000017E0  4E75                    1057          RTS   
000017E2                          1058  
000017E2= 3C 08 00 10 18 20 ...   1059  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
000017EB= 3F 38 38 38 38 38 ...   1060  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
000017F4                          1061  
000017F4= 00 10 18 20 38 39 00    1062  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
000017FB= 38 38 38 38 3F 3F 00    1063  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
00001802                          1064  
00001802                          1065  MOVE:
00001802                          1066          
00001802                          1067  
00001802                          1068          
00001802  7000                    1069          MOVEQ.L #0, D0 ;clear D0
00001804                          1070          
00001804                          1071  validMoveSourceModes:
00001804                          1072          
00001804  43F8 17EB               1073          LEA moveSourceEAmasks,A1 ;load the list of masks
00001808  D3C0                    1074          ADDA.L D0,A1 ;displace to a specific mask
0000180A  1A11                    1075          MOVE.B (A1),D5 ;move the mask to D5
0000180C                          1076          
0000180C  0C05 0000               1077          CMPI.B #0,D5 ;check if the mask is 0
00001810  6700 F85E               1078          BEQ falsePositive ;branch if it is
00001814                          1079          
00001814  1401                    1080          MOVE.B D1,D2 ;copy instruction to D2
00001816  C405                    1081          AND.B D5,D2  ;mask D2
00001818                          1082          
00001818  43F8 17E2               1083          LEA moveSourceEA,A1 ;load the list of valid modes
0000181C  D3C0                    1084          ADDA.L D0,A1 ;displace to a specific mode
0000181E  1811                    1085          MOVE.B (A1),D4 ;move mode to D4
00001820  B404                    1086          CMP.B D4,D2 ;compare mode to masked value
00001822  6700 0006               1087          BEQ  checkMoveDest ;if its match, its a valid mode and we can procede
00001826                          1088          
00001826  5280                    1089          ADDQ.L #1,D0 ;add one to displacement
00001828  60DA                    1090          BRA validMoveSourceModes ;check for next mode
0000182A                          1091          
0000182A                          1092  checkMoveDest:
0000182A  7000                    1093          MOVEQ.L #0, D0 ;clear D0
0000182C                          1094          
0000182C                          1095  validMoveDestModes:
0000182C                          1096          
0000182C  43F8 17FB               1097          LEA moveDestEAmasks,A1 ;load the list of masks
00001830  D3C0                    1098          ADDA.L D0,A1 ;displace to a specific mask
00001832  1A11                    1099          MOVE.B (A1),D5 ;move the mask to D5
00001834                          1100          
00001834  0C05 0000               1101          CMPI.B #0,D5 ;check if the mask is 0
00001838  6700 F836               1102          BEQ falsePositive ;branch if it is
0000183C                          1103          
0000183C  3401                    1104          MOVE.W D1,D2 ;copy instruction to D2
0000183E  EC4A                    1105          LSR.W #6,D2  ;move mode
00001840  6100 04C2               1106          BSR switchModeAndReg ;switch register and mode
00001844  C405                    1107          AND.B D5,D2  ;mask D2
00001846                          1108          
00001846  43F8 17F4               1109          LEA moveDestEA,A1 ;load the list of valid modes
0000184A  D3C0                    1110          ADDA.L D0,A1 ;displace to a specific mode
0000184C  1811                    1111          MOVE.B (A1),D4 ;move mode to D4
0000184E  B404                    1112          CMP.B D4,D2 ;compare mode to masked value
00001850  6700 0006               1113          BEQ moveBody ;if its match, its a valid mode and we can procede
00001854                          1114          
00001854  5280                    1115          ADDQ.L #1,D0 ;add one to displacement
00001856  60D4                    1116          BRA validMoveDestModes ;check for next mode
00001858                          1117          
00001858                          1118  moveBody
00001858  3401                    1119          MOVE.W  D1,D2 ;copy inst to D2
0000185A  C47C 3000               1120          AND.W  #%0011000000000000,D2 ;mask word for size
0000185E  0C42 0000               1121          CMPI.W #0,D2 ;0 is the only non valid size
00001862  6700 F80C               1122          BEQ falsePositive ; if zero, this is not move
00001866                          1123  
00001866  43F9 00001F20           1124          LEA     moveMessage,A1  ;move string for MOVE
0000186C  103C 000E               1125          MOVE.B  #14,D0        ;set for task to display null terminated 
00001870                          1126                                ;string with CR, LF
00001870  4E4F                    1127          TRAP    #15
00001872                          1128          
00001872                          1129          
00001872  3401                    1130          MOVE.W  D1,D2 ;check source mode
00001874  C43C 003F               1131          AND.B   #%00111111,D2
00001878  1A02                    1132          MOVE.B  D2,D5
0000187A  48E7 4000               1133          MOVEM.L D1,-(SP)
0000187E  6100 0310               1134          BSR     Get_Effective_Address
00001882  4CDF 0002               1135          MOVEM.L (SP)+,D1
00001886                          1136          
00001886                          1137          ;print separator
00001886                          1138          
00001886  3401                    1139          MOVE.W  D1,D2 ;check dest mode
00001888  EC4A                    1140          LSR.W   #6,D2
0000188A  6100 0478               1141          BSR  switchModeAndReg
0000188E  C43C 003F               1142          AND.B   #%00111111,D2
00001892  1A02                    1143          MOVE.B  D2,D5
00001894  48E7 4000               1144          MOVEM.L D1,-(SP)
00001898  6100 02F6               1145          BSR     Get_Effective_Address
0000189C  4CDF 0002               1146          MOVEM.L (SP)+,D1
000018A0                          1147          
000018A0                          1148          
000018A0                          1149          
000018A0  43F9 00001EE0           1150          LEA     clearLine,A1  ;move string for a CR and LF
000018A6  103C 000E               1151          MOVE.B  #14,D0        ;set for task to display null terminated 
000018AA                          1152                                ;string without CR, LF
000018AA  4E4F                    1153          TRAP    #15
000018AC                          1154  
000018AC  7000                    1155          MOVEQ.L #0,D0
000018AE  4E75                    1156          RTS
000018B0                          1157          
000018B0= 08 00                   1158  moveADestEA        DC.B %001000,0
000018B2= 38 00                   1159  moveADestEAmasks   DC.B %111000,0
000018B4                          1160          
000018B4                          1161  MOVEA:
000018B4                          1162  
000018B4  7000                    1163          MOVEQ.L #0, D0 ;clear D0
000018B6                          1164          
000018B6                          1165  validMoveASourceModes:
000018B6                          1166          
000018B6  43F8 17EB               1167          LEA moveSourceEAmasks,A1 ;load the list of masks
000018BA  D3C0                    1168          ADDA.L D0,A1 ;displace to a specific mask
000018BC  1A11                    1169          MOVE.B (A1),D5 ;move the mask to D5
000018BE                          1170          
000018BE  0C05 0000               1171          CMPI.B #0,D5 ;check if the mask is 0
000018C2  6700 F7AC               1172          BEQ falsePositive ;branch if it is
000018C6                          1173          
000018C6  1401                    1174          MOVE.B D1,D2 ;copy instruction to D2
000018C8  C405                    1175          AND.B D5,D2  ;mask D2
000018CA                          1176          
000018CA  43F8 17E2               1177          LEA moveSourceEA,A1 ;load the list of valid modes
000018CE  D3C0                    1178          ADDA.L D0,A1 ;displace to a specific mode
000018D0  1811                    1179          MOVE.B (A1),D4 ;move mode to D4
000018D2  B404                    1180          CMP.B D4,D2 ;compare mode to masked value
000018D4  6700 0006               1181          BEQ  checkMoveADest ;if its match, its a valid mode and we can procede
000018D8                          1182          
000018D8  5280                    1183          ADDQ.L #1,D0 ;add one to displacement
000018DA  60DA                    1184          BRA validMoveASourceModes ;check for next mode
000018DC                          1185          
000018DC                          1186  checkMoveADest:
000018DC  7000                    1187          MOVEQ.L #0, D0 ;clear D0
000018DE                          1188  validMoveADestModes:
000018DE                          1189          
000018DE  43F8 18B2               1190          LEA moveADestEAmasks,A1 ;load the list of masks
000018E2  D3C0                    1191          ADDA.L D0,A1 ;displace to a specific mask
000018E4  1A11                    1192          MOVE.B (A1),D5 ;move the mask to D5
000018E6                          1193          
000018E6  0C05 0000               1194          CMPI.B #0,D5 ;check if the mask is 0
000018EA  6700 F784               1195          BEQ falsePositive ;branch if it is
000018EE                          1196          
000018EE  3401                    1197          MOVE.W D1,D2 ;copy instruction to D2
000018F0  EA4A                    1198          LSR.W #5,D2  ;move mode
000018F2  6100 0410               1199          BSR switchModeAndReg ;switch register and mode
000018F6  C405                    1200          AND.B D5,D2  ;mask D2
000018F8                          1201          
000018F8  43F8 18B0               1202          LEA moveADestEA,A1 ;load the list of valid modes
000018FC  D3C0                    1203          ADDA.L D0,A1 ;displace to a specific mode
000018FE  1811                    1204          MOVE.B (A1),D4 ;move mode to D4
00001900  B404                    1205          CMP.B D4,D2 ;compare mode to masked value
00001902  6700 0006               1206          BEQ moveABody ;if its match, its a valid mode and we can procede
00001906                          1207          
00001906  5280                    1208          ADDQ.L #1,D0 ;add one to displacement
00001908  60D4                    1209          BRA validMoveADestModes ;check for next mode
0000190A                          1210  moveABody:
0000190A  3401                    1211          MOVE.W  D1,D2 ;copy inst to D2
0000190C  C47C 3000               1212          AND.W  #%0011000000000000,D2 ;mask word for size
00001910  0C42 0000               1213          CMPI.W #0,D2 ;0 is the non valid size
00001914  6700 F75A               1214          BEQ falsePositive ; if zero, this is not move
00001918  0C42 1000               1215          CMPI.W #%0001000000000000,D2
0000191C  6700 F752               1216          BEQ falsePositive ; if byte, this is not movea
00001920                          1217  
00001920                          1218  
00001920  43F9 00001F33           1219          LEA     moveAMessage,A1  ;move string for MOVE
00001926  103C 000D               1220          MOVE.B  #13,D0        ;set for task to display null terminated 
0000192A                          1221                                ;string with CR, LF
0000192A  4E4F                    1222          TRAP    #15
0000192C                          1223  
0000192C  7000                    1224          MOVEQ.L #0,D0
0000192E  4E75                    1225          RTS
00001930                          1226  
00001930                          1227             
00001930                          1228  Bcc:
00001930                          1229  
00001930  43F9 00001F26           1230          LEA     bccMessage,A1  ;move string for BRA info
00001936  103C 000E               1231          MOVE.B  #14,D0        ;set for task to display null terminated 
0000193A                          1232                                ;string without CR, LF
0000193A  4E4F                    1233          TRAP    #15
0000193C                          1234          
0000193C  7000                    1235          MOVEQ.L #0,D0 ;clear D0
0000193E  3401                    1236          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001940  E04A                    1237          LSR.W   #8,D2
00001942  C47C 000F               1238          AND.W   #$0F,D2 ;mask instruction
00001946                          1239          
00001946                          1240  checkCC:        
00001946  41F9 00001E67           1241          LEA     bccList,A0 ;get condition code signature list in A0
0000194C  D1C0                    1242          ADDA.L  D0,A0 ;get correct sig         
0000194E  B410                    1243          CMP.B   (A0),D2 ;compare to sig
00001950  6700 0006               1244          BEQ     foundCC ;if sig matches branch
00001954  5200                    1245          ADDQ.B  #byte,D0
00001956  60EE                    1246          BRA     checkCC
00001958                          1247  foundCC:
00001958  43F9 00001E78           1248          LEA     conditionCodeMessage,A1 ;get condition code message in A1
0000195E  C0FC 0004               1249          MULU.W  #long,D0 ;adjust size of D0 for a long
00001962  D3C0                    1250          ADDA.L  D0,A1 ;get correct message location
00001964  2251                    1251          MOVEA.L (A1),A1 ;get correct message
00001966                          1252          
00001966  103C 000E               1253          MOVE.B  #14,D0        ;set for task to display null terminated 
0000196A                          1254                                ;string without CR, LF
0000196A  4E4F                    1255          TRAP    #15
0000196C                          1256  
0000196C                          1257          
0000196C                          1258          
0000196C  548B                    1259          ADDQ.L  #word,A3 ;move past instruction in case long displacement
0000196E  C27C 00FF               1260          AND.W   #$00FF,D1   ;check for word sized displacement
00001972                          1261          
00001972  B23C 0000               1262          CMP.B   #$0,D1
00001976  6700 0010               1263          BEQ     BccWord
0000197A                          1264          
0000197A  B23C 00FF               1265          CMP.B   #$FF,D1 check for long sized displacement
0000197E  6700 0010               1266          BEQ     BccLong
00001982                          1267          
00001982                          1268  BccByte:
00001982                          1269          
00001982  7E00                    1270          MOVEQ.L #0,D7 ;pass back no extra data followed
00001984  6000 0012               1271          BRA     BccDone
00001988                          1272  BccWord:
00001988  3213                    1273          MOVE.W  (A3),D1
0000198A                          1274          
0000198A  7E02                    1275          MOVEQ.L #word,D7 ;pass back an extra word followed
0000198C  6000 000A               1276          BRA     BccDone
00001990                          1277  BccLong:
00001990  2213                    1278          MOVE.L  (A3),D1
00001992                          1279          
00001992  7E04                    1280          MOVEQ.L #long,D7 ;pass back an extra long followed
00001994  6000 0002               1281          BRA     BccDone
00001998                          1282  BccDone:
00001998                          1283  
00001998  343C 0010               1284          MOVE.W  #16,D2 ;put base in D2
0000199C  303C 000F               1285          MOVE.W  #15,D0  ;put task #15 in D0
000019A0  4E4F                    1286          TRAP    #15
000019A2                          1287          
000019A2  43F9 00001EE0           1288          LEA     clearLine,A1  ;move string for a CR and LF
000019A8  103C 000E               1289          MOVE.B  #14,D0        ;set for task to display null terminated 
000019AC                          1290                                ;string without CR, LF
000019AC  4E4F                    1291          TRAP    #15
000019AE                          1292  
000019AE  7000                    1293          MOVEQ.L #0,D0
000019B0  4E75                    1294          RTS
000019B2                          1295          
000019B2                          1296          
000019B2                          1297  unknownOpCode:
000019B2  43F9 00001F2D           1298          LEA     dataMessage,A1 ;move string for data info
000019B8  103C 000E               1299          MOVE.B  #14,D0        ;set for task to display null terminated 
000019BC                          1300                                ;string without CR, LF
000019BC  4E4F                    1301          TRAP    #15
000019BE                          1302          
000019BE  143C 0010               1303          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
000019C2  103C 000F               1304          MOVE.B  #15,D0
000019C6  4E4F                    1305          TRAP    #15
000019C8                          1306          
000019C8  43F9 00001EE0           1307          LEA     clearLine,A1  ;move string for a CR and LF
000019CE  103C 000E               1308          MOVE.B  #14,D0        ;set for task to display null terminated 
000019D2                          1309                                ;string without CR, LF
000019D2  4E4F                    1310          TRAP    #15
000019D4                          1311          
000019D4  7000                    1312          MOVEQ.L #0,D0
000019D6  4E75                    1313          RTS
000019D8                          1314          
000019D8                          1315  handlebytedata:
000019D8                          1316  
000019D8  43F9 00001F2D           1317          LEA     dataMessage,A1 ;move string for data info
000019DE  103C 000E               1318          MOVE.B  #14,D0        ;set for task to display null terminated 
000019E2                          1319                                ;string without CR, LF
000019E2  4E4F                    1320          TRAP    #15
000019E4                          1321          
000019E4  E049                    1322          LSR.W   #8,D1 ;shift the word read into D1 by a byte
000019E6                          1323          
000019E6  143C 0010               1324          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
000019EA  103C 000F               1325          MOVE.B  #15,D0
000019EE  4E4F                    1326          TRAP    #15
000019F0                          1327          
000019F0  43F9 00001EE0           1328          LEA     clearLine,A1  ;move string for a CR and LF
000019F6  103C 000E               1329          MOVE.B  #14,D0        ;set for task to display null terminated 
000019FA                          1330                                ;string without CR, LF
000019FA  4E4F                    1331          TRAP    #15
000019FC                          1332          
000019FC  7000                    1333          MOVEQ.L #0,D0
000019FE                          1334          
000019FE  528B                    1335          ADDQ.L  #byte,A3
00001A00  6000 F624               1336          BRA main_Loop
00001A04                          1337  
00001A04                          1338          
00001A04                          1339          
00001A04                          1340  fin
00001A04                          1341  
00001A04                          1342          
00001A04                          1343          
00001A04  FFFF FFFF               1344          simhalt
00001A08                          1345          
00001A08                          1346  
00001A08                          1347  *******************************************************************************
00001A08                          1348  *                            SUB ROUTINES
00001A08                          1349  *******************************************************************************
00001A08                          1350  
00001A08                          1351  *******************************************************************************
00001A08                          1352  *                          IO ROLE ROUTINES
00001A08                          1353  *******************************************************************************
00001A08                          1354  
00001A08                          1355  *==========================================================================
00001A08                          1356  *                   Enter / Validate beginning address 
00001A08                          1357  *==========================================================================
00001A08                          1358   
00001A08                          1359  begin_address:
00001A08                          1360  
00001A08                          1361         
00001A08  43F9 00001D18           1362          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00001A0E  2239 00001D18           1363          MOVE.L      slPrompt,D1         ;Load display length to D1
00001A14  700E                    1364          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001A16  4E4F                    1365          TRAP        #15                 ;Perform task 14 (display)
00001A18                          1366          
00001A18  43F9 00001F64           1367          LEA         startLocation,A1    ;Load address to store user input
00001A1E  103C 0002               1368          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001A22  4E4F                    1369          TRAP        #15                 ;Perform task 2 (input)
00001A24                          1370          
00001A24  0C11 001B               1371          CMP.B       #27,(A1)            ;Check for ESC entered
00001A28  6700 004C               1372          BEQ         address_Exit        ;Exit condition 
00001A2C                          1373          
00001A2C  6100 0050               1374          BSR         enter_addr_edit_all
00001A30  B67C FFFF               1375          CMP.W       #-1,D3              ;Did the edit pass?
00001A34  67D2                    1376          BEQ         begin_address       ;No, loop and ask for correct input
00001A36                          1377          
00001A36  2643                    1378          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
00001A38                          1379          
00001A38  43F9 00001E25           1380          LEA         spc,A1              ;Load address for starting loaction prompt
00001A3E  1239 00001E26           1381          MOVE.B      spc_len,D1          ;Load empty line length
00001A44  7000                    1382          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
00001A46  4E4F                    1383          TRAP        #15                 ;Perform task 14 (display)
00001A48  6000 0002               1384          BRA         end_address
00001A4C                          1385  
00001A4C                          1386  *===========================================================================
00001A4C                          1387  *                   Enter / Validate ending address 
00001A4C                          1388  *===========================================================================
00001A4C                          1389  
00001A4C                          1390  end_address:
00001A4C                          1391          
00001A4C  43F9 00001D49           1392          LEA         elPrompt,A1         ;Load address for ending loaction prompt
00001A52                          1393          ;MOVE.L     elPrompt,D1         ;Load display length to D1
00001A52  7250                    1394          MOVE.L      #80,D1       ;did not like previous command, do not know why, it should have worked
00001A54  700E                    1395          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001A56  4E4F                    1396          TRAP        #15                 ;Perform task 14 (display)
00001A58                          1397          
00001A58  103C 0002               1398          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001A5C  4E4F                    1399          TRAP        #15                 ;Perform task 2 (input)
00001A5E                          1400          
00001A5E  0C11 001B               1401          CMP.B       #27,(A1)            ;Check for ESC entered
00001A62  6700 0012               1402          BEQ         address_Exit        ;Exit condition 
00001A66                          1403          
00001A66  6100 0016               1404          BSR         enter_addr_edit_all
00001A6A  B67C FFFF               1405          CMP.W       #-1,D3              ;Did the edit pass?
00001A6E  67DC                    1406          BEQ         end_address         ;No, loop and ask for correct input
00001A70                          1407  
00001A70  2843                    1408          MOVEA.L     D3,A4               ;Ending address gets stored in A4
00001A72  6000 0008               1409          BRA         address_done
00001A76                          1410  
00001A76                          1411  address_Exit:
00001A76                          1412  
00001A76  76FF                    1413          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001A78  6000 0002               1414          BRA         address_done
00001A7C                          1415          
00001A7C                          1416  address_done:
00001A7C                          1417  
00001A7C  4E75                    1418          RTS    
00001A7E                          1419  
00001A7E                          1420  *==============================================================================
00001A7E                          1421  * enter_addr_edit_all - Enter address edit check to edit all errors  
00001A7E                          1422  *                       using multiple different error checking routines.
00001A7E                          1423  *
00001A7E                          1424  * Parameters -
00001A7E                          1425  *   Input   A1      The data that needs checked.
00001A7E                          1426  *   Input   D1      The number of characters input     
00001A7E                          1427  *   Output  D3      Returns '-1' when there is an error.
00001A7E                          1428  *==============================================================================
00001A7E                          1429  
00001A7E                          1430  enter_addr_edit_all
00001A7E                          1431  
00001A7E                          1432  *------------------------------------------------------------------------------
00001A7E                          1433  * Test for odd number of characters entered, not allowed
00001A7E                          1434  *------------------------------------------------------------------------------
00001A7E                          1435         
00001A7E  6100 0024               1436          BSR         ck_boundry          ;check if the input is on a odd / even boundry
00001A82  B67C FFFF               1437          CMP.W       #-1,D3              ;Is the address odd?
00001A86  6700 001A               1438          BEQ         enter_addr_edit_all_exit     ;No, return
00001A8A                          1439  
00001A8A                          1440  *------------------------------------------------------------------------------
00001A8A                          1441  * Ttest for character entered all being valid address characters
00001A8A                          1442  * Note: lower case a-f, gets converted to upper case A-F in D3
00001A8A                          1443  *------------------------------------------------------------------------------
00001A8A                          1444          
00001A8A  6100 0062               1445          BSR         parseHexString      ;check if the input contains valid Hex characters
00001A8E  B67C FFFF               1446          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
00001A92  6700 000E               1447          BEQ         enter_addr_edit_all_exit     ;No, return
00001A96                          1448  
00001A96                          1449  *------------------------------------------------------------------------------
00001A96                          1450  * Verify that the address entered is witin the range defined in the Equate
00001A96                          1451  *------------------------------------------------------------------------------        
00001A96                          1452          
00001A96  6100 00C8               1453          BSR         ck_addr_range       ;is address entered witin the range 
00001A9A                          1454                                          ;   as defined in the Equate? 
00001A9A  B67C FFFF               1455          CMP.W       #-1,D3              ;is the address  valid?
00001A9E  6700 0002               1456          BEQ         enter_addr_edit_all_exit     ;No, return
00001AA2                          1457  
00001AA2                          1458  enter_addr_edit_all_exit:
00001AA2                          1459  
00001AA2  4E75                    1460          RTS                             ;return
00001AA4                          1461  
00001AA4                          1462  *==============================================================================
00001AA4                          1463  * ck_boundry - Check the size of the data characters input and determine
00001AA4                          1464  *              if an odd number of characters was entered
00001AA4                          1465  *
00001AA4                          1466  * Parameters -
00001AA4                          1467  *   Input   A1      The data that needs checked for odd length.
00001AA4                          1468  *   Input   D1      The number of characters input     
00001AA4                          1469  *   Output  D3      Returns '-1' when there is an odd length.
00001AA4                          1470  *==============================================================================
00001AA4                          1471  
00001AA4                          1472  ck_boundry:
00001AA4                          1473  
00001AA4  4243                    1474          CLR.W       D3                  ;Clear the return
00001AA6                          1475  
00001AA6  B23C 0000               1476          CMP.B       #0,D1               ;Check for nothing entered
00001AAA  6700 002E               1477          BEQ         ck_size_error       ;Number of characters entered must be 
00001AAE                          1478                                          ;greater than 0  
00001AAE                          1479          
00001AAE                          1480          
00001AAE                          1481          * The program will branch to ck_size_error if D1 is greater than #8        
00001AAE  B23C 0008               1482          CMP.B       #8,D1               ;Check for more than 8 characters entered
00001AB2  6E00 0026               1483          BGT         ck_size_error       ;Number of characters entered must be less
00001AB6                          1484                                          ;than 9
00001AB6                          1485          
00001AB6  7402                    1486          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
00001AB8  82C2                    1487          DIVU        D2,D1               ;Divide address by 2
00001ABA  4841                    1488          SWAP        D1                  ;get remainder
00001ABC  B23C 0001               1489          CMP.B       #$01,D1             ;Check for remainder of 1
00001AC0  6700 0004               1490          BEQ         ck_boundry_error    ;Number of characters entered must be an 
00001AC4                          1491                                          ;even number   
00001AC4                          1492    
00001AC4  4E75                    1493          RTS                             ;return
00001AC6                          1494  
00001AC6                          1495  *------------------------------------------------------------------------------
00001AC6                          1496  * ck_boundry_error - An odd number of characters was entered
00001AC6                          1497  *                  - Load error message and display it
00001AC6                          1498  *                  - Return error condition
00001AC6                          1499  *------------------------------------------------------------------------------
00001AC6                          1500          
00001AC6                          1501  ck_boundry_error:
00001AC6                          1502  
00001AC6  43F9 00001E05           1503          LEA         even_msg,A1         ;Load odd error message into A1
00001ACC  2239 00001E05           1504          MOVE.L      even_msg,D1         ;Load error length to D1
00001AD2                          1505          
00001AD2  7000                    1506          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001AD4                          1507                                          ; n is D1.W with CR, LF. 
00001AD4  4E4F                    1508          TRAP #15                        ;Display the error message
00001AD6  76FF                    1509          MOVE.L #-1,D3                   ;Load -1 into return parameter
00001AD8  4E75                    1510          RTS                             ;Return
00001ADA                          1511          
00001ADA                          1512  *------------------------------------------------------------------------------
00001ADA                          1513  * ck_size_error -   The number of characters entered must be more than zero
00001ADA                          1514  *                  - Load error message and display it
00001ADA                          1515  *                  - Return error condition
00001ADA                          1516  *------------------------------------------------------------------------------
00001ADA                          1517          
00001ADA                          1518  ck_size_error:
00001ADA                          1519  
00001ADA  43F9 00001D78           1520          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001AE0  2239 00001D78           1521          MOVE.L      invalidMsg,D1       ;Load error length to D1
00001AE6                          1522          
00001AE6  7000                    1523          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001AE8                          1524                                          ; n is D1.W with CR, LF. 
00001AE8  4E4F                    1525          TRAP        #15                 ;Display the error message
00001AEA  76FF                    1526          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001AEC  4E75                    1527          RTS                             ;Return        
00001AEE                          1528  
00001AEE                          1529  
00001AEE                          1530  *==============================================================================
00001AEE                          1531  * parseHexString - Converts user input string into a valid memory address
00001AEE                          1532  *                - Stores parsed address data into D3
00001AEE                          1533  *                - Stores good/bad (1/0) data in D4 
00001AEE                          1534  *
00001AEE                          1535  * Hex values are stored as bytes in D2, the ASCII chart shows their value
00001AEE                          1536  *   The ASCII chart values we care about are in the ranges of: 
00001AEE                          1537  *                            Hex            Decimal
00001AEE                          1538  *       No Value           NULL = 0         0
00001AEE                          1539  *       Numeric Values:     0-9 = 30-39     48-57
00001AEE                          1540  *       Upper Case letters: A-F = 41-46     65-70
00001AEE                          1541  *       Lower Case letterc: a-f = 61-66     97-102
00001AEE                          1542  
00001AEE                          1543  * Parameters -
00001AEE                          1544  *   Input   A1      The data that needs checked for valid input.
00001AEE                          1545  *   Output  D3      The return value, '-1' for error
00001AEE                          1546  *==============================================================================
00001AEE                          1547  
00001AEE                          1548  parseHexString:
00001AEE                          1549  
00001AEE                          1550  * setup any initializing item that do not get looped through
00001AEE  4243                    1551          CLR.W       D3                  ;Clear the return
00001AF0                          1552  
00001AF0                          1553          
00001AF0                          1554  *------------------------------------------------------------------------------
00001AF0                          1555  * NextHex - Loop through all bytes and vaildate the input
00001AF0                          1556  * Parameters -
00001AF0                          1557  *   Input   A1      The data that needs checked for valid input.
00001AF0                          1558  *   Output  D3      The return value, '-1' for error
00001AF0                          1559  *------------------------------------------------------------------------------
00001AF0                          1560          
00001AF0                          1561  NextHex:
00001AF0                          1562  
00001AF0  1419                    1563          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00001AF2  B43C 0000               1564          CMP.B       #0,D2               ;Check character for null 
00001AF6  6700 0066               1565          BEQ         NextHexReturn       ;Character is null (end of input)
00001AFA                          1566          
00001AFA                          1567  *................................................................................
00001AFA                          1568  *  Check decimal values 0-9 by testing hexadecimal values 30-39
00001AFA                          1569  *................................................................................
00001AFA                          1570                  
00001AFA                          1571          * The program will branch to hex_range_error if D2 is less than #30
00001AFA  B43C 0030               1572          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
00001AFE  6D00 0048               1573          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001B02                          1574                                          ;processing
00001B02                          1575          
00001B02                          1576          * The program will branch to UcaseHex if D2 is greater than #39
00001B02  B43C 0039               1577          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
00001B06  6E00 000A               1578          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
00001B0A                          1579          
00001B0A                          1580          *a valid number was found within this range
00001B0A  0402 0030               1581          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
00001B0E  6000 0032               1582          BRA         NextHexDone         ;Done parsing this byte
00001B12                          1583  
00001B12                          1584  
00001B12                          1585  *..............................................................................
00001B12                          1586  *  Check upper case values A-F by testing hexadecimal values 41-46
00001B12                          1587  *..............................................................................
00001B12                          1588  
00001B12                          1589  UcaseHex:
00001B12                          1590  
00001B12                          1591          * The program will branch to hex_range_error if D2 is less than #41
00001B12  B43C 0041               1592          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
00001B16  6D00 0030               1593          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001B1A                          1594                                          ;processing
00001B1A                          1595          
00001B1A  B43C 0046               1596          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
00001B1E  6E00 000A               1597          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
00001B22                          1598                                          ;processing
00001B22                          1599          
00001B22                          1600          *a valid number was found within this range
00001B22  0402 0037               1601          SUBI.B      #55,D2              ;Change uppercase character to actual value
00001B26  6000 001A               1602          BRA         NextHexDone         ;Done parsing this byte
00001B2A                          1603  
00001B2A                          1604  
00001B2A                          1605  *..............................................................................
00001B2A                          1606  *  Check lower case values a-f by testing hexadecimal values 61-66
00001B2A                          1607  *..............................................................................
00001B2A                          1608  
00001B2A                          1609  LcaseHex
00001B2A                          1610          
00001B2A                          1611          * The program will branch to hex_range_error if D2 is less than #61
00001B2A  B43C 0061               1612          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
00001B2E  6D00 0018               1613          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
00001B32                          1614                                          ;processing
00001B32                          1615  
00001B32  B43C 0066               1616          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
00001B36  6E00 0010               1617          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
00001B3A                          1618                                          ;processing
00001B3A                          1619  
00001B3A                          1620          *a valid number was found within this range
00001B3A  0402 0057               1621          SUBI.B      #87,D2              ;Change lowercase character to actual value
00001B3E  6000 0002               1622          BRA         NextHexDone         ;Done parsing this byte
00001B42                          1623  
00001B42                          1624  NextHexDone:
00001B42                          1625  
00001B42  E983                    1626          ASL.L       #4,D3               ; Make rooom for new byte in the return register
00001B44  D602                    1627          ADD.B       D2,D3               ; Move the new byte into the return register
00001B46  60A8                    1628          BRA         NextHex             ; We're ready to parse the next byte
00001B48                          1629          
00001B48                          1630  *-------------------------------------------------------------------------------------
00001B48                          1631  * hex_range_error -  A character entered was within the valid range for a hex address
00001B48                          1632  *                 -  Load error message and display it
00001B48                          1633  *                 -  Return error condition
00001B48                          1634  *-------------------------------------------------------------------------------------
00001B48                          1635          
00001B48                          1636  hex_range_error:
00001B48                          1637  
00001B48  43F9 00001DBD           1638          LEA         invCharMsg,A1       ;Load invalid range message into A1
00001B4E  2239 00001DBD           1639          MOVE.L      invCharMsg,D1       ;Load error length to D1
00001B54                          1640          
00001B54  7000                    1641          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001B56                          1642                                          ; n is D1.W with CR, LF. 
00001B56  4E4F                    1643          TRAP        #15                 ;Display the error message
00001B58  76FF                    1644          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001B5A  6000 0002               1645          BRA         NextHexReturn
00001B5E                          1646          
00001B5E                          1647  NextHexReturn:
00001B5E                          1648          
00001B5E  4E75                    1649          RTS                             ;Return      
00001B60                          1650  
00001B60                          1651  
00001B60                          1652  *===============================================================================
00001B60                          1653  * ck_addr_range - check the address input is within a valid memory address range
00001B60                          1654  *                - Parsed address data into D3
00001B60                          1655  *
00001B60                          1656  * Parameters -
00001B60                          1657  *   Input   A1      The data that needs checked for valid address.
00001B60                          1658  *   Output  D3      The return value, '-1' for error
00001B60                          1659  *===============================================================================
00001B60                          1660  
00001B60                          1661  
00001B60                          1662  ck_addr_range:   
00001B60                          1663  
00001B60                          1664  *------------------------------------------------------------------------------
00001B60                          1665  * Verify that the address entered is witin the 
00001B60                          1666  * beginning range ('begin') as defined in the Equate
00001B60                          1667  *------------------------------------------------------------------------------   
00001B60                          1668              
00001B60  2C3C 00005001           1669          MOVE.L      #begin,D6           * Load minimum starting address
00001B66  B686                    1670          CMP.L       D6,D3               * Is input at or above minimum?
00001B68  6D00 0012               1671          BLT         ck_addr_range_error 
00001B6C                          1672          
00001B6C                          1673  *------------------------------------------------------------------------------
00001B6C                          1674  * Verify that the address entered is witin the 
00001B6C                          1675  * ending range ('end') as defined in the Equate
00001B6C                          1676  *------------------------------------------------------------------------------
00001B6C                          1677          
00001B6C  2C3C 00FFFFFE           1678          MOVE.L      #end,D6             * Load maximum starting address
00001B72  B686                    1679          CMP.L       D6,D3               * Is input at or below maximum?
00001B74  6E00 0006               1680          BGT         ck_addr_range_error 
00001B78  6000 0012               1681          BRA         ck_addr_done        ;done checking
00001B7C                          1682          
00001B7C                          1683  *..............................................................................
00001B7C                          1684  * ck_addr_range_error -  A address entered is not within the 
00001B7C                          1685  *                        valid range for a hex address
00001B7C                          1686  *..............................................................................
00001B7C                          1687          
00001B7C                          1688  ck_addr_range_error
00001B7C                          1689  
00001B7C  43F9 00001D78           1690          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001B82                          1691          
00001B82  700D                    1692          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
00001B84                          1693                                          ;with CR, LF. 
00001B84  4E4F                    1694          TRAP        #15                 ;Display the error message
00001B86  76FF                    1695          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001B88  6000 0002               1696          BRA         ck_addr_done 
00001B8C                          1697  
00001B8C                          1698  ck_addr_done:
00001B8C                          1699  
00001B8C  4E75                    1700          RTS                             ;Return
00001B8E                          1701  
00001B8E                          1702  *******************************************************************************
00001B8E                          1703  *                          OP CODE ROLE ROUTINES
00001B8E                          1704  *******************************************************************************
00001B8E                          1705  
00001B8E                          1706  process_op_codes:
00001B8E                          1707  
00001B8E                          1708  
00001B8E                          1709  
00001B8E                          1710  process_op_codes_exit:
00001B8E                          1711  
00001B8E  4E75                    1712          RTS
00001B90                          1713  
00001B90                          1714  
00001B90                          1715  *******************************************************************************
00001B90                          1716  *                    Effective Addressing ROLE ROUTINES
00001B90                          1717  *******************************************************************************
00001B90                          1718  
00001B90                          1719  Get_Effective_Address:
00001B90                          1720  
00001B90  1C05                    1721          MOVE.B      D5,D6
00001B92  E60E                    1722          LSR.B       #3,D6               ;mode
00001B94  CA3C 0007               1723          And.B       #%00000111,D5       ;register
00001B98                          1724          
00001B98  BC3C 0000               1725          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
00001B9C  6700 004A               1726          BEQ         Data_Reg_Direct
00001BA0                          1727          
00001BA0  BC3C 0001               1728          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
00001BA4  6700 005C               1729          BEQ         Addr_Reg_Direct
00001BA8                          1730          
00001BA8  BC3C 0002               1731          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
00001BAC  6700 006E               1732          BEQ         Addr_Reg_Indirect
00001BB0                          1733          
00001BB0  BC3C 0003               1734          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
00001BB4  6700 0098               1735          BEQ         Addr_Reg_Indirect_Inc
00001BB8                          1736          
00001BB8  BC3C 0004               1737          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
00001BBC  6700 00CE               1738          BEQ         Addr_Reg_Indirect_Dec
00001BC0                          1739          
00001BC0  BC3C 0007               1740          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
00001BC4  6700 0006               1741          BEQ         Get_Effective_Address_Other
00001BC8                          1742          
00001BC8  6000 0138               1743          BRA         invalidEA
00001BCC                          1744          
00001BCC                          1745  Get_Effective_Address_Other:        
00001BCC                          1746          
00001BCC  BA3C 0000               1747          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00001BD0  6700 00F8               1748          BEQ Addr_Abs_Short
00001BD4                          1749          
00001BD4  BA3C 0001               1750          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
00001BD8  6700 0104               1751          BEQ Addr_Abs_Long
00001BDC                          1752          
00001BDC  BA3C 0004               1753          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
00001BE0  6700 0110               1754          BEQ Addr_Immediate_Data
00001BE4                          1755          
00001BE4  6000 011C               1756          BRA         invalidEA
00001BE8                          1757          
00001BE8                          1758  Data_Reg_Direct:                        ;case 0(0000)
00001BE8                          1759  
00001BE8  43F9 00001F5A           1760          LEA         letterD,A1          ;output 'D' for data register
00001BEE  103C 000E               1761          MOVE.B      #14,D0              ;set for task to display null terminated 
00001BF2  4E4F                    1762          TRAP        #15                 ;string without CR, LF
00001BF4                          1763                          
00001BF4  4281                    1764          CLR.L       D1
00001BF6  1205                    1765          MOVE.B      D5,D1               ;move register number for display into D1
00001BF8  103C 0003               1766          MOVE.B      #3,D0               ;set for task to display null terminated 
00001BFC  4E4F                    1767          TRAP        #15                 ;string without CR, LF
00001BFE                          1768                 
00001BFE  6000 0102               1769          BRA         Get_Effective_Address_Exit  ;return
00001C02                          1770          
00001C02                          1771          
00001C02                          1772  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
00001C02                          1773        
00001C02  43F9 00001F58           1774          LEA         letterA,A1          ;output 'A' for address register
00001C08  103C 000E               1775          MOVE.B      #14,D0              ;set for task to display null terminated 
00001C0C  4E4F                    1776          TRAP        #15                 ;string without CR, LF
00001C0E                          1777          
00001C0E  4281                    1778          CLR.L       D1
00001C10  1205                    1779          MOVE.B      D5,D1               ;move register number for display into D1
00001C12  103C 0003               1780          MOVE.B      #3,D0               ;set for task to display null terminated 
00001C16  4E4F                    1781          TRAP        #15                 ;string without CR, LF
00001C18                          1782          
00001C18  6000 00E8               1783          BRA         Get_Effective_Address_Exit  ;return
00001C1C                          1784  
00001C1C                          1785  
00001C1C                          1786  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
00001C1C                          1787          
00001C1C  43F9 00001F60           1788          LEA         lprn,A1             ;output 'D' for data register
00001C22  103C 000E               1789          MOVE.B      #14,D0              ;set for task to display null terminated 
00001C26  4E4F                    1790          TRAP        #15                 ;string without CR, LF
00001C28                          1791  
00001C28  43F9 00001F58           1792          LEA         letterA,A1          ;output 'A' for address register
00001C2E  103C 000E               1793          MOVE.B      #14,D0              ;set for task to display null terminated 
00001C32  4E4F                    1794          TRAP        #15                 ;string without CR, LF
00001C34                          1795          
00001C34  4281                    1796          CLR.L       D1
00001C36  1205                    1797          MOVE.B      D5,D1               ;move register number for display into D1
00001C38  103C 0003               1798          MOVE.B      #3,D0               ;set for task to display null terminated 
00001C3C  4E4F                    1799          TRAP        #15                 ;string without CR, LF
00001C3E                          1800  
00001C3E  43F9 00001F62           1801          LEA         rprn,A1             ;output 'D' for data register
00001C44  103C 000E               1802          MOVE.B      #14,D0              ;set for task to display null terminated 
00001C48  4E4F                    1803          TRAP        #15                 ;string without CR, LF
00001C4A                          1804          
00001C4A  6000 00B6               1805          BRA         Get_Effective_Address_Exit  ;return
00001C4E                          1806  
00001C4E                          1807                 
00001C4E                          1808  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
00001C4E                          1809  
00001C4E  43F9 00001F60           1810          LEA         lprn,A1             ;output 'D' for data register
00001C54  103C 000E               1811          MOVE.B      #14,D0              ;set for task to display null terminated 
00001C58  4E4F                    1812          TRAP        #15                 ;string without CR, LF
00001C5A                          1813  
00001C5A  43F9 00001F58           1814          LEA         letterA,A1          ;output 'A' for address register
00001C60  103C 000E               1815          MOVE.B      #14,D0              ;set for task to display null terminated 
00001C64  4E4F                    1816          TRAP        #15                 ;string without CR, LF
00001C66                          1817          
00001C66  4281                    1818          CLR.L       D1
00001C68  1205                    1819          MOVE.B      D5,D1               ;move register number for display into D1
00001C6A  103C 0003               1820          MOVE.B      #3,D0               ;set for task to display null terminated 
00001C6E  4E4F                    1821          TRAP        #15                 ;string without CR, LF
00001C70                          1822  
00001C70  43F9 00001F62           1823          LEA         rprn,A1             ;output 'D' for data register
00001C76  103C 000E               1824          MOVE.B      #14,D0              ;set for task to display null terminated 
00001C7A  4E4F                    1825          TRAP        #15                 ;string without CR, LF
00001C7C                          1826          
00001C7C  43F9 00001F5C           1827          LEA         plus,A1             ;output 'D' for data register
00001C82  103C 000E               1828          MOVE.B      #14,D0              ;set for task to display null terminated 
00001C86  4E4F                    1829          TRAP        #15                 ;string without CR, LF
00001C88                          1830          
00001C88  6000 0078               1831          BRA         Get_Effective_Address_Exit  ;return
00001C8C                          1832  
00001C8C                          1833  Addr_Reg_Indirect_Dec                   ;4 = (An) - Address Register Indirect with Predecrement (100)
00001C8C                          1834  
00001C8C  43F9 00001F5E           1835          LEA         minus,A1            ;output '-' for Predecrement
00001C92  103C 000E               1836          MOVE.B      #14,D0              ;set for task to display null terminated 
00001C96  4E4F                    1837          TRAP        #15                 ;string without CR, LF
00001C98                          1838  
00001C98  43F9 00001F60           1839          LEA         lprn,A1             ;output 'D' for data register
00001C9E  103C 000E               1840          MOVE.B      #14,D0              ;set for task to display null terminated 
00001CA2  4E4F                    1841          TRAP        #15                 ;string without CR, LF
00001CA4                          1842  
00001CA4  43F9 00001F58           1843          LEA         letterA,A1          ;output 'A' for address register
00001CAA  103C 000E               1844          MOVE.B      #14,D0              ;set for task to display null terminated 
00001CAE  4E4F                    1845          TRAP        #15                 ;string without CR, LF
00001CB0                          1846          
00001CB0  4281                    1847          CLR.L       D1
00001CB2  1205                    1848          MOVE.B      D5,D1               ;move register number for display into D1
00001CB4  103C 0003               1849          MOVE.B      #3,D0               ;set for task to display null terminated 
00001CB8  4E4F                    1850          TRAP        #15                 ;string without CR, LF
00001CBA                          1851  
00001CBA  43F9 00001F62           1852          LEA         rprn,A1             ;output 'D' for data register
00001CC0  103C 000E               1853          MOVE.B      #14,D0              ;set for task to display null terminated 
00001CC4  4E4F                    1854          TRAP        #15                 ;string without CR, LF
00001CC6                          1855          
00001CC6  6000 003A               1856          BRA         Get_Effective_Address_Exit  ;return
00001CCA                          1857          
00001CCA                          1858                         
00001CCA                          1859  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00001CCA                          1860          
00001CCA                          1861          
00001CCA  43F9 00001F3A           1862          LEA         xxxW,A1             ;output 'D' for data register
00001CD0  103C 000E               1863          MOVE.B      #14,D0              ;set for task to display null terminated 
00001CD4  4E4F                    1864          TRAP        #15                 ;string without CR, LF
00001CD6                          1865  
00001CD6  548B                    1866          ADDA.L      #word,A3
00001CD8                          1867          
00001CD8                          1868          ;print word (A3)
00001CD8                          1869          ;MOVE.W      A3,(A1)
00001CD8                          1870          ;MOVE.B      #1,D0               ;set for task to display null terminated 
00001CD8                          1871          ;TRAP        #15                 ;string without CR, LF
00001CD8                          1872          
00001CD8  5487                    1873          ADDI.L      #word,D7 
00001CDA  6000 0026               1874          BRA         Get_Effective_Address_Exit  ;return
00001CDE                          1875                         
00001CDE                          1876  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
00001CDE                          1877          
00001CDE  43F9 00001F44           1878          LEA         xxxL,A1             ;output 'D' for data register
00001CE4  103C 000E               1879          MOVE.B      #14,D0              ;set for task to display null terminated 
00001CE8  4E4F                    1880          TRAP        #15                 ;string without CR, LF
00001CEA                          1881  
00001CEA  548B                    1882          ADDA.L      #word,A3
00001CEC                          1883          
00001CEC                          1884          ;print long (A3)
00001CEC                          1885          ;MOVE.L      A3,(A1)
00001CEC                          1886          ;MOVE.B      #14,D0              ;set for task to display null terminated 
00001CEC                          1887          ;TRAP        #15                 ;string without CR, LF
00001CEC                          1888          
00001CEC  5887                    1889          ADDI.L      #long,D7
00001CEE  6000 0012               1890          BRA         Get_Effective_Address_Exit  ;return
00001CF2                          1891                         
00001CF2                          1892  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
00001CF2                          1893  
00001CF2  43F9 00001F4E           1894          LEA         iData,A1            ;output 'D' for data register
00001CF8  103C 000E               1895          MOVE.B      #14,D0              ;set for task to display null terminated 
00001CFC  4E4F                    1896          TRAP        #15                 ;string without CR, LF
00001CFE                          1897          
00001CFE                          1898          *need another input param for size
00001CFE  6000 0002               1899          BRA         Get_Effective_Address_Exit  ;return
00001D02                          1900  
00001D02                          1901  invalidEA:
00001D02                          1902  
00001D02                          1903          ;do something
00001D02                          1904   
00001D02                          1905  Get_Effective_Address_Exit:     
00001D02                          1906  
00001D02  4E75                    1907          RTS                             ;return
00001D04                          1908  
00001D04                          1909  switchModeAndReg:
00001D04                          1910  ***
00001D04                          1911  * Assumed in D2
00001D04                          1912  *
00001D04                          1913  * Assumed that they are in least significant byte:
00001D04                          1914  *
00001D04                          1915  *            _this_
00001D04                          1916  *           /      \
00001D04                          1917  *  ........ ........
00001D04                          1918  *  \                /
00001D04                          1919  *   -----word-------
00001D04                          1920  *
00001D04                          1921  *  and that in that byte they are ordered:
00001D04                          1922  *
00001D04                          1923  *       ........   
00001D04                          1924  *       \/\_/\_/
00001D04                          1925  *      /  /    \
00001D04                          1926  *    /   /      \
00001D04                          1927  * dont  one    other
00001D04                          1928  * care
00001D04                          1929  *
00001D04                          1930  * after they will be
00001D04                          1931  *
00001D04                          1932  *       ........   
00001D04                          1933  *       \/\_/\_/
00001D04                          1934  *      /  /    \
00001D04                          1935  *    /   /      \
00001D04                          1936  * dont other    one
00001D04                          1937  * care
00001D04                          1938  *** 
00001D04  0202 003F               1939          AndI.B #%00111111,D2 ;remove unwanted bits from D2
00001D08  0283 00000000           1940          ANDI.L #0,D3 ;clear D3
00001D0E  1602                    1941          MOVE.B D2,D3 ;copy to D3
00001D10  E70B                    1942          LSL.B  #3,D3 
00001D12  E60A                    1943          LSR.B  #3,D2
00001D14  D403                    1944          ADD.B  D3,D2
00001D16  4E75                    1945          RTS
00001D18                          1946  
00001D18                          1947          
00001D18                          1948  *==============================================================================
00001D18                          1949  *                            variables and constants
00001D18                          1950  *==============================================================================
00001D18                          1951  
00001D18                          1952  
00001D18                          1953  ***initial user prompt stuff        
00001D18= 45 6E 74 65 72 20 ...   1954  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE: $',0
00001D49= 45 6E 74 65 72 20 ...   1955  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE: $',0
00001D78                          1956  
00001D78= 20 41 64 64 72 65 ...   1957  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
00001DBD= 20 41 20 43 68 61 ...   1958  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
00001E05                          1959  
00001E05= 20 59 6F 75 20 6D ...   1960  even_msg        DC.B    ' You must enter an even address!'
00001E25                          1961  
00001E25= 20                      1962  spc             DC.B    ' '
00001E26= 01                      1963  spc_len         DC.B    spc_len-spc
00001E27                          1964  ***
00001E27                          1965  
00001E27                          1966  
00001E27                          1967  
00001E27                          1968  ***list of OP codes
00001E27                          1969  
00001E27  =00005100               1970  subqInstruction  EQU %0101000100000000
00001E27  =00009000               1971  subInstruction   EQU %1001000000000000
00001E27  =0000D000               1972  addaInstruction  EQU %1101000000000000
00001E27  =0000D000               1973  addInstruction   EQU %1101000000000000
00001E27  =00004880               1974  movemInstruction EQU %0100100010000000
00001E27  =00000600               1975  addiInstruction  EQU %0000011000000000
00001E27  =00000000               1976  oriInstruction   EQU 0
00001E27  =00000C00               1977  cmpiInstruction  EQU %0000110000000000
00001E27  =00004E80               1978  jsrInstruction   EQU %0100111010000000
00001E27  =00004E75               1979  rtsInstruction   EQU %0100111001110101
00001E27  =00004E71               1980  NoOpInstruction  EQU %0100111001110001
00001E27  =00000000               1981  moveInstruction  EQU 0
00001E27  =00006000               1982  bccInstruction   EQU %0110000000000000
00001E27  =00004400               1983  negInstruction   EQU %0100010000000000
00001E27  =00000000               1984  dataInstruction  EQU 0
00001E27                          1985  
00001E27                          1986  ***
00001E27                          1987  
00001E27                          1988  ***list of OP masks
00001E27                          1989  
00001E27  =0000F100               1990  subqMask  EQU %1111000100000000
00001E27  =0000F000               1991  subMask   EQU %1111000000000000
00001E27  =0000F000               1992  addaMask  EQU %1111000000000000
00001E27  =0000F000               1993  addMask   EQU %1111000000000000
00001E27  =0000FB80               1994  movemMask EQU %1111101110000000
00001E27  =0000FF00               1995  addiMask  EQU %1111111100000000
00001E27  =0000FF00               1996  oriMask   EQU %1111111100000000
00001E27  =0000FF00               1997  cmpiMask  EQU %1111111100000000
00001E27  =0000FFC0               1998  jsrMask   EQU %1111111111000000
00001E27  =0000FFFF               1999  rtsMask   EQU $FFFF
00001E27  =0000FFFF               2000  NoOpMask  EQU $FFFF
00001E27  =0000C000               2001  moveMask  EQU $C000
00001E27  =0000F000               2002  bccMask   EQU $F000
00001E27  =0000FF00               2003  negMask   EQU $FF00
00001E27  =00000000               2004  dataMask  EQU 0
00001E27                          2005  ***
00001E27                          2006  
00001E27                          2007  ***Bcc Codes***
00001E27  =00000004               2008  CC EQU $04
00001E27  =00000005               2009  CS EQU $05
00001E27  =00000007               2010  EQ EQU $07
00001E27  =0000000C               2011  GE EQU $0C
00001E27  =0000000E               2012  GT EQU $0E
00001E27  =00000002               2013  HI EQU $02
00001E27  =0000000F               2014  LE EQU $0F
00001E27  =00000003               2015  LS EQU $03
00001E27  =0000000D               2016  LT EQU $0D
00001E27  =0000000B               2017  MI EQU $0B
00001E27  =00000006               2018  NE EQU $06
00001E27  =0000000A               2019  PL EQU $0A
00001E27  =00000008               2020  VC EQU $08
00001E27  =00000009               2021  VS EQU $09
00001E27  =00000000               2022  RA EQU $00 ;not really a Condition Code
00001E27  =00000001               2023  SR EQU $01 ;not really a Condition Code
00001E27                          2024  
00001E27= 43 43 20 00             2025  CCm DC.B 'CC ',0
00001E2B= 43 53 20 00             2026  CSm DC.B 'CS ',0
00001E2F= 45 51 20 00             2027  EQm DC.B 'EQ ',0
00001E33= 47 45 20 00             2028  GEm DC.B 'GE ',0
00001E37= 47 54 20 00             2029  GTm DC.B 'GT ',0
00001E3B= 48 49 20 00             2030  HIm DC.B 'HI ',0
00001E3F= 4C 45 20 00             2031  LEm DC.B 'LE ',0
00001E43= 4C 53 20 00             2032  LSm DC.B 'LS ',0
00001E47= 4C 54 20 00             2033  LTm DC.B 'LT ',0
00001E4B= 4D 49 20 00             2034  MIm DC.B 'MI ',0
00001E4F= 4E 45 20 00             2035  NEm DC.B 'NE ',0
00001E53= 50 4C 20 00             2036  PLm DC.B 'PL ',0
00001E57= 56 43 20 00             2037  VCm DC.B 'VC ',0
00001E5B= 56 53 20 00             2038  VSm DC.B 'VS ',0
00001E5F= 52 41 20 00             2039  RAm DC.B 'RA ',0
00001E63= 53 52 20 00             2040  SRm DC.B 'SR ',0
00001E67                          2041  
00001E67= 01 04 05 07 0C 0E ...   2042  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
00001E78= 00001E63 00001E27 ...   2043  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
00001EB8                          2044  ***
00001EB8                          2045  
00001EB8= 45 6E 74 65 72 20 ...   2046  startLocationPrompt DC.B    'Enter start location',0
00001ECD= 45 6E 74 65 72 20 ...   2047  endLocationPrompt   DC.B    'Enter end location',0
00001EE0                          2048  
00001EE0= 0D 0A 00                2049  clearLine  DC.B $0D,$0A,0
00001EE3                          2050  
00001EE3= 53 55 42 51 20 00       2051  subqMessage     DC.B 'SUBQ ',0
00001EE9= 53 55 42 20 00          2052  subMessage      DC.B 'SUB ',0 
00001EEE= 41 44 44 41 20 00       2053  addaMessage     DC.B 'ADDA ',0
00001EF4= 41 44 44 20 00          2054  addMessage      DC.B 'ADD ',0
00001EF9= 4D 4F 56 45 4D 20 00    2055  movemMessage    DC.B 'MOVEM ',0
00001F00= 41 44 44 49 20 00       2056  addiMessage     DC.B 'ADDI ',0
00001F06= 4F 52 49 20 00          2057  oriMessage      DC.B 'ORI ',0
00001F0B= 43 4D 50 49 20 00       2058  cmpiMessage     DC.B 'CMPI ',0
00001F11= 4A 53 52 20 00          2059  jsrMessage      DC.B 'JSR ',0
00001F16= 52 54 53 20 00          2060  rtsMessage      DC.B 'RTS ',0
00001F1B= 4E 4F 50 20 00          2061  nopMessage      DC.B 'NOP ',0 
00001F20= 4D 4F 56 45 20 00       2062  moveMessage     DC.B 'MOVE ',0
00001F26= 42 00                   2063  bccMessage      DC.B 'B',0
00001F28= 4E 45 47 20 00          2064  negMessage      DC.B 'NEG ',0
00001F2D= 44 41 54 41 20 00       2065  dataMessage     DC.B 'DATA ',0
00001F33= 4D 4F 56 45 41 20 00    2066  moveaMessage    DC.B 'MOVEA ',0
00001F3A                          2067  
00001F3A= 28 78 78 78 29 2E ...   2068  xxxW            DC.B '(xxx).W: ',0
00001F44= 28 78 78 78 29 2E ...   2069  xxxL            DC.B '(xxx).L: ',0
00001F4E= 23 28 64 61 74 61 ...   2070  iData           DC.B '#(data): ',0
00001F58                          2071  
00001F58= 41 00                   2072  letterA         DC.B 'A', 0
00001F5A= 44 00                   2073  letterD         DC.B 'D', 0
00001F5C                          2074  
00001F5C= 2B 00                   2075  plus            DC.B '+', 0
00001F5E= 2D 00                   2076  minus           DC.B '-', 0
00001F60= 28 00                   2077  lPrn            DC.B '(', 0
00001F62= 29 00                   2078  rPrn            DC.B ')', 0
00001F64                          2079  
00001F64                          2080  
00001F64= 00000000                2081  startLocation       DC.L    0
00001F68= 00000000                2082  endLocation         DC.L    0
00001F6C                          2083  
00001F6C                          2084  
00001F6C                          2085     
00001F6C                          2086      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 13B8
ADDA                131A
ADDABODY            1362
ADDAINSTRUCTION     D000
ADDAMASK            F000
ADDAMESSAGE         1EEE
ADDDEST             147C
ADDDESTEA           13AC
ADDDESTEAMASKS      13B2
ADDI                15EA
ADDIBODY            1616
ADDIDONE            1654
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         1F00
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          1EF4
ADDRESS_DONE        1A7C
ADDRESS_EXIT        1A76
ADDR_ABS_LONG       1CDE
ADDR_ABS_SHORT      1CCA
ADDR_IMMEDIATE_DATA  1CF2
ADDR_REG_DIRECT     1C02
ADDR_REG_INDIRECT   1C1C
ADDR_REG_INDIRECT_DEC  1C8C
ADDR_REG_INDIRECT_INC  1C4E
ADDSOURCE           1434
BCC                 1930
BCCBYTE             1982
BCCDONE             1998
BCCINSTRUCTION      6000
BCCLIST             1E67
BCCLONG             1990
BCCMASK             F000
BCCMESSAGE          1F26
BCCWORD             1988
BEGIN               5001
BEGIN_ADDRESS       1A08
BYTE                1
CC                  4
CCM                 1E27
CHECKCC             1946
CHECKMOVEADEST      18DC
CHECKMOVEDEST       182A
CHECKOPCODE         1050
CK_ADDR_DONE        1B8C
CK_ADDR_RANGE       1B60
CK_ADDR_RANGE_ERROR  1B7C
CK_BOUNDRY          1AA4
CK_BOUNDRY_ERROR    1AC6
CK_SIZE_ERROR       1ADA
CLEARLINE           1EE0
CMPI                16EC
CMPIBODY            1714
CMPIDONE            1752
CMPIEA              16DE
CMPIEAMASKS         16E5
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         1F0B
CONDITIONCODEMESSAGE  1E78
CS                  5
CSM                 1E2B
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         1F2D
DATA_REG_DIRECT     1BE8
ELPROMPT            1D49
END                 FFFFFE
ENDLOCATION         1F68
ENDLOCATIONPROMPT   1ECD
END_ADDRESS         1A4C
ENTER_ADDR_EDIT_ALL  1A7E
ENTER_ADDR_EDIT_ALL_EXIT  1AA2
EQ                  7
EQM                 1E2F
EVEN_MSG            1E05
FALSEPOSITIVE       1070
FARLABEL            FFE
FIN                 1A04
FOUNDCC             1958
GE                  C
GEM                 1E33
GET_EFFECTIVE_ADDRESS  1B90
GET_EFFECTIVE_ADDRESS_EXIT  1D02
GET_EFFECTIVE_ADDRESS_OTHER  1BCC
GT                  E
GTM                 1E37
HANDLEBYTEDATA      19D8
HEX_RANGE_ERROR     1B48
HI                  2
HIM                 1E3B
IDATA               1F4E
INSTLABELLIST       10D2
INSTMASKLIST        10B4
INSTOPLIST          1096
INVALIDEA           1D02
INVALIDMSG          1D78
INVCHARMSG          1DBD
JSR                 176A
JSRBODY             1792
JSRDONE             17B2
JSREA               1762
JSREAMASKS          1766
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          1F11
LCASEHEX            1B2A
LE                  F
LEM                 1E3F
LETTERA             1F58
LETTERD             1F5A
LONG                4
LPRN                1F60
LS                  3
LSM                 1E43
LT                  D
LTM                 1E47
MAIN_LOOP           1026
MATCH               1076
MI                  B
MIM                 1E4B
MINUS               1F5E
MOVE                1802
MOVEA               18B4
MOVEABODY           190A
MOVEADESTEA         18B0
MOVEADESTEAMASKS    18B2
MOVEAMESSAGE        1F33
MOVEBODY            1858
MOVEDESTEA          17F4
MOVEDESTEAMASKS     17FB
MOVEINSTRUCTION     0
MOVEM               14D8
MOVEMASK            C000
MOVEMBODY           1542
MOVEMESSAGE         1F20
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     14CE
MOVEMMEMTOREGEAMASKS  14D3
MOVEMMESSAGE        1EF9
MOVEMREGTOMEMEA     14C4
MOVEMREGTOMEMEAMASKS  14C9
MOVESOURCEEA        17E2
MOVESOURCEEAMASKS   17EB
NE                  6
NEG                 1584
NEGBODY             15AC
NEGDONE             15DA
NEGEA               1574
NEGEAMASKS          157C
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          1F28
NEM                 1E4F
NEXTHEX             1AF0
NEXTHEXDONE         1B42
NEXTHEXRETURN       1B5E
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 17C2
NOPMESSAGE          1F1B
ORI                 1664
ORIBODY             1690
ORIDONE             16CE
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          1F06
PARSEHEXSTRING      1AEE
PL                  A
PLM                 1E53
PLUS                1F5C
PRGORG              1000
PROCESS_OP_CODES    1B8E
PROCESS_OP_CODES_EXIT  1B8E
PROMPT_USER         1014
RA                  0
RAM                 1E5F
RPRN                1F62
RTS                 17D2
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          1F16
SLPROMPT            1D18
SNIPPET             110E
SNIPPETEND          114E
SPC                 1E25
SPC_LEN             1E26
SR                  1
SRM                 1E63
STACK               5000
START               1000
STARTLOCATION       1F64
STARTLOCATIONPROMPT  1EB8
SUB                 120A
SUBDEST             12D2
SUBINSTRUCTION      9000
SUBMASK             F000
SUBMESSAGE          1EE9
SUBQ                1162
SUBQBODY            119A
SUBQEA              1152
SUBQEAMASKS         115A
SUBQINSTRUCTION     5100
SUBQMASK            F100
SUBQMESSAGE         1EE3
SUBSOURCE           128A
SWITCHMODEANDREG    1D04
TOEIGHT             1206
UCASEHEX            1B12
UNKNOWNOPCODE       19B2
VALIDADDA           1338
VALIDADDDESTEA      1408
VALIDADDIMODES      15EC
VALIDADDSOURCEEA    13DE
VALIDCMPIMODES      16EE
VALIDJSRMODES       176C
VALIDMEMTOREG       1514
VALIDMOVEADESTMODES  18DE
VALIDMOVEASOURCEMODES  18B6
VALIDMOVEDESTMODES  182C
VALIDMOVESOURCEMODES  1804
VALIDNEGMODES       1586
VALIDORIMODES       1666
VALIDREGTOMEM       14EE
VALIDSUBDESTEA      125A
VALIDSUBQ           1174
VALIDSUBSOURCEEA    1230
VC                  8
VCM                 1E57
VS                  9
VSM                 1E5B
WORD                2
XXXL                1F44
XXXW                1F3A
ZEROTOEIGHT         11FC
ZEROTOEIGHTRETURN   1204

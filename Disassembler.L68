00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/9/2014 4:55:57 AM

00000000                             1  *##########################################################################
00000000                             2  * Title      : 
00000000                             3  * Written by : Andrew Watson
00000000                             4  *            : Elaine Keller
00000000                             5  *            : Robert Anderson
00000000                             6  * Date       : 11/14/2014
00000000                             7  * Description: 
00000000                             8  *##########################################################################
00000000                             9  
00000000                            10  ***Possible Bug***
00000000                            11  *can not tell data from an
00000000                            12  *unidentified instruction from an actual
00000000                            13  *instruction therefore causing errors.
00000000                            14  *may not actually be a bug because data
00000000                            15  *is data to the machine, and if you modify
00000000                            16  *the instructions in memory for a program
00000000                            17  *by moivng data, you can modify the instuctions
00000000                            18  *executed.
00000000                            19  
00000000                            20  
00000000                            21  ***************************************************************************
00000000                            22  *                   Variable/Data Definitions
00000000                            23  ***************************************************************************
00000000                            24  
00000000  =00005000                 25  stack   EQU   $00005000
00000000  =00005001                 26  begin   EQU   $00005001
00000000  =00FFFFFE                 27  end     EQU   $00FFFFFE
00000000  =00000001                 28  byte    EQU   1
00000000  =00000002                 29  word    EQU   2
00000000  =00000004                 30  long    EQU   4
00000000  =00001000                 31  prgorg  EQU   $1000
00000000                            32  
00000FFE                            33      ORG $00000FFE
00000FFE                            34  FarLabel:
00001000                            35      ORG    prgorg
00001000                            36  start:
00001000  4FF8 5000                 37          LEA stack, SP ;initialize stack
00001004                            38  
00001000                            39      ORG    prgorg
00001000                            40  
00001000                            41  ******************************************************************************
00001000                            42  *                   Begin processing active code
00001000                            43  ******************************************************************************
00001000                            44      
00001000                            45  start:
00001000                            46  
00001000  4FF8 5000                 47          LEA         stack, SP           ;Initialize stack
00001004                            48          
00001004                            49  *.............................................................................
00001004                            50  * Debug Mode - Comment out when done
00001004  267C 0000112E             51          MOVE.L      #snippet,A3
0000100A  287C 00001192             52          MOVE.L      #snippetEnd,A4
00001010  6000 0014                 53          BRA         main_Loop
00001014                            54  * Debug Mode - Comment out when done
00001014                            55  *.............................................................................        
00001014                            56          
00001014                            57  prompt_user:
00001014                            58  
00001014  6100 0C42                 59          BSR         begin_address
00001018  B67C FFFF                 60          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000101C  6700 0C36                 61          BEQ         fin                 ;Yes, then exit
00001020                            62          
00001020  6000 0004                 63          BRA         main_Loop
00001024                            64          ;BSR         process_op_codes
00001024  60EE                      65          BRA         prompt_user
00001026                            66                  
00001026                            67  ******************************************************************************
00001026                            68  *                   Begin processing OP Codes
00001026                            69  ******************************************************************************
00001026                            70   
00001026                            71  main_Loop:
00001026                            72  
00001026  B9CB                      73          CMPA.L A3,A4 ;check end of prog
00001028  6700 0C2A                 74          BEQ fin
0000102C                            75          
0000102C  3213                      76          MOVE.W (A3),D1 ;copy word from other prog to analyze as instruction
0000102E                            77          
0000102E                            78          ;handle an odd memory access(instructions will never be misaligned)
0000102E  240B                      79          MOVE.L A3,D2 ; copy address to D2
00001030  0202 0001                 80          ANDI.B #%00000001,D2 ;mask everything except the least significant bit
00001034  0C02 0001                 81          CMPI.B #1,D2 ;compare the least sig bit of the address to one
00001038  6700 0BEE                 82          BEQ handlebytedata ;the least sig bit will only be one if the insrtuction
0000103C                            83                             ;is odd(misaligned) and therefore not an instruction
0000103C                            84          
0000103C  7600                      85          MOVEQ.L #0,D3
0000103E                            86          
0000103E                            87          ***things to save A3,A4,D1(?)***
0000103E  48E7 0018                 88          MOVEM.L A3-A4,-(SP)
00001042  6100 000C                 89          BSR checkOPcode
00001046  4CDF 1800                 90          MOVEM.L (SP)+,A3-A4
0000104A  D7C7                      91          ADDA.L  D7,A3 ;look past data that was part of the instruction
0000104C                            92          
0000104C  548B                      93          ADDQ.L  #word,A3
0000104E  60D6                      94          BRA     main_Loop 
00001050                            95          
00001050                            96  checkOPcode:
00001050                            97  
00001050                            98  
00001050  7E00                      99          MOVEQ.L #0,D7
00001052                           100          
00001052  41F9 00001096            101          LEA     instOPList,A0 ;get instruction signitrue list in A0
00001058  D1C3                     102          ADDA.L  D3,A0 ;get correct sig         
0000105A                           103          
0000105A  43F9 000010BC            104          LEA     instMaskList,A1 ;get instruction mask in A1
00001060  D3C3                     105          ADDA.L  D3,A1  ;get correct mast
00001062                           106          
00001062  3401                     107          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001064                           108          
00001064  C451                     109          AND.W   (A1),D2 ;mask instruction
00001066                           110          
00001066                           111          
00001066                           112          
00001066                           113          
00001066  B450                     114          CMP.W   (A0),D2 ;compare to sig
00001068  6700 000C                115          BEQ     match ;if sig matches branch
0000106C  5483                     116          ADDQ.L  #word,D3 ;add to D3 to check for next instruction
0000106E  60E0                     117          BRA checkOPcode
00001070                           118          
00001070                           119  falsePositive:
00001070                           120          
00001070  103C 00FF                121          MOVE.B #-1,D0
00001074  4E75                     122          RTS
00001076                           123  
00001076                           124  match:
00001076                           125          
00001076  43F9 000010E2            126          LEA     instLabelList,A1 ;get instruction code label
0000107C  D3C3                     127          ADDA.L  D3,A1 ;get correct label
0000107E  D3C3                     128          ADDA.L  D3,A1
00001080  5483                     129          ADDQ.L  #word,D3 ;add to D3 incase false positive
00001082  2251                     130          MOVEA.L (A1),A1
00001084  48E7 1000                131          MOVEM.L D3,-(SP) ; save D3
00001088  4E91                     132          JSR     (A1)
0000108A  4CDF 0008                133          MOVEM.L (SP)+,D3 ;restore D3
0000108E  B03C 00FF                134          CMP.B   #-1,D0
00001092  67BC                     135          BEQ     checkOPcode
00001094  4E75                     136          RTS
00001096                           137          
00001096                           138  
00001096= E0C0 E000 E2C0 E008      139  instOPList  DC.W asrlweaInstruction,asrlregInstruction,lsrlweaInstruction,lsrlregInstruction
0000109E= 5100 9000 D000 D...      140  instOPList2 DC.W subqInstruction,subInstruction,addaInstruction,addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruct
000010BC                           141      
000010BC= FEC0 F018 FEC0 F...      142  instMaskList DC.W asrlweaMask,asrlregMask,lsrlweaMask,lsrlregMask,subqMask,subMask,addaMask,addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
000010E2= 00001196 000011F6 ...    143  instLabelList DC.L ASRLWEA,ASRLREG,LSRLWEA,LSRLREG,SUBQ,SUB,ADDA,ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
0000112E                           144  
0000112E                           145  snippet:
0000112E  4E71                     146           NOP
00001130  60FC                     147           BRA snippet
00001132  6000 FECA                148           BRA FarLabel
00001136  67F6                     149           BEQ snippet
00001138  6E00 069A                150           BGT NEG
0000113C  61F0                     151           BSR snippet
0000113E  4441                     152           NEG D1
00001140  3239 00008500            153           MOVE.W $8500,D1
00001146  0645 001E                154           ADDI.W #30,D5
0000114A  4E75                     155           RTS
0000114C  4EB8 0054                156           JSR $54
00001150  0C41 0003                157           CMPI #3,D1
00001154  0041 0003                158           ORI  #3,D1
00001158  48E7 0018                159           MOVEM.L A3-A4,-(SP)
0000115C  D401                     160           ADD.B D1,D2
0000115E  0603 000A                161           ADD.B #10,D3
00001162  D7FC 00000463            162           ADDA.L #1123,A3
00001168  9A43                     163           SUB.W D3,D5
0000116A  5105                     164           SUBQ.B #8,D5
0000116C  5305                     165           SUBQ.B #1,D5
0000116E  E64B                     166           LSR #3,D3
00001170  E74C                     167           LSL #3,D4
00001172  E369                     168           LSL D1,D1
00001174  E66F                     169           LSR D3,D7
00001176  E2F8 3563                170           LSR $3563
0000117A  E3F9 00486412            171           LSL $486412
00001180  E643                     172           ASR #3,D3
00001182  E744                     173           ASL #3,D4
00001184  E361                     174           ASL D1,D1
00001186  E667                     175           ASR D3,D7
00001188  E0F8 3563                176           ASR $3563
0000118C  E1F9 00486412            177           ASL $486412
00001192                           178  
00001192                           179           
00001192                           180  snippetEnd:
00001192  FFFF FFFF                181           SIMHALT
00001196                           182       
00001196                           183  
00001196                           184  ASRLWEA:
00001196                           185          
00001196                           186  
00001196                           187          
00001196  7000                     188          MOVEQ.L #0, D0 ;clear D0
00001198                           189          
00001198                           190  validASRL:
00001198                           191          
00001198  43F9 00001242            192          LEA lsrlEAmasks,A1 ;load the list of masks
0000119E  D3C0                     193          ADDA.L D0,A1 ;displace to a specific mask
000011A0  1A11                     194          MOVE.B (A1),D5 ;move the mask to D5
000011A2                           195          
000011A2  0C05 0000                196          CMPI.B #0,D5 ;check if the mask is 0
000011A6  6700 FEC8                197          BEQ falsePositive ;branch if it is
000011AA                           198          
000011AA  1401                     199          MOVE.B D1,D2 ;copy instruction to D2
000011AC  C405                     200          AND.B D5,D2  ;mask D2
000011AE                           201          
000011AE  43F9 0000123C            202          LEA lsrlEA,A1 ;load the list of valid modes
000011B4  D3C0                     203          ADDA.L D0,A1 ;displace to a specific mode
000011B6  1811                     204          MOVE.B (A1),D4 ;move mode to D4
000011B8  B404                     205          CMP.B D4,D2 ;compare mode to masked value
000011BA  6700 0006                206          BEQ  asrlweaCheckDirection ;if its match, its a valid mode and we can procede
000011BE                           207          
000011BE  5280                     208          ADDQ.L #1,D0 ;add one to displacement
000011C0  60D6                     209          BRA validASRL ;check for next mode
000011C2                           210  
000011C2                           211  asrlweaCheckDirection:
000011C2                           212          ;Figure out which direction we are going
000011C2  3401                     213          MOVE.W D1,D2 ;copy inst to D2
000011C4  E04A                     214          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000011C6  0202 0001                215          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000011CA  0C02 0000                216          CMPI.B #0,D2 ;compare bit to zero
000011CE  6700 0006                217          BEQ ASREA ;if zero, right
000011D2  6000 0012                218          BRA ASLEA ;else, its left
000011D6                           219  
000011D6                           220  ASREA:
000011D6                           221  
000011D6  43F9 00002138            222          LEA     asrMessage,A1  ;move string for MOVE
000011DC  103C 000E                223          MOVE.B  #14,D0        ;set for task to display null terminated 
000011E0                           224                                ;string with CR, LF
000011E0  4E4F                     225          TRAP    #15
000011E2  6000 00C0                226          BRA lsrlweaBody
000011E6                           227          
000011E6                           228  ASLEA:
000011E6                           229          
000011E6  43F9 00002133            230          LEA     aslMessage,A1  ;move string for MOVE
000011EC  103C 000E                231          MOVE.B  #14,D0        ;set for task to display null terminated 
000011F0                           232                                ;string with CR, LF
000011F0  4E4F                     233          TRAP    #15
000011F2  6000 00B0                234          BRA lsrlweaBody        
000011F6                           235          
000011F6                           236  
000011F6                           237  
000011F6                           238  ASRLREG:
000011F6                           239          
000011F6                           240  
000011F6                           241          
000011F6  7000                     242          MOVEQ.L #0, D0 ;clear D0
000011F8                           243          
000011F8                           244          ;check valid size field
000011F8  3401                     245          MOVE.W D1,D2 ;copy inst to D2
000011FA  EC4A                     246          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
000011FC  0202 0003                247          ANDI.B #%00000011,D2 ;mask out rest of byte
00001200  0C02 0003                248          CMPI.B #%11,D2 ;compare to 3
00001204  6700 FE6A                249          BEQ falsePositive ;invalid size
00001208                           250  
00001208                           251          
00001208                           252          ;Figure out which direction we are going
00001208  3401                     253          MOVE.W D1,D2 ;copy inst to D2
0000120A  E04A                     254          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
0000120C  0202 0001                255          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
00001210  0C02 0000                256          CMPI.B #0,D2 ;compare bit to zero
00001214  6700 0006                257          BEQ ASRreg ;if zero, right
00001218  6000 0012                258          BRA ASLreg ;else, its left        
0000121C                           259          
0000121C                           260  ASRreg:
0000121C                           261  
0000121C  43F9 00002138            262          LEA     asrMessage,A1  ;move string for MOVE
00001222  103C 000E                263          MOVE.B  #14,D0        ;set for task to display null terminated 
00001226                           264                                ;string with CR, LF
00001226  4E4F                     265          TRAP    #15
00001228  6000 00E4                266          BRA LSRLregBody
0000122C                           267          
0000122C                           268  ASLreg:
0000122C                           269          
0000122C  43F9 00002133            270          LEA     aslMessage,A1  ;move string for MOVE
00001232  103C 000E                271          MOVE.B  #14,D0        ;set for task to display null terminated 
00001236                           272                                ;string with CR, LF
00001236  4E4F                     273          TRAP    #15
00001238  6000 00D4                274          BRA LSRLregBody
0000123C                           275  
0000123C                           276  
0000123C= 10 18 20 38 39 00        277  lsrlEA        DC.B %010000,%011000,%100000,%111000,%111001,0
00001242= 38 38 38 3F 3F 00        278  lsrlEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0       
00001248                           279  
00001248                           280  LSRLWEA:
00001248                           281          
00001248                           282  
00001248                           283          
00001248  7000                     284          MOVEQ.L #0, D0 ;clear D0
0000124A                           285          
0000124A                           286  validLSRL:
0000124A                           287          
0000124A  43F8 1242                288          LEA lsrlEAmasks,A1 ;load the list of masks
0000124E  D3C0                     289          ADDA.L D0,A1 ;displace to a specific mask
00001250  1A11                     290          MOVE.B (A1),D5 ;move the mask to D5
00001252                           291          
00001252  0C05 0000                292          CMPI.B #0,D5 ;check if the mask is 0
00001256  6700 FE18                293          BEQ falsePositive ;branch if it is
0000125A                           294          
0000125A  1401                     295          MOVE.B D1,D2 ;copy instruction to D2
0000125C  C405                     296          AND.B D5,D2  ;mask D2
0000125E                           297          
0000125E  43F8 123C                298          LEA lsrlEA,A1 ;load the list of valid modes
00001262  D3C0                     299          ADDA.L D0,A1 ;displace to a specific mode
00001264  1811                     300          MOVE.B (A1),D4 ;move mode to D4
00001266  B404                     301          CMP.B D4,D2 ;compare mode to masked value
00001268  6700 0006                302          BEQ  lsrlweaCheckDirection ;if its match, its a valid mode and we can procede
0000126C                           303          
0000126C  5280                     304          ADDQ.L #1,D0 ;add one to displacement
0000126E  60DA                     305          BRA validLSRL ;check for next mode
00001270                           306  
00001270                           307  lsrlweaCheckDirection:
00001270                           308          ;Figure out which direction we are going
00001270  3401                     309          MOVE.W D1,D2 ;copy inst to D2
00001272  E04A                     310          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
00001274  0202 0001                311          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
00001278  0C02 0000                312          CMPI.B #0,D2 ;compare bit to zero
0000127C  6700 0006                313          BEQ LSREA ;if zero, right
00001280  6000 0012                314          BRA LSLEA ;else, its left
00001284                           315  
00001284                           316  LSREA:
00001284                           317  
00001284  43F9 00002142            318          LEA     lsrMessage,A1  ;move string for MOVE
0000128A  103C 000E                319          MOVE.B  #14,D0        ;set for task to display null terminated 
0000128E                           320                                ;string with CR, LF
0000128E  4E4F                     321          TRAP    #15
00001290  6000 0012                322          BRA lsrlweaBody
00001294                           323          
00001294                           324  LSLEA:
00001294                           325          
00001294  43F9 0000213D            326          LEA     lslMessage,A1  ;move string for MOVE
0000129A  103C 000E                327          MOVE.B  #14,D0        ;set for task to display null terminated 
0000129E                           328                                ;string with CR, LF
0000129E  4E4F                     329          TRAP    #15
000012A0  6000 0002                330          BRA lsrlweaBody        
000012A4                           331          
000012A4                           332  lsrlweaBody:
000012A4                           333  
000012A4                           334          
000012A4  3401                     335          MOVE.W  D1,D2 ;check mode
000012A6  C43C 003F                336          AND.B   #%00111111,D2
000012AA  1A02                     337          MOVE.B  D2,D5
000012AC  48E7 4000                338          MOVEM.L D1,-(SP)
000012B0  6100 0B2E                339          BSR     Get_Effective_Address
000012B4  4CDF 0002                340          MOVEM.L (SP)+,D1
000012B8                           341          
000012B8                           342          
000012B8  43F9 00002130            343          LEA     clearLine,A1  ;move string for a CR and LF
000012BE  103C 000E                344          MOVE.B  #14,D0        ;set for task to display null terminated 
000012C2                           345                                ;string without CR, LF
000012C2  4E4F                     346          TRAP    #15
000012C4                           347  
000012C4  7000                     348          MOVEQ.L #0,D0
000012C6  4E75                     349          RTS
000012C8                           350  
000012C8                           351  
000012C8                           352  LSRLREG:
000012C8                           353          
000012C8                           354  
000012C8                           355          
000012C8  7000                     356          MOVEQ.L #0, D0 ;clear D0
000012CA                           357          
000012CA                           358          ;check valid size field
000012CA  3401                     359          MOVE.W D1,D2 ;copy inst to D2
000012CC  EC4A                     360          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
000012CE  0202 0003                361          ANDI.B #%00000011,D2 ;mask out rest of byte
000012D2  0C02 0003                362          CMPI.B #%11,D2 ;compare to 3
000012D6  6700 FD98                363          BEQ falsePositive ;invalid size
000012DA                           364  
000012DA                           365          
000012DA                           366          ;Figure out which direction we are going
000012DA  3401                     367          MOVE.W D1,D2 ;copy inst to D2
000012DC  E04A                     368          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000012DE  0202 0001                369          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000012E2  0C02 0000                370          CMPI.B #0,D2 ;compare bit to zero
000012E6  6700 0006                371          BEQ LSRreg ;if zero, right
000012EA  6000 0012                372          BRA LSLreg ;else, its left        
000012EE                           373          
000012EE                           374  LSRreg:
000012EE                           375  
000012EE  43F9 00002142            376          LEA     lsrMessage,A1  ;move string for MOVE
000012F4  103C 000E                377          MOVE.B  #14,D0        ;set for task to display null terminated 
000012F8                           378                                ;string with CR, LF
000012F8  4E4F                     379          TRAP    #15
000012FA  6000 0012                380          BRA LSRLregBody
000012FE                           381          
000012FE                           382  LSLreg:
000012FE                           383          
000012FE  43F9 0000213D            384          LEA     lslMessage,A1  ;move string for MOVE
00001304  103C 000E                385          MOVE.B  #14,D0        ;set for task to display null terminated 
00001308                           386                                ;string with CR, LF
00001308  4E4F                     387          TRAP    #15
0000130A  6000 0002                388          BRA LSRLregBody
0000130E                           389          
0000130E                           390  LSRLregBody:
0000130E                           391                      
0000130E                           392          ;check i/r
0000130E  48E7 4000                393          MOVEM.L D1,-(SP)
00001312  6100 002A                394          BSR LSRLcheckIR
00001316  4CDF 0002                395          MOVEM.L (SP)+,D1
0000131A                           396          
0000131A  3401                     397          MOVE.W  D1,D2 ;check mode
0000131C  C43C 0007                398          AND.B   #%00000111,D2
00001320  1A02                     399          MOVE.B  D2,D5
00001322  48E7 4000                400          MOVEM.L D1,-(SP)
00001326  6100 0AB8                401          BSR     Get_Effective_Address
0000132A  4CDF 0002                402          MOVEM.L (SP)+,D1
0000132E                           403          
0000132E                           404          
0000132E  43F9 00002130            405          LEA     clearLine,A1  ;move string for a CR and LF
00001334  103C 000E                406          MOVE.B  #14,D0        ;set for task to display null terminated 
00001338                           407                                ;string without CR, LF
00001338  4E4F                     408          TRAP    #15
0000133A                           409  
0000133A  7000                     410          MOVEQ.L #0,D0
0000133C  4E75                     411          RTS
0000133E                           412  
0000133E                           413  LSRLcheckIR:
0000133E                           414  
0000133E  1401                     415          MOVE.B D1,D2 ;move inst to D2
00001340  EA0A                     416          LSR.B  #5,D2
00001342  C43C 0001                417          AND.B  #%00000001,D2
00001346  0C02 0000                418          CMPI.B #0,D2
0000134A  6700 0008                419          BEQ  LSRLcheckI
0000134E  6000 0038                420          BRA  LSRLcheckR
00001352                           421  LSRLcheckIRreturn:
00001352  4E75                     422          RTS
00001354                           423          
00001354                           424  LSRLcheckI:
00001354                           425          ;print '#'
00001354  48E7 4000                426          MOVEM.L D1,-(SP) ;save D1 to the stack
00001358  123C 0023                427          MOVE.B #'#',D1 ;put ascii value of '#' in D1
0000135C  103C 0006                428          MOVE.B #6,D0 ;move task 6 into D0
00001360  4E4F                     429          TRAP #15 ;prin char
00001362  4CDF 0002                430          MOVEM.L (SP)+,D1 ;pull D1 off the stack
00001366                           431          
00001366                           432          ;print number
00001366  48E7 4000                433          MOVEM.L D1,-(SP)
0000136A  3401                     434          MOVE.W D1,D2 ;copy inst to d2
0000136C  E04A                     435          LSR.W #8,D2 ;shift data section
0000136E  E20A                     436          LSR.B #1,D2
00001370  C43C 0007                437          AND.B #%00000111,D2 ;mask out rest of data
00001374  6100 00D6                438          BSR ZeroToEight ;handle zero
00001378  7200                     439          MOVEQ.L #0,D1 ;clear D1
0000137A  1202                     440          MOVE.B D2,D1 ;move number to display into D1
0000137C  103C 0003                441          MOVE.B #3,D0 ;move task 3 to D0
00001380  4E4F                     442          TRAP #15
00001382  4CDF 0002                443          MOVEM.L (SP)+,D1
00001386  60CA                     444          BRA LSRLcheckIRreturn
00001388                           445          
00001388                           446  LSRLcheckR:
00001388  3401                     447          MOVE.W D1,D2 ;copy inst to d2
0000138A  E04A                     448          LSR.W #8,D2 ;shift data section
0000138C  E20A                     449          LSR.B #1,D2
0000138E  C43C 0007                450          AND.B #%00000111,D2 ;mask out rest of data
00001392  1A02                     451          MOVE.B D2,D5 ;force Dn
00001394  48E7 4000                452          MOVEM.L D1,-(SP)
00001398  6100 0A46                453          BSR     Get_Effective_Address
0000139C  4CDF 0002                454          MOVEM.L (SP)+,D1
000013A0  60B0                     455          BRA LSRLcheckIRreturn
000013A2                           456          
000013A2= 00 08 10 18 20 38 ...    457  subqEA        DC.B %000000,%001000,%010000,%011000,%100000,%111000,%111001,0
000013AA= 38 38 38 38 38 3F ...    458  subqEAmasks   DC.B %111000,%111000,%111000,%111000,%111000,%111111,%111111,0
000013B2                           459  
000013B2                           460  SUBQ:
000013B2                           461          
000013B2                           462  
000013B2                           463          
000013B2  7000                     464          MOVEQ.L #0, D0 ;clear D0
000013B4                           465          
000013B4                           466          ;check valid size field
000013B4  3401                     467          MOVE.W D1,D2 ;copy inst to D2
000013B6  EC4A                     468          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
000013B8  0202 0003                469          ANDI.B #%00000011,D2 ;mask out rest of byte
000013BC  0C02 0003                470          CMPI.B #%11,D2 ;compare to 3
000013C0  6700 FCAE                471          BEQ falsePositive ;invalid size
000013C4                           472          
000013C4                           473  validSubq:
000013C4                           474          
000013C4  43F8 13AA                475          LEA subqEAmasks,A1 ;load the list of masks
000013C8  D3C0                     476          ADDA.L D0,A1 ;displace to a specific mask
000013CA  1A11                     477          MOVE.B (A1),D5 ;move the mask to D5
000013CC                           478          
000013CC  0C05 0000                479          CMPI.B #0,D5 ;check if the mask is 0
000013D0  6700 FC9E                480          BEQ falsePositive ;branch if it is
000013D4                           481          
000013D4  1401                     482          MOVE.B D1,D2 ;copy instruction to D2
000013D6  C405                     483          AND.B D5,D2  ;mask D2
000013D8                           484          
000013D8  43F8 13A2                485          LEA subqEA,A1 ;load the list of valid modes
000013DC  D3C0                     486          ADDA.L D0,A1 ;displace to a specific mode
000013DE  1811                     487          MOVE.B (A1),D4 ;move mode to D4
000013E0  B404                     488          CMP.B D4,D2 ;compare mode to masked value
000013E2  6700 0006                489          BEQ  subqBody ;if its match, its a valid mode and we can procede
000013E6                           490          
000013E6  5280                     491          ADDQ.L #1,D0 ;add one to displacement
000013E8  60DA                     492          BRA validSubq ;check for next mode
000013EA                           493          
000013EA                           494          
000013EA                           495  subqBody
000013EA                           496  
000013EA  43F9 00002147            497          LEA     subqMessage,A1  ;move string for MOVE
000013F0  103C 000E                498          MOVE.B  #14,D0        ;set for task to display null terminated 
000013F4                           499                                ;string with CR, LF
000013F4  4E4F                     500          TRAP    #15
000013F6                           501          
000013F6                           502          ;immediate data
000013F6                           503          
000013F6                           504          ;print '#'
000013F6  48E7 4000                505          MOVEM.L D1,-(SP) ;save D1 to the stack
000013FA  123C 0023                506          MOVE.B #'#',D1 ;put ascii value of '#' in D1
000013FE  103C 0006                507          MOVE.B #6,D0 ;move task 6 into D0
00001402  4E4F                     508          TRAP #15 ;prin char
00001404  4CDF 0002                509          MOVEM.L (SP)+,D1 ;pull D1 off the stack
00001408                           510          
00001408                           511          ;print number
00001408  48E7 4000                512          MOVEM.L D1,-(SP)
0000140C  3401                     513          MOVE.W D1,D2 ;copy inst to d2
0000140E  E04A                     514          LSR.W #8,D2 ;shift data section
00001410  E20A                     515          LSR.B #1,D2
00001412  C43C 0007                516          AND.B #%00000111,D2 ;mask out rest of data
00001416  6100 0034                517          BSR ZeroToEight ;handle zero
0000141A  7200                     518          MOVEQ.L #0,D1 ;clear D1
0000141C  1202                     519          MOVE.B D2,D1 ;move number to display into D1
0000141E  103C 0003                520          MOVE.B #3,D0 ;move task 3 to D0
00001422  4E4F                     521          TRAP #15
00001424  4CDF 0002                522          MOVEM.L (SP)+,D1
00001428                           523          
00001428                           524          ;print separator
00001428                           525          
00001428                           526          ;Then do EA
00001428                           527          
00001428  3401                     528          MOVE.W  D1,D2 ;check mode
0000142A  C43C 003F                529          AND.B   #%00111111,D2
0000142E  1A02                     530          MOVE.B  D2,D5
00001430  48E7 4000                531          MOVEM.L D1,-(SP)
00001434  6100 09AA                532          BSR     Get_Effective_Address
00001438  4CDF 0002                533          MOVEM.L (SP)+,D1
0000143C                           534          
0000143C  43F9 00002130            535          LEA     clearLine,A1  ;move string for a CR and LF
00001442  103C 000E                536          MOVE.B  #14,D0        ;set for task to display null terminated 
00001446                           537                                ;string without CR, LF
00001446  4E4F                     538          TRAP    #15
00001448                           539  
00001448  7000                     540          MOVEQ.L #0,D0
0000144A  4E75                     541          RTS
0000144C                           542          
0000144C                           543  ZeroToEight:
0000144C                           544          
0000144C  0C02 0000                545          CMPI.B #0,D2
00001450  6700 0004                546          BEQ toEight
00001454                           547  ZeroToEightReturn:
00001454                           548          
00001454  4E75                     549          RTS
00001456                           550  toEight:
00001456                           551          
00001456  5002                     552          ADDQ.B #8,D2
00001458  60FA                     553          BRA ZeroToEightReturn
0000145A                           554  
0000145A                           555      
0000145A                           556  SUB:
0000145A                           557          
0000145A                           558  
0000145A                           559          
0000145A  7000                     560          MOVEQ.L #0, D0 ;clear D0
0000145C                           561          
0000145C                           562          ;Figure out if EA is source or destination
0000145C  3401                     563          MOVE.W D1,D2 ;copy inst to D2
0000145E  EC4A                     564          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
00001460  0202 0007                565          ANDI.B #%00000111,D2 ;mask out rest of byte
00001464  0C02 0002                566          CMPI.B #2,D2 ;compare to 2
00001468  6F00 0016                567          BLE validSubSourceEA ;2 or less is EA is source
0000146C                           568          
0000146C  0C02 0007                569          CMPI.B #%111,D2 ;compare to 7
00001470  6700 FBFE                570          BEQ falsePositive ;thats not valid
00001474  0C02 0003                571          CMPI.B #%11,D2 ;compare to 3
00001478  6700 FBF6                572          BEQ falsePositive ;also not valid
0000147C  6000 002C                573          BRA validSubDestEA ;all thats left is valid EA as Dest 
00001480                           574          
00001480                           575  validSubSourceEA:
00001480                           576          
00001480  43F9 00001A3B            577          LEA moveSourceEAmasks,A1 ;load the list of masks
00001486  D3C0                     578          ADDA.L D0,A1 ;displace to a specific mask
00001488  1A11                     579          MOVE.B (A1),D5 ;move the mask to D5
0000148A                           580          
0000148A  0C05 0000                581          CMPI.B #0,D5 ;check if the mask is 0
0000148E  6700 FBE0                582          BEQ falsePositive ;branch if it is
00001492                           583          
00001492  1401                     584          MOVE.B D1,D2 ;copy instruction to D2
00001494  C405                     585          AND.B D5,D2  ;mask D2
00001496                           586          
00001496  43F9 00001A32            587          LEA moveSourceEA,A1 ;load the list of valid modes
0000149C  D3C0                     588          ADDA.L D0,A1 ;displace to a specific mode
0000149E  1811                     589          MOVE.B (A1),D4 ;move mode to D4
000014A0  B404                     590          CMP.B D4,D2 ;compare mode to masked value
000014A2  6700 0036                591          BEQ  subSource ;if its match, its a valid mode and we can procede
000014A6                           592          
000014A6  5280                     593          ADDQ.L #1,D0 ;add one to displacement
000014A8  60D6                     594          BRA validSubSourceEA ;check for next mode
000014AA                           595          
000014AA                           596          
000014AA                           597  validSubDestEA:
000014AA                           598          
000014AA  43F9 00001602            599          LEA addDestEAmasks,A1 ;load the list of masks
000014B0  D3C0                     600          ADDA.L D0,A1 ;displace to a specific mask
000014B2  1A11                     601          MOVE.B (A1),D5 ;move the mask to D5
000014B4                           602          
000014B4  0C05 0000                603          CMPI.B #0,D5 ;check if the mask is 0
000014B8  6700 FBB6                604          BEQ falsePositive ;branch if it is
000014BC                           605          
000014BC  3401                     606          MOVE.W D1,D2 ;copy instruction to D2
000014BE  EC4A                     607          LSR.W #6,D2  ;move mode
000014C0  6100 0A92                608          BSR switchModeAndReg ;switch register and mode
000014C4  C405                     609          AND.B D5,D2  ;mask D2
000014C6                           610          
000014C6  43F9 000015FC            611          LEA addDestEA,A1 ;load the list of valid modes
000014CC  D3C0                     612          ADDA.L D0,A1 ;displace to a specific mode
000014CE  1811                     613          MOVE.B (A1),D4 ;move mode to D4
000014D0  B404                     614          CMP.B D4,D2 ;compare mode to masked value
000014D2  6700 004E                615          BEQ subDest ;if its match, its a valid mode and we can procede
000014D6                           616          
000014D6  5280                     617          ADDQ.L #1,D0 ;add one to displacement
000014D8  60D0                     618          BRA validSubDestEA ;check for next mode
000014DA                           619          
000014DA                           620  subSource
000014DA                           621  
000014DA  43F9 0000214D            622          LEA     subMessage,A1  ;move string for MOVE
000014E0  103C 000E                623          MOVE.B  #14,D0        ;set for task to display null terminated 
000014E4                           624                                ;string with CR, LF
000014E4  4E4F                     625          TRAP    #15
000014E6                           626          
000014E6                           627          ;do EA
000014E6                           628          
000014E6  3401                     629          MOVE.W  D1,D2 ;check mode
000014E8  C43C 003F                630          AND.B   #%00111111,D2
000014EC  1A02                     631          MOVE.B  D2,D5
000014EE  48E7 4000                632          MOVEM.L D1,-(SP)
000014F2  6100 08EC                633          BSR     Get_Effective_Address
000014F6  4CDF 0002                634          MOVEM.L (SP)+,D1
000014FA                           635          
000014FA                           636          ;print separator
000014FA                           637          
000014FA                           638          ;Then do Dn
000014FA                           639          
000014FA  3401                     640          MOVE.W  D1,D2
000014FC  E04A                     641          LSR.W   #8,D2 ;move reg into first byte
000014FE  E20A                     642          LSR.B   #1,D2 ;line it up to least sig bit
00001500  C43C 0007                643          AND.B   #%00000111,D2 ;force mode to Dn
00001504  1A02                     644          MOVE.B  D2,D5
00001506  48E7 4000                645          MOVEM.L D1,-(SP)
0000150A  6100 08D4                646          BSR     Get_Effective_Address
0000150E  4CDF 0002                647          MOVEM.L (SP)+,D1
00001512                           648          
00001512  43F9 00002130            649          LEA     clearLine,A1  ;move string for a CR and LF
00001518  103C 000E                650          MOVE.B  #14,D0        ;set for task to display null terminated 
0000151C                           651                                ;string without CR, LF
0000151C  4E4F                     652          TRAP    #15
0000151E                           653  
0000151E  7000                     654          MOVEQ.L #0,D0
00001520  4E75                     655          RTS
00001522                           656  
00001522                           657  subDest
00001522                           658  
00001522  43F9 0000214D            659          LEA     subMessage,A1  ;move string for MOVE
00001528  103C 000E                660          MOVE.B  #14,D0        ;set for task to display null terminated 
0000152C                           661                                ;string with CR, LF
0000152C  4E4F                     662          TRAP    #15
0000152E                           663          
0000152E                           664          ;Do Dn
0000152E                           665          
0000152E  3401                     666          MOVE.W  D1,D2
00001530  E04A                     667          LSR.W   #8,D2 ;move reg into first byte
00001532  E20A                     668          LSR.B   #1,D2 ;line it up to least sig bit
00001534  C43C 0007                669          AND.B   #%00000111,D2 ;force mode to Dn
00001538  1A02                     670          MOVE.B  D2,D5
0000153A  48E7 4000                671          MOVEM.L D1,-(SP)
0000153E  6100 08A0                672          BSR     Get_Effective_Address
00001542  4CDF 0002                673          MOVEM.L (SP)+,D1
00001546                           674          
00001546                           675          
00001546                           676          ;print separator
00001546                           677          
00001546                           678          ;Then do EA
00001546                           679          
00001546  3401                     680          MOVE.W  D1,D2 ;check mode
00001548  C43C 003F                681          AND.B   #%00111111,D2
0000154C  1A02                     682          MOVE.B  D2,D5
0000154E  48E7 4000                683          MOVEM.L D1,-(SP)
00001552  6100 088C                684          BSR     Get_Effective_Address
00001556  4CDF 0002                685          MOVEM.L (SP)+,D1
0000155A                           686          
0000155A                           687          
0000155A  43F9 00002130            688          LEA     clearLine,A1  ;move string for a CR and LF
00001560  103C 000E                689          MOVE.B  #14,D0        ;set for task to display null terminated 
00001564                           690                                ;string without CR, LF
00001564  4E4F                     691          TRAP    #15
00001566                           692  
00001566  7000                     693          MOVEQ.L #0,D0
00001568  4E75                     694          RTS
0000156A                           695  
0000156A                           696  
0000156A                           697  ADDA:
0000156A                           698          
0000156A                           699  
0000156A                           700          
0000156A  7000                     701          MOVEQ.L #0, D0 ;clear D0
0000156C                           702          
0000156C                           703          ;check opmode field
0000156C  3401                     704          MOVE.W D1,D2 ;copy inst to D2
0000156E  EC4A                     705          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
00001570  0202 0007                706          ANDI.B #%00000111,D2 ;mask out rest of byte
00001574  0C02 0007                707          CMPI.B #%111,D2 ;compare to 7
00001578  6700 000E                708          BEQ validAdda ;thats valid
0000157C  0C02 0003                709          CMPI.B #%11,D2 ;compare to 3
00001580  6700 0006                710          BEQ validAdda ;also valid
00001584  6000 FAEA                711          BRA falsePositive ;all thats left is invalid 
00001588                           712          
00001588                           713  validAdda:
00001588                           714          
00001588  43F9 00001A3B            715          LEA moveSourceEAmasks,A1 ;load the list of masks
0000158E  D3C0                     716          ADDA.L D0,A1 ;displace to a specific mask
00001590  1A11                     717          MOVE.B (A1),D5 ;move the mask to D5
00001592                           718          
00001592  0C05 0000                719          CMPI.B #0,D5 ;check if the mask is 0
00001596  6700 FAD8                720          BEQ falsePositive ;branch if it is
0000159A                           721          
0000159A  1401                     722          MOVE.B D1,D2 ;copy instruction to D2
0000159C  C405                     723          AND.B D5,D2  ;mask D2
0000159E                           724          
0000159E  43F9 00001A32            725          LEA moveSourceEA,A1 ;load the list of valid modes
000015A4  D3C0                     726          ADDA.L D0,A1 ;displace to a specific mode
000015A6  1811                     727          MOVE.B (A1),D4 ;move mode to D4
000015A8  B404                     728          CMP.B D4,D2 ;compare mode to masked value
000015AA  6700 0006                729          BEQ  addaBody ;if its match, its a valid mode and we can procede
000015AE                           730          
000015AE  5280                     731          ADDQ.L #1,D0 ;add one to displacement
000015B0  60D6                     732          BRA validAdda ;check for next mode
000015B2                           733          
000015B2                           734          
000015B2                           735  addaBody
000015B2                           736  
000015B2  43F9 00002152            737          LEA     addaMessage,A1  ;move string for MOVE
000015B8  103C 000E                738          MOVE.B  #14,D0        ;set for task to display null terminated 
000015BC                           739                                ;string with CR, LF
000015BC  4E4F                     740          TRAP    #15
000015BE                           741          
000015BE                           742          ;do EA
000015BE                           743          
000015BE  3401                     744          MOVE.W  D1,D2 ;check mode
000015C0  C43C 003F                745          AND.B   #%00111111,D2
000015C4  1A02                     746          MOVE.B  D2,D5
000015C6  48E7 4000                747          MOVEM.L D1,-(SP)
000015CA  6100 0814                748          BSR     Get_Effective_Address
000015CE  4CDF 0002                749          MOVEM.L (SP)+,D1
000015D2                           750          
000015D2                           751          ;print separator
000015D2                           752          
000015D2                           753          ;Then do Dn
000015D2                           754          
000015D2  3401                     755          MOVE.W  D1,D2
000015D4  E04A                     756          LSR.W   #8,D2 ;move reg into first byte
000015D6  E20A                     757          LSR.B   #1,D2 ;line it up to least sig bit
000015D8  C43C 0007                758          AND.B   #%00000111,D2 ;force mode to An
000015DC  5002                     759          ADDI.B  #%00001000,D2 
000015DE  1A02                     760          MOVE.B  D2,D5
000015E0  48E7 4000                761          MOVEM.L D1,-(SP)
000015E4  6100 07FA                762          BSR     Get_Effective_Address
000015E8  4CDF 0002                763          MOVEM.L (SP)+,D1
000015EC                           764          
000015EC  43F9 00002130            765          LEA     clearLine,A1  ;move string for a CR and LF
000015F2  103C 000E                766          MOVE.B  #14,D0        ;set for task to display null terminated 
000015F6                           767                                ;string without CR, LF
000015F6  4E4F                     768          TRAP    #15
000015F8                           769  
000015F8  7000                     770          MOVEQ.L #0,D0
000015FA  4E75                     771          RTS
000015FC                           772  
000015FC                           773  
000015FC                           774      
000015FC= 10 18 20 38 39 00        775  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
00001602= 38 38 38 3F 3F 00        776  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
00001608                           777  
00001608                           778  ADD:
00001608                           779          
00001608                           780  
00001608                           781          
00001608  7000                     782          MOVEQ.L #0, D0 ;clear D0
0000160A                           783          
0000160A                           784          ;Figure out if EA is source or destination
0000160A  3401                     785          MOVE.W D1,D2 ;copy inst to D2
0000160C  EC4A                     786          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
0000160E  0202 0007                787          ANDI.B #%00000111,D2 ;mask out rest of byte
00001612  0C02 0002                788          CMPI.B #2,D2 ;compare to 2
00001616  6F00 0016                789          BLE validAddSourceEA ;2 or less is EA is source
0000161A                           790          
0000161A  0C02 0007                791          CMPI.B #%111,D2 ;compare to 7
0000161E  6700 FA50                792          BEQ falsePositive ;thats not valid
00001622  0C02 0003                793          CMPI.B #%11,D2 ;compare to 3
00001626  6700 FA48                794          BEQ falsePositive ;also not valid
0000162A  6000 002C                795          BRA validAddDestEA ;all thats left is valid EA as Dest 
0000162E                           796          
0000162E                           797  validAddSourceEA:
0000162E                           798          
0000162E  43F9 00001A3B            799          LEA moveSourceEAmasks,A1 ;load the list of masks
00001634  D3C0                     800          ADDA.L D0,A1 ;displace to a specific mask
00001636  1A11                     801          MOVE.B (A1),D5 ;move the mask to D5
00001638                           802          
00001638  0C05 0000                803          CMPI.B #0,D5 ;check if the mask is 0
0000163C  6700 FA32                804          BEQ falsePositive ;branch if it is
00001640                           805          
00001640  1401                     806          MOVE.B D1,D2 ;copy instruction to D2
00001642  C405                     807          AND.B D5,D2  ;mask D2
00001644                           808          
00001644  43F9 00001A32            809          LEA moveSourceEA,A1 ;load the list of valid modes
0000164A  D3C0                     810          ADDA.L D0,A1 ;displace to a specific mode
0000164C  1811                     811          MOVE.B (A1),D4 ;move mode to D4
0000164E  B404                     812          CMP.B D4,D2 ;compare mode to masked value
00001650  6700 0032                813          BEQ  addSource ;if its match, its a valid mode and we can procede
00001654                           814          
00001654  5280                     815          ADDQ.L #1,D0 ;add one to displacement
00001656  60D6                     816          BRA validAddSourceEA ;check for next mode
00001658                           817          
00001658                           818          
00001658                           819  validAddDestEA:
00001658                           820          
00001658  43F8 1602                821          LEA addDestEAmasks,A1 ;load the list of masks
0000165C  D3C0                     822          ADDA.L D0,A1 ;displace to a specific mask
0000165E  1A11                     823          MOVE.B (A1),D5 ;move the mask to D5
00001660                           824          
00001660  0C05 0000                825          CMPI.B #0,D5 ;check if the mask is 0
00001664  6700 FA0A                826          BEQ falsePositive ;branch if it is
00001668                           827          
00001668  3401                     828          MOVE.W D1,D2 ;copy instruction to D2
0000166A  EC4A                     829          LSR.W #6,D2  ;move mode
0000166C  6100 08E6                830          BSR switchModeAndReg ;switch register and mode
00001670  C405                     831          AND.B D5,D2  ;mask D2
00001672                           832          
00001672  43F8 15FC                833          LEA addDestEA,A1 ;load the list of valid modes
00001676  D3C0                     834          ADDA.L D0,A1 ;displace to a specific mode
00001678  1811                     835          MOVE.B (A1),D4 ;move mode to D4
0000167A  B404                     836          CMP.B D4,D2 ;compare mode to masked value
0000167C  6700 004E                837          BEQ addDest ;if its match, its a valid mode and we can procede
00001680                           838          
00001680  5280                     839          ADDQ.L #1,D0 ;add one to displacement
00001682  60D4                     840          BRA validAddDestEA ;check for next mode
00001684                           841          
00001684                           842  addSource
00001684                           843  
00001684  43F9 00002158            844          LEA     addMessage,A1  ;move string for MOVE
0000168A  103C 000E                845          MOVE.B  #14,D0        ;set for task to display null terminated 
0000168E                           846                                ;string with CR, LF
0000168E  4E4F                     847          TRAP    #15
00001690                           848          
00001690                           849          ;do EA
00001690                           850          
00001690  3401                     851          MOVE.W  D1,D2 ;check mode
00001692  C43C 003F                852          AND.B   #%00111111,D2
00001696  1A02                     853          MOVE.B  D2,D5
00001698  48E7 4000                854          MOVEM.L D1,-(SP)
0000169C  6100 0742                855          BSR     Get_Effective_Address
000016A0  4CDF 0002                856          MOVEM.L (SP)+,D1
000016A4                           857          
000016A4                           858          ;print separator
000016A4                           859          
000016A4                           860          ;Then do Dn
000016A4                           861          
000016A4  3401                     862          MOVE.W  D1,D2
000016A6  E04A                     863          LSR.W   #8,D2 ;move reg into first byte
000016A8  E20A                     864          LSR.B   #1,D2 ;line it up to least sig bit
000016AA  C43C 0007                865          AND.B   #%00000111,D2 ;force mode to Dn
000016AE  1A02                     866          MOVE.B  D2,D5
000016B0  48E7 4000                867          MOVEM.L D1,-(SP)
000016B4  6100 072A                868          BSR     Get_Effective_Address
000016B8  4CDF 0002                869          MOVEM.L (SP)+,D1
000016BC                           870          
000016BC  43F9 00002130            871          LEA     clearLine,A1  ;move string for a CR and LF
000016C2  103C 000E                872          MOVE.B  #14,D0        ;set for task to display null terminated 
000016C6                           873                                ;string without CR, LF
000016C6  4E4F                     874          TRAP    #15
000016C8                           875  
000016C8  7000                     876          MOVEQ.L #0,D0
000016CA  4E75                     877          RTS
000016CC                           878  
000016CC                           879  addDest
000016CC                           880  
000016CC  43F9 00002158            881          LEA     addMessage,A1  ;move string for MOVE
000016D2  103C 000E                882          MOVE.B  #14,D0        ;set for task to display null terminated 
000016D6                           883                                ;string with CR, LF
000016D6  4E4F                     884          TRAP    #15
000016D8                           885          
000016D8                           886          ;Do Dn
000016D8                           887          
000016D8  3401                     888          MOVE.W  D1,D2
000016DA  E04A                     889          LSR.W   #8,D2 ;move reg into first byte
000016DC  E20A                     890          LSR.B   #1,D2 ;line it up to least sig bit
000016DE  C43C 0007                891          AND.B   #%00000111,D2 ;force mode to Dn
000016E2  1A02                     892          MOVE.B  D2,D5
000016E4  48E7 4000                893          MOVEM.L D1,-(SP)
000016E8  6100 06F6                894          BSR     Get_Effective_Address
000016EC  4CDF 0002                895          MOVEM.L (SP)+,D1
000016F0                           896          
000016F0                           897          
000016F0                           898          ;print separator
000016F0                           899          
000016F0                           900          ;Then do EA
000016F0                           901          
000016F0  3401                     902          MOVE.W  D1,D2 ;check mode
000016F2  C43C 003F                903          AND.B   #%00111111,D2
000016F6  1A02                     904          MOVE.B  D2,D5
000016F8  48E7 4000                905          MOVEM.L D1,-(SP)
000016FC  6100 06E2                906          BSR     Get_Effective_Address
00001700  4CDF 0002                907          MOVEM.L (SP)+,D1
00001704                           908          
00001704                           909          
00001704  43F9 00002130            910          LEA     clearLine,A1  ;move string for a CR and LF
0000170A  103C 000E                911          MOVE.B  #14,D0        ;set for task to display null terminated 
0000170E                           912                                ;string without CR, LF
0000170E  4E4F                     913          TRAP    #15
00001710                           914  
00001710  7000                     915          MOVEQ.L #0,D0
00001712  4E75                     916          RTS
00001714                           917  
00001714                           918  
00001714= 10 20 38 39 00           919  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
00001719= 38 38 3F 3F 00           920  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
0000171E                           921  
0000171E= 10 18 38 39 00           922  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
00001723= 38 38 3F 3F 00           923  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
00001728                           924  
00001728                           925  MOVEM:
00001728                           926          
00001728                           927  
00001728                           928          
00001728  7000                     929          MOVEQ.L #0, D0 ;clear D0
0000172A                           930          
0000172A                           931          ;Figure out which direction we are going
0000172A  3401                     932          MOVE.W D1,D2 ;copy inst to D2
0000172C  E64A                     933          LSR.W #3,D2 ;shift direction bit into most sig bit of first byte
0000172E  0202 0080                934          ANDI.B #%10000000,D2 ;mask out everything but direction bit in first byte
00001732  0C02 0000                935          CMPI.B #0,D2 ;compare bit to zero
00001736  6700 0006                936          BEQ validRegToMem ;if zero, reg to mem
0000173A  6000 0028                937          BRA validMemToReg ;else, its mem to reg
0000173E                           938          
0000173E                           939  validRegToMem:
0000173E                           940          
0000173E  43F8 1719                941          LEA movemRegToMemEAmasks,A1 ;load the list of masks
00001742  D3C0                     942          ADDA.L D0,A1 ;displace to a specific mask
00001744  1A11                     943          MOVE.B (A1),D5 ;move the mask to D5
00001746                           944          
00001746  0C05 0000                945          CMPI.B #0,D5 ;check if the mask is 0
0000174A  6700 F924                946          BEQ falsePositive ;branch if it is
0000174E                           947          
0000174E  1401                     948          MOVE.B D1,D2 ;copy instruction to D2
00001750  C405                     949          AND.B D5,D2  ;mask D2
00001752                           950          
00001752  43F8 1714                951          LEA movemRegToMemEA,A1 ;load the list of valid modes
00001756  D3C0                     952          ADDA.L D0,A1 ;displace to a specific mode
00001758  1811                     953          MOVE.B (A1),D4 ;move mode to D4
0000175A  B404                     954          CMP.B D4,D2 ;compare mode to masked value
0000175C  6700 0034                955          BEQ  movemBody ;if its match, its a valid mode and we can procede
00001760                           956          
00001760  5280                     957          ADDQ.L #1,D0 ;add one to displacement
00001762  60DA                     958          BRA validRegToMem ;check for next mode
00001764                           959          
00001764                           960          
00001764                           961  validMemToReg:
00001764                           962          
00001764  43F8 1723                963          LEA movemMemToRegEAmasks,A1 ;load the list of masks
00001768  D3C0                     964          ADDA.L D0,A1 ;displace to a specific mask
0000176A  1A11                     965          MOVE.B (A1),D5 ;move the mask to D5
0000176C                           966          
0000176C  0C05 0000                967          CMPI.B #0,D5 ;check if the mask is 0
00001770  6700 F8FE                968          BEQ falsePositive ;branch if it is
00001774                           969          
00001774  3401                     970          MOVE.W D1,D2 ;copy instruction to D2
00001776  EC4A                     971          LSR.W #6,D2  ;move mode
00001778  6100 07DA                972          BSR switchModeAndReg ;switch register and mode
0000177C  C405                     973          AND.B D5,D2  ;mask D2
0000177E                           974          
0000177E  43F8 171E                975          LEA movemMemToRegEA,A1 ;load the list of valid modes
00001782  D3C0                     976          ADDA.L D0,A1 ;displace to a specific mode
00001784  1811                     977          MOVE.B (A1),D4 ;move mode to D4
00001786  B404                     978          CMP.B D4,D2 ;compare mode to masked value
00001788  6700 0008                979          BEQ movemBody ;if its match, its a valid mode and we can procede
0000178C                           980          
0000178C  5280                     981          ADDQ.L #1,D0 ;add one to displacement
0000178E  6000 02EC                982          BRA validMoveDestModes ;check for next mode
00001792                           983          
00001792                           984  movemBody
00001792                           985  
00001792  43F9 0000215D            986          LEA     movemMessage,A1  ;move string for MOVE
00001798  103C 000E                987          MOVE.B  #14,D0        ;set for task to display null terminated 
0000179C                           988                                ;string with CR, LF
0000179C  4E4F                     989          TRAP    #15
0000179E                           990          
0000179E                           991          ;show list
0000179E                           992          
0000179E  5487                     993          ADDQ.L #word,D7 ;read past the register list mask(word) following
000017A0                           994                          ;the instruction
000017A0                           995          
000017A0                           996          ;print separator
000017A0                           997          
000017A0  3401                     998          MOVE.W  D1,D2 ;check mode
000017A2  C43C 003F                999          AND.B   #%00111111,D2
000017A6  1A02                    1000          MOVE.B  D2,D5
000017A8  48E7 4000               1001          MOVEM.L D1,-(SP)
000017AC  6100 0632               1002          BSR     Get_Effective_Address
000017B0  4CDF 0002               1003          MOVEM.L (SP)+,D1
000017B4                          1004          
000017B4                          1005          
000017B4  43F9 00002130           1006          LEA     clearLine,A1  ;move string for a CR and LF
000017BA  103C 000E               1007          MOVE.B  #14,D0        ;set for task to display null terminated 
000017BE                          1008                                ;string without CR, LF
000017BE  4E4F                    1009          TRAP    #15
000017C0                          1010  
000017C0  7000                    1011          MOVEQ.L #0,D0
000017C2  4E75                    1012          RTS
000017C4                          1013  
000017C4                          1014  
000017C4                          1015      
000017C4= 00 10 18 20 28 38 ...   1016  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
000017CC= 38 38 38 38 38 3F ...   1017  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
000017D4                          1018     
000017D4                          1019  NEG:            
000017D4                          1020       
000017D4  7000                    1021          MOVEQ.L #0, D0 ;clear D0
000017D6                          1022          
000017D6                          1023  validNegModes:
000017D6                          1024          
000017D6  43F8 17CC               1025          LEA NegEAmasks,A1 ;load the list of masks
000017DA  D3C0                    1026          ADDA.L D0,A1 ;displace to a specific mask
000017DC  1A11                    1027          MOVE.B (A1),D5 ;move the mask to D5
000017DE                          1028          
000017DE  0C05 0000               1029          CMPI.B #0,D5 ;check if the mask is 0
000017E2  6700 F88C               1030          BEQ falsePositive ;branch if it is
000017E6                          1031          
000017E6  1401                    1032          MOVE.B D1,D2 ;copy instruction to D2
000017E8  C405                    1033          AND.B D5,D2  ;mask D2
000017EA  43F8 17C4               1034          LEA NegEA,A1 ;load the list of valid modes
000017EE  D3C0                    1035          ADDA.L D0,A1 ;displace to a specific mode
000017F0  1811                    1036          MOVE.B (A1),D4 ;move mode to D4
000017F2  B404                    1037          CMP.B D4,D2 ;compare mode to masked value
000017F4  6700 0006               1038          BEQ NegBody ;if its match, its a valid mode and we can procede
000017F8                          1039          
000017F8  5280                    1040          ADDQ.L #1,D0 ;add one to displacement
000017FA  60DA                    1041          BRA validNegModes ;check for next mode
000017FC                          1042          
000017FC                          1043  NegBody:
000017FC                          1044  
000017FC                          1045  
000017FC  3401                    1046          MOVE.W  D1,D2 ;copy inst to D2
000017FE  C47C 0600               1047          AND.W  #%0011000000000,D2 ;mask word for size
00001802  0C42 0000               1048          CMPI.W #0,D2 ;0 is the only non valid size
00001806  6700 F868               1049          BEQ falsePositive ; zero is not valid
0000180A                          1050  
0000180A  43F9 0000218C           1051          LEA     negMessage,A1  ;move string for NEG info
00001810  103C 000E               1052          MOVE.B  #14,D0        ;set for task to display null terminated 
00001814                          1053                                ;string without CR, LF
00001814  4E4F                    1054          TRAP    #15
00001816                          1055          
00001816  3401                    1056          MOVE.W D1,D2
00001818  C47C 003F               1057          AND #%000000000111111,D2
0000181C  1A02                    1058          MOVE.B D2,D5
0000181E                          1059          
0000181E  48E7 4000               1060          MOVEM.L D1,-(SP)
00001822  6100 05BC               1061          BSR     Get_Effective_Address
00001826  4CDF 0002               1062          MOVEM.L (SP)+,D1
0000182A                          1063          
0000182A                          1064                
0000182A                          1065          
0000182A                          1066  NEGdone:
0000182A                          1067  
0000182A  43F9 00002130           1068          LEA     clearLine,A1  ;move string for a CR and LF
00001830  103C 000E               1069          MOVE.B  #14,D0        ;set for task to display null terminated 
00001834                          1070                                ;string without CR, LF
00001834  4E4F                    1071          TRAP    #15
00001836  7000                    1072          MOVEQ.L #0,D0
00001838  4E75                    1073          RTS
0000183A                          1074          
0000183A                          1075   ADDI:            
0000183A                          1076       
0000183A  7000                    1077          MOVEQ.L #0, D0 ;clear D0
0000183C                          1078          
0000183C                          1079  validAddiModes:
0000183C                          1080          
0000183C                          1081          
0000183C  43F9 00001935           1082          LEA cmpiEAmasks,A1 ;load the list of masks
00001842  D3C0                    1083          ADDA.L D0,A1 ;displace to a specific mask
00001844  1A11                    1084          MOVE.B (A1),D5 ;move the mask to D5
00001846                          1085          
00001846  0C05 0000               1086          CMPI.B #0,D5 ;check if the mask is 0
0000184A  6700 F824               1087          BEQ falsePositive ;branch if it is
0000184E                          1088          
0000184E  1401                    1089          MOVE.B D1,D2 ;copy instruction to D2
00001850  C405                    1090          AND.B D5,D2  ;mask D2
00001852  43F9 0000192E           1091          LEA cmpiEA,A1 ;load the list of valid modes
00001858  D3C0                    1092          ADDA.L D0,A1 ;displace to a specific mode
0000185A  1811                    1093          MOVE.B (A1),D4 ;move mode to D4
0000185C  B404                    1094          CMP.B D4,D2 ;compare mode to masked value
0000185E  6700 0006               1095          BEQ addiBody ;if its match, its a valid mode and we can procede
00001862                          1096          
00001862  5280                    1097          ADDQ.L #1,D0 ;add one to displacement
00001864  60D6                    1098          BRA validAddiModes ;check for next mode
00001866                          1099          
00001866                          1100  addiBody:
00001866                          1101  
00001866                          1102  
00001866  3401                    1103          MOVE.W  D1,D2 ;copy inst to D2
00001868  C47C 00C0               1104          AND.W  #%0000000011000000,D2 ;mask word for size
0000186C  0C42 00C0               1105          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001870  6700 F7FE               1106          BEQ falsePositive
00001874                          1107  
00001874  43F9 00002164           1108          LEA     addiMessage,A1  ;move string for NEG info
0000187A  103C 000E               1109          MOVE.B  #14,D0        ;set for task to display null terminated 
0000187E                          1110                                ;string without CR, LF
0000187E  4E4F                    1111          TRAP    #15
00001880                          1112          
00001880                          1113          ;go to Effective_Address for immediate data
00001880  143C 003C               1114          MOVE.B #%00111100,D2
00001884  48E7 4000               1115          MOVEM.L D1,-(SP)
00001888  6100 0556               1116          BSR     Get_Effective_Address
0000188C  4CDF 0002               1117          MOVEM.L (SP)+,D1
00001890                          1118          
00001890  3401                    1119          MOVE.W D1,D2 ;copy inst to D2
00001892  C47C 003F               1120          AND #%000000000111111,D2 ;and out everything but modes and regs
00001896  1A02                    1121          MOVE.B D2,D5 ; copy to D5 for following BSR
00001898                          1122          
00001898  48E7 4000               1123          MOVEM.L D1,-(SP)
0000189C  6100 0542               1124          BSR     Get_Effective_Address
000018A0  4CDF 0002               1125          MOVEM.L (SP)+,D1
000018A4                          1126          
000018A4                          1127                
000018A4                          1128          
000018A4                          1129  addidone:
000018A4                          1130  
000018A4  43F9 00002130           1131          LEA     clearLine,A1  ;move string for a CR and LF
000018AA  103C 000E               1132          MOVE.B  #14,D0        ;set for task to display null terminated 
000018AE                          1133                                ;string without CR, LF
000018AE  4E4F                    1134          TRAP    #15
000018B0  7000                    1135          MOVEQ.L #0,D0
000018B2  4E75                    1136          RTS
000018B4                          1137    
000018B4                          1138  ORI:            
000018B4                          1139       
000018B4  7000                    1140          MOVEQ.L #0, D0 ;clear D0
000018B6                          1141          
000018B6                          1142  validOriModes:
000018B6                          1143          
000018B6                          1144          
000018B6  43F9 00001935           1145          LEA cmpiEAmasks,A1 ;load the list of masks
000018BC  D3C0                    1146          ADDA.L D0,A1 ;displace to a specific mask
000018BE  1A11                    1147          MOVE.B (A1),D5 ;move the mask to D5
000018C0                          1148          
000018C0  0C05 0000               1149          CMPI.B #0,D5 ;check if the mask is 0
000018C4  6700 F7AA               1150          BEQ falsePositive ;branch if it is
000018C8                          1151          
000018C8  1401                    1152          MOVE.B D1,D2 ;copy instruction to D2
000018CA  C405                    1153          AND.B D5,D2  ;mask D2
000018CC  43F9 0000192E           1154          LEA cmpiEA,A1 ;load the list of valid modes
000018D2  D3C0                    1155          ADDA.L D0,A1 ;displace to a specific mode
000018D4  1811                    1156          MOVE.B (A1),D4 ;move mode to D4
000018D6  B404                    1157          CMP.B D4,D2 ;compare mode to masked value
000018D8  6700 0006               1158          BEQ oriBody ;if its match, its a valid mode and we can procede
000018DC                          1159          
000018DC  5280                    1160          ADDQ.L #1,D0 ;add one to displacement
000018DE  60D6                    1161          BRA validOriModes ;check for next mode
000018E0                          1162          
000018E0                          1163  oriBody:
000018E0                          1164  
000018E0                          1165  
000018E0  3401                    1166          MOVE.W  D1,D2 ;copy inst to D2
000018E2  C47C 00C0               1167          AND.W  #%0000000011000000,D2 ;mask word for size
000018E6  0C42 00C0               1168          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
000018EA  6700 F784               1169          BEQ falsePositive
000018EE                          1170  
000018EE  43F9 0000216A           1171          LEA     oriMessage,A1  ;move string for NEG info
000018F4  103C 000E               1172          MOVE.B  #14,D0        ;set for task to display null terminated 
000018F8                          1173                                ;string without CR, LF
000018F8  4E4F                    1174          TRAP    #15
000018FA                          1175          
000018FA                          1176          ;go to Effective_Address for immediate data
000018FA  143C 003C               1177          MOVE.B #%00111100,D2
000018FE  48E7 4000               1178          MOVEM.L D1,-(SP)
00001902  6100 04DC               1179          BSR     Get_Effective_Address
00001906  4CDF 0002               1180          MOVEM.L (SP)+,D1
0000190A                          1181          
0000190A  3401                    1182          MOVE.W D1,D2 ;copy inst to D2
0000190C  C47C 003F               1183          AND #%000000000111111,D2 ;and out everything but modes and regs
00001910  1A02                    1184          MOVE.B D2,D5 ; copy to D5 for following BSR
00001912                          1185          
00001912  48E7 4000               1186          MOVEM.L D1,-(SP)
00001916  6100 04C8               1187          BSR     Get_Effective_Address
0000191A  4CDF 0002               1188          MOVEM.L (SP)+,D1
0000191E                          1189          
0000191E                          1190                
0000191E                          1191          
0000191E                          1192  oridone:
0000191E                          1193  
0000191E  43F9 00002130           1194          LEA     clearLine,A1  ;move string for a CR and LF
00001924  103C 000E               1195          MOVE.B  #14,D0        ;set for task to display null terminated 
00001928                          1196                                ;string without CR, LF
00001928  4E4F                    1197          TRAP    #15
0000192A  7000                    1198          MOVEQ.L #0,D0
0000192C  4E75                    1199          RTS
0000192E                          1200  
0000192E                          1201          
0000192E                          1202          
0000192E= 20 18 00 10 38 39 00    1203  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
00001935= 38 38 38 38 3F 3F 00    1204  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
0000193C                          1205     
0000193C                          1206  CMPI:            
0000193C                          1207       
0000193C  7000                    1208          MOVEQ.L #0, D0 ;clear D0
0000193E                          1209          
0000193E                          1210  validCmpiModes:
0000193E                          1211          
0000193E                          1212          
0000193E  43F8 1935               1213          LEA cmpiEAmasks,A1 ;load the list of masks
00001942  D3C0                    1214          ADDA.L D0,A1 ;displace to a specific mask
00001944  1A11                    1215          MOVE.B (A1),D5 ;move the mask to D5
00001946                          1216          
00001946  0C05 0000               1217          CMPI.B #0,D5 ;check if the mask is 0
0000194A  6700 F724               1218          BEQ falsePositive ;branch if it is
0000194E                          1219          
0000194E  1401                    1220          MOVE.B D1,D2 ;copy instruction to D2
00001950  C405                    1221          AND.B D5,D2  ;mask D2
00001952  43F8 192E               1222          LEA cmpiEA,A1 ;load the list of valid modes
00001956  D3C0                    1223          ADDA.L D0,A1 ;displace to a specific mode
00001958  1811                    1224          MOVE.B (A1),D4 ;move mode to D4
0000195A  B404                    1225          CMP.B D4,D2 ;compare mode to masked value
0000195C  6700 0006               1226          BEQ CMPIBody ;if its match, its a valid mode and we can procede
00001960                          1227          
00001960  5280                    1228          ADDQ.L #1,D0 ;add one to displacement
00001962  60DA                    1229          BRA validCmpiModes ;check for next mode
00001964                          1230          
00001964                          1231  CMPIBody:
00001964                          1232  
00001964                          1233  
00001964  3401                    1234          MOVE.W  D1,D2 ;copy inst to D2
00001966  C47C 00C0               1235          AND.W  #%0000000011000000,D2 ;mask word for size
0000196A  0C42 00C0               1236          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
0000196E  6700 F700               1237          BEQ falsePositive
00001972                          1238  
00001972  43F9 0000216F           1239          LEA     cmpiMessage,A1  ;move string for NEG info
00001978  103C 000E               1240          MOVE.B  #14,D0        ;set for task to display null terminated 
0000197C                          1241                                ;string without CR, LF
0000197C  4E4F                    1242          TRAP    #15
0000197E                          1243          
0000197E                          1244          ;go to Effective_Address for immediate data
0000197E  143C 003C               1245          MOVE.B #%00111100,D2
00001982  48E7 4000               1246          MOVEM.L D1,-(SP)
00001986  6100 0458               1247          BSR     Get_Effective_Address
0000198A  4CDF 0002               1248          MOVEM.L (SP)+,D1
0000198E                          1249          
0000198E  3401                    1250          MOVE.W D1,D2 ;copy inst to D2
00001990  C47C 003F               1251          AND #%000000000111111,D2 ;and out everything but modes and regs
00001994  1A02                    1252          MOVE.B D2,D5 ; copy to D5 for following BSR
00001996                          1253          
00001996  48E7 4000               1254          MOVEM.L D1,-(SP)
0000199A  6100 0444               1255          BSR     Get_Effective_Address
0000199E  4CDF 0002               1256          MOVEM.L (SP)+,D1
000019A2                          1257          
000019A2                          1258                
000019A2                          1259          
000019A2                          1260  CMPidone:
000019A2                          1261  
000019A2  43F9 00002130           1262          LEA     clearLine,A1  ;move string for a CR and LF
000019A8  103C 000E               1263          MOVE.B  #14,D0        ;set for task to display null terminated 
000019AC                          1264                                ;string without CR, LF
000019AC  4E4F                    1265          TRAP    #15
000019AE  7000                    1266          MOVEQ.L #0,D0
000019B0  4E75                    1267          RTS
000019B2                          1268  
000019B2                          1269          
000019B2= 10 38 39 00             1270  JsrEA        DC.B %010000, %111000, %111001,0
000019B6= 38 3F 3F 00             1271  JsrEAmasks   DC.B %111000, %111111, %111111,0
000019BA                          1272     
000019BA                          1273  JSR:            
000019BA                          1274       
000019BA  7000                    1275          MOVEQ.L #0, D0 ;clear D0
000019BC                          1276          
000019BC                          1277  validJsrModes:
000019BC                          1278          
000019BC  43F8 19B6               1279          LEA JsrEAmasks,A1 ;load the list of masks
000019C0  D3C0                    1280          ADDA.L D0,A1 ;displace to a specific mask
000019C2  1A11                    1281          MOVE.B (A1),D5 ;move the mask to D5
000019C4                          1282          
000019C4  0C05 0000               1283          CMPI.B #0,D5 ;check if the mask is 0
000019C8  6700 F6A6               1284          BEQ falsePositive ;branch if it is
000019CC                          1285          
000019CC  1401                    1286          MOVE.B D1,D2 ;copy instruction to D2
000019CE  C405                    1287          AND.B D5,D2  ;mask D2
000019D0  43F8 19B2               1288          LEA JsrEA,A1 ;load the list of valid modes
000019D4  D3C0                    1289          ADDA.L D0,A1 ;displace to a specific mode
000019D6  1811                    1290          MOVE.B (A1),D4 ;move mode to D4
000019D8  B404                    1291          CMP.B D4,D2 ;compare mode to masked value
000019DA  6700 0006               1292          BEQ JsrBody ;if its match, its a valid mode and we can procede
000019DE                          1293          
000019DE  5280                    1294          ADDQ.L #1,D0 ;add one to displacement
000019E0  60DA                    1295          BRA validJsrModes ;check for next mode
000019E2                          1296          
000019E2                          1297  JsrBody:
000019E2                          1298  
000019E2                          1299  
000019E2  43F9 00002175           1300          LEA     jsrMessage,A1  ;move string for NEG info
000019E8  103C 000E               1301          MOVE.B  #14,D0        ;set for task to display null terminated 
000019EC                          1302                                ;string without CR, LF
000019EC  4E4F                    1303          TRAP    #15
000019EE                          1304          
000019EE  3401                    1305          MOVE.W D1,D2 ;copy inst to D2
000019F0  C47C 003F               1306          AND #%000000000111111,D2 ;and out everything but modes and regs
000019F4  1A02                    1307          MOVE.B D2,D5 ; copy to D5 for following BSR
000019F6                          1308          
000019F6  48E7 4000               1309          MOVEM.L D1,-(SP)
000019FA  6100 03E4               1310          BSR     Get_Effective_Address
000019FE  4CDF 0002               1311          MOVEM.L (SP)+,D1
00001A02                          1312          
00001A02                          1313                
00001A02                          1314          
00001A02                          1315  Jsrdone:
00001A02                          1316  
00001A02  43F9 00002130           1317          LEA     clearLine,A1  ;move string for a CR and LF
00001A08  103C 000E               1318          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A0C                          1319                                ;string without CR, LF
00001A0C  4E4F                    1320          TRAP    #15
00001A0E  7000                    1321          MOVEQ.L #0,D0
00001A10  4E75                    1322          RTS
00001A12                          1323  
00001A12                          1324  
00001A12                          1325          
00001A12                          1326  NOP:
00001A12                          1327  
00001A12  43F9 0000217F           1328          LEA     nopMessage,A1 ;move string for NOP info
00001A18  103C 000D               1329          MOVE.B  #13,D0        ;set for task to display null terminated 
00001A1C                          1330                                ;string with CR, LF
00001A1C  4E4F                    1331          TRAP    #15
00001A1E                          1332          
00001A1E  7000                    1333          MOVEQ.L #0,D0
00001A20  4E75                    1334          RTS
00001A22                          1335          
00001A22                          1336  RTS:
00001A22                          1337          
00001A22  43F9 0000217A           1338          LEA     rtsMessage,A1  ;move string for rts info
00001A28  103C 000D               1339          MOVE.B  #13,D0        ;set for task to display null terminated 
00001A2C                          1340                                ;string with CR, LF
00001A2C  4E4F                    1341          TRAP    #15  
00001A2E                          1342     
00001A2E  7000                    1343          MOVEQ.L #0,D0
00001A30  4E75                    1344          RTS   
00001A32                          1345  
00001A32= 3C 08 00 10 18 20 ...   1346  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
00001A3B= 3F 38 38 38 38 38 ...   1347  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001A44                          1348  
00001A44= 00 10 18 20 38 39 00    1349  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
00001A4B= 38 38 38 38 3F 3F 00    1350  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
00001A52                          1351  
00001A52                          1352  MOVE:
00001A52                          1353          
00001A52                          1354  
00001A52                          1355          
00001A52  7000                    1356          MOVEQ.L #0, D0 ;clear D0
00001A54                          1357          
00001A54                          1358  validMoveSourceModes:
00001A54                          1359          
00001A54  43F8 1A3B               1360          LEA moveSourceEAmasks,A1 ;load the list of masks
00001A58  D3C0                    1361          ADDA.L D0,A1 ;displace to a specific mask
00001A5A  1A11                    1362          MOVE.B (A1),D5 ;move the mask to D5
00001A5C                          1363          
00001A5C  0C05 0000               1364          CMPI.B #0,D5 ;check if the mask is 0
00001A60  6700 F60E               1365          BEQ falsePositive ;branch if it is
00001A64                          1366          
00001A64  1401                    1367          MOVE.B D1,D2 ;copy instruction to D2
00001A66  C405                    1368          AND.B D5,D2  ;mask D2
00001A68                          1369          
00001A68  43F8 1A32               1370          LEA moveSourceEA,A1 ;load the list of valid modes
00001A6C  D3C0                    1371          ADDA.L D0,A1 ;displace to a specific mode
00001A6E  1811                    1372          MOVE.B (A1),D4 ;move mode to D4
00001A70  B404                    1373          CMP.B D4,D2 ;compare mode to masked value
00001A72  6700 0006               1374          BEQ  checkMoveDest ;if its match, its a valid mode and we can procede
00001A76                          1375          
00001A76  5280                    1376          ADDQ.L #1,D0 ;add one to displacement
00001A78  60DA                    1377          BRA validMoveSourceModes ;check for next mode
00001A7A                          1378          
00001A7A                          1379  checkMoveDest:
00001A7A  7000                    1380          MOVEQ.L #0, D0 ;clear D0
00001A7C                          1381          
00001A7C                          1382  validMoveDestModes:
00001A7C                          1383          
00001A7C  43F8 1A4B               1384          LEA moveDestEAmasks,A1 ;load the list of masks
00001A80  D3C0                    1385          ADDA.L D0,A1 ;displace to a specific mask
00001A82  1A11                    1386          MOVE.B (A1),D5 ;move the mask to D5
00001A84                          1387          
00001A84  0C05 0000               1388          CMPI.B #0,D5 ;check if the mask is 0
00001A88  6700 F5E6               1389          BEQ falsePositive ;branch if it is
00001A8C                          1390          
00001A8C  3401                    1391          MOVE.W D1,D2 ;copy instruction to D2
00001A8E  EC4A                    1392          LSR.W #6,D2  ;move mode
00001A90  6100 04C2               1393          BSR switchModeAndReg ;switch register and mode
00001A94  C405                    1394          AND.B D5,D2  ;mask D2
00001A96                          1395          
00001A96  43F8 1A44               1396          LEA moveDestEA,A1 ;load the list of valid modes
00001A9A  D3C0                    1397          ADDA.L D0,A1 ;displace to a specific mode
00001A9C  1811                    1398          MOVE.B (A1),D4 ;move mode to D4
00001A9E  B404                    1399          CMP.B D4,D2 ;compare mode to masked value
00001AA0  6700 0006               1400          BEQ moveBody ;if its match, its a valid mode and we can procede
00001AA4                          1401          
00001AA4  5280                    1402          ADDQ.L #1,D0 ;add one to displacement
00001AA6  60D4                    1403          BRA validMoveDestModes ;check for next mode
00001AA8                          1404          
00001AA8                          1405  moveBody
00001AA8  3401                    1406          MOVE.W  D1,D2 ;copy inst to D2
00001AAA  C47C 3000               1407          AND.W  #%0011000000000000,D2 ;mask word for size
00001AAE  0C42 0000               1408          CMPI.W #0,D2 ;0 is the only non valid size
00001AB2  6700 F5BC               1409          BEQ falsePositive ; if zero, this is not move
00001AB6                          1410  
00001AB6  43F9 00002184           1411          LEA     moveMessage,A1  ;move string for MOVE
00001ABC  103C 000E               1412          MOVE.B  #14,D0        ;set for task to display null terminated 
00001AC0                          1413                                ;string with CR, LF
00001AC0  4E4F                    1414          TRAP    #15
00001AC2                          1415          
00001AC2                          1416          
00001AC2  3401                    1417          MOVE.W  D1,D2 ;check source mode
00001AC4  C43C 003F               1418          AND.B   #%00111111,D2
00001AC8  1A02                    1419          MOVE.B  D2,D5
00001ACA  48E7 4000               1420          MOVEM.L D1,-(SP)
00001ACE  6100 0310               1421          BSR     Get_Effective_Address
00001AD2  4CDF 0002               1422          MOVEM.L (SP)+,D1
00001AD6                          1423          
00001AD6                          1424          ;print separator
00001AD6                          1425          
00001AD6  3401                    1426          MOVE.W  D1,D2 ;check dest mode
00001AD8  EC4A                    1427          LSR.W   #6,D2
00001ADA  6100 0478               1428          BSR  switchModeAndReg
00001ADE  C43C 003F               1429          AND.B   #%00111111,D2
00001AE2  1A02                    1430          MOVE.B  D2,D5
00001AE4  48E7 4000               1431          MOVEM.L D1,-(SP)
00001AE8  6100 02F6               1432          BSR     Get_Effective_Address
00001AEC  4CDF 0002               1433          MOVEM.L (SP)+,D1
00001AF0                          1434          
00001AF0                          1435          
00001AF0                          1436          
00001AF0  43F9 00002130           1437          LEA     clearLine,A1  ;move string for a CR and LF
00001AF6  103C 000E               1438          MOVE.B  #14,D0        ;set for task to display null terminated 
00001AFA                          1439                                ;string without CR, LF
00001AFA  4E4F                    1440          TRAP    #15
00001AFC                          1441  
00001AFC  7000                    1442          MOVEQ.L #0,D0
00001AFE  4E75                    1443          RTS
00001B00                          1444          
00001B00= 08 00                   1445  moveADestEA        DC.B %001000,0
00001B02= 38 00                   1446  moveADestEAmasks   DC.B %111000,0
00001B04                          1447          
00001B04                          1448  MOVEA:
00001B04                          1449  
00001B04  7000                    1450          MOVEQ.L #0, D0 ;clear D0
00001B06                          1451          
00001B06                          1452  validMoveASourceModes:
00001B06                          1453          
00001B06  43F8 1A3B               1454          LEA moveSourceEAmasks,A1 ;load the list of masks
00001B0A  D3C0                    1455          ADDA.L D0,A1 ;displace to a specific mask
00001B0C  1A11                    1456          MOVE.B (A1),D5 ;move the mask to D5
00001B0E                          1457          
00001B0E  0C05 0000               1458          CMPI.B #0,D5 ;check if the mask is 0
00001B12  6700 F55C               1459          BEQ falsePositive ;branch if it is
00001B16                          1460          
00001B16  1401                    1461          MOVE.B D1,D2 ;copy instruction to D2
00001B18  C405                    1462          AND.B D5,D2  ;mask D2
00001B1A                          1463          
00001B1A  43F8 1A32               1464          LEA moveSourceEA,A1 ;load the list of valid modes
00001B1E  D3C0                    1465          ADDA.L D0,A1 ;displace to a specific mode
00001B20  1811                    1466          MOVE.B (A1),D4 ;move mode to D4
00001B22  B404                    1467          CMP.B D4,D2 ;compare mode to masked value
00001B24  6700 0006               1468          BEQ  checkMoveADest ;if its match, its a valid mode and we can procede
00001B28                          1469          
00001B28  5280                    1470          ADDQ.L #1,D0 ;add one to displacement
00001B2A  60DA                    1471          BRA validMoveASourceModes ;check for next mode
00001B2C                          1472          
00001B2C                          1473  checkMoveADest:
00001B2C  7000                    1474          MOVEQ.L #0, D0 ;clear D0
00001B2E                          1475  validMoveADestModes:
00001B2E                          1476          
00001B2E  43F8 1B02               1477          LEA moveADestEAmasks,A1 ;load the list of masks
00001B32  D3C0                    1478          ADDA.L D0,A1 ;displace to a specific mask
00001B34  1A11                    1479          MOVE.B (A1),D5 ;move the mask to D5
00001B36                          1480          
00001B36  0C05 0000               1481          CMPI.B #0,D5 ;check if the mask is 0
00001B3A  6700 F534               1482          BEQ falsePositive ;branch if it is
00001B3E                          1483          
00001B3E  3401                    1484          MOVE.W D1,D2 ;copy instruction to D2
00001B40  EA4A                    1485          LSR.W #5,D2  ;move mode
00001B42  6100 0410               1486          BSR switchModeAndReg ;switch register and mode
00001B46  C405                    1487          AND.B D5,D2  ;mask D2
00001B48                          1488          
00001B48  43F8 1B00               1489          LEA moveADestEA,A1 ;load the list of valid modes
00001B4C  D3C0                    1490          ADDA.L D0,A1 ;displace to a specific mode
00001B4E  1811                    1491          MOVE.B (A1),D4 ;move mode to D4
00001B50  B404                    1492          CMP.B D4,D2 ;compare mode to masked value
00001B52  6700 0006               1493          BEQ moveABody ;if its match, its a valid mode and we can procede
00001B56                          1494          
00001B56  5280                    1495          ADDQ.L #1,D0 ;add one to displacement
00001B58  60D4                    1496          BRA validMoveADestModes ;check for next mode
00001B5A                          1497  moveABody:
00001B5A  3401                    1498          MOVE.W  D1,D2 ;copy inst to D2
00001B5C  C47C 3000               1499          AND.W  #%0011000000000000,D2 ;mask word for size
00001B60  0C42 0000               1500          CMPI.W #0,D2 ;0 is the non valid size
00001B64  6700 F50A               1501          BEQ falsePositive ; if zero, this is not move
00001B68  0C42 1000               1502          CMPI.W #%0001000000000000,D2
00001B6C  6700 F502               1503          BEQ falsePositive ; if byte, this is not movea
00001B70                          1504  
00001B70                          1505  
00001B70  43F9 00002197           1506          LEA     moveAMessage,A1  ;move string for MOVE
00001B76  103C 000D               1507          MOVE.B  #13,D0        ;set for task to display null terminated 
00001B7A                          1508                                ;string with CR, LF
00001B7A  4E4F                    1509          TRAP    #15
00001B7C                          1510  
00001B7C  7000                    1511          MOVEQ.L #0,D0
00001B7E  4E75                    1512          RTS
00001B80                          1513  
00001B80                          1514             
00001B80                          1515  Bcc:
00001B80                          1516  
00001B80  43F9 0000218A           1517          LEA     bccMessage,A1  ;move string for BRA info
00001B86  103C 000E               1518          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B8A                          1519                                ;string without CR, LF
00001B8A  4E4F                    1520          TRAP    #15
00001B8C                          1521          
00001B8C  7000                    1522          MOVEQ.L #0,D0 ;clear D0
00001B8E  3401                    1523          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001B90  E04A                    1524          LSR.W   #8,D2
00001B92  C47C 000F               1525          AND.W   #$0F,D2 ;mask instruction
00001B96                          1526          
00001B96                          1527  checkCC:        
00001B96  41F9 000020B7           1528          LEA     bccList,A0 ;get condition code signature list in A0
00001B9C  D1C0                    1529          ADDA.L  D0,A0 ;get correct sig         
00001B9E  B410                    1530          CMP.B   (A0),D2 ;compare to sig
00001BA0  6700 0006               1531          BEQ     foundCC ;if sig matches branch
00001BA4  5200                    1532          ADDQ.B  #byte,D0
00001BA6  60EE                    1533          BRA     checkCC
00001BA8                          1534  foundCC:
00001BA8  43F9 000020C8           1535          LEA     conditionCodeMessage,A1 ;get condition code message in A1
00001BAE  C0FC 0004               1536          MULU.W  #long,D0 ;adjust size of D0 for a long
00001BB2  D3C0                    1537          ADDA.L  D0,A1 ;get correct message location
00001BB4  2251                    1538          MOVEA.L (A1),A1 ;get correct message
00001BB6                          1539          
00001BB6  103C 000E               1540          MOVE.B  #14,D0        ;set for task to display null terminated 
00001BBA                          1541                                ;string without CR, LF
00001BBA  4E4F                    1542          TRAP    #15
00001BBC                          1543  
00001BBC                          1544          
00001BBC                          1545          
00001BBC  548B                    1546          ADDQ.L  #word,A3 ;move past instruction in case long displacement
00001BBE  C27C 00FF               1547          AND.W   #$00FF,D1   ;check for word sized displacement
00001BC2                          1548          
00001BC2  B23C 0000               1549          CMP.B   #$0,D1
00001BC6  6700 0010               1550          BEQ     BccWord
00001BCA                          1551          
00001BCA  B23C 00FF               1552          CMP.B   #$FF,D1 check for long sized displacement
00001BCE  6700 0010               1553          BEQ     BccLong
00001BD2                          1554          
00001BD2                          1555  BccByte:
00001BD2                          1556          
00001BD2  7E00                    1557          MOVEQ.L #0,D7 ;pass back no extra data followed
00001BD4  6000 0012               1558          BRA     BccDone
00001BD8                          1559  BccWord:
00001BD8  3213                    1560          MOVE.W  (A3),D1
00001BDA                          1561          
00001BDA  7E02                    1562          MOVEQ.L #word,D7 ;pass back an extra word followed
00001BDC  6000 000A               1563          BRA     BccDone
00001BE0                          1564  BccLong:
00001BE0  2213                    1565          MOVE.L  (A3),D1
00001BE2                          1566          
00001BE2  7E04                    1567          MOVEQ.L #long,D7 ;pass back an extra long followed
00001BE4  6000 0002               1568          BRA     BccDone
00001BE8                          1569  BccDone:
00001BE8                          1570  
00001BE8  343C 0010               1571          MOVE.W  #16,D2 ;put base in D2
00001BEC  303C 000F               1572          MOVE.W  #15,D0  ;put task #15 in D0
00001BF0  4E4F                    1573          TRAP    #15
00001BF2                          1574          
00001BF2  43F9 00002130           1575          LEA     clearLine,A1  ;move string for a CR and LF
00001BF8  103C 000E               1576          MOVE.B  #14,D0        ;set for task to display null terminated 
00001BFC                          1577                                ;string without CR, LF
00001BFC  4E4F                    1578          TRAP    #15
00001BFE                          1579  
00001BFE  7000                    1580          MOVEQ.L #0,D0
00001C00  4E75                    1581          RTS
00001C02                          1582          
00001C02                          1583          
00001C02                          1584  unknownOpCode:
00001C02  43F9 00002191           1585          LEA     dataMessage,A1 ;move string for data info
00001C08  103C 000E               1586          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C0C                          1587                                ;string without CR, LF
00001C0C  4E4F                    1588          TRAP    #15
00001C0E                          1589          
00001C0E  143C 0010               1590          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001C12  103C 000F               1591          MOVE.B  #15,D0
00001C16  4E4F                    1592          TRAP    #15
00001C18                          1593          
00001C18  43F9 00002130           1594          LEA     clearLine,A1  ;move string for a CR and LF
00001C1E  103C 000E               1595          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C22                          1596                                ;string without CR, LF
00001C22  4E4F                    1597          TRAP    #15
00001C24                          1598          
00001C24  7000                    1599          MOVEQ.L #0,D0
00001C26  4E75                    1600          RTS
00001C28                          1601          
00001C28                          1602  handlebytedata:
00001C28                          1603  
00001C28  43F9 00002191           1604          LEA     dataMessage,A1 ;move string for data info
00001C2E  103C 000E               1605          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C32                          1606                                ;string without CR, LF
00001C32  4E4F                    1607          TRAP    #15
00001C34                          1608          
00001C34  E049                    1609          LSR.W   #8,D1 ;shift the word read into D1 by a byte
00001C36                          1610          
00001C36  143C 0010               1611          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001C3A  103C 000F               1612          MOVE.B  #15,D0
00001C3E  4E4F                    1613          TRAP    #15
00001C40                          1614          
00001C40  43F9 00002130           1615          LEA     clearLine,A1  ;move string for a CR and LF
00001C46  103C 000E               1616          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C4A                          1617                                ;string without CR, LF
00001C4A  4E4F                    1618          TRAP    #15
00001C4C                          1619          
00001C4C  7000                    1620          MOVEQ.L #0,D0
00001C4E                          1621          
00001C4E  528B                    1622          ADDQ.L  #byte,A3
00001C50  6000 F3D4               1623          BRA main_Loop
00001C54                          1624  
00001C54                          1625          
00001C54                          1626          
00001C54                          1627  fin
00001C54                          1628  
00001C54                          1629          
00001C54                          1630          
00001C54  FFFF FFFF               1631          simhalt
00001C58                          1632          
00001C58                          1633  
00001C58                          1634  *******************************************************************************
00001C58                          1635  *                            SUB ROUTINES
00001C58                          1636  *******************************************************************************
00001C58                          1637  
00001C58                          1638  *******************************************************************************
00001C58                          1639  *                          IO ROLE ROUTINES
00001C58                          1640  *******************************************************************************
00001C58                          1641  
00001C58                          1642  *==========================================================================
00001C58                          1643  *                   Enter / Validate beginning address 
00001C58                          1644  *==========================================================================
00001C58                          1645   
00001C58                          1646  begin_address:
00001C58                          1647  
00001C58                          1648         
00001C58  43F9 00001F68           1649          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00001C5E  2239 00001F68           1650          MOVE.L      slPrompt,D1         ;Load display length to D1
00001C64  700E                    1651          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001C66  4E4F                    1652          TRAP        #15                 ;Perform task 14 (display)
00001C68                          1653          
00001C68  43F9 000021C8           1654          LEA         startLocation,A1    ;Load address to store user input
00001C6E  103C 0002               1655          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001C72  4E4F                    1656          TRAP        #15                 ;Perform task 2 (input)
00001C74                          1657          
00001C74  0C11 001B               1658          CMP.B       #27,(A1)            ;Check for ESC entered
00001C78  6700 004C               1659          BEQ         address_Exit        ;Exit condition 
00001C7C                          1660          
00001C7C  6100 0050               1661          BSR         enter_addr_edit_all
00001C80  B67C FFFF               1662          CMP.W       #-1,D3              ;Did the edit pass?
00001C84  67D2                    1663          BEQ         begin_address       ;No, loop and ask for correct input
00001C86                          1664          
00001C86  2643                    1665          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
00001C88                          1666          
00001C88  43F9 00002075           1667          LEA         spc,A1              ;Load address for starting loaction prompt
00001C8E  1239 00002076           1668          MOVE.B      spc_len,D1          ;Load empty line length
00001C94  7000                    1669          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
00001C96  4E4F                    1670          TRAP        #15                 ;Perform task 14 (display)
00001C98  6000 0002               1671          BRA         end_address
00001C9C                          1672  
00001C9C                          1673  *===========================================================================
00001C9C                          1674  *                   Enter / Validate ending address 
00001C9C                          1675  *===========================================================================
00001C9C                          1676  
00001C9C                          1677  end_address:
00001C9C                          1678          
00001C9C  43F9 00001F99           1679          LEA         elPrompt,A1         ;Load address for ending loaction prompt
00001CA2                          1680          ;MOVE.L     elPrompt,D1         ;Load display length to D1
00001CA2  7250                    1681          MOVE.L      #80,D1       ;did not like previous command, do not know why, it should have worked
00001CA4  700E                    1682          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001CA6  4E4F                    1683          TRAP        #15                 ;Perform task 14 (display)
00001CA8                          1684          
00001CA8  103C 0002               1685          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001CAC  4E4F                    1686          TRAP        #15                 ;Perform task 2 (input)
00001CAE                          1687          
00001CAE  0C11 001B               1688          CMP.B       #27,(A1)            ;Check for ESC entered
00001CB2  6700 0012               1689          BEQ         address_Exit        ;Exit condition 
00001CB6                          1690          
00001CB6  6100 0016               1691          BSR         enter_addr_edit_all
00001CBA  B67C FFFF               1692          CMP.W       #-1,D3              ;Did the edit pass?
00001CBE  67DC                    1693          BEQ         end_address         ;No, loop and ask for correct input
00001CC0                          1694  
00001CC0  2843                    1695          MOVEA.L     D3,A4               ;Ending address gets stored in A4
00001CC2  6000 0008               1696          BRA         address_done
00001CC6                          1697  
00001CC6                          1698  address_Exit:
00001CC6                          1699  
00001CC6  76FF                    1700          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001CC8  6000 0002               1701          BRA         address_done
00001CCC                          1702          
00001CCC                          1703  address_done:
00001CCC                          1704  
00001CCC  4E75                    1705          RTS    
00001CCE                          1706  
00001CCE                          1707  *==============================================================================
00001CCE                          1708  * enter_addr_edit_all - Enter address edit check to edit all errors  
00001CCE                          1709  *                       using multiple different error checking routines.
00001CCE                          1710  *
00001CCE                          1711  * Parameters -
00001CCE                          1712  *   Input   A1      The data that needs checked.
00001CCE                          1713  *   Input   D1      The number of characters input     
00001CCE                          1714  *   Output  D3      Returns '-1' when there is an error.
00001CCE                          1715  *==============================================================================
00001CCE                          1716  
00001CCE                          1717  enter_addr_edit_all
00001CCE                          1718  
00001CCE                          1719  *------------------------------------------------------------------------------
00001CCE                          1720  * Test for odd number of characters entered, not allowed
00001CCE                          1721  *------------------------------------------------------------------------------
00001CCE                          1722         
00001CCE  6100 0024               1723          BSR         ck_boundry          ;check if the input is on a odd / even boundry
00001CD2  B67C FFFF               1724          CMP.W       #-1,D3              ;Is the address odd?
00001CD6  6700 001A               1725          BEQ         enter_addr_edit_all_exit     ;No, return
00001CDA                          1726  
00001CDA                          1727  *------------------------------------------------------------------------------
00001CDA                          1728  * Ttest for character entered all being valid address characters
00001CDA                          1729  * Note: lower case a-f, gets converted to upper case A-F in D3
00001CDA                          1730  *------------------------------------------------------------------------------
00001CDA                          1731          
00001CDA  6100 0062               1732          BSR         parseHexString      ;check if the input contains valid Hex characters
00001CDE  B67C FFFF               1733          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
00001CE2  6700 000E               1734          BEQ         enter_addr_edit_all_exit     ;No, return
00001CE6                          1735  
00001CE6                          1736  *------------------------------------------------------------------------------
00001CE6                          1737  * Verify that the address entered is witin the range defined in the Equate
00001CE6                          1738  *------------------------------------------------------------------------------        
00001CE6                          1739          
00001CE6  6100 00C8               1740          BSR         ck_addr_range       ;is address entered witin the range 
00001CEA                          1741                                          ;   as defined in the Equate? 
00001CEA  B67C FFFF               1742          CMP.W       #-1,D3              ;is the address  valid?
00001CEE  6700 0002               1743          BEQ         enter_addr_edit_all_exit     ;No, return
00001CF2                          1744  
00001CF2                          1745  enter_addr_edit_all_exit:
00001CF2                          1746  
00001CF2  4E75                    1747          RTS                             ;return
00001CF4                          1748  
00001CF4                          1749  *==============================================================================
00001CF4                          1750  * ck_boundry - Check the size of the data characters input and determine
00001CF4                          1751  *              if an odd number of characters was entered
00001CF4                          1752  *
00001CF4                          1753  * Parameters -
00001CF4                          1754  *   Input   A1      The data that needs checked for odd length.
00001CF4                          1755  *   Input   D1      The number of characters input     
00001CF4                          1756  *   Output  D3      Returns '-1' when there is an odd length.
00001CF4                          1757  *==============================================================================
00001CF4                          1758  
00001CF4                          1759  ck_boundry:
00001CF4                          1760  
00001CF4  4243                    1761          CLR.W       D3                  ;Clear the return
00001CF6                          1762  
00001CF6  B23C 0000               1763          CMP.B       #0,D1               ;Check for nothing entered
00001CFA  6700 002E               1764          BEQ         ck_size_error       ;Number of characters entered must be 
00001CFE                          1765                                          ;greater than 0  
00001CFE                          1766          
00001CFE                          1767          
00001CFE                          1768          * The program will branch to ck_size_error if D1 is greater than #8        
00001CFE  B23C 0008               1769          CMP.B       #8,D1               ;Check for more than 8 characters entered
00001D02  6E00 0026               1770          BGT         ck_size_error       ;Number of characters entered must be less
00001D06                          1771                                          ;than 9
00001D06                          1772          
00001D06  7402                    1773          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
00001D08  82C2                    1774          DIVU        D2,D1               ;Divide address by 2
00001D0A  4841                    1775          SWAP        D1                  ;get remainder
00001D0C  B23C 0001               1776          CMP.B       #$01,D1             ;Check for remainder of 1
00001D10  6700 0004               1777          BEQ         ck_boundry_error    ;Number of characters entered must be an 
00001D14                          1778                                          ;even number   
00001D14                          1779    
00001D14  4E75                    1780          RTS                             ;return
00001D16                          1781  
00001D16                          1782  *------------------------------------------------------------------------------
00001D16                          1783  * ck_boundry_error - An odd number of characters was entered
00001D16                          1784  *                  - Load error message and display it
00001D16                          1785  *                  - Return error condition
00001D16                          1786  *------------------------------------------------------------------------------
00001D16                          1787          
00001D16                          1788  ck_boundry_error:
00001D16                          1789  
00001D16  43F9 00002055           1790          LEA         even_msg,A1         ;Load odd error message into A1
00001D1C  2239 00002055           1791          MOVE.L      even_msg,D1         ;Load error length to D1
00001D22                          1792          
00001D22  7000                    1793          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001D24                          1794                                          ; n is D1.W with CR, LF. 
00001D24  4E4F                    1795          TRAP #15                        ;Display the error message
00001D26  76FF                    1796          MOVE.L #-1,D3                   ;Load -1 into return parameter
00001D28  4E75                    1797          RTS                             ;Return
00001D2A                          1798          
00001D2A                          1799  *------------------------------------------------------------------------------
00001D2A                          1800  * ck_size_error -   The number of characters entered must be more than zero
00001D2A                          1801  *                  - Load error message and display it
00001D2A                          1802  *                  - Return error condition
00001D2A                          1803  *------------------------------------------------------------------------------
00001D2A                          1804          
00001D2A                          1805  ck_size_error:
00001D2A                          1806  
00001D2A  43F9 00001FC8           1807          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001D30  2239 00001FC8           1808          MOVE.L      invalidMsg,D1       ;Load error length to D1
00001D36                          1809          
00001D36  7000                    1810          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001D38                          1811                                          ; n is D1.W with CR, LF. 
00001D38  4E4F                    1812          TRAP        #15                 ;Display the error message
00001D3A  76FF                    1813          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001D3C  4E75                    1814          RTS                             ;Return        
00001D3E                          1815  
00001D3E                          1816  
00001D3E                          1817  *==============================================================================
00001D3E                          1818  * parseHexString - Converts user input string into a valid memory address
00001D3E                          1819  *                - Stores parsed address data into D3
00001D3E                          1820  *                - Stores good/bad (1/0) data in D4 
00001D3E                          1821  *
00001D3E                          1822  * Hex values are stored as bytes in D2, the ASCII chart shows their value
00001D3E                          1823  *   The ASCII chart values we care about are in the ranges of: 
00001D3E                          1824  *                            Hex            Decimal
00001D3E                          1825  *       No Value           NULL = 0         0
00001D3E                          1826  *       Numeric Values:     0-9 = 30-39     48-57
00001D3E                          1827  *       Upper Case letters: A-F = 41-46     65-70
00001D3E                          1828  *       Lower Case letterc: a-f = 61-66     97-102
00001D3E                          1829  
00001D3E                          1830  * Parameters -
00001D3E                          1831  *   Input   A1      The data that needs checked for valid input.
00001D3E                          1832  *   Output  D3      The return value, '-1' for error
00001D3E                          1833  *==============================================================================
00001D3E                          1834  
00001D3E                          1835  parseHexString:
00001D3E                          1836  
00001D3E                          1837  * setup any initializing item that do not get looped through
00001D3E  4243                    1838          CLR.W       D3                  ;Clear the return
00001D40                          1839  
00001D40                          1840          
00001D40                          1841  *------------------------------------------------------------------------------
00001D40                          1842  * NextHex - Loop through all bytes and vaildate the input
00001D40                          1843  * Parameters -
00001D40                          1844  *   Input   A1      The data that needs checked for valid input.
00001D40                          1845  *   Output  D3      The return value, '-1' for error
00001D40                          1846  *------------------------------------------------------------------------------
00001D40                          1847          
00001D40                          1848  NextHex:
00001D40                          1849  
00001D40  1419                    1850          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00001D42  B43C 0000               1851          CMP.B       #0,D2               ;Check character for null 
00001D46  6700 0066               1852          BEQ         NextHexReturn       ;Character is null (end of input)
00001D4A                          1853          
00001D4A                          1854  *................................................................................
00001D4A                          1855  *  Check decimal values 0-9 by testing hexadecimal values 30-39
00001D4A                          1856  *................................................................................
00001D4A                          1857                  
00001D4A                          1858          * The program will branch to hex_range_error if D2 is less than #30
00001D4A  B43C 0030               1859          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
00001D4E  6D00 0048               1860          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001D52                          1861                                          ;processing
00001D52                          1862          
00001D52                          1863          * The program will branch to UcaseHex if D2 is greater than #39
00001D52  B43C 0039               1864          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
00001D56  6E00 000A               1865          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
00001D5A                          1866          
00001D5A                          1867          *a valid number was found within this range
00001D5A  0402 0030               1868          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
00001D5E  6000 0032               1869          BRA         NextHexDone         ;Done parsing this byte
00001D62                          1870  
00001D62                          1871  
00001D62                          1872  *..............................................................................
00001D62                          1873  *  Check upper case values A-F by testing hexadecimal values 41-46
00001D62                          1874  *..............................................................................
00001D62                          1875  
00001D62                          1876  UcaseHex:
00001D62                          1877  
00001D62                          1878          * The program will branch to hex_range_error if D2 is less than #41
00001D62  B43C 0041               1879          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
00001D66  6D00 0030               1880          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001D6A                          1881                                          ;processing
00001D6A                          1882          
00001D6A  B43C 0046               1883          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
00001D6E  6E00 000A               1884          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
00001D72                          1885                                          ;processing
00001D72                          1886          
00001D72                          1887          *a valid number was found within this range
00001D72  0402 0037               1888          SUBI.B      #55,D2              ;Change uppercase character to actual value
00001D76  6000 001A               1889          BRA         NextHexDone         ;Done parsing this byte
00001D7A                          1890  
00001D7A                          1891  
00001D7A                          1892  *..............................................................................
00001D7A                          1893  *  Check lower case values a-f by testing hexadecimal values 61-66
00001D7A                          1894  *..............................................................................
00001D7A                          1895  
00001D7A                          1896  LcaseHex
00001D7A                          1897          
00001D7A                          1898          * The program will branch to hex_range_error if D2 is less than #61
00001D7A  B43C 0061               1899          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
00001D7E  6D00 0018               1900          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
00001D82                          1901                                          ;processing
00001D82                          1902  
00001D82  B43C 0066               1903          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
00001D86  6E00 0010               1904          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
00001D8A                          1905                                          ;processing
00001D8A                          1906  
00001D8A                          1907          *a valid number was found within this range
00001D8A  0402 0057               1908          SUBI.B      #87,D2              ;Change lowercase character to actual value
00001D8E  6000 0002               1909          BRA         NextHexDone         ;Done parsing this byte
00001D92                          1910  
00001D92                          1911  NextHexDone:
00001D92                          1912  
00001D92  E983                    1913          ASL.L       #4,D3               ; Make rooom for new byte in the return register
00001D94  D602                    1914          ADD.B       D2,D3               ; Move the new byte into the return register
00001D96  60A8                    1915          BRA         NextHex             ; We're ready to parse the next byte
00001D98                          1916          
00001D98                          1917  *-------------------------------------------------------------------------------------
00001D98                          1918  * hex_range_error -  A character entered was within the valid range for a hex address
00001D98                          1919  *                 -  Load error message and display it
00001D98                          1920  *                 -  Return error condition
00001D98                          1921  *-------------------------------------------------------------------------------------
00001D98                          1922          
00001D98                          1923  hex_range_error:
00001D98                          1924  
00001D98  43F9 0000200D           1925          LEA         invCharMsg,A1       ;Load invalid range message into A1
00001D9E  2239 0000200D           1926          MOVE.L      invCharMsg,D1       ;Load error length to D1
00001DA4                          1927          
00001DA4  7000                    1928          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001DA6                          1929                                          ; n is D1.W with CR, LF. 
00001DA6  4E4F                    1930          TRAP        #15                 ;Display the error message
00001DA8  76FF                    1931          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001DAA  6000 0002               1932          BRA         NextHexReturn
00001DAE                          1933          
00001DAE                          1934  NextHexReturn:
00001DAE                          1935          
00001DAE  4E75                    1936          RTS                             ;Return      
00001DB0                          1937  
00001DB0                          1938  
00001DB0                          1939  *===============================================================================
00001DB0                          1940  * ck_addr_range - check the address input is within a valid memory address range
00001DB0                          1941  *                - Parsed address data into D3
00001DB0                          1942  *
00001DB0                          1943  * Parameters -
00001DB0                          1944  *   Input   A1      The data that needs checked for valid address.
00001DB0                          1945  *   Output  D3      The return value, '-1' for error
00001DB0                          1946  *===============================================================================
00001DB0                          1947  
00001DB0                          1948  
00001DB0                          1949  ck_addr_range:   
00001DB0                          1950  
00001DB0                          1951  *------------------------------------------------------------------------------
00001DB0                          1952  * Verify that the address entered is witin the 
00001DB0                          1953  * beginning range ('begin') as defined in the Equate
00001DB0                          1954  *------------------------------------------------------------------------------   
00001DB0                          1955              
00001DB0  2C3C 00005001           1956          MOVE.L      #begin,D6           * Load minimum starting address
00001DB6  B686                    1957          CMP.L       D6,D3               * Is input at or above minimum?
00001DB8  6D00 0012               1958          BLT         ck_addr_range_error 
00001DBC                          1959          
00001DBC                          1960  *------------------------------------------------------------------------------
00001DBC                          1961  * Verify that the address entered is witin the 
00001DBC                          1962  * ending range ('end') as defined in the Equate
00001DBC                          1963  *------------------------------------------------------------------------------
00001DBC                          1964          
00001DBC  2C3C 00FFFFFE           1965          MOVE.L      #end,D6             * Load maximum starting address
00001DC2  B686                    1966          CMP.L       D6,D3               * Is input at or below maximum?
00001DC4  6E00 0006               1967          BGT         ck_addr_range_error 
00001DC8  6000 0012               1968          BRA         ck_addr_done        ;done checking
00001DCC                          1969          
00001DCC                          1970  *..............................................................................
00001DCC                          1971  * ck_addr_range_error -  A address entered is not within the 
00001DCC                          1972  *                        valid range for a hex address
00001DCC                          1973  *..............................................................................
00001DCC                          1974          
00001DCC                          1975  ck_addr_range_error
00001DCC                          1976  
00001DCC  43F9 00001FC8           1977          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001DD2                          1978          
00001DD2  700D                    1979          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
00001DD4                          1980                                          ;with CR, LF. 
00001DD4  4E4F                    1981          TRAP        #15                 ;Display the error message
00001DD6  76FF                    1982          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001DD8  6000 0002               1983          BRA         ck_addr_done 
00001DDC                          1984  
00001DDC                          1985  ck_addr_done:
00001DDC                          1986  
00001DDC  4E75                    1987          RTS                             ;Return
00001DDE                          1988  
00001DDE                          1989  *******************************************************************************
00001DDE                          1990  *                          OP CODE ROLE ROUTINES
00001DDE                          1991  *******************************************************************************
00001DDE                          1992  
00001DDE                          1993  process_op_codes:
00001DDE                          1994  
00001DDE                          1995  
00001DDE                          1996  
00001DDE                          1997  process_op_codes_exit:
00001DDE                          1998  
00001DDE  4E75                    1999          RTS
00001DE0                          2000  
00001DE0                          2001  
00001DE0                          2002  *******************************************************************************
00001DE0                          2003  *                    Effective Addressing ROLE ROUTINES
00001DE0                          2004  *******************************************************************************
00001DE0                          2005  
00001DE0                          2006  Get_Effective_Address:
00001DE0                          2007  
00001DE0  1C05                    2008          MOVE.B      D5,D6
00001DE2  E60E                    2009          LSR.B       #3,D6               ;mode
00001DE4  CA3C 0007               2010          And.B       #%00000111,D5       ;register
00001DE8                          2011          
00001DE8  BC3C 0000               2012          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
00001DEC  6700 004A               2013          BEQ         Data_Reg_Direct
00001DF0                          2014          
00001DF0  BC3C 0001               2015          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
00001DF4  6700 005C               2016          BEQ         Addr_Reg_Direct
00001DF8                          2017          
00001DF8  BC3C 0002               2018          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
00001DFC  6700 006E               2019          BEQ         Addr_Reg_Indirect
00001E00                          2020          
00001E00  BC3C 0003               2021          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
00001E04  6700 0098               2022          BEQ         Addr_Reg_Indirect_Inc
00001E08                          2023          
00001E08  BC3C 0004               2024          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
00001E0C  6700 00CE               2025          BEQ         Addr_Reg_Indirect_Dec
00001E10                          2026          
00001E10  BC3C 0007               2027          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
00001E14  6700 0006               2028          BEQ         Get_Effective_Address_Other
00001E18                          2029          
00001E18  6000 0138               2030          BRA         invalidEA
00001E1C                          2031          
00001E1C                          2032  Get_Effective_Address_Other:        
00001E1C                          2033          
00001E1C  BA3C 0000               2034          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00001E20  6700 00F8               2035          BEQ Addr_Abs_Short
00001E24                          2036          
00001E24  BA3C 0001               2037          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
00001E28  6700 0104               2038          BEQ Addr_Abs_Long
00001E2C                          2039          
00001E2C  BA3C 0004               2040          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
00001E30  6700 0110               2041          BEQ Addr_Immediate_Data
00001E34                          2042          
00001E34  6000 011C               2043          BRA         invalidEA
00001E38                          2044          
00001E38                          2045  Data_Reg_Direct:                        ;case 0(0000)
00001E38                          2046  
00001E38  43F9 000021BE           2047          LEA         letterD,A1          ;output 'D' for data register
00001E3E  103C 000E               2048          MOVE.B      #14,D0              ;set for task to display null terminated 
00001E42  4E4F                    2049          TRAP        #15                 ;string without CR, LF
00001E44                          2050                          
00001E44  4281                    2051          CLR.L       D1
00001E46  1205                    2052          MOVE.B      D5,D1               ;move register number for display into D1
00001E48  103C 0003               2053          MOVE.B      #3,D0               ;set for task to display null terminated 
00001E4C  4E4F                    2054          TRAP        #15                 ;string without CR, LF
00001E4E                          2055                 
00001E4E  6000 0102               2056          BRA         Get_Effective_Address_Exit  ;return
00001E52                          2057          
00001E52                          2058          
00001E52                          2059  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
00001E52                          2060        
00001E52  43F9 000021BC           2061          LEA         letterA,A1          ;output 'A' for address register
00001E58  103C 000E               2062          MOVE.B      #14,D0              ;set for task to display null terminated 
00001E5C  4E4F                    2063          TRAP        #15                 ;string without CR, LF
00001E5E                          2064          
00001E5E  4281                    2065          CLR.L       D1
00001E60  1205                    2066          MOVE.B      D5,D1               ;move register number for display into D1
00001E62  103C 0003               2067          MOVE.B      #3,D0               ;set for task to display null terminated 
00001E66  4E4F                    2068          TRAP        #15                 ;string without CR, LF
00001E68                          2069          
00001E68  6000 00E8               2070          BRA         Get_Effective_Address_Exit  ;return
00001E6C                          2071  
00001E6C                          2072  
00001E6C                          2073  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
00001E6C                          2074          
00001E6C  43F9 000021C4           2075          LEA         lprn,A1             ;output 'D' for data register
00001E72  103C 000E               2076          MOVE.B      #14,D0              ;set for task to display null terminated 
00001E76  4E4F                    2077          TRAP        #15                 ;string without CR, LF
00001E78                          2078  
00001E78  43F9 000021BC           2079          LEA         letterA,A1          ;output 'A' for address register
00001E7E  103C 000E               2080          MOVE.B      #14,D0              ;set for task to display null terminated 
00001E82  4E4F                    2081          TRAP        #15                 ;string without CR, LF
00001E84                          2082          
00001E84  4281                    2083          CLR.L       D1
00001E86  1205                    2084          MOVE.B      D5,D1               ;move register number for display into D1
00001E88  103C 0003               2085          MOVE.B      #3,D0               ;set for task to display null terminated 
00001E8C  4E4F                    2086          TRAP        #15                 ;string without CR, LF
00001E8E                          2087  
00001E8E  43F9 000021C6           2088          LEA         rprn,A1             ;output 'D' for data register
00001E94  103C 000E               2089          MOVE.B      #14,D0              ;set for task to display null terminated 
00001E98  4E4F                    2090          TRAP        #15                 ;string without CR, LF
00001E9A                          2091          
00001E9A  6000 00B6               2092          BRA         Get_Effective_Address_Exit  ;return
00001E9E                          2093  
00001E9E                          2094                 
00001E9E                          2095  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
00001E9E                          2096  
00001E9E  43F9 000021C4           2097          LEA         lprn,A1             ;output 'D' for data register
00001EA4  103C 000E               2098          MOVE.B      #14,D0              ;set for task to display null terminated 
00001EA8  4E4F                    2099          TRAP        #15                 ;string without CR, LF
00001EAA                          2100  
00001EAA  43F9 000021BC           2101          LEA         letterA,A1          ;output 'A' for address register
00001EB0  103C 000E               2102          MOVE.B      #14,D0              ;set for task to display null terminated 
00001EB4  4E4F                    2103          TRAP        #15                 ;string without CR, LF
00001EB6                          2104          
00001EB6  4281                    2105          CLR.L       D1
00001EB8  1205                    2106          MOVE.B      D5,D1               ;move register number for display into D1
00001EBA  103C 0003               2107          MOVE.B      #3,D0               ;set for task to display null terminated 
00001EBE  4E4F                    2108          TRAP        #15                 ;string without CR, LF
00001EC0                          2109  
00001EC0  43F9 000021C6           2110          LEA         rprn,A1             ;output 'D' for data register
00001EC6  103C 000E               2111          MOVE.B      #14,D0              ;set for task to display null terminated 
00001ECA  4E4F                    2112          TRAP        #15                 ;string without CR, LF
00001ECC                          2113          
00001ECC  43F9 000021C0           2114          LEA         plus,A1             ;output 'D' for data register
00001ED2  103C 000E               2115          MOVE.B      #14,D0              ;set for task to display null terminated 
00001ED6  4E4F                    2116          TRAP        #15                 ;string without CR, LF
00001ED8                          2117          
00001ED8  6000 0078               2118          BRA         Get_Effective_Address_Exit  ;return
00001EDC                          2119  
00001EDC                          2120  Addr_Reg_Indirect_Dec                   ;4 = (An) - Address Register Indirect with Predecrement (100)
00001EDC                          2121  
00001EDC  43F9 000021C2           2122          LEA         minus,A1            ;output '-' for Predecrement
00001EE2  103C 000E               2123          MOVE.B      #14,D0              ;set for task to display null terminated 
00001EE6  4E4F                    2124          TRAP        #15                 ;string without CR, LF
00001EE8                          2125  
00001EE8  43F9 000021C4           2126          LEA         lprn,A1             ;output 'D' for data register
00001EEE  103C 000E               2127          MOVE.B      #14,D0              ;set for task to display null terminated 
00001EF2  4E4F                    2128          TRAP        #15                 ;string without CR, LF
00001EF4                          2129  
00001EF4  43F9 000021BC           2130          LEA         letterA,A1          ;output 'A' for address register
00001EFA  103C 000E               2131          MOVE.B      #14,D0              ;set for task to display null terminated 
00001EFE  4E4F                    2132          TRAP        #15                 ;string without CR, LF
00001F00                          2133          
00001F00  4281                    2134          CLR.L       D1
00001F02  1205                    2135          MOVE.B      D5,D1               ;move register number for display into D1
00001F04  103C 0003               2136          MOVE.B      #3,D0               ;set for task to display null terminated 
00001F08  4E4F                    2137          TRAP        #15                 ;string without CR, LF
00001F0A                          2138  
00001F0A  43F9 000021C6           2139          LEA         rprn,A1             ;output 'D' for data register
00001F10  103C 000E               2140          MOVE.B      #14,D0              ;set for task to display null terminated 
00001F14  4E4F                    2141          TRAP        #15                 ;string without CR, LF
00001F16                          2142          
00001F16  6000 003A               2143          BRA         Get_Effective_Address_Exit  ;return
00001F1A                          2144          
00001F1A                          2145                         
00001F1A                          2146  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00001F1A                          2147          
00001F1A                          2148          
00001F1A  43F9 0000219E           2149          LEA         xxxW,A1             ;output 'D' for data register
00001F20  103C 000E               2150          MOVE.B      #14,D0              ;set for task to display null terminated 
00001F24  4E4F                    2151          TRAP        #15                 ;string without CR, LF
00001F26                          2152  
00001F26  548B                    2153          ADDA.L      #word,A3
00001F28                          2154          
00001F28                          2155          ;print word (A3)
00001F28                          2156          ;MOVE.W      A3,(A1)
00001F28                          2157          ;MOVE.B      #1,D0               ;set for task to display null terminated 
00001F28                          2158          ;TRAP        #15                 ;string without CR, LF
00001F28                          2159          
00001F28  5487                    2160          ADDI.L      #word,D7 
00001F2A  6000 0026               2161          BRA         Get_Effective_Address_Exit  ;return
00001F2E                          2162                         
00001F2E                          2163  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
00001F2E                          2164          
00001F2E  43F9 000021A8           2165          LEA         xxxL,A1             ;output 'D' for data register
00001F34  103C 000E               2166          MOVE.B      #14,D0              ;set for task to display null terminated 
00001F38  4E4F                    2167          TRAP        #15                 ;string without CR, LF
00001F3A                          2168  
00001F3A  548B                    2169          ADDA.L      #word,A3
00001F3C                          2170          
00001F3C                          2171          ;print long (A3)
00001F3C                          2172          ;MOVE.L      A3,(A1)
00001F3C                          2173          ;MOVE.B      #14,D0              ;set for task to display null terminated 
00001F3C                          2174          ;TRAP        #15                 ;string without CR, LF
00001F3C                          2175          
00001F3C  5887                    2176          ADDI.L      #long,D7
00001F3E  6000 0012               2177          BRA         Get_Effective_Address_Exit  ;return
00001F42                          2178                         
00001F42                          2179  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
00001F42                          2180  
00001F42  43F9 000021B2           2181          LEA         iData,A1            ;output 'D' for data register
00001F48  103C 000E               2182          MOVE.B      #14,D0              ;set for task to display null terminated 
00001F4C  4E4F                    2183          TRAP        #15                 ;string without CR, LF
00001F4E                          2184          
00001F4E                          2185          *need another input param for size
00001F4E  6000 0002               2186          BRA         Get_Effective_Address_Exit  ;return
00001F52                          2187  
00001F52                          2188  invalidEA:
00001F52                          2189  
00001F52                          2190          ;do something
00001F52                          2191   
00001F52                          2192  Get_Effective_Address_Exit:     
00001F52                          2193  
00001F52  4E75                    2194          RTS                             ;return
00001F54                          2195  
00001F54                          2196  switchModeAndReg:
00001F54                          2197  ***
00001F54                          2198  * Assumed in D2
00001F54                          2199  *
00001F54                          2200  * Assumed that they are in least significant byte:
00001F54                          2201  *
00001F54                          2202  *            _this_
00001F54                          2203  *           /      \
00001F54                          2204  *  ........ ........
00001F54                          2205  *  \                /
00001F54                          2206  *   -----word-------
00001F54                          2207  *
00001F54                          2208  *  and that in that byte they are ordered:
00001F54                          2209  *
00001F54                          2210  *       ........   
00001F54                          2211  *       \/\_/\_/
00001F54                          2212  *      /  /    \
00001F54                          2213  *    /   /      \
00001F54                          2214  * dont  one    other
00001F54                          2215  * care
00001F54                          2216  *
00001F54                          2217  * after they will be
00001F54                          2218  *
00001F54                          2219  *       ........   
00001F54                          2220  *       \/\_/\_/
00001F54                          2221  *      /  /    \
00001F54                          2222  *    /   /      \
00001F54                          2223  * dont other    one
00001F54                          2224  * care
00001F54                          2225  *** 
00001F54  0202 003F               2226          AndI.B #%00111111,D2 ;remove unwanted bits from D2
00001F58  0283 00000000           2227          ANDI.L #0,D3 ;clear D3
00001F5E  1602                    2228          MOVE.B D2,D3 ;copy to D3
00001F60  E70B                    2229          LSL.B  #3,D3 
00001F62  E60A                    2230          LSR.B  #3,D2
00001F64  D403                    2231          ADD.B  D3,D2
00001F66  4E75                    2232          RTS
00001F68                          2233  
00001F68                          2234          
00001F68                          2235  *==============================================================================
00001F68                          2236  *                            variables and constants
00001F68                          2237  *==============================================================================
00001F68                          2238  
00001F68                          2239  
00001F68                          2240  ***initial user prompt stuff        
00001F68= 45 6E 74 65 72 20 ...   2241  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE: $',0
00001F99= 45 6E 74 65 72 20 ...   2242  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE: $',0
00001FC8                          2243  
00001FC8= 20 41 64 64 72 65 ...   2244  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
0000200D= 20 41 20 43 68 61 ...   2245  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
00002055                          2246  
00002055= 20 59 6F 75 20 6D ...   2247  even_msg        DC.B    ' You must enter an even address!'
00002075                          2248  
00002075= 20                      2249  spc             DC.B    ' '
00002076= 01                      2250  spc_len         DC.B    spc_len-spc
00002077                          2251  ***
00002077                          2252  
00002077                          2253  
00002077                          2254  
00002077                          2255  ***list of OP codes
00002077                          2256  
00002077  =0000E0C0               2257  asrlweaInstruction  EQU %1110000011000000
00002077  =0000E000               2258  asrlregInstruction  EQU %1110000000000000
00002077  =0000E2C0               2259  lsrlweaInstruction  EQU %1110001011000000
00002077  =0000E008               2260  lsrlregInstruction  EQU %1110000000001000
00002077  =00005100               2261  subqInstruction  EQU %0101000100000000
00002077  =00009000               2262  subInstruction   EQU %1001000000000000
00002077  =0000D000               2263  addaInstruction  EQU %1101000000000000
00002077  =0000D000               2264  addInstruction   EQU %1101000000000000
00002077  =00004880               2265  movemInstruction EQU %0100100010000000
00002077  =00000600               2266  addiInstruction  EQU %0000011000000000
00002077  =00000000               2267  oriInstruction   EQU 0
00002077  =00000C00               2268  cmpiInstruction  EQU %0000110000000000
00002077  =00004E80               2269  jsrInstruction   EQU %0100111010000000
00002077  =00004E75               2270  rtsInstruction   EQU %0100111001110101
00002077  =00004E71               2271  NoOpInstruction  EQU %0100111001110001
00002077  =00000000               2272  moveInstruction  EQU 0
00002077  =00006000               2273  bccInstruction   EQU %0110000000000000
00002077  =00004400               2274  negInstruction   EQU %0100010000000000
00002077  =00000000               2275  dataInstruction  EQU 0
00002077                          2276  
00002077                          2277  ***
00002077                          2278  
00002077                          2279  ***list of OP masks
00002077                          2280  
00002077  =0000FEC0               2281  asrlweaMask  EQU %1111111011000000
00002077  =0000F018               2282  asrlregMask  EQU %1111000000011000
00002077  =0000FEC0               2283  lsrlweaMask  EQU %1111111011000000
00002077  =0000F018               2284  lsrlregMask  EQU %1111000000011000
00002077  =0000F100               2285  subqMask  EQU %1111000100000000
00002077  =0000F000               2286  subMask   EQU %1111000000000000
00002077  =0000F000               2287  addaMask  EQU %1111000000000000
00002077  =0000F000               2288  addMask   EQU %1111000000000000
00002077  =0000FB80               2289  movemMask EQU %1111101110000000
00002077  =0000FF00               2290  addiMask  EQU %1111111100000000
00002077  =0000FF00               2291  oriMask   EQU %1111111100000000
00002077  =0000FF00               2292  cmpiMask  EQU %1111111100000000
00002077  =0000FFC0               2293  jsrMask   EQU %1111111111000000
00002077  =0000FFFF               2294  rtsMask   EQU $FFFF
00002077  =0000FFFF               2295  NoOpMask  EQU $FFFF
00002077  =0000C000               2296  moveMask  EQU $C000
00002077  =0000F000               2297  bccMask   EQU $F000
00002077  =0000FF00               2298  negMask   EQU $FF00
00002077  =00000000               2299  dataMask  EQU 0
00002077                          2300  ***
00002077                          2301  
00002077                          2302  ***Bcc Codes***
00002077  =00000004               2303  CC EQU $04
00002077  =00000005               2304  CS EQU $05
00002077  =00000007               2305  EQ EQU $07
00002077  =0000000C               2306  GE EQU $0C
00002077  =0000000E               2307  GT EQU $0E
00002077  =00000002               2308  HI EQU $02
00002077  =0000000F               2309  LE EQU $0F
00002077  =00000003               2310  LS EQU $03
00002077  =0000000D               2311  LT EQU $0D
00002077  =0000000B               2312  MI EQU $0B
00002077  =00000006               2313  NE EQU $06
00002077  =0000000A               2314  PL EQU $0A
00002077  =00000008               2315  VC EQU $08
00002077  =00000009               2316  VS EQU $09
00002077  =00000000               2317  RA EQU $00 ;not really a Condition Code
00002077  =00000001               2318  SR EQU $01 ;not really a Condition Code
00002077                          2319  
00002077= 43 43 20 00             2320  CCm DC.B 'CC ',0
0000207B= 43 53 20 00             2321  CSm DC.B 'CS ',0
0000207F= 45 51 20 00             2322  EQm DC.B 'EQ ',0
00002083= 47 45 20 00             2323  GEm DC.B 'GE ',0
00002087= 47 54 20 00             2324  GTm DC.B 'GT ',0
0000208B= 48 49 20 00             2325  HIm DC.B 'HI ',0
0000208F= 4C 45 20 00             2326  LEm DC.B 'LE ',0
00002093= 4C 53 20 00             2327  LSm DC.B 'LS ',0
00002097= 4C 54 20 00             2328  LTm DC.B 'LT ',0
0000209B= 4D 49 20 00             2329  MIm DC.B 'MI ',0
0000209F= 4E 45 20 00             2330  NEm DC.B 'NE ',0
000020A3= 50 4C 20 00             2331  PLm DC.B 'PL ',0
000020A7= 56 43 20 00             2332  VCm DC.B 'VC ',0
000020AB= 56 53 20 00             2333  VSm DC.B 'VS ',0
000020AF= 52 41 20 00             2334  RAm DC.B 'RA ',0
000020B3= 53 52 20 00             2335  SRm DC.B 'SR ',0
000020B7                          2336  
000020B7= 01 04 05 07 0C 0E ...   2337  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
000020C8= 000020B3 00002077 ...   2338  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
00002108                          2339  ***
00002108                          2340  
00002108= 45 6E 74 65 72 20 ...   2341  startLocationPrompt DC.B    'Enter start location',0
0000211D= 45 6E 74 65 72 20 ...   2342  endLocationPrompt   DC.B    'Enter end location',0
00002130                          2343  
00002130= 0D 0A 00                2344  clearLine  DC.B $0D,$0A,0
00002133                          2345  
00002133= 41 53 4C 20 00          2346  aslMessage      DC.B 'ASL ',0
00002138= 41 53 52 20 00          2347  asrMessage      DC.B 'ASR ',0
0000213D= 4C 53 4C 20 00          2348  lslMessage      DC.B 'LSL ',0
00002142= 4C 53 52 20 00          2349  lsrMessage      DC.B 'LSR ',0
00002147= 53 55 42 51 20 00       2350  subqMessage     DC.B 'SUBQ ',0
0000214D= 53 55 42 20 00          2351  subMessage      DC.B 'SUB ',0 
00002152= 41 44 44 41 20 00       2352  addaMessage     DC.B 'ADDA ',0
00002158= 41 44 44 20 00          2353  addMessage      DC.B 'ADD ',0
0000215D= 4D 4F 56 45 4D 20 00    2354  movemMessage    DC.B 'MOVEM ',0
00002164= 41 44 44 49 20 00       2355  addiMessage     DC.B 'ADDI ',0
0000216A= 4F 52 49 20 00          2356  oriMessage      DC.B 'ORI ',0
0000216F= 43 4D 50 49 20 00       2357  cmpiMessage     DC.B 'CMPI ',0
00002175= 4A 53 52 20 00          2358  jsrMessage      DC.B 'JSR ',0
0000217A= 52 54 53 20 00          2359  rtsMessage      DC.B 'RTS ',0
0000217F= 4E 4F 50 20 00          2360  nopMessage      DC.B 'NOP ',0 
00002184= 4D 4F 56 45 20 00       2361  moveMessage     DC.B 'MOVE ',0
0000218A= 42 00                   2362  bccMessage      DC.B 'B',0
0000218C= 4E 45 47 20 00          2363  negMessage      DC.B 'NEG ',0
00002191= 44 41 54 41 20 00       2364  dataMessage     DC.B 'DATA ',0
00002197= 4D 4F 56 45 41 20 00    2365  moveaMessage    DC.B 'MOVEA ',0
0000219E                          2366  
0000219E= 28 78 78 78 29 2E ...   2367  xxxW            DC.B '(xxx).W: ',0
000021A8= 28 78 78 78 29 2E ...   2368  xxxL            DC.B '(xxx).L: ',0
000021B2= 23 28 64 61 74 61 ...   2369  iData           DC.B '#(data): ',0
000021BC                          2370  
000021BC= 41 00                   2371  letterA         DC.B 'A', 0
000021BE= 44 00                   2372  letterD         DC.B 'D', 0
000021C0                          2373  
000021C0= 2B 00                   2374  plus            DC.B '+', 0
000021C2= 2D 00                   2375  minus           DC.B '-', 0
000021C4= 28 00                   2376  lPrn            DC.B '(', 0
000021C6= 29 00                   2377  rPrn            DC.B ')', 0
000021C8                          2378  
000021C8                          2379  
000021C8= 00000000                2380  startLocation       DC.L    0
000021CC= 00000000                2381  endLocation         DC.L    0
000021D0                          2382  
000021D0                          2383  
000021D0                          2384     
000021D0                          2385      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 1608
ADDA                156A
ADDABODY            15B2
ADDAINSTRUCTION     D000
ADDAMASK            F000
ADDAMESSAGE         2152
ADDDEST             16CC
ADDDESTEA           15FC
ADDDESTEAMASKS      1602
ADDI                183A
ADDIBODY            1866
ADDIDONE            18A4
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         2164
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          2158
ADDRESS_DONE        1CCC
ADDRESS_EXIT        1CC6
ADDR_ABS_LONG       1F2E
ADDR_ABS_SHORT      1F1A
ADDR_IMMEDIATE_DATA  1F42
ADDR_REG_DIRECT     1E52
ADDR_REG_INDIRECT   1E6C
ADDR_REG_INDIRECT_DEC  1EDC
ADDR_REG_INDIRECT_INC  1E9E
ADDSOURCE           1684
ASLEA               11E6
ASLMESSAGE          2133
ASLREG              122C
ASREA               11D6
ASRLREG             11F6
ASRLREGINSTRUCTION  E000
ASRLREGMASK         F018
ASRLWEA             1196
ASRLWEACHECKDIRECTION  11C2
ASRLWEAINSTRUCTION  E0C0
ASRLWEAMASK         FEC0
ASRMESSAGE          2138
ASRREG              121C
BCC                 1B80
BCCBYTE             1BD2
BCCDONE             1BE8
BCCINSTRUCTION      6000
BCCLIST             20B7
BCCLONG             1BE0
BCCMASK             F000
BCCMESSAGE          218A
BCCWORD             1BD8
BEGIN               5001
BEGIN_ADDRESS       1C58
BYTE                1
CC                  4
CCM                 2077
CHECKCC             1B96
CHECKMOVEADEST      1B2C
CHECKMOVEDEST       1A7A
CHECKOPCODE         1050
CK_ADDR_DONE        1DDC
CK_ADDR_RANGE       1DB0
CK_ADDR_RANGE_ERROR  1DCC
CK_BOUNDRY          1CF4
CK_BOUNDRY_ERROR    1D16
CK_SIZE_ERROR       1D2A
CLEARLINE           2130
CMPI                193C
CMPIBODY            1964
CMPIDONE            19A2
CMPIEA              192E
CMPIEAMASKS         1935
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         216F
CONDITIONCODEMESSAGE  20C8
CS                  5
CSM                 207B
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         2191
DATA_REG_DIRECT     1E38
ELPROMPT            1F99
END                 FFFFFE
ENDLOCATION         21CC
ENDLOCATIONPROMPT   211D
END_ADDRESS         1C9C
ENTER_ADDR_EDIT_ALL  1CCE
ENTER_ADDR_EDIT_ALL_EXIT  1CF2
EQ                  7
EQM                 207F
EVEN_MSG            2055
FALSEPOSITIVE       1070
FARLABEL            FFE
FIN                 1C54
FOUNDCC             1BA8
GE                  C
GEM                 2083
GET_EFFECTIVE_ADDRESS  1DE0
GET_EFFECTIVE_ADDRESS_EXIT  1F52
GET_EFFECTIVE_ADDRESS_OTHER  1E1C
GT                  E
GTM                 2087
HANDLEBYTEDATA      1C28
HEX_RANGE_ERROR     1D98
HI                  2
HIM                 208B
IDATA               21B2
INSTLABELLIST       10E2
INSTMASKLIST        10BC
INSTOPLIST          1096
INSTOPLIST2         109E
INVALIDEA           1F52
INVALIDMSG          1FC8
INVCHARMSG          200D
JSR                 19BA
JSRBODY             19E2
JSRDONE             1A02
JSREA               19B2
JSREAMASKS          19B6
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          2175
LCASEHEX            1D7A
LE                  F
LEM                 208F
LETTERA             21BC
LETTERD             21BE
LONG                4
LPRN                21C4
LS                  3
LSLEA               1294
LSLMESSAGE          213D
LSLREG              12FE
LSM                 2093
LSREA               1284
LSRLCHECKI          1354
LSRLCHECKIR         133E
LSRLCHECKIRRETURN   1352
LSRLCHECKR          1388
LSRLEA              123C
LSRLEAMASKS         1242
LSRLREG             12C8
LSRLREGBODY         130E
LSRLREGINSTRUCTION  E008
LSRLREGMASK         F018
LSRLWEA             1248
LSRLWEABODY         12A4
LSRLWEACHECKDIRECTION  1270
LSRLWEAINSTRUCTION  E2C0
LSRLWEAMASK         FEC0
LSRMESSAGE          2142
LSRREG              12EE
LT                  D
LTM                 2097
MAIN_LOOP           1026
MATCH               1076
MI                  B
MIM                 209B
MINUS               21C2
MOVE                1A52
MOVEA               1B04
MOVEABODY           1B5A
MOVEADESTEA         1B00
MOVEADESTEAMASKS    1B02
MOVEAMESSAGE        2197
MOVEBODY            1AA8
MOVEDESTEA          1A44
MOVEDESTEAMASKS     1A4B
MOVEINSTRUCTION     0
MOVEM               1728
MOVEMASK            C000
MOVEMBODY           1792
MOVEMESSAGE         2184
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     171E
MOVEMMEMTOREGEAMASKS  1723
MOVEMMESSAGE        215D
MOVEMREGTOMEMEA     1714
MOVEMREGTOMEMEAMASKS  1719
MOVESOURCEEA        1A32
MOVESOURCEEAMASKS   1A3B
NE                  6
NEG                 17D4
NEGBODY             17FC
NEGDONE             182A
NEGEA               17C4
NEGEAMASKS          17CC
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          218C
NEM                 209F
NEXTHEX             1D40
NEXTHEXDONE         1D92
NEXTHEXRETURN       1DAE
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 1A12
NOPMESSAGE          217F
ORI                 18B4
ORIBODY             18E0
ORIDONE             191E
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          216A
PARSEHEXSTRING      1D3E
PL                  A
PLM                 20A3
PLUS                21C0
PRGORG              1000
PROCESS_OP_CODES    1DDE
PROCESS_OP_CODES_EXIT  1DDE
PROMPT_USER         1014
RA                  0
RAM                 20AF
RPRN                21C6
RTS                 1A22
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          217A
SLPROMPT            1F68
SNIPPET             112E
SNIPPETEND          1192
SPC                 2075
SPC_LEN             2076
SR                  1
SRM                 20B3
STACK               5000
START               1000
STARTLOCATION       21C8
STARTLOCATIONPROMPT  2108
SUB                 145A
SUBDEST             1522
SUBINSTRUCTION      9000
SUBMASK             F000
SUBMESSAGE          214D
SUBQ                13B2
SUBQBODY            13EA
SUBQEA              13A2
SUBQEAMASKS         13AA
SUBQINSTRUCTION     5100
SUBQMASK            F100
SUBQMESSAGE         2147
SUBSOURCE           14DA
SWITCHMODEANDREG    1F54
TOEIGHT             1456
UCASEHEX            1D62
UNKNOWNOPCODE       1C02
VALIDADDA           1588
VALIDADDDESTEA      1658
VALIDADDIMODES      183C
VALIDADDSOURCEEA    162E
VALIDASRL           1198
VALIDCMPIMODES      193E
VALIDJSRMODES       19BC
VALIDLSRL           124A
VALIDMEMTOREG       1764
VALIDMOVEADESTMODES  1B2E
VALIDMOVEASOURCEMODES  1B06
VALIDMOVEDESTMODES  1A7C
VALIDMOVESOURCEMODES  1A54
VALIDNEGMODES       17D6
VALIDORIMODES       18B6
VALIDREGTOMEM       173E
VALIDSUBDESTEA      14AA
VALIDSUBQ           13C4
VALIDSUBSOURCEEA    1480
VC                  8
VCM                 20A7
VS                  9
VSM                 20AB
WORD                2
XXXL                21A8
XXXW                219E
ZEROTOEIGHT         144C
ZEROTOEIGHTRETURN   1454

00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/8/2014 12:17:51 PM

00000000                             1  *##########################################################################
00000000                             2  * Title      : 
00000000                             3  * Written by : Andrew Watson
00000000                             4  *            : Elaine Keller
00000000                             5  *            : Robert Anderson
00000000                             6  * Date       : 11/14/2014
00000000                             7  * Description: 
00000000                             8  *##########################################################################
00000000                             9  
00000000                            10  ***Possible Bug***
00000000                            11  *can not tell data from an
00000000                            12  *unidentified instruction from an actual
00000000                            13  *instruction therefore causing errors.
00000000                            14  *may not actually be a bug because data
00000000                            15  *is data to the machine, and if you modify
00000000                            16  *the instructions in memory for a program
00000000                            17  *by moivng data, you can modify the instuctions
00000000                            18  *executed.
00000000                            19  
00000000                            20  
00000000                            21  ***************************************************************************
00000000                            22  *                   Variable/Data Definitions
00000000                            23  ***************************************************************************
00000000                            24  
00000000  =00005000                 25  stack   EQU   $00005000
00000000  =00005001                 26  begin   EQU   $00005001
00000000  =00FFFFFE                 27  end     EQU   $00FFFFFE
00000000  =00000001                 28  byte    EQU   1
00000000  =00000002                 29  word    EQU   2
00000000  =00000004                 30  long    EQU   4
00000000  =00001000                 31  prgorg  EQU   $1000
00000000                            32  
00000FFE                            33      ORG $00000FFE
00000FFE                            34  FarLabel:
00001000                            35      ORG    prgorg
00001000                            36  start:
00001000  4FF8 5000                 37          LEA stack, SP ;initialize stack
00001004                            38  
00001000                            39      ORG    prgorg
00001000                            40  
00001000                            41  ******************************************************************************
00001000                            42  *                   Begin processing active code
00001000                            43  ******************************************************************************
00001000                            44      
00001000                            45  start:
00001000                            46  
00001000  4FF8 5000                 47          LEA         stack, SP           ;Initialize stack
00001004                            48          
00001004                            49  *.............................................................................
00001004                            50  * Debug Mode - Comment out when done
00001004  267C 00001106             51          MOVE.L      #snippet,A3
0000100A  287C 00001142             52          MOVE.L      #snippetEnd,A4
00001010  6000 0014                 53          BRA         main_Loop
00001014                            54  * Debug Mode - Comment out when done
00001014                            55  *.............................................................................        
00001014                            56          
00001014                            57  prompt_user:
00001014                            58  
00001014  6100 092E                 59          BSR         begin_address
00001018  B67C FFFF                 60          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000101C  6700 0922                 61          BEQ         fin                 ;Yes, then exit
00001020                            62          
00001020  6000 0004                 63          BRA         main_Loop
00001024                            64          ;BSR         process_op_codes
00001024  60EE                      65          BRA         prompt_user
00001026                            66                  
00001026                            67  ******************************************************************************
00001026                            68  *                   Begin processing OP Codes
00001026                            69  ******************************************************************************
00001026                            70   
00001026                            71  main_Loop:
00001026                            72  
00001026  B9CB                      73          CMPA.L A3,A4 ;check end of prog
00001028  6700 0916                 74          BEQ fin
0000102C                            75          
0000102C  3213                      76          MOVE.W (A3),D1 ;copy word from other prog to analyze as instruction
0000102E                            77          
0000102E                            78          ;handle an odd memory access(instructions will never be misaligned)
0000102E  240B                      79          MOVE.L A3,D2 ; copy address to D2
00001030  0202 0001                 80          ANDI.B #%00000001,D2 ;mask everything except the least significant bit
00001034  0C02 0001                 81          CMPI.B #1,D2 ;compare the least sig bit of the address to one
00001038  6700 08DA                 82          BEQ handlebytedata ;the least sig bit will only be one if the insrtuction
0000103C                            83                             ;is odd(misaligned) and therefore not an instruction
0000103C                            84          
0000103C  7600                      85          MOVEQ.L #0,D3
0000103E                            86          
0000103E                            87          ***things to save A3,A4,D1(?)***
0000103E  48E7 0018                 88          MOVEM.L A3-A4,-(SP)
00001042  6100 000C                 89          BSR checkOPcode
00001046  4CDF 1800                 90          MOVEM.L (SP)+,A3-A4
0000104A  D7C7                      91          ADDA.L  D7,A3 ;look past data that was part of the instruction
0000104C                            92          
0000104C  548B                      93          ADDQ.L  #word,A3
0000104E  60D6                      94          BRA     main_Loop 
00001050                            95          
00001050                            96  checkOPcode:
00001050                            97  
00001050                            98  
00001050  7E00                      99          MOVEQ.L #0,D7
00001052                           100          
00001052  41F9 00001096            101          LEA     instOPList,A0 ;get instruction signitrue list in A0
00001058  D1C3                     102          ADDA.L  D3,A0 ;get correct sig         
0000105A                           103          
0000105A  43F9 000010B2            104          LEA     instMaskList,A1 ;get instruction mask in A1
00001060  D3C3                     105          ADDA.L  D3,A1  ;get correct mast
00001062                           106          
00001062  3401                     107          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001064                           108          
00001064  C451                     109          AND.W   (A1),D2 ;mask instruction
00001066                           110          
00001066                           111          
00001066                           112          
00001066                           113          
00001066  B450                     114          CMP.W   (A0),D2 ;compare to sig
00001068  6700 000C                115          BEQ     match ;if sig matches branch
0000106C  5483                     116          ADDQ.L  #word,D3 ;add to D3 to check for next instruction
0000106E  60E0                     117          BRA checkOPcode
00001070                           118          
00001070                           119  falsePositive:
00001070                           120          
00001070  103C 00FF                121          MOVE.B #-1,D0
00001074  4E75                     122          RTS
00001076                           123  
00001076                           124  match:
00001076                           125          
00001076  43F9 000010CE            126          LEA     instLabelList,A1 ;get instruction code label
0000107C  D3C3                     127          ADDA.L  D3,A1 ;get correct label
0000107E  D3C3                     128          ADDA.L  D3,A1
00001080  5483                     129          ADDQ.L  #word,D3 ;add to D3 incase false positive
00001082  2251                     130          MOVEA.L (A1),A1
00001084  48E7 1000                131          MOVEM.L D3,-(SP) ; save D3
00001088  4E91                     132          JSR     (A1)
0000108A  4CDF 0008                133          MOVEM.L (SP)+,D3 ;restore D3
0000108E  B03C 00FF                134          CMP.B   #-1,D0
00001092  67BC                     135          BEQ     checkOPcode
00001094  4E75                     136          RTS
00001096                           137          
00001096                           138  
00001096= 9000 D000 D000 4...      139  instOPList DC.W subInstruction,addaInstruction,addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruction         
000010B2= F000 F000 F000 F...      140  instMaskList DC.W subMask,addaMask,addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
000010CE= 00001146 00001256 ...    141  instLabelList DC.L SUB,ADDA,ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
00001106                           142  
00001106                           143  snippet:
00001106  4E71                     144           NOP
00001108  60FC                     145           BRA snippet
0000110A  6000 FEF2                146           BRA FarLabel
0000110E  67F6                     147           BEQ snippet
00001110  6E00 03AE                148           BGT NEG
00001114  61F0                     149           BSR snippet
00001116  4441                     150           NEG D1
00001118  3239 00008500            151           MOVE.W $8500,D1
0000111E  0645 001E                152           ADDI.W #30,D5
00001122  4E75                     153           RTS
00001124  4EB8 0054                154           JSR $54
00001128  0C41 0003                155           CMPI #3,D1
0000112C  0041 0003                156           ORI  #3,D1
00001130  48E7 0018                157           MOVEM.L A3-A4,-(SP)
00001134  D401                     158           ADD.B D1,D2
00001136  0603 000A                159           ADD.B #10,D3
0000113A  D7FC 00000463            160           ADDA.L #1123,A3
00001140  9A43                     161           SUB.W D3,D5
00001142                           162           
00001142                           163  
00001142                           164           
00001142                           165  snippetEnd:
00001142  FFFF FFFF                166           SIMHALT
00001146                           167      
00001146                           168  SUB:
00001146                           169          
00001146                           170  
00001146                           171          
00001146  7000                     172          MOVEQ.L #0, D0 ;clear D0
00001148                           173          
00001148                           174          ;Figure out if EA is source or destination
00001148  3401                     175          MOVE.W D1,D2 ;copy inst to D2
0000114A  EC4A                     176          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
0000114C  0202 0007                177          ANDI.B #%00000111,D2 ;mask out rest of byte
00001150  0C02 0002                178          CMPI.B #2,D2 ;compare to 2
00001154  6F00 0016                179          BLE validSubSourceEA ;2 or less is EA is source
00001158                           180          
00001158  0C02 0007                181          CMPI.B #%111,D2 ;compare to 7
0000115C  6700 FF12                182          BEQ falsePositive ;thats not valid
00001160  0C02 0003                183          CMPI.B #%11,D2 ;compare to 3
00001164  6700 FF0A                184          BEQ falsePositive ;also not valid
00001168  6000 002C                185          BRA validSubDestEA ;all thats left is valid EA as Dest 
0000116C                           186          
0000116C                           187  validSubSourceEA:
0000116C                           188          
0000116C  43F9 00001727            189          LEA moveSourceEAmasks,A1 ;load the list of masks
00001172  D3C0                     190          ADDA.L D0,A1 ;displace to a specific mask
00001174  1A11                     191          MOVE.B (A1),D5 ;move the mask to D5
00001176                           192          
00001176  0C05 0000                193          CMPI.B #0,D5 ;check if the mask is 0
0000117A  6700 FEF4                194          BEQ falsePositive ;branch if it is
0000117E                           195          
0000117E  1401                     196          MOVE.B D1,D2 ;copy instruction to D2
00001180  C405                     197          AND.B D5,D2  ;mask D2
00001182                           198          
00001182  43F9 0000171E            199          LEA moveSourceEA,A1 ;load the list of valid modes
00001188  D3C0                     200          ADDA.L D0,A1 ;displace to a specific mode
0000118A  1811                     201          MOVE.B (A1),D4 ;move mode to D4
0000118C  B404                     202          CMP.B D4,D2 ;compare mode to masked value
0000118E  6700 0036                203          BEQ  subSource ;if its match, its a valid mode and we can procede
00001192                           204          
00001192  5280                     205          ADDQ.L #1,D0 ;add one to displacement
00001194  60D6                     206          BRA validSubSourceEA ;check for next mode
00001196                           207          
00001196                           208          
00001196                           209  validSubDestEA:
00001196                           210          
00001196  43F9 000012EE            211          LEA addDestEAmasks,A1 ;load the list of masks
0000119C  D3C0                     212          ADDA.L D0,A1 ;displace to a specific mask
0000119E  1A11                     213          MOVE.B (A1),D5 ;move the mask to D5
000011A0                           214          
000011A0  0C05 0000                215          CMPI.B #0,D5 ;check if the mask is 0
000011A4  6700 FECA                216          BEQ falsePositive ;branch if it is
000011A8                           217          
000011A8  3401                     218          MOVE.W D1,D2 ;copy instruction to D2
000011AA  EC4A                     219          LSR.W #6,D2  ;move mode
000011AC  6100 0A92                220          BSR switchModeAndReg ;switch register and mode
000011B0  C405                     221          AND.B D5,D2  ;mask D2
000011B2                           222          
000011B2  43F9 000012E8            223          LEA addDestEA,A1 ;load the list of valid modes
000011B8  D3C0                     224          ADDA.L D0,A1 ;displace to a specific mode
000011BA  1811                     225          MOVE.B (A1),D4 ;move mode to D4
000011BC  B404                     226          CMP.B D4,D2 ;compare mode to masked value
000011BE  6700 004E                227          BEQ subDest ;if its match, its a valid mode and we can procede
000011C2                           228          
000011C2  5280                     229          ADDQ.L #1,D0 ;add one to displacement
000011C4  60D0                     230          BRA validSubDestEA ;check for next mode
000011C6                           231          
000011C6                           232  subSource
000011C6                           233  
000011C6  43F9 00001E1F            234          LEA     subMessage,A1  ;move string for MOVE
000011CC  103C 000E                235          MOVE.B  #14,D0        ;set for task to display null terminated 
000011D0                           236                                ;string with CR, LF
000011D0  4E4F                     237          TRAP    #15
000011D2                           238          
000011D2                           239          ;do EA
000011D2                           240          
000011D2  3401                     241          MOVE.W  D1,D2 ;check mode
000011D4  C43C 003F                242          AND.B   #%00111111,D2
000011D8  1A02                     243          MOVE.B  D2,D5
000011DA  48E7 4000                244          MOVEM.L D1,-(SP)
000011DE  6100 08EC                245          BSR     Get_Effective_Address
000011E2  4CDF 0002                246          MOVEM.L (SP)+,D1
000011E6                           247          
000011E6                           248          ;print separator
000011E6                           249          
000011E6                           250          ;Then do Dn
000011E6                           251          
000011E6  3401                     252          MOVE.W  D1,D2
000011E8  E04A                     253          LSR.W   #8,D2 ;move reg into first byte
000011EA  E20A                     254          LSR.B   #1,D2 ;line it up to least sig bit
000011EC  C43C 0007                255          AND.B   #%00000111,D2 ;force mode to Dn
000011F0  1A02                     256          MOVE.B  D2,D5
000011F2  48E7 4000                257          MOVEM.L D1,-(SP)
000011F6  6100 08D4                258          BSR     Get_Effective_Address
000011FA  4CDF 0002                259          MOVEM.L (SP)+,D1
000011FE                           260          
000011FE  43F9 00001E1C            261          LEA     clearLine,A1  ;move string for a CR and LF
00001204  103C 000E                262          MOVE.B  #14,D0        ;set for task to display null terminated 
00001208                           263                                ;string without CR, LF
00001208  4E4F                     264          TRAP    #15
0000120A                           265  
0000120A  7000                     266          MOVEQ.L #0,D0
0000120C  4E75                     267          RTS
0000120E                           268  
0000120E                           269  subDest
0000120E                           270  
0000120E  43F9 00001E1F            271          LEA     subMessage,A1  ;move string for MOVE
00001214  103C 000E                272          MOVE.B  #14,D0        ;set for task to display null terminated 
00001218                           273                                ;string with CR, LF
00001218  4E4F                     274          TRAP    #15
0000121A                           275          
0000121A                           276          ;Do Dn
0000121A                           277          
0000121A  3401                     278          MOVE.W  D1,D2
0000121C  E04A                     279          LSR.W   #8,D2 ;move reg into first byte
0000121E  E20A                     280          LSR.B   #1,D2 ;line it up to least sig bit
00001220  C43C 0007                281          AND.B   #%00000111,D2 ;force mode to Dn
00001224  1A02                     282          MOVE.B  D2,D5
00001226  48E7 4000                283          MOVEM.L D1,-(SP)
0000122A  6100 08A0                284          BSR     Get_Effective_Address
0000122E  4CDF 0002                285          MOVEM.L (SP)+,D1
00001232                           286          
00001232                           287          
00001232                           288          ;print separator
00001232                           289          
00001232                           290          ;Then do EA
00001232                           291          
00001232  3401                     292          MOVE.W  D1,D2 ;check mode
00001234  C43C 003F                293          AND.B   #%00111111,D2
00001238  1A02                     294          MOVE.B  D2,D5
0000123A  48E7 4000                295          MOVEM.L D1,-(SP)
0000123E  6100 088C                296          BSR     Get_Effective_Address
00001242  4CDF 0002                297          MOVEM.L (SP)+,D1
00001246                           298          
00001246                           299          
00001246  43F9 00001E1C            300          LEA     clearLine,A1  ;move string for a CR and LF
0000124C  103C 000E                301          MOVE.B  #14,D0        ;set for task to display null terminated 
00001250                           302                                ;string without CR, LF
00001250  4E4F                     303          TRAP    #15
00001252                           304  
00001252  7000                     305          MOVEQ.L #0,D0
00001254  4E75                     306          RTS
00001256                           307  
00001256                           308  
00001256                           309  ADDA:
00001256                           310          
00001256                           311  
00001256                           312          
00001256  7000                     313          MOVEQ.L #0, D0 ;clear D0
00001258                           314          
00001258                           315          ;check opmode field
00001258  3401                     316          MOVE.W D1,D2 ;copy inst to D2
0000125A  EC4A                     317          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
0000125C  0202 0007                318          ANDI.B #%00000111,D2 ;mask out rest of byte
00001260  0C02 0007                319          CMPI.B #%111,D2 ;compare to 7
00001264  6700 000E                320          BEQ validAdda ;thats valid
00001268  0C02 0003                321          CMPI.B #%11,D2 ;compare to 3
0000126C  6700 0006                322          BEQ validAdda ;also valid
00001270  6000 FDFE                323          BRA falsePositive ;all thats left is invalid 
00001274                           324          
00001274                           325  validAdda:
00001274                           326          
00001274  43F9 00001727            327          LEA moveSourceEAmasks,A1 ;load the list of masks
0000127A  D3C0                     328          ADDA.L D0,A1 ;displace to a specific mask
0000127C  1A11                     329          MOVE.B (A1),D5 ;move the mask to D5
0000127E                           330          
0000127E  0C05 0000                331          CMPI.B #0,D5 ;check if the mask is 0
00001282  6700 FDEC                332          BEQ falsePositive ;branch if it is
00001286                           333          
00001286  1401                     334          MOVE.B D1,D2 ;copy instruction to D2
00001288  C405                     335          AND.B D5,D2  ;mask D2
0000128A                           336          
0000128A  43F9 0000171E            337          LEA moveSourceEA,A1 ;load the list of valid modes
00001290  D3C0                     338          ADDA.L D0,A1 ;displace to a specific mode
00001292  1811                     339          MOVE.B (A1),D4 ;move mode to D4
00001294  B404                     340          CMP.B D4,D2 ;compare mode to masked value
00001296  6700 0006                341          BEQ  addaBody ;if its match, its a valid mode and we can procede
0000129A                           342          
0000129A  5280                     343          ADDQ.L #1,D0 ;add one to displacement
0000129C  60D6                     344          BRA validAdda ;check for next mode
0000129E                           345          
0000129E                           346          
0000129E                           347  addaBody
0000129E                           348  
0000129E  43F9 00001E24            349          LEA     addaMessage,A1  ;move string for MOVE
000012A4  103C 000E                350          MOVE.B  #14,D0        ;set for task to display null terminated 
000012A8                           351                                ;string with CR, LF
000012A8  4E4F                     352          TRAP    #15
000012AA                           353          
000012AA                           354          ;do EA
000012AA                           355          
000012AA  3401                     356          MOVE.W  D1,D2 ;check mode
000012AC  C43C 003F                357          AND.B   #%00111111,D2
000012B0  1A02                     358          MOVE.B  D2,D5
000012B2  48E7 4000                359          MOVEM.L D1,-(SP)
000012B6  6100 0814                360          BSR     Get_Effective_Address
000012BA  4CDF 0002                361          MOVEM.L (SP)+,D1
000012BE                           362          
000012BE                           363          ;print separator
000012BE                           364          
000012BE                           365          ;Then do Dn
000012BE                           366          
000012BE  3401                     367          MOVE.W  D1,D2
000012C0  E04A                     368          LSR.W   #8,D2 ;move reg into first byte
000012C2  E20A                     369          LSR.B   #1,D2 ;line it up to least sig bit
000012C4  C43C 0007                370          AND.B   #%00000111,D2 ;force mode to An
000012C8  5002                     371          ADDI.B  #%00001000,D2 
000012CA  1A02                     372          MOVE.B  D2,D5
000012CC  48E7 4000                373          MOVEM.L D1,-(SP)
000012D0  6100 07FA                374          BSR     Get_Effective_Address
000012D4  4CDF 0002                375          MOVEM.L (SP)+,D1
000012D8                           376          
000012D8  43F9 00001E1C            377          LEA     clearLine,A1  ;move string for a CR and LF
000012DE  103C 000E                378          MOVE.B  #14,D0        ;set for task to display null terminated 
000012E2                           379                                ;string without CR, LF
000012E2  4E4F                     380          TRAP    #15
000012E4                           381  
000012E4  7000                     382          MOVEQ.L #0,D0
000012E6  4E75                     383          RTS
000012E8                           384  
000012E8                           385  
000012E8                           386      
000012E8= 10 18 20 38 39 00        387  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
000012EE= 38 38 38 3F 3F 00        388  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
000012F4                           389  
000012F4                           390  ADD:
000012F4                           391          
000012F4                           392  
000012F4                           393          
000012F4  7000                     394          MOVEQ.L #0, D0 ;clear D0
000012F6                           395          
000012F6                           396          ;Figure out if EA is source or destination
000012F6  3401                     397          MOVE.W D1,D2 ;copy inst to D2
000012F8  EC4A                     398          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
000012FA  0202 0007                399          ANDI.B #%00000111,D2 ;mask out rest of byte
000012FE  0C02 0002                400          CMPI.B #2,D2 ;compare to 2
00001302  6F00 0016                401          BLE validAddSourceEA ;2 or less is EA is source
00001306                           402          
00001306  0C02 0007                403          CMPI.B #%111,D2 ;compare to 7
0000130A  6700 FD64                404          BEQ falsePositive ;thats not valid
0000130E  0C02 0003                405          CMPI.B #%11,D2 ;compare to 3
00001312  6700 FD5C                406          BEQ falsePositive ;also not valid
00001316  6000 002C                407          BRA validAddDestEA ;all thats left is valid EA as Dest 
0000131A                           408          
0000131A                           409  validAddSourceEA:
0000131A                           410          
0000131A  43F9 00001727            411          LEA moveSourceEAmasks,A1 ;load the list of masks
00001320  D3C0                     412          ADDA.L D0,A1 ;displace to a specific mask
00001322  1A11                     413          MOVE.B (A1),D5 ;move the mask to D5
00001324                           414          
00001324  0C05 0000                415          CMPI.B #0,D5 ;check if the mask is 0
00001328  6700 FD46                416          BEQ falsePositive ;branch if it is
0000132C                           417          
0000132C  1401                     418          MOVE.B D1,D2 ;copy instruction to D2
0000132E  C405                     419          AND.B D5,D2  ;mask D2
00001330                           420          
00001330  43F9 0000171E            421          LEA moveSourceEA,A1 ;load the list of valid modes
00001336  D3C0                     422          ADDA.L D0,A1 ;displace to a specific mode
00001338  1811                     423          MOVE.B (A1),D4 ;move mode to D4
0000133A  B404                     424          CMP.B D4,D2 ;compare mode to masked value
0000133C  6700 0032                425          BEQ  addSource ;if its match, its a valid mode and we can procede
00001340                           426          
00001340  5280                     427          ADDQ.L #1,D0 ;add one to displacement
00001342  60D6                     428          BRA validAddSourceEA ;check for next mode
00001344                           429          
00001344                           430          
00001344                           431  validAddDestEA:
00001344                           432          
00001344  43F8 12EE                433          LEA addDestEAmasks,A1 ;load the list of masks
00001348  D3C0                     434          ADDA.L D0,A1 ;displace to a specific mask
0000134A  1A11                     435          MOVE.B (A1),D5 ;move the mask to D5
0000134C                           436          
0000134C  0C05 0000                437          CMPI.B #0,D5 ;check if the mask is 0
00001350  6700 FD1E                438          BEQ falsePositive ;branch if it is
00001354                           439          
00001354  3401                     440          MOVE.W D1,D2 ;copy instruction to D2
00001356  EC4A                     441          LSR.W #6,D2  ;move mode
00001358  6100 08E6                442          BSR switchModeAndReg ;switch register and mode
0000135C  C405                     443          AND.B D5,D2  ;mask D2
0000135E                           444          
0000135E  43F8 12E8                445          LEA addDestEA,A1 ;load the list of valid modes
00001362  D3C0                     446          ADDA.L D0,A1 ;displace to a specific mode
00001364  1811                     447          MOVE.B (A1),D4 ;move mode to D4
00001366  B404                     448          CMP.B D4,D2 ;compare mode to masked value
00001368  6700 004E                449          BEQ addDest ;if its match, its a valid mode and we can procede
0000136C                           450          
0000136C  5280                     451          ADDQ.L #1,D0 ;add one to displacement
0000136E  60D4                     452          BRA validAddDestEA ;check for next mode
00001370                           453          
00001370                           454  addSource
00001370                           455  
00001370  43F9 00001E2A            456          LEA     addMessage,A1  ;move string for MOVE
00001376  103C 000E                457          MOVE.B  #14,D0        ;set for task to display null terminated 
0000137A                           458                                ;string with CR, LF
0000137A  4E4F                     459          TRAP    #15
0000137C                           460          
0000137C                           461          ;do EA
0000137C                           462          
0000137C  3401                     463          MOVE.W  D1,D2 ;check mode
0000137E  C43C 003F                464          AND.B   #%00111111,D2
00001382  1A02                     465          MOVE.B  D2,D5
00001384  48E7 4000                466          MOVEM.L D1,-(SP)
00001388  6100 0742                467          BSR     Get_Effective_Address
0000138C  4CDF 0002                468          MOVEM.L (SP)+,D1
00001390                           469          
00001390                           470          ;print separator
00001390                           471          
00001390                           472          ;Then do Dn
00001390                           473          
00001390  3401                     474          MOVE.W  D1,D2
00001392  E04A                     475          LSR.W   #8,D2 ;move reg into first byte
00001394  E20A                     476          LSR.B   #1,D2 ;line it up to least sig bit
00001396  C43C 0007                477          AND.B   #%00000111,D2 ;force mode to Dn
0000139A  1A02                     478          MOVE.B  D2,D5
0000139C  48E7 4000                479          MOVEM.L D1,-(SP)
000013A0  6100 072A                480          BSR     Get_Effective_Address
000013A4  4CDF 0002                481          MOVEM.L (SP)+,D1
000013A8                           482          
000013A8  43F9 00001E1C            483          LEA     clearLine,A1  ;move string for a CR and LF
000013AE  103C 000E                484          MOVE.B  #14,D0        ;set for task to display null terminated 
000013B2                           485                                ;string without CR, LF
000013B2  4E4F                     486          TRAP    #15
000013B4                           487  
000013B4  7000                     488          MOVEQ.L #0,D0
000013B6  4E75                     489          RTS
000013B8                           490  
000013B8                           491  addDest
000013B8                           492  
000013B8  43F9 00001E2A            493          LEA     addMessage,A1  ;move string for MOVE
000013BE  103C 000E                494          MOVE.B  #14,D0        ;set for task to display null terminated 
000013C2                           495                                ;string with CR, LF
000013C2  4E4F                     496          TRAP    #15
000013C4                           497          
000013C4                           498          ;Do Dn
000013C4                           499          
000013C4  3401                     500          MOVE.W  D1,D2
000013C6  E04A                     501          LSR.W   #8,D2 ;move reg into first byte
000013C8  E20A                     502          LSR.B   #1,D2 ;line it up to least sig bit
000013CA  C43C 0007                503          AND.B   #%00000111,D2 ;force mode to Dn
000013CE  1A02                     504          MOVE.B  D2,D5
000013D0  48E7 4000                505          MOVEM.L D1,-(SP)
000013D4  6100 06F6                506          BSR     Get_Effective_Address
000013D8  4CDF 0002                507          MOVEM.L (SP)+,D1
000013DC                           508          
000013DC                           509          
000013DC                           510          ;print separator
000013DC                           511          
000013DC                           512          ;Then do EA
000013DC                           513          
000013DC  3401                     514          MOVE.W  D1,D2 ;check mode
000013DE  C43C 003F                515          AND.B   #%00111111,D2
000013E2  1A02                     516          MOVE.B  D2,D5
000013E4  48E7 4000                517          MOVEM.L D1,-(SP)
000013E8  6100 06E2                518          BSR     Get_Effective_Address
000013EC  4CDF 0002                519          MOVEM.L (SP)+,D1
000013F0                           520          
000013F0                           521          
000013F0  43F9 00001E1C            522          LEA     clearLine,A1  ;move string for a CR and LF
000013F6  103C 000E                523          MOVE.B  #14,D0        ;set for task to display null terminated 
000013FA                           524                                ;string without CR, LF
000013FA  4E4F                     525          TRAP    #15
000013FC                           526  
000013FC  7000                     527          MOVEQ.L #0,D0
000013FE  4E75                     528          RTS
00001400                           529  
00001400                           530  
00001400= 10 20 38 39 00           531  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
00001405= 38 38 3F 3F 00           532  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
0000140A                           533  
0000140A= 10 18 38 39 00           534  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
0000140F= 38 38 3F 3F 00           535  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
00001414                           536  
00001414                           537  MOVEM:
00001414                           538          
00001414                           539  
00001414                           540          
00001414  7000                     541          MOVEQ.L #0, D0 ;clear D0
00001416                           542          
00001416                           543          ;Figure out which direction we are going
00001416  3401                     544          MOVE.W D1,D2 ;copy inst to D2
00001418  E64A                     545          LSR.W #3,D2 ;shift direction bit into most sig bit of first byte
0000141A  0202 0080                546          ANDI.B #%10000000,D2 ;mask out everything but direction bit in first byte
0000141E  0C02 0000                547          CMPI.B #0,D2 ;compare bit to zero
00001422  6700 0006                548          BEQ validRegToMem ;if zero, reg to mem
00001426  6000 0028                549          BRA validMemToReg ;else, its mem to reg
0000142A                           550          
0000142A                           551  validRegToMem:
0000142A                           552          
0000142A  43F8 1405                553          LEA movemRegToMemEAmasks,A1 ;load the list of masks
0000142E  D3C0                     554          ADDA.L D0,A1 ;displace to a specific mask
00001430  1A11                     555          MOVE.B (A1),D5 ;move the mask to D5
00001432                           556          
00001432  0C05 0000                557          CMPI.B #0,D5 ;check if the mask is 0
00001436  6700 FC38                558          BEQ falsePositive ;branch if it is
0000143A                           559          
0000143A  1401                     560          MOVE.B D1,D2 ;copy instruction to D2
0000143C  C405                     561          AND.B D5,D2  ;mask D2
0000143E                           562          
0000143E  43F8 1400                563          LEA movemRegToMemEA,A1 ;load the list of valid modes
00001442  D3C0                     564          ADDA.L D0,A1 ;displace to a specific mode
00001444  1811                     565          MOVE.B (A1),D4 ;move mode to D4
00001446  B404                     566          CMP.B D4,D2 ;compare mode to masked value
00001448  6700 0034                567          BEQ  movemBody ;if its match, its a valid mode and we can procede
0000144C                           568          
0000144C  5280                     569          ADDQ.L #1,D0 ;add one to displacement
0000144E  60DA                     570          BRA validRegToMem ;check for next mode
00001450                           571          
00001450                           572          
00001450                           573  validMemToReg:
00001450                           574          
00001450  43F8 140F                575          LEA movemMemToRegEAmasks,A1 ;load the list of masks
00001454  D3C0                     576          ADDA.L D0,A1 ;displace to a specific mask
00001456  1A11                     577          MOVE.B (A1),D5 ;move the mask to D5
00001458                           578          
00001458  0C05 0000                579          CMPI.B #0,D5 ;check if the mask is 0
0000145C  6700 FC12                580          BEQ falsePositive ;branch if it is
00001460                           581          
00001460  3401                     582          MOVE.W D1,D2 ;copy instruction to D2
00001462  EC4A                     583          LSR.W #6,D2  ;move mode
00001464  6100 07DA                584          BSR switchModeAndReg ;switch register and mode
00001468  C405                     585          AND.B D5,D2  ;mask D2
0000146A                           586          
0000146A  43F8 140A                587          LEA movemMemToRegEA,A1 ;load the list of valid modes
0000146E  D3C0                     588          ADDA.L D0,A1 ;displace to a specific mode
00001470  1811                     589          MOVE.B (A1),D4 ;move mode to D4
00001472  B404                     590          CMP.B D4,D2 ;compare mode to masked value
00001474  6700 0008                591          BEQ movemBody ;if its match, its a valid mode and we can procede
00001478                           592          
00001478  5280                     593          ADDQ.L #1,D0 ;add one to displacement
0000147A  6000 02EC                594          BRA validMoveDestModes ;check for next mode
0000147E                           595          
0000147E                           596  movemBody
0000147E                           597  
0000147E  43F9 00001E2F            598          LEA     movemMessage,A1  ;move string for MOVE
00001484  103C 000E                599          MOVE.B  #14,D0        ;set for task to display null terminated 
00001488                           600                                ;string with CR, LF
00001488  4E4F                     601          TRAP    #15
0000148A                           602          
0000148A                           603          ;show list
0000148A                           604          
0000148A  5487                     605          ADDQ.L #word,D7 ;read past the register list mask(word) following
0000148C                           606                          ;the instruction
0000148C                           607          
0000148C                           608          ;print separator
0000148C                           609          
0000148C  3401                     610          MOVE.W  D1,D2 ;check mode
0000148E  C43C 003F                611          AND.B   #%00111111,D2
00001492  1A02                     612          MOVE.B  D2,D5
00001494  48E7 4000                613          MOVEM.L D1,-(SP)
00001498  6100 0632                614          BSR     Get_Effective_Address
0000149C  4CDF 0002                615          MOVEM.L (SP)+,D1
000014A0                           616          
000014A0                           617          
000014A0  43F9 00001E1C            618          LEA     clearLine,A1  ;move string for a CR and LF
000014A6  103C 000E                619          MOVE.B  #14,D0        ;set for task to display null terminated 
000014AA                           620                                ;string without CR, LF
000014AA  4E4F                     621          TRAP    #15
000014AC                           622  
000014AC  7000                     623          MOVEQ.L #0,D0
000014AE  4E75                     624          RTS
000014B0                           625  
000014B0                           626  
000014B0                           627      
000014B0= 00 10 18 20 28 38 ...    628  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
000014B8= 38 38 38 38 38 3F ...    629  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
000014C0                           630     
000014C0                           631  NEG:            
000014C0                           632       
000014C0  7000                     633          MOVEQ.L #0, D0 ;clear D0
000014C2                           634          
000014C2                           635  validNegModes:
000014C2                           636          
000014C2  43F8 14B8                637          LEA NegEAmasks,A1 ;load the list of masks
000014C6  D3C0                     638          ADDA.L D0,A1 ;displace to a specific mask
000014C8  1A11                     639          MOVE.B (A1),D5 ;move the mask to D5
000014CA                           640          
000014CA  0C05 0000                641          CMPI.B #0,D5 ;check if the mask is 0
000014CE  6700 FBA0                642          BEQ falsePositive ;branch if it is
000014D2                           643          
000014D2  1401                     644          MOVE.B D1,D2 ;copy instruction to D2
000014D4  C405                     645          AND.B D5,D2  ;mask D2
000014D6  43F8 14B0                646          LEA NegEA,A1 ;load the list of valid modes
000014DA  D3C0                     647          ADDA.L D0,A1 ;displace to a specific mode
000014DC  1811                     648          MOVE.B (A1),D4 ;move mode to D4
000014DE  B404                     649          CMP.B D4,D2 ;compare mode to masked value
000014E0  6700 0006                650          BEQ NegBody ;if its match, its a valid mode and we can procede
000014E4                           651          
000014E4  5280                     652          ADDQ.L #1,D0 ;add one to displacement
000014E6  60DA                     653          BRA validNegModes ;check for next mode
000014E8                           654          
000014E8                           655  NegBody:
000014E8                           656  
000014E8                           657  
000014E8  3401                     658          MOVE.W  D1,D2 ;copy inst to D2
000014EA  C47C 0600                659          AND.W  #%0011000000000,D2 ;mask word for size
000014EE  0C42 0000                660          CMPI.W #0,D2 ;0 is the only non valid size
000014F2  6700 FB7C                661          BEQ falsePositive ; zero is not valid
000014F6                           662  
000014F6  43F9 00001E5E            663          LEA     negMessage,A1  ;move string for NEG info
000014FC  103C 000E                664          MOVE.B  #14,D0        ;set for task to display null terminated 
00001500                           665                                ;string without CR, LF
00001500  4E4F                     666          TRAP    #15
00001502                           667          
00001502  3401                     668          MOVE.W D1,D2
00001504  C47C 003F                669          AND #%000000000111111,D2
00001508  1A02                     670          MOVE.B D2,D5
0000150A                           671          
0000150A  48E7 4000                672          MOVEM.L D1,-(SP)
0000150E  6100 05BC                673          BSR     Get_Effective_Address
00001512  4CDF 0002                674          MOVEM.L (SP)+,D1
00001516                           675          
00001516                           676                
00001516                           677          
00001516                           678  NEGdone:
00001516                           679  
00001516  43F9 00001E1C            680          LEA     clearLine,A1  ;move string for a CR and LF
0000151C  103C 000E                681          MOVE.B  #14,D0        ;set for task to display null terminated 
00001520                           682                                ;string without CR, LF
00001520  4E4F                     683          TRAP    #15
00001522  7000                     684          MOVEQ.L #0,D0
00001524  4E75                     685          RTS
00001526                           686          
00001526                           687   ADDI:            
00001526                           688       
00001526  7000                     689          MOVEQ.L #0, D0 ;clear D0
00001528                           690          
00001528                           691  validAddiModes:
00001528                           692          
00001528                           693          
00001528  43F9 00001621            694          LEA cmpiEAmasks,A1 ;load the list of masks
0000152E  D3C0                     695          ADDA.L D0,A1 ;displace to a specific mask
00001530  1A11                     696          MOVE.B (A1),D5 ;move the mask to D5
00001532                           697          
00001532  0C05 0000                698          CMPI.B #0,D5 ;check if the mask is 0
00001536  6700 FB38                699          BEQ falsePositive ;branch if it is
0000153A                           700          
0000153A  1401                     701          MOVE.B D1,D2 ;copy instruction to D2
0000153C  C405                     702          AND.B D5,D2  ;mask D2
0000153E  43F9 0000161A            703          LEA cmpiEA,A1 ;load the list of valid modes
00001544  D3C0                     704          ADDA.L D0,A1 ;displace to a specific mode
00001546  1811                     705          MOVE.B (A1),D4 ;move mode to D4
00001548  B404                     706          CMP.B D4,D2 ;compare mode to masked value
0000154A  6700 0006                707          BEQ addiBody ;if its match, its a valid mode and we can procede
0000154E                           708          
0000154E  5280                     709          ADDQ.L #1,D0 ;add one to displacement
00001550  60D6                     710          BRA validAddiModes ;check for next mode
00001552                           711          
00001552                           712  addiBody:
00001552                           713  
00001552                           714  
00001552  3401                     715          MOVE.W  D1,D2 ;copy inst to D2
00001554  C47C 00C0                716          AND.W  #%0000000011000000,D2 ;mask word for size
00001558  0C42 00C0                717          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
0000155C  6700 FB12                718          BEQ falsePositive
00001560                           719  
00001560  43F9 00001E36            720          LEA     addiMessage,A1  ;move string for NEG info
00001566  103C 000E                721          MOVE.B  #14,D0        ;set for task to display null terminated 
0000156A                           722                                ;string without CR, LF
0000156A  4E4F                     723          TRAP    #15
0000156C                           724          
0000156C                           725          ;go to Effective_Address for immediate data
0000156C  143C 003C                726          MOVE.B #%00111100,D2
00001570  48E7 4000                727          MOVEM.L D1,-(SP)
00001574  6100 0556                728          BSR     Get_Effective_Address
00001578  4CDF 0002                729          MOVEM.L (SP)+,D1
0000157C                           730          
0000157C  3401                     731          MOVE.W D1,D2 ;copy inst to D2
0000157E  C47C 003F                732          AND #%000000000111111,D2 ;and out everything but modes and regs
00001582  1A02                     733          MOVE.B D2,D5 ; copy to D5 for following BSR
00001584                           734          
00001584  48E7 4000                735          MOVEM.L D1,-(SP)
00001588  6100 0542                736          BSR     Get_Effective_Address
0000158C  4CDF 0002                737          MOVEM.L (SP)+,D1
00001590                           738          
00001590                           739                
00001590                           740          
00001590                           741  addidone:
00001590                           742  
00001590  43F9 00001E1C            743          LEA     clearLine,A1  ;move string for a CR and LF
00001596  103C 000E                744          MOVE.B  #14,D0        ;set for task to display null terminated 
0000159A                           745                                ;string without CR, LF
0000159A  4E4F                     746          TRAP    #15
0000159C  7000                     747          MOVEQ.L #0,D0
0000159E  4E75                     748          RTS
000015A0                           749    
000015A0                           750  ORI:            
000015A0                           751       
000015A0  7000                     752          MOVEQ.L #0, D0 ;clear D0
000015A2                           753          
000015A2                           754  validOriModes:
000015A2                           755          
000015A2                           756          
000015A2  43F9 00001621            757          LEA cmpiEAmasks,A1 ;load the list of masks
000015A8  D3C0                     758          ADDA.L D0,A1 ;displace to a specific mask
000015AA  1A11                     759          MOVE.B (A1),D5 ;move the mask to D5
000015AC                           760          
000015AC  0C05 0000                761          CMPI.B #0,D5 ;check if the mask is 0
000015B0  6700 FABE                762          BEQ falsePositive ;branch if it is
000015B4                           763          
000015B4  1401                     764          MOVE.B D1,D2 ;copy instruction to D2
000015B6  C405                     765          AND.B D5,D2  ;mask D2
000015B8  43F9 0000161A            766          LEA cmpiEA,A1 ;load the list of valid modes
000015BE  D3C0                     767          ADDA.L D0,A1 ;displace to a specific mode
000015C0  1811                     768          MOVE.B (A1),D4 ;move mode to D4
000015C2  B404                     769          CMP.B D4,D2 ;compare mode to masked value
000015C4  6700 0006                770          BEQ oriBody ;if its match, its a valid mode and we can procede
000015C8                           771          
000015C8  5280                     772          ADDQ.L #1,D0 ;add one to displacement
000015CA  60D6                     773          BRA validOriModes ;check for next mode
000015CC                           774          
000015CC                           775  oriBody:
000015CC                           776  
000015CC                           777  
000015CC  3401                     778          MOVE.W  D1,D2 ;copy inst to D2
000015CE  C47C 00C0                779          AND.W  #%0000000011000000,D2 ;mask word for size
000015D2  0C42 00C0                780          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
000015D6  6700 FA98                781          BEQ falsePositive
000015DA                           782  
000015DA  43F9 00001E3C            783          LEA     oriMessage,A1  ;move string for NEG info
000015E0  103C 000E                784          MOVE.B  #14,D0        ;set for task to display null terminated 
000015E4                           785                                ;string without CR, LF
000015E4  4E4F                     786          TRAP    #15
000015E6                           787          
000015E6                           788          ;go to Effective_Address for immediate data
000015E6  143C 003C                789          MOVE.B #%00111100,D2
000015EA  48E7 4000                790          MOVEM.L D1,-(SP)
000015EE  6100 04DC                791          BSR     Get_Effective_Address
000015F2  4CDF 0002                792          MOVEM.L (SP)+,D1
000015F6                           793          
000015F6  3401                     794          MOVE.W D1,D2 ;copy inst to D2
000015F8  C47C 003F                795          AND #%000000000111111,D2 ;and out everything but modes and regs
000015FC  1A02                     796          MOVE.B D2,D5 ; copy to D5 for following BSR
000015FE                           797          
000015FE  48E7 4000                798          MOVEM.L D1,-(SP)
00001602  6100 04C8                799          BSR     Get_Effective_Address
00001606  4CDF 0002                800          MOVEM.L (SP)+,D1
0000160A                           801          
0000160A                           802                
0000160A                           803          
0000160A                           804  oridone:
0000160A                           805  
0000160A  43F9 00001E1C            806          LEA     clearLine,A1  ;move string for a CR and LF
00001610  103C 000E                807          MOVE.B  #14,D0        ;set for task to display null terminated 
00001614                           808                                ;string without CR, LF
00001614  4E4F                     809          TRAP    #15
00001616  7000                     810          MOVEQ.L #0,D0
00001618  4E75                     811          RTS
0000161A                           812  
0000161A                           813          
0000161A                           814          
0000161A= 20 18 00 10 38 39 00     815  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
00001621= 38 38 38 38 3F 3F 00     816  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
00001628                           817     
00001628                           818  CMPI:            
00001628                           819       
00001628  7000                     820          MOVEQ.L #0, D0 ;clear D0
0000162A                           821          
0000162A                           822  validCmpiModes:
0000162A                           823          
0000162A                           824          
0000162A  43F8 1621                825          LEA cmpiEAmasks,A1 ;load the list of masks
0000162E  D3C0                     826          ADDA.L D0,A1 ;displace to a specific mask
00001630  1A11                     827          MOVE.B (A1),D5 ;move the mask to D5
00001632                           828          
00001632  0C05 0000                829          CMPI.B #0,D5 ;check if the mask is 0
00001636  6700 FA38                830          BEQ falsePositive ;branch if it is
0000163A                           831          
0000163A  1401                     832          MOVE.B D1,D2 ;copy instruction to D2
0000163C  C405                     833          AND.B D5,D2  ;mask D2
0000163E  43F8 161A                834          LEA cmpiEA,A1 ;load the list of valid modes
00001642  D3C0                     835          ADDA.L D0,A1 ;displace to a specific mode
00001644  1811                     836          MOVE.B (A1),D4 ;move mode to D4
00001646  B404                     837          CMP.B D4,D2 ;compare mode to masked value
00001648  6700 0006                838          BEQ CMPIBody ;if its match, its a valid mode and we can procede
0000164C                           839          
0000164C  5280                     840          ADDQ.L #1,D0 ;add one to displacement
0000164E  60DA                     841          BRA validCmpiModes ;check for next mode
00001650                           842          
00001650                           843  CMPIBody:
00001650                           844  
00001650                           845  
00001650  3401                     846          MOVE.W  D1,D2 ;copy inst to D2
00001652  C47C 00C0                847          AND.W  #%0000000011000000,D2 ;mask word for size
00001656  0C42 00C0                848          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
0000165A  6700 FA14                849          BEQ falsePositive
0000165E                           850  
0000165E  43F9 00001E41            851          LEA     cmpiMessage,A1  ;move string for NEG info
00001664  103C 000E                852          MOVE.B  #14,D0        ;set for task to display null terminated 
00001668                           853                                ;string without CR, LF
00001668  4E4F                     854          TRAP    #15
0000166A                           855          
0000166A                           856          ;go to Effective_Address for immediate data
0000166A  143C 003C                857          MOVE.B #%00111100,D2
0000166E  48E7 4000                858          MOVEM.L D1,-(SP)
00001672  6100 0458                859          BSR     Get_Effective_Address
00001676  4CDF 0002                860          MOVEM.L (SP)+,D1
0000167A                           861          
0000167A  3401                     862          MOVE.W D1,D2 ;copy inst to D2
0000167C  C47C 003F                863          AND #%000000000111111,D2 ;and out everything but modes and regs
00001680  1A02                     864          MOVE.B D2,D5 ; copy to D5 for following BSR
00001682                           865          
00001682  48E7 4000                866          MOVEM.L D1,-(SP)
00001686  6100 0444                867          BSR     Get_Effective_Address
0000168A  4CDF 0002                868          MOVEM.L (SP)+,D1
0000168E                           869          
0000168E                           870                
0000168E                           871          
0000168E                           872  CMPidone:
0000168E                           873  
0000168E  43F9 00001E1C            874          LEA     clearLine,A1  ;move string for a CR and LF
00001694  103C 000E                875          MOVE.B  #14,D0        ;set for task to display null terminated 
00001698                           876                                ;string without CR, LF
00001698  4E4F                     877          TRAP    #15
0000169A  7000                     878          MOVEQ.L #0,D0
0000169C  4E75                     879          RTS
0000169E                           880  
0000169E                           881          
0000169E= 10 38 39 00              882  JsrEA        DC.B %010000, %111000, %111001,0
000016A2= 38 3F 3F 00              883  JsrEAmasks   DC.B %111000, %111111, %111111,0
000016A6                           884     
000016A6                           885  JSR:            
000016A6                           886       
000016A6  7000                     887          MOVEQ.L #0, D0 ;clear D0
000016A8                           888          
000016A8                           889  validJsrModes:
000016A8                           890          
000016A8  43F8 16A2                891          LEA JsrEAmasks,A1 ;load the list of masks
000016AC  D3C0                     892          ADDA.L D0,A1 ;displace to a specific mask
000016AE  1A11                     893          MOVE.B (A1),D5 ;move the mask to D5
000016B0                           894          
000016B0  0C05 0000                895          CMPI.B #0,D5 ;check if the mask is 0
000016B4  6700 F9BA                896          BEQ falsePositive ;branch if it is
000016B8                           897          
000016B8  1401                     898          MOVE.B D1,D2 ;copy instruction to D2
000016BA  C405                     899          AND.B D5,D2  ;mask D2
000016BC  43F8 169E                900          LEA JsrEA,A1 ;load the list of valid modes
000016C0  D3C0                     901          ADDA.L D0,A1 ;displace to a specific mode
000016C2  1811                     902          MOVE.B (A1),D4 ;move mode to D4
000016C4  B404                     903          CMP.B D4,D2 ;compare mode to masked value
000016C6  6700 0006                904          BEQ JsrBody ;if its match, its a valid mode and we can procede
000016CA                           905          
000016CA  5280                     906          ADDQ.L #1,D0 ;add one to displacement
000016CC  60DA                     907          BRA validJsrModes ;check for next mode
000016CE                           908          
000016CE                           909  JsrBody:
000016CE                           910  
000016CE                           911  
000016CE  43F9 00001E47            912          LEA     jsrMessage,A1  ;move string for NEG info
000016D4  103C 000E                913          MOVE.B  #14,D0        ;set for task to display null terminated 
000016D8                           914                                ;string without CR, LF
000016D8  4E4F                     915          TRAP    #15
000016DA                           916          
000016DA  3401                     917          MOVE.W D1,D2 ;copy inst to D2
000016DC  C47C 003F                918          AND #%000000000111111,D2 ;and out everything but modes and regs
000016E0  1A02                     919          MOVE.B D2,D5 ; copy to D5 for following BSR
000016E2                           920          
000016E2  48E7 4000                921          MOVEM.L D1,-(SP)
000016E6  6100 03E4                922          BSR     Get_Effective_Address
000016EA  4CDF 0002                923          MOVEM.L (SP)+,D1
000016EE                           924          
000016EE                           925                
000016EE                           926          
000016EE                           927  Jsrdone:
000016EE                           928  
000016EE  43F9 00001E1C            929          LEA     clearLine,A1  ;move string for a CR and LF
000016F4  103C 000E                930          MOVE.B  #14,D0        ;set for task to display null terminated 
000016F8                           931                                ;string without CR, LF
000016F8  4E4F                     932          TRAP    #15
000016FA  7000                     933          MOVEQ.L #0,D0
000016FC  4E75                     934          RTS
000016FE                           935  
000016FE                           936  
000016FE                           937          
000016FE                           938  NOP:
000016FE                           939  
000016FE  43F9 00001E51            940          LEA     nopMessage,A1 ;move string for NOP info
00001704  103C 000D                941          MOVE.B  #13,D0        ;set for task to display null terminated 
00001708                           942                                ;string with CR, LF
00001708  4E4F                     943          TRAP    #15
0000170A                           944          
0000170A  7000                     945          MOVEQ.L #0,D0
0000170C  4E75                     946          RTS
0000170E                           947          
0000170E                           948  RTS:
0000170E                           949          
0000170E  43F9 00001E4C            950          LEA     rtsMessage,A1  ;move string for rts info
00001714  103C 000D                951          MOVE.B  #13,D0        ;set for task to display null terminated 
00001718                           952                                ;string with CR, LF
00001718  4E4F                     953          TRAP    #15  
0000171A                           954     
0000171A  7000                     955          MOVEQ.L #0,D0
0000171C  4E75                     956          RTS   
0000171E                           957  
0000171E= 3C 08 00 10 18 20 ...    958  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
00001727= 3F 38 38 38 38 38 ...    959  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001730                           960  
00001730= 00 10 18 20 38 39 00     961  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
00001737= 38 38 38 38 3F 3F 00     962  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
0000173E                           963  
0000173E                           964  MOVE:
0000173E                           965          
0000173E                           966  
0000173E                           967          
0000173E  7000                     968          MOVEQ.L #0, D0 ;clear D0
00001740                           969          
00001740                           970  validMoveSourceModes:
00001740                           971          
00001740  43F8 1727                972          LEA moveSourceEAmasks,A1 ;load the list of masks
00001744  D3C0                     973          ADDA.L D0,A1 ;displace to a specific mask
00001746  1A11                     974          MOVE.B (A1),D5 ;move the mask to D5
00001748                           975          
00001748  0C05 0000                976          CMPI.B #0,D5 ;check if the mask is 0
0000174C  6700 F922                977          BEQ falsePositive ;branch if it is
00001750                           978          
00001750  1401                     979          MOVE.B D1,D2 ;copy instruction to D2
00001752  C405                     980          AND.B D5,D2  ;mask D2
00001754                           981          
00001754  43F8 171E                982          LEA moveSourceEA,A1 ;load the list of valid modes
00001758  D3C0                     983          ADDA.L D0,A1 ;displace to a specific mode
0000175A  1811                     984          MOVE.B (A1),D4 ;move mode to D4
0000175C  B404                     985          CMP.B D4,D2 ;compare mode to masked value
0000175E  6700 0006                986          BEQ  checkMoveDest ;if its match, its a valid mode and we can procede
00001762                           987          
00001762  5280                     988          ADDQ.L #1,D0 ;add one to displacement
00001764  60DA                     989          BRA validMoveSourceModes ;check for next mode
00001766                           990          
00001766                           991  checkMoveDest:
00001766  7000                     992          MOVEQ.L #0, D0 ;clear D0
00001768                           993          
00001768                           994  validMoveDestModes:
00001768                           995          
00001768  43F8 1737                996          LEA moveDestEAmasks,A1 ;load the list of masks
0000176C  D3C0                     997          ADDA.L D0,A1 ;displace to a specific mask
0000176E  1A11                     998          MOVE.B (A1),D5 ;move the mask to D5
00001770                           999          
00001770  0C05 0000               1000          CMPI.B #0,D5 ;check if the mask is 0
00001774  6700 F8FA               1001          BEQ falsePositive ;branch if it is
00001778                          1002          
00001778  3401                    1003          MOVE.W D1,D2 ;copy instruction to D2
0000177A  EC4A                    1004          LSR.W #6,D2  ;move mode
0000177C  6100 04C2               1005          BSR switchModeAndReg ;switch register and mode
00001780  C405                    1006          AND.B D5,D2  ;mask D2
00001782                          1007          
00001782  43F8 1730               1008          LEA moveDestEA,A1 ;load the list of valid modes
00001786  D3C0                    1009          ADDA.L D0,A1 ;displace to a specific mode
00001788  1811                    1010          MOVE.B (A1),D4 ;move mode to D4
0000178A  B404                    1011          CMP.B D4,D2 ;compare mode to masked value
0000178C  6700 0006               1012          BEQ moveBody ;if its match, its a valid mode and we can procede
00001790                          1013          
00001790  5280                    1014          ADDQ.L #1,D0 ;add one to displacement
00001792  60D4                    1015          BRA validMoveDestModes ;check for next mode
00001794                          1016          
00001794                          1017  moveBody
00001794  3401                    1018          MOVE.W  D1,D2 ;copy inst to D2
00001796  C47C 3000               1019          AND.W  #%0011000000000000,D2 ;mask word for size
0000179A  0C42 0000               1020          CMPI.W #0,D2 ;0 is the only non valid size
0000179E  6700 F8D0               1021          BEQ falsePositive ; if zero, this is not move
000017A2                          1022  
000017A2  43F9 00001E56           1023          LEA     moveMessage,A1  ;move string for MOVE
000017A8  103C 000E               1024          MOVE.B  #14,D0        ;set for task to display null terminated 
000017AC                          1025                                ;string with CR, LF
000017AC  4E4F                    1026          TRAP    #15
000017AE                          1027          
000017AE                          1028          
000017AE  3401                    1029          MOVE.W  D1,D2 ;check source mode
000017B0  C43C 003F               1030          AND.B   #%00111111,D2
000017B4  1A02                    1031          MOVE.B  D2,D5
000017B6  48E7 4000               1032          MOVEM.L D1,-(SP)
000017BA  6100 0310               1033          BSR     Get_Effective_Address
000017BE  4CDF 0002               1034          MOVEM.L (SP)+,D1
000017C2                          1035          
000017C2                          1036          ;print separator
000017C2                          1037          
000017C2  3401                    1038          MOVE.W  D1,D2 ;check dest mode
000017C4  EC4A                    1039          LSR.W   #6,D2
000017C6  6100 0478               1040          BSR  switchModeAndReg
000017CA  C43C 003F               1041          AND.B   #%00111111,D2
000017CE  1A02                    1042          MOVE.B  D2,D5
000017D0  48E7 4000               1043          MOVEM.L D1,-(SP)
000017D4  6100 02F6               1044          BSR     Get_Effective_Address
000017D8  4CDF 0002               1045          MOVEM.L (SP)+,D1
000017DC                          1046          
000017DC                          1047          
000017DC                          1048          
000017DC  43F9 00001E1C           1049          LEA     clearLine,A1  ;move string for a CR and LF
000017E2  103C 000E               1050          MOVE.B  #14,D0        ;set for task to display null terminated 
000017E6                          1051                                ;string without CR, LF
000017E6  4E4F                    1052          TRAP    #15
000017E8                          1053  
000017E8  7000                    1054          MOVEQ.L #0,D0
000017EA  4E75                    1055          RTS
000017EC                          1056          
000017EC= 08 00                   1057  moveADestEA        DC.B %001000,0
000017EE= 38 00                   1058  moveADestEAmasks   DC.B %111000,0
000017F0                          1059          
000017F0                          1060  MOVEA:
000017F0                          1061  
000017F0  7000                    1062          MOVEQ.L #0, D0 ;clear D0
000017F2                          1063          
000017F2                          1064  validMoveASourceModes:
000017F2                          1065          
000017F2  43F8 1727               1066          LEA moveSourceEAmasks,A1 ;load the list of masks
000017F6  D3C0                    1067          ADDA.L D0,A1 ;displace to a specific mask
000017F8  1A11                    1068          MOVE.B (A1),D5 ;move the mask to D5
000017FA                          1069          
000017FA  0C05 0000               1070          CMPI.B #0,D5 ;check if the mask is 0
000017FE  6700 F870               1071          BEQ falsePositive ;branch if it is
00001802                          1072          
00001802  1401                    1073          MOVE.B D1,D2 ;copy instruction to D2
00001804  C405                    1074          AND.B D5,D2  ;mask D2
00001806                          1075          
00001806  43F8 171E               1076          LEA moveSourceEA,A1 ;load the list of valid modes
0000180A  D3C0                    1077          ADDA.L D0,A1 ;displace to a specific mode
0000180C  1811                    1078          MOVE.B (A1),D4 ;move mode to D4
0000180E  B404                    1079          CMP.B D4,D2 ;compare mode to masked value
00001810  6700 0006               1080          BEQ  checkMoveADest ;if its match, its a valid mode and we can procede
00001814                          1081          
00001814  5280                    1082          ADDQ.L #1,D0 ;add one to displacement
00001816  60DA                    1083          BRA validMoveASourceModes ;check for next mode
00001818                          1084          
00001818                          1085  checkMoveADest:
00001818  7000                    1086          MOVEQ.L #0, D0 ;clear D0
0000181A                          1087  validMoveADestModes:
0000181A                          1088          
0000181A  43F8 17EE               1089          LEA moveADestEAmasks,A1 ;load the list of masks
0000181E  D3C0                    1090          ADDA.L D0,A1 ;displace to a specific mask
00001820  1A11                    1091          MOVE.B (A1),D5 ;move the mask to D5
00001822                          1092          
00001822  0C05 0000               1093          CMPI.B #0,D5 ;check if the mask is 0
00001826  6700 F848               1094          BEQ falsePositive ;branch if it is
0000182A                          1095          
0000182A  3401                    1096          MOVE.W D1,D2 ;copy instruction to D2
0000182C  EA4A                    1097          LSR.W #5,D2  ;move mode
0000182E  6100 0410               1098          BSR switchModeAndReg ;switch register and mode
00001832  C405                    1099          AND.B D5,D2  ;mask D2
00001834                          1100          
00001834  43F8 17EC               1101          LEA moveADestEA,A1 ;load the list of valid modes
00001838  D3C0                    1102          ADDA.L D0,A1 ;displace to a specific mode
0000183A  1811                    1103          MOVE.B (A1),D4 ;move mode to D4
0000183C  B404                    1104          CMP.B D4,D2 ;compare mode to masked value
0000183E  6700 0006               1105          BEQ moveABody ;if its match, its a valid mode and we can procede
00001842                          1106          
00001842  5280                    1107          ADDQ.L #1,D0 ;add one to displacement
00001844  60D4                    1108          BRA validMoveADestModes ;check for next mode
00001846                          1109  moveABody:
00001846  3401                    1110          MOVE.W  D1,D2 ;copy inst to D2
00001848  C47C 3000               1111          AND.W  #%0011000000000000,D2 ;mask word for size
0000184C  0C42 0000               1112          CMPI.W #0,D2 ;0 is the non valid size
00001850  6700 F81E               1113          BEQ falsePositive ; if zero, this is not move
00001854  0C42 1000               1114          CMPI.W #%0001000000000000,D2
00001858  6700 F816               1115          BEQ falsePositive ; if byte, this is not movea
0000185C                          1116  
0000185C                          1117  
0000185C  43F9 00001E69           1118          LEA     moveAMessage,A1  ;move string for MOVE
00001862  103C 000D               1119          MOVE.B  #13,D0        ;set for task to display null terminated 
00001866                          1120                                ;string with CR, LF
00001866  4E4F                    1121          TRAP    #15
00001868                          1122  
00001868  7000                    1123          MOVEQ.L #0,D0
0000186A  4E75                    1124          RTS
0000186C                          1125  
0000186C                          1126             
0000186C                          1127  Bcc:
0000186C                          1128  
0000186C  43F9 00001E5C           1129          LEA     bccMessage,A1  ;move string for BRA info
00001872  103C 000E               1130          MOVE.B  #14,D0        ;set for task to display null terminated 
00001876                          1131                                ;string without CR, LF
00001876  4E4F                    1132          TRAP    #15
00001878                          1133          
00001878  7000                    1134          MOVEQ.L #0,D0 ;clear D0
0000187A  3401                    1135          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
0000187C  E04A                    1136          LSR.W   #8,D2
0000187E  C47C 000F               1137          AND.W   #$0F,D2 ;mask instruction
00001882                          1138          
00001882                          1139  checkCC:        
00001882  41F9 00001DA3           1140          LEA     bccList,A0 ;get condition code signature list in A0
00001888  D1C0                    1141          ADDA.L  D0,A0 ;get correct sig         
0000188A  B410                    1142          CMP.B   (A0),D2 ;compare to sig
0000188C  6700 0006               1143          BEQ     foundCC ;if sig matches branch
00001890  5200                    1144          ADDQ.B  #byte,D0
00001892  60EE                    1145          BRA     checkCC
00001894                          1146  foundCC:
00001894  43F9 00001DB4           1147          LEA     conditionCodeMessage,A1 ;get condition code message in A1
0000189A  C0FC 0004               1148          MULU.W  #long,D0 ;adjust size of D0 for a long
0000189E  D3C0                    1149          ADDA.L  D0,A1 ;get correct message location
000018A0  2251                    1150          MOVEA.L (A1),A1 ;get correct message
000018A2                          1151          
000018A2  103C 000E               1152          MOVE.B  #14,D0        ;set for task to display null terminated 
000018A6                          1153                                ;string without CR, LF
000018A6  4E4F                    1154          TRAP    #15
000018A8                          1155  
000018A8                          1156          
000018A8                          1157          
000018A8  548B                    1158          ADDQ.L  #word,A3 ;move past instruction in case long displacement
000018AA  C27C 00FF               1159          AND.W   #$00FF,D1   ;check for word sized displacement
000018AE                          1160          
000018AE  B23C 0000               1161          CMP.B   #$0,D1
000018B2  6700 0010               1162          BEQ     BccWord
000018B6                          1163          
000018B6  B23C 00FF               1164          CMP.B   #$FF,D1 check for long sized displacement
000018BA  6700 0010               1165          BEQ     BccLong
000018BE                          1166          
000018BE                          1167  BccByte:
000018BE                          1168          
000018BE  7E00                    1169          MOVEQ.L #0,D7 ;pass back no extra data followed
000018C0  6000 0012               1170          BRA     BccDone
000018C4                          1171  BccWord:
000018C4  3213                    1172          MOVE.W  (A3),D1
000018C6                          1173          
000018C6  7E02                    1174          MOVEQ.L #word,D7 ;pass back an extra word followed
000018C8  6000 000A               1175          BRA     BccDone
000018CC                          1176  BccLong:
000018CC  2213                    1177          MOVE.L  (A3),D1
000018CE                          1178          
000018CE  7E04                    1179          MOVEQ.L #long,D7 ;pass back an extra long followed
000018D0  6000 0002               1180          BRA     BccDone
000018D4                          1181  BccDone:
000018D4                          1182  
000018D4  343C 0010               1183          MOVE.W  #16,D2 ;put base in D2
000018D8  303C 000F               1184          MOVE.W  #15,D0  ;put task #15 in D0
000018DC  4E4F                    1185          TRAP    #15
000018DE                          1186          
000018DE  43F9 00001E1C           1187          LEA     clearLine,A1  ;move string for a CR and LF
000018E4  103C 000E               1188          MOVE.B  #14,D0        ;set for task to display null terminated 
000018E8                          1189                                ;string without CR, LF
000018E8  4E4F                    1190          TRAP    #15
000018EA                          1191  
000018EA  7000                    1192          MOVEQ.L #0,D0
000018EC  4E75                    1193          RTS
000018EE                          1194          
000018EE                          1195          
000018EE                          1196  unknownOpCode:
000018EE  43F9 00001E63           1197          LEA     dataMessage,A1 ;move string for data info
000018F4  103C 000E               1198          MOVE.B  #14,D0        ;set for task to display null terminated 
000018F8                          1199                                ;string without CR, LF
000018F8  4E4F                    1200          TRAP    #15
000018FA                          1201          
000018FA  143C 0010               1202          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
000018FE  103C 000F               1203          MOVE.B  #15,D0
00001902  4E4F                    1204          TRAP    #15
00001904                          1205          
00001904  43F9 00001E1C           1206          LEA     clearLine,A1  ;move string for a CR and LF
0000190A  103C 000E               1207          MOVE.B  #14,D0        ;set for task to display null terminated 
0000190E                          1208                                ;string without CR, LF
0000190E  4E4F                    1209          TRAP    #15
00001910                          1210          
00001910  7000                    1211          MOVEQ.L #0,D0
00001912  4E75                    1212          RTS
00001914                          1213          
00001914                          1214  handlebytedata:
00001914                          1215  
00001914  43F9 00001E63           1216          LEA     dataMessage,A1 ;move string for data info
0000191A  103C 000E               1217          MOVE.B  #14,D0        ;set for task to display null terminated 
0000191E                          1218                                ;string without CR, LF
0000191E  4E4F                    1219          TRAP    #15
00001920                          1220          
00001920  E049                    1221          LSR.W   #8,D1 ;shift the word read into D1 by a byte
00001922                          1222          
00001922  143C 0010               1223          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001926  103C 000F               1224          MOVE.B  #15,D0
0000192A  4E4F                    1225          TRAP    #15
0000192C                          1226          
0000192C  43F9 00001E1C           1227          LEA     clearLine,A1  ;move string for a CR and LF
00001932  103C 000E               1228          MOVE.B  #14,D0        ;set for task to display null terminated 
00001936                          1229                                ;string without CR, LF
00001936  4E4F                    1230          TRAP    #15
00001938                          1231          
00001938  7000                    1232          MOVEQ.L #0,D0
0000193A                          1233          
0000193A  528B                    1234          ADDQ.L  #byte,A3
0000193C  6000 F6E8               1235          BRA main_Loop
00001940                          1236  
00001940                          1237          
00001940                          1238          
00001940                          1239  fin
00001940                          1240  
00001940                          1241          
00001940                          1242          
00001940  FFFF FFFF               1243          simhalt
00001944                          1244          
00001944                          1245  
00001944                          1246  *******************************************************************************
00001944                          1247  *                            SUB ROUTINES
00001944                          1248  *******************************************************************************
00001944                          1249  
00001944                          1250  *******************************************************************************
00001944                          1251  *                          IO ROLE ROUTINES
00001944                          1252  *******************************************************************************
00001944                          1253  
00001944                          1254  *==========================================================================
00001944                          1255  *                   Enter / Validate beginning address 
00001944                          1256  *==========================================================================
00001944                          1257   
00001944                          1258  begin_address:
00001944                          1259  
00001944                          1260         
00001944  43F9 00001C54           1261          LEA         slPrompt,A1         ;Load address for starting loaction prompt
0000194A  2239 00001C54           1262          MOVE.L      slPrompt,D1         ;Load display length to D1
00001950  700E                    1263          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001952  4E4F                    1264          TRAP        #15                 ;Perform task 14 (display)
00001954                          1265          
00001954  43F9 00001E9A           1266          LEA         startLocation,A1    ;Load address to store user input
0000195A  103C 0002               1267          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
0000195E  4E4F                    1268          TRAP        #15                 ;Perform task 2 (input)
00001960                          1269          
00001960  0C11 001B               1270          CMP.B       #27,(A1)            ;Check for ESC entered
00001964  6700 004C               1271          BEQ         address_Exit        ;Exit condition 
00001968                          1272          
00001968  6100 0050               1273          BSR         enter_addr_edit_all
0000196C  B67C FFFF               1274          CMP.W       #-1,D3              ;Did the edit pass?
00001970  67D2                    1275          BEQ         begin_address       ;No, loop and ask for correct input
00001972                          1276          
00001972  2643                    1277          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
00001974                          1278          
00001974  43F9 00001D61           1279          LEA         spc,A1              ;Load address for starting loaction prompt
0000197A  1239 00001D62           1280          MOVE.B      spc_len,D1          ;Load empty line length
00001980  7000                    1281          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
00001982  4E4F                    1282          TRAP        #15                 ;Perform task 14 (display)
00001984  6000 0002               1283          BRA         end_address
00001988                          1284  
00001988                          1285  *===========================================================================
00001988                          1286  *                   Enter / Validate ending address 
00001988                          1287  *===========================================================================
00001988                          1288  
00001988                          1289  end_address:
00001988                          1290          
00001988  43F9 00001C85           1291          LEA         elPrompt,A1         ;Load address for ending loaction prompt
0000198E                          1292          ;MOVE.L     elPrompt,D1         ;Load display length to D1
0000198E  7250                    1293          MOVE.L      #80,D1       ;did not like previous command, do not know why, it should have worked
00001990  700E                    1294          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001992  4E4F                    1295          TRAP        #15                 ;Perform task 14 (display)
00001994                          1296          
00001994  103C 0002               1297          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001998  4E4F                    1298          TRAP        #15                 ;Perform task 2 (input)
0000199A                          1299          
0000199A  0C11 001B               1300          CMP.B       #27,(A1)            ;Check for ESC entered
0000199E  6700 0012               1301          BEQ         address_Exit        ;Exit condition 
000019A2                          1302          
000019A2  6100 0016               1303          BSR         enter_addr_edit_all
000019A6  B67C FFFF               1304          CMP.W       #-1,D3              ;Did the edit pass?
000019AA  67DC                    1305          BEQ         end_address         ;No, loop and ask for correct input
000019AC                          1306  
000019AC  2843                    1307          MOVEA.L     D3,A4               ;Ending address gets stored in A4
000019AE  6000 0008               1308          BRA         address_done
000019B2                          1309  
000019B2                          1310  address_Exit:
000019B2                          1311  
000019B2  76FF                    1312          MOVE.L      #-1,D3              ;Load -1 into return parameter
000019B4  6000 0002               1313          BRA         address_done
000019B8                          1314          
000019B8                          1315  address_done:
000019B8                          1316  
000019B8  4E75                    1317          RTS    
000019BA                          1318  
000019BA                          1319  *==============================================================================
000019BA                          1320  * enter_addr_edit_all - Enter address edit check to edit all errors  
000019BA                          1321  *                       using multiple different error checking routines.
000019BA                          1322  *
000019BA                          1323  * Parameters -
000019BA                          1324  *   Input   A1      The data that needs checked.
000019BA                          1325  *   Input   D1      The number of characters input     
000019BA                          1326  *   Output  D3      Returns '-1' when there is an error.
000019BA                          1327  *==============================================================================
000019BA                          1328  
000019BA                          1329  enter_addr_edit_all
000019BA                          1330  
000019BA                          1331  *------------------------------------------------------------------------------
000019BA                          1332  * Test for odd number of characters entered, not allowed
000019BA                          1333  *------------------------------------------------------------------------------
000019BA                          1334         
000019BA  6100 0024               1335          BSR         ck_boundry          ;check if the input is on a odd / even boundry
000019BE  B67C FFFF               1336          CMP.W       #-1,D3              ;Is the address odd?
000019C2  6700 001A               1337          BEQ         enter_addr_edit_all_exit     ;No, return
000019C6                          1338  
000019C6                          1339  *------------------------------------------------------------------------------
000019C6                          1340  * Ttest for character entered all being valid address characters
000019C6                          1341  * Note: lower case a-f, gets converted to upper case A-F in D3
000019C6                          1342  *------------------------------------------------------------------------------
000019C6                          1343          
000019C6  6100 0062               1344          BSR         parseHexString      ;check if the input contains valid Hex characters
000019CA  B67C FFFF               1345          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
000019CE  6700 000E               1346          BEQ         enter_addr_edit_all_exit     ;No, return
000019D2                          1347  
000019D2                          1348  *------------------------------------------------------------------------------
000019D2                          1349  * Verify that the address entered is witin the range defined in the Equate
000019D2                          1350  *------------------------------------------------------------------------------        
000019D2                          1351          
000019D2  6100 00C8               1352          BSR         ck_addr_range       ;is address entered witin the range 
000019D6                          1353                                          ;   as defined in the Equate? 
000019D6  B67C FFFF               1354          CMP.W       #-1,D3              ;is the address  valid?
000019DA  6700 0002               1355          BEQ         enter_addr_edit_all_exit     ;No, return
000019DE                          1356  
000019DE                          1357  enter_addr_edit_all_exit:
000019DE                          1358  
000019DE  4E75                    1359          RTS                             ;return
000019E0                          1360  
000019E0                          1361  *==============================================================================
000019E0                          1362  * ck_boundry - Check the size of the data characters input and determine
000019E0                          1363  *              if an odd number of characters was entered
000019E0                          1364  *
000019E0                          1365  * Parameters -
000019E0                          1366  *   Input   A1      The data that needs checked for odd length.
000019E0                          1367  *   Input   D1      The number of characters input     
000019E0                          1368  *   Output  D3      Returns '-1' when there is an odd length.
000019E0                          1369  *==============================================================================
000019E0                          1370  
000019E0                          1371  ck_boundry:
000019E0                          1372  
000019E0  4243                    1373          CLR.W       D3                  ;Clear the return
000019E2                          1374  
000019E2  B23C 0000               1375          CMP.B       #0,D1               ;Check for nothing entered
000019E6  6700 002E               1376          BEQ         ck_size_error       ;Number of characters entered must be 
000019EA                          1377                                          ;greater than 0  
000019EA                          1378          
000019EA                          1379          
000019EA                          1380          * The program will branch to ck_size_error if D1 is greater than #8        
000019EA  B23C 0008               1381          CMP.B       #8,D1               ;Check for more than 8 characters entered
000019EE  6E00 0026               1382          BGT         ck_size_error       ;Number of characters entered must be less
000019F2                          1383                                          ;than 9
000019F2                          1384          
000019F2  7402                    1385          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
000019F4  82C2                    1386          DIVU        D2,D1               ;Divide address by 2
000019F6  4841                    1387          SWAP        D1                  ;get remainder
000019F8  B23C 0001               1388          CMP.B       #$01,D1             ;Check for remainder of 1
000019FC  6700 0004               1389          BEQ         ck_boundry_error    ;Number of characters entered must be an 
00001A00                          1390                                          ;even number   
00001A00                          1391    
00001A00  4E75                    1392          RTS                             ;return
00001A02                          1393  
00001A02                          1394  *------------------------------------------------------------------------------
00001A02                          1395  * ck_boundry_error - An odd number of characters was entered
00001A02                          1396  *                  - Load error message and display it
00001A02                          1397  *                  - Return error condition
00001A02                          1398  *------------------------------------------------------------------------------
00001A02                          1399          
00001A02                          1400  ck_boundry_error:
00001A02                          1401  
00001A02  43F9 00001D41           1402          LEA         even_msg,A1         ;Load odd error message into A1
00001A08  2239 00001D41           1403          MOVE.L      even_msg,D1         ;Load error length to D1
00001A0E                          1404          
00001A0E  7000                    1405          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001A10                          1406                                          ; n is D1.W with CR, LF. 
00001A10  4E4F                    1407          TRAP #15                        ;Display the error message
00001A12  76FF                    1408          MOVE.L #-1,D3                   ;Load -1 into return parameter
00001A14  4E75                    1409          RTS                             ;Return
00001A16                          1410          
00001A16                          1411  *------------------------------------------------------------------------------
00001A16                          1412  * ck_size_error -   The number of characters entered must be more than zero
00001A16                          1413  *                  - Load error message and display it
00001A16                          1414  *                  - Return error condition
00001A16                          1415  *------------------------------------------------------------------------------
00001A16                          1416          
00001A16                          1417  ck_size_error:
00001A16                          1418  
00001A16  43F9 00001CB4           1419          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001A1C  2239 00001CB4           1420          MOVE.L      invalidMsg,D1       ;Load error length to D1
00001A22                          1421          
00001A22  7000                    1422          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001A24                          1423                                          ; n is D1.W with CR, LF. 
00001A24  4E4F                    1424          TRAP        #15                 ;Display the error message
00001A26  76FF                    1425          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001A28  4E75                    1426          RTS                             ;Return        
00001A2A                          1427  
00001A2A                          1428  
00001A2A                          1429  *==============================================================================
00001A2A                          1430  * parseHexString - Converts user input string into a valid memory address
00001A2A                          1431  *                - Stores parsed address data into D3
00001A2A                          1432  *                - Stores good/bad (1/0) data in D4 
00001A2A                          1433  *
00001A2A                          1434  * Hex values are stored as bytes in D2, the ASCII chart shows their value
00001A2A                          1435  *   The ASCII chart values we care about are in the ranges of: 
00001A2A                          1436  *                            Hex            Decimal
00001A2A                          1437  *       No Value           NULL = 0         0
00001A2A                          1438  *       Numeric Values:     0-9 = 30-39     48-57
00001A2A                          1439  *       Upper Case letters: A-F = 41-46     65-70
00001A2A                          1440  *       Lower Case letterc: a-f = 61-66     97-102
00001A2A                          1441  
00001A2A                          1442  * Parameters -
00001A2A                          1443  *   Input   A1      The data that needs checked for valid input.
00001A2A                          1444  *   Output  D3      The return value, '-1' for error
00001A2A                          1445  *==============================================================================
00001A2A                          1446  
00001A2A                          1447  parseHexString:
00001A2A                          1448  
00001A2A                          1449  * setup any initializing item that do not get looped through
00001A2A  4243                    1450          CLR.W       D3                  ;Clear the return
00001A2C                          1451  
00001A2C                          1452          
00001A2C                          1453  *------------------------------------------------------------------------------
00001A2C                          1454  * NextHex - Loop through all bytes and vaildate the input
00001A2C                          1455  * Parameters -
00001A2C                          1456  *   Input   A1      The data that needs checked for valid input.
00001A2C                          1457  *   Output  D3      The return value, '-1' for error
00001A2C                          1458  *------------------------------------------------------------------------------
00001A2C                          1459          
00001A2C                          1460  NextHex:
00001A2C                          1461  
00001A2C  1419                    1462          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00001A2E  B43C 0000               1463          CMP.B       #0,D2               ;Check character for null 
00001A32  6700 0066               1464          BEQ         NextHexReturn       ;Character is null (end of input)
00001A36                          1465          
00001A36                          1466  *................................................................................
00001A36                          1467  *  Check decimal values 0-9 by testing hexadecimal values 30-39
00001A36                          1468  *................................................................................
00001A36                          1469                  
00001A36                          1470          * The program will branch to hex_range_error if D2 is less than #30
00001A36  B43C 0030               1471          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
00001A3A  6D00 0048               1472          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001A3E                          1473                                          ;processing
00001A3E                          1474          
00001A3E                          1475          * The program will branch to UcaseHex if D2 is greater than #39
00001A3E  B43C 0039               1476          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
00001A42  6E00 000A               1477          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
00001A46                          1478          
00001A46                          1479          *a valid number was found within this range
00001A46  0402 0030               1480          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
00001A4A  6000 0032               1481          BRA         NextHexDone         ;Done parsing this byte
00001A4E                          1482  
00001A4E                          1483  
00001A4E                          1484  *..............................................................................
00001A4E                          1485  *  Check upper case values A-F by testing hexadecimal values 41-46
00001A4E                          1486  *..............................................................................
00001A4E                          1487  
00001A4E                          1488  UcaseHex:
00001A4E                          1489  
00001A4E                          1490          * The program will branch to hex_range_error if D2 is less than #41
00001A4E  B43C 0041               1491          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
00001A52  6D00 0030               1492          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001A56                          1493                                          ;processing
00001A56                          1494          
00001A56  B43C 0046               1495          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
00001A5A  6E00 000A               1496          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
00001A5E                          1497                                          ;processing
00001A5E                          1498          
00001A5E                          1499          *a valid number was found within this range
00001A5E  0402 0037               1500          SUBI.B      #55,D2              ;Change uppercase character to actual value
00001A62  6000 001A               1501          BRA         NextHexDone         ;Done parsing this byte
00001A66                          1502  
00001A66                          1503  
00001A66                          1504  *..............................................................................
00001A66                          1505  *  Check lower case values a-f by testing hexadecimal values 61-66
00001A66                          1506  *..............................................................................
00001A66                          1507  
00001A66                          1508  LcaseHex
00001A66                          1509          
00001A66                          1510          * The program will branch to hex_range_error if D2 is less than #61
00001A66  B43C 0061               1511          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
00001A6A  6D00 0018               1512          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
00001A6E                          1513                                          ;processing
00001A6E                          1514  
00001A6E  B43C 0066               1515          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
00001A72  6E00 0010               1516          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
00001A76                          1517                                          ;processing
00001A76                          1518  
00001A76                          1519          *a valid number was found within this range
00001A76  0402 0057               1520          SUBI.B      #87,D2              ;Change lowercase character to actual value
00001A7A  6000 0002               1521          BRA         NextHexDone         ;Done parsing this byte
00001A7E                          1522  
00001A7E                          1523  NextHexDone:
00001A7E                          1524  
00001A7E  E983                    1525          ASL.L       #4,D3               ; Make rooom for new byte in the return register
00001A80  D602                    1526          ADD.B       D2,D3               ; Move the new byte into the return register
00001A82  60A8                    1527          BRA         NextHex             ; We're ready to parse the next byte
00001A84                          1528          
00001A84                          1529  *-------------------------------------------------------------------------------------
00001A84                          1530  * hex_range_error -  A character entered was within the valid range for a hex address
00001A84                          1531  *                 -  Load error message and display it
00001A84                          1532  *                 -  Return error condition
00001A84                          1533  *-------------------------------------------------------------------------------------
00001A84                          1534          
00001A84                          1535  hex_range_error:
00001A84                          1536  
00001A84  43F9 00001CF9           1537          LEA         invCharMsg,A1       ;Load invalid range message into A1
00001A8A  2239 00001CF9           1538          MOVE.L      invCharMsg,D1       ;Load error length to D1
00001A90                          1539          
00001A90  7000                    1540          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001A92                          1541                                          ; n is D1.W with CR, LF. 
00001A92  4E4F                    1542          TRAP        #15                 ;Display the error message
00001A94  76FF                    1543          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001A96  6000 0002               1544          BRA         NextHexReturn
00001A9A                          1545          
00001A9A                          1546  NextHexReturn:
00001A9A                          1547          
00001A9A  4E75                    1548          RTS                             ;Return      
00001A9C                          1549  
00001A9C                          1550  
00001A9C                          1551  *===============================================================================
00001A9C                          1552  * ck_addr_range - check the address input is within a valid memory address range
00001A9C                          1553  *                - Parsed address data into D3
00001A9C                          1554  *
00001A9C                          1555  * Parameters -
00001A9C                          1556  *   Input   A1      The data that needs checked for valid address.
00001A9C                          1557  *   Output  D3      The return value, '-1' for error
00001A9C                          1558  *===============================================================================
00001A9C                          1559  
00001A9C                          1560  
00001A9C                          1561  ck_addr_range:   
00001A9C                          1562  
00001A9C                          1563  *------------------------------------------------------------------------------
00001A9C                          1564  * Verify that the address entered is witin the 
00001A9C                          1565  * beginning range ('begin') as defined in the Equate
00001A9C                          1566  *------------------------------------------------------------------------------   
00001A9C                          1567              
00001A9C  2C3C 00005001           1568          MOVE.L      #begin,D6           * Load minimum starting address
00001AA2  B686                    1569          CMP.L       D6,D3               * Is input at or above minimum?
00001AA4  6D00 0012               1570          BLT         ck_addr_range_error 
00001AA8                          1571          
00001AA8                          1572  *------------------------------------------------------------------------------
00001AA8                          1573  * Verify that the address entered is witin the 
00001AA8                          1574  * ending range ('end') as defined in the Equate
00001AA8                          1575  *------------------------------------------------------------------------------
00001AA8                          1576          
00001AA8  2C3C 00FFFFFE           1577          MOVE.L      #end,D6             * Load maximum starting address
00001AAE  B686                    1578          CMP.L       D6,D3               * Is input at or below maximum?
00001AB0  6E00 0006               1579          BGT         ck_addr_range_error 
00001AB4  6000 0012               1580          BRA         ck_addr_done        ;done checking
00001AB8                          1581          
00001AB8                          1582  *..............................................................................
00001AB8                          1583  * ck_addr_range_error -  A address entered is not within the 
00001AB8                          1584  *                        valid range for a hex address
00001AB8                          1585  *..............................................................................
00001AB8                          1586          
00001AB8                          1587  ck_addr_range_error
00001AB8                          1588  
00001AB8  43F9 00001CB4           1589          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001ABE                          1590          
00001ABE  700D                    1591          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
00001AC0                          1592                                          ;with CR, LF. 
00001AC0  4E4F                    1593          TRAP        #15                 ;Display the error message
00001AC2  76FF                    1594          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001AC4  6000 0002               1595          BRA         ck_addr_done 
00001AC8                          1596  
00001AC8                          1597  ck_addr_done:
00001AC8                          1598  
00001AC8  4E75                    1599          RTS                             ;Return
00001ACA                          1600  
00001ACA                          1601  *******************************************************************************
00001ACA                          1602  *                          OP CODE ROLE ROUTINES
00001ACA                          1603  *******************************************************************************
00001ACA                          1604  
00001ACA                          1605  process_op_codes:
00001ACA                          1606  
00001ACA                          1607  
00001ACA                          1608  
00001ACA                          1609  process_op_codes_exit:
00001ACA                          1610  
00001ACA  4E75                    1611          RTS
00001ACC                          1612  
00001ACC                          1613  
00001ACC                          1614  *******************************************************************************
00001ACC                          1615  *                    Effective Addressing ROLE ROUTINES
00001ACC                          1616  *******************************************************************************
00001ACC                          1617  
00001ACC                          1618  Get_Effective_Address:
00001ACC                          1619  
00001ACC  1C05                    1620          MOVE.B      D5,D6
00001ACE  E60E                    1621          LSR.B       #3,D6               ;mode
00001AD0  CA3C 0007               1622          And.B       #%00000111,D5       ;register
00001AD4                          1623          
00001AD4  BC3C 0000               1624          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
00001AD8  6700 004A               1625          BEQ         Data_Reg_Direct
00001ADC                          1626          
00001ADC  BC3C 0001               1627          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
00001AE0  6700 005C               1628          BEQ         Addr_Reg_Direct
00001AE4                          1629          
00001AE4  BC3C 0002               1630          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
00001AE8  6700 006E               1631          BEQ         Addr_Reg_Indirect
00001AEC                          1632          
00001AEC  BC3C 0003               1633          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
00001AF0  6700 0098               1634          BEQ         Addr_Reg_Indirect_Inc
00001AF4                          1635          
00001AF4  BC3C 0004               1636          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
00001AF8  6700 00CE               1637          BEQ         Addr_Reg_Indirect_Dec
00001AFC                          1638          
00001AFC  BC3C 0007               1639          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
00001B00  6700 0006               1640          BEQ         Get_Effective_Address_Other
00001B04                          1641          
00001B04  6000 0138               1642          BRA         invalidEA
00001B08                          1643          
00001B08                          1644  Get_Effective_Address_Other:        
00001B08                          1645          
00001B08  BA3C 0000               1646          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00001B0C  6700 00F8               1647          BEQ Addr_Abs_Short
00001B10                          1648          
00001B10  BA3C 0001               1649          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
00001B14  6700 0104               1650          BEQ Addr_Abs_Long
00001B18                          1651          
00001B18  BA3C 0004               1652          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
00001B1C  6700 0110               1653          BEQ Addr_Immediate_Data
00001B20                          1654          
00001B20  6000 011C               1655          BRA         invalidEA
00001B24                          1656          
00001B24                          1657  Data_Reg_Direct:                        ;case 0(0000)
00001B24                          1658  
00001B24  43F9 00001E90           1659          LEA         letterD,A1          ;output 'D' for data register
00001B2A  103C 000E               1660          MOVE.B      #14,D0              ;set for task to display null terminated 
00001B2E  4E4F                    1661          TRAP        #15                 ;string without CR, LF
00001B30                          1662                          
00001B30  4281                    1663          CLR.L       D1
00001B32  1205                    1664          MOVE.B      D5,D1               ;move register number for display into D1
00001B34  103C 0003               1665          MOVE.B      #3,D0               ;set for task to display null terminated 
00001B38  4E4F                    1666          TRAP        #15                 ;string without CR, LF
00001B3A                          1667                 
00001B3A  6000 0102               1668          BRA         Get_Effective_Address_Exit  ;return
00001B3E                          1669          
00001B3E                          1670          
00001B3E                          1671  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
00001B3E                          1672        
00001B3E  43F9 00001E8E           1673          LEA         letterA,A1          ;output 'A' for address register
00001B44  103C 000E               1674          MOVE.B      #14,D0              ;set for task to display null terminated 
00001B48  4E4F                    1675          TRAP        #15                 ;string without CR, LF
00001B4A                          1676          
00001B4A  4281                    1677          CLR.L       D1
00001B4C  1205                    1678          MOVE.B      D5,D1               ;move register number for display into D1
00001B4E  103C 0003               1679          MOVE.B      #3,D0               ;set for task to display null terminated 
00001B52  4E4F                    1680          TRAP        #15                 ;string without CR, LF
00001B54                          1681          
00001B54  6000 00E8               1682          BRA         Get_Effective_Address_Exit  ;return
00001B58                          1683  
00001B58                          1684  
00001B58                          1685  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
00001B58                          1686          
00001B58  43F9 00001E96           1687          LEA         lprn,A1             ;output 'D' for data register
00001B5E  103C 000E               1688          MOVE.B      #14,D0              ;set for task to display null terminated 
00001B62  4E4F                    1689          TRAP        #15                 ;string without CR, LF
00001B64                          1690  
00001B64  43F9 00001E8E           1691          LEA         letterA,A1          ;output 'A' for address register
00001B6A  103C 000E               1692          MOVE.B      #14,D0              ;set for task to display null terminated 
00001B6E  4E4F                    1693          TRAP        #15                 ;string without CR, LF
00001B70                          1694          
00001B70  4281                    1695          CLR.L       D1
00001B72  1205                    1696          MOVE.B      D5,D1               ;move register number for display into D1
00001B74  103C 0003               1697          MOVE.B      #3,D0               ;set for task to display null terminated 
00001B78  4E4F                    1698          TRAP        #15                 ;string without CR, LF
00001B7A                          1699  
00001B7A  43F9 00001E98           1700          LEA         rprn,A1             ;output 'D' for data register
00001B80  103C 000E               1701          MOVE.B      #14,D0              ;set for task to display null terminated 
00001B84  4E4F                    1702          TRAP        #15                 ;string without CR, LF
00001B86                          1703          
00001B86  6000 00B6               1704          BRA         Get_Effective_Address_Exit  ;return
00001B8A                          1705  
00001B8A                          1706                 
00001B8A                          1707  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
00001B8A                          1708  
00001B8A  43F9 00001E96           1709          LEA         lprn,A1             ;output 'D' for data register
00001B90  103C 000E               1710          MOVE.B      #14,D0              ;set for task to display null terminated 
00001B94  4E4F                    1711          TRAP        #15                 ;string without CR, LF
00001B96                          1712  
00001B96  43F9 00001E8E           1713          LEA         letterA,A1          ;output 'A' for address register
00001B9C  103C 000E               1714          MOVE.B      #14,D0              ;set for task to display null terminated 
00001BA0  4E4F                    1715          TRAP        #15                 ;string without CR, LF
00001BA2                          1716          
00001BA2  4281                    1717          CLR.L       D1
00001BA4  1205                    1718          MOVE.B      D5,D1               ;move register number for display into D1
00001BA6  103C 0003               1719          MOVE.B      #3,D0               ;set for task to display null terminated 
00001BAA  4E4F                    1720          TRAP        #15                 ;string without CR, LF
00001BAC                          1721  
00001BAC  43F9 00001E98           1722          LEA         rprn,A1             ;output 'D' for data register
00001BB2  103C 000E               1723          MOVE.B      #14,D0              ;set for task to display null terminated 
00001BB6  4E4F                    1724          TRAP        #15                 ;string without CR, LF
00001BB8                          1725          
00001BB8  43F9 00001E92           1726          LEA         plus,A1             ;output 'D' for data register
00001BBE  103C 000E               1727          MOVE.B      #14,D0              ;set for task to display null terminated 
00001BC2  4E4F                    1728          TRAP        #15                 ;string without CR, LF
00001BC4                          1729          
00001BC4  6000 0078               1730          BRA         Get_Effective_Address_Exit  ;return
00001BC8                          1731  
00001BC8                          1732  Addr_Reg_Indirect_Dec                   ;4 = (An) - Address Register Indirect with Predecrement (100)
00001BC8                          1733  
00001BC8  43F9 00001E94           1734          LEA         minus,A1            ;output '-' for Predecrement
00001BCE  103C 000E               1735          MOVE.B      #14,D0              ;set for task to display null terminated 
00001BD2  4E4F                    1736          TRAP        #15                 ;string without CR, LF
00001BD4                          1737  
00001BD4  43F9 00001E96           1738          LEA         lprn,A1             ;output 'D' for data register
00001BDA  103C 000E               1739          MOVE.B      #14,D0              ;set for task to display null terminated 
00001BDE  4E4F                    1740          TRAP        #15                 ;string without CR, LF
00001BE0                          1741  
00001BE0  43F9 00001E8E           1742          LEA         letterA,A1          ;output 'A' for address register
00001BE6  103C 000E               1743          MOVE.B      #14,D0              ;set for task to display null terminated 
00001BEA  4E4F                    1744          TRAP        #15                 ;string without CR, LF
00001BEC                          1745          
00001BEC  4281                    1746          CLR.L       D1
00001BEE  1205                    1747          MOVE.B      D5,D1               ;move register number for display into D1
00001BF0  103C 0003               1748          MOVE.B      #3,D0               ;set for task to display null terminated 
00001BF4  4E4F                    1749          TRAP        #15                 ;string without CR, LF
00001BF6                          1750  
00001BF6  43F9 00001E98           1751          LEA         rprn,A1             ;output 'D' for data register
00001BFC  103C 000E               1752          MOVE.B      #14,D0              ;set for task to display null terminated 
00001C00  4E4F                    1753          TRAP        #15                 ;string without CR, LF
00001C02                          1754          
00001C02  6000 003A               1755          BRA         Get_Effective_Address_Exit  ;return
00001C06                          1756          
00001C06                          1757                         
00001C06                          1758  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00001C06                          1759          
00001C06                          1760          
00001C06  43F9 00001E70           1761          LEA         xxxW,A1             ;output 'D' for data register
00001C0C  103C 000E               1762          MOVE.B      #14,D0              ;set for task to display null terminated 
00001C10  4E4F                    1763          TRAP        #15                 ;string without CR, LF
00001C12                          1764  
00001C12  548B                    1765          ADDA.L      #word,A3
00001C14                          1766          
00001C14                          1767          ;print word (A3)
00001C14                          1768          ;MOVE.W      A3,(A1)
00001C14                          1769          ;MOVE.B      #1,D0               ;set for task to display null terminated 
00001C14                          1770          ;TRAP        #15                 ;string without CR, LF
00001C14                          1771          
00001C14  5487                    1772          ADDI.L      #word,D7 
00001C16  6000 0026               1773          BRA         Get_Effective_Address_Exit  ;return
00001C1A                          1774                         
00001C1A                          1775  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
00001C1A                          1776          
00001C1A  43F9 00001E7A           1777          LEA         xxxL,A1             ;output 'D' for data register
00001C20  103C 000E               1778          MOVE.B      #14,D0              ;set for task to display null terminated 
00001C24  4E4F                    1779          TRAP        #15                 ;string without CR, LF
00001C26                          1780  
00001C26  548B                    1781          ADDA.L      #word,A3
00001C28                          1782          
00001C28                          1783          ;print long (A3)
00001C28                          1784          ;MOVE.L      A3,(A1)
00001C28                          1785          ;MOVE.B      #14,D0              ;set for task to display null terminated 
00001C28                          1786          ;TRAP        #15                 ;string without CR, LF
00001C28                          1787          
00001C28  5887                    1788          ADDI.L      #long,D7
00001C2A  6000 0012               1789          BRA         Get_Effective_Address_Exit  ;return
00001C2E                          1790                         
00001C2E                          1791  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
00001C2E                          1792  
00001C2E  43F9 00001E84           1793          LEA         iData,A1            ;output 'D' for data register
00001C34  103C 000E               1794          MOVE.B      #14,D0              ;set for task to display null terminated 
00001C38  4E4F                    1795          TRAP        #15                 ;string without CR, LF
00001C3A                          1796          
00001C3A                          1797          *need another input param for size
00001C3A  6000 0002               1798          BRA         Get_Effective_Address_Exit  ;return
00001C3E                          1799  
00001C3E                          1800  invalidEA:
00001C3E                          1801  
00001C3E                          1802          ;do something
00001C3E                          1803   
00001C3E                          1804  Get_Effective_Address_Exit:     
00001C3E                          1805  
00001C3E  4E75                    1806          RTS                             ;return
00001C40                          1807  
00001C40                          1808  switchModeAndReg:
00001C40                          1809  ***
00001C40                          1810  * Assumed in D2
00001C40                          1811  *
00001C40                          1812  * Assumed that they are in least significant byte:
00001C40                          1813  *
00001C40                          1814  *            _this_
00001C40                          1815  *           /      \
00001C40                          1816  *  ........ ........
00001C40                          1817  *  \                /
00001C40                          1818  *   -----word-------
00001C40                          1819  *
00001C40                          1820  *  and that in that byte they are ordered:
00001C40                          1821  *
00001C40                          1822  *       ........   
00001C40                          1823  *       \/\_/\_/
00001C40                          1824  *      /  /    \
00001C40                          1825  *    /   /      \
00001C40                          1826  * dont  one    other
00001C40                          1827  * care
00001C40                          1828  *
00001C40                          1829  * after they will be
00001C40                          1830  *
00001C40                          1831  *       ........   
00001C40                          1832  *       \/\_/\_/
00001C40                          1833  *      /  /    \
00001C40                          1834  *    /   /      \
00001C40                          1835  * dont other    one
00001C40                          1836  * care
00001C40                          1837  *** 
00001C40  0202 003F               1838          AndI.B #%00111111,D2 ;remove unwanted bits from D2
00001C44  0283 00000000           1839          ANDI.L #0,D3 ;clear D3
00001C4A  1602                    1840          MOVE.B D2,D3 ;copy to D3
00001C4C  E70B                    1841          LSL.B  #3,D3 
00001C4E  E60A                    1842          LSR.B  #3,D2
00001C50  D403                    1843          ADD.B  D3,D2
00001C52  4E75                    1844          RTS
00001C54                          1845  
00001C54                          1846          
00001C54                          1847  *==============================================================================
00001C54                          1848  *                            variables and constants
00001C54                          1849  *==============================================================================
00001C54                          1850  
00001C54                          1851  
00001C54                          1852  ***initial user prompt stuff        
00001C54= 45 6E 74 65 72 20 ...   1853  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE: $',0
00001C85= 45 6E 74 65 72 20 ...   1854  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE: $',0
00001CB4                          1855  
00001CB4= 20 41 64 64 72 65 ...   1856  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
00001CF9= 20 41 20 43 68 61 ...   1857  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
00001D41                          1858  
00001D41= 20 59 6F 75 20 6D ...   1859  even_msg        DC.B    ' You must enter an even address!'
00001D61                          1860  
00001D61= 20                      1861  spc             DC.B    ' '
00001D62= 01                      1862  spc_len         DC.B    spc_len-spc
00001D63                          1863  ***
00001D63                          1864  
00001D63                          1865  
00001D63                          1866  
00001D63                          1867  ***list of OP codes
00001D63                          1868  
00001D63  =00009000               1869  subInstruction   EQU %1001000000000000
00001D63  =0000D000               1870  addaInstruction  EQU %1101000000000000
00001D63  =0000D000               1871  addInstruction   EQU %1101000000000000
00001D63  =00004880               1872  movemInstruction EQU %0100100010000000
00001D63  =00000600               1873  addiInstruction  EQU %0000011000000000
00001D63  =00000000               1874  oriInstruction   EQU 0
00001D63  =00000C00               1875  cmpiInstruction  EQU %0000110000000000
00001D63  =00004E80               1876  jsrInstruction   EQU %0100111010000000
00001D63  =00004E75               1877  rtsInstruction   EQU %0100111001110101
00001D63  =00004E71               1878  NoOpInstruction  EQU %0100111001110001
00001D63  =00000000               1879  moveInstruction  EQU 0
00001D63  =00006000               1880  bccInstruction   EQU %0110000000000000
00001D63  =00004400               1881  negInstruction   EQU %0100010000000000
00001D63  =00000000               1882  dataInstruction  EQU 0
00001D63                          1883  
00001D63                          1884  ***
00001D63                          1885  
00001D63                          1886  ***list of OP masks
00001D63                          1887  
00001D63  =0000F000               1888  subMask   EQU %1111000000000000
00001D63  =0000F000               1889  addaMask  EQU %1111000000000000
00001D63  =0000F000               1890  addMask   EQU %1111000000000000
00001D63  =0000FB80               1891  movemMask EQU %1111101110000000
00001D63  =0000FF00               1892  addiMask  EQU %1111111100000000
00001D63  =0000FF00               1893  oriMask   EQU %1111111100000000
00001D63  =0000FF00               1894  cmpiMask  EQU %1111111100000000
00001D63  =0000FFC0               1895  jsrMask   EQU %1111111111000000
00001D63  =0000FFFF               1896  rtsMask   EQU $FFFF
00001D63  =0000FFFF               1897  NoOpMask  EQU $FFFF
00001D63  =0000C000               1898  moveMask  EQU $C000
00001D63  =0000F000               1899  bccMask   EQU $F000
00001D63  =0000FF00               1900  negMask   EQU $FF00
00001D63  =00000000               1901  dataMask  EQU 0
00001D63                          1902  ***
00001D63                          1903  
00001D63                          1904  ***Bcc Codes***
00001D63  =00000004               1905  CC EQU $04
00001D63  =00000005               1906  CS EQU $05
00001D63  =00000007               1907  EQ EQU $07
00001D63  =0000000C               1908  GE EQU $0C
00001D63  =0000000E               1909  GT EQU $0E
00001D63  =00000002               1910  HI EQU $02
00001D63  =0000000F               1911  LE EQU $0F
00001D63  =00000003               1912  LS EQU $03
00001D63  =0000000D               1913  LT EQU $0D
00001D63  =0000000B               1914  MI EQU $0B
00001D63  =00000006               1915  NE EQU $06
00001D63  =0000000A               1916  PL EQU $0A
00001D63  =00000008               1917  VC EQU $08
00001D63  =00000009               1918  VS EQU $09
00001D63  =00000000               1919  RA EQU $00 ;not really a Condition Code
00001D63  =00000001               1920  SR EQU $01 ;not really a Condition Code
00001D63                          1921  
00001D63= 43 43 20 00             1922  CCm DC.B 'CC ',0
00001D67= 43 53 20 00             1923  CSm DC.B 'CS ',0
00001D6B= 45 51 20 00             1924  EQm DC.B 'EQ ',0
00001D6F= 47 45 20 00             1925  GEm DC.B 'GE ',0
00001D73= 47 54 20 00             1926  GTm DC.B 'GT ',0
00001D77= 48 49 20 00             1927  HIm DC.B 'HI ',0
00001D7B= 4C 45 20 00             1928  LEm DC.B 'LE ',0
00001D7F= 4C 53 20 00             1929  LSm DC.B 'LS ',0
00001D83= 4C 54 20 00             1930  LTm DC.B 'LT ',0
00001D87= 4D 49 20 00             1931  MIm DC.B 'MI ',0
00001D8B= 4E 45 20 00             1932  NEm DC.B 'NE ',0
00001D8F= 50 4C 20 00             1933  PLm DC.B 'PL ',0
00001D93= 56 43 20 00             1934  VCm DC.B 'VC ',0
00001D97= 56 53 20 00             1935  VSm DC.B 'VS ',0
00001D9B= 52 41 20 00             1936  RAm DC.B 'RA ',0
00001D9F= 53 52 20 00             1937  SRm DC.B 'SR ',0
00001DA3                          1938  
00001DA3= 01 04 05 07 0C 0E ...   1939  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
00001DB4= 00001D9F 00001D63 ...   1940  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
00001DF4                          1941  ***
00001DF4                          1942  
00001DF4= 45 6E 74 65 72 20 ...   1943  startLocationPrompt DC.B    'Enter start location',0
00001E09= 45 6E 74 65 72 20 ...   1944  endLocationPrompt   DC.B    'Enter end location',0
00001E1C                          1945  
00001E1C= 0D 0A 00                1946  clearLine  DC.B $0D,$0A,0
00001E1F                          1947  
00001E1F= 53 55 42 20 00          1948  subMessage      DC.B 'SUB ',0 
00001E24= 41 44 44 41 20 00       1949  addaMessage     DC.B 'ADDA ',0
00001E2A= 41 44 44 20 00          1950  addMessage      DC.B 'ADD ',0
00001E2F= 4D 4F 56 45 4D 20 00    1951  movemMessage    DC.B 'MOVEM ',0
00001E36= 41 44 44 49 20 00       1952  addiMessage     DC.B 'ADDI ',0
00001E3C= 4F 52 49 20 00          1953  oriMessage      DC.B 'ORI ',0
00001E41= 43 4D 50 49 20 00       1954  cmpiMessage     DC.B 'CMPI ',0
00001E47= 4A 53 52 20 00          1955  jsrMessage      DC.B 'JSR ',0
00001E4C= 52 54 53 20 00          1956  rtsMessage      DC.B 'RTS ',0
00001E51= 4E 4F 50 20 00          1957  nopMessage      DC.B 'NOP ',0 
00001E56= 4D 4F 56 45 20 00       1958  moveMessage     DC.B 'MOVE ',0
00001E5C= 42 00                   1959  bccMessage      DC.B 'B',0
00001E5E= 4E 45 47 20 00          1960  negMessage      DC.B 'NEG ',0
00001E63= 44 41 54 41 20 00       1961  dataMessage     DC.B 'DATA ',0
00001E69= 4D 4F 56 45 41 20 00    1962  moveaMessage    DC.B 'MOVEA ',0
00001E70                          1963  
00001E70= 28 78 78 78 29 2E ...   1964  xxxW            DC.B '(xxx).W: ',0
00001E7A= 28 78 78 78 29 2E ...   1965  xxxL            DC.B '(xxx).L: ',0
00001E84= 23 28 64 61 74 61 ...   1966  iData           DC.B '#(data): ',0
00001E8E                          1967  
00001E8E= 41 00                   1968  letterA         DC.B 'A', 0
00001E90= 44 00                   1969  letterD         DC.B 'D', 0
00001E92                          1970  
00001E92= 2B 00                   1971  plus            DC.B '+', 0
00001E94= 2D 00                   1972  minus           DC.B '-', 0
00001E96= 28 00                   1973  lPrn            DC.B '(', 0
00001E98= 29 00                   1974  rPrn            DC.B ')', 0
00001E9A                          1975  
00001E9A                          1976  
00001E9A= 00000000                1977  startLocation       DC.L    0
00001E9E= 00000000                1978  endLocation         DC.L    0
00001EA2                          1979  
00001EA2                          1980  
00001EA2                          1981     
00001EA2                          1982      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 12F4
ADDA                1256
ADDABODY            129E
ADDAINSTRUCTION     D000
ADDAMASK            F000
ADDAMESSAGE         1E24
ADDDEST             13B8
ADDDESTEA           12E8
ADDDESTEAMASKS      12EE
ADDI                1526
ADDIBODY            1552
ADDIDONE            1590
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         1E36
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          1E2A
ADDRESS_DONE        19B8
ADDRESS_EXIT        19B2
ADDR_ABS_LONG       1C1A
ADDR_ABS_SHORT      1C06
ADDR_IMMEDIATE_DATA  1C2E
ADDR_REG_DIRECT     1B3E
ADDR_REG_INDIRECT   1B58
ADDR_REG_INDIRECT_DEC  1BC8
ADDR_REG_INDIRECT_INC  1B8A
ADDSOURCE           1370
BCC                 186C
BCCBYTE             18BE
BCCDONE             18D4
BCCINSTRUCTION      6000
BCCLIST             1DA3
BCCLONG             18CC
BCCMASK             F000
BCCMESSAGE          1E5C
BCCWORD             18C4
BEGIN               5001
BEGIN_ADDRESS       1944
BYTE                1
CC                  4
CCM                 1D63
CHECKCC             1882
CHECKMOVEADEST      1818
CHECKMOVEDEST       1766
CHECKOPCODE         1050
CK_ADDR_DONE        1AC8
CK_ADDR_RANGE       1A9C
CK_ADDR_RANGE_ERROR  1AB8
CK_BOUNDRY          19E0
CK_BOUNDRY_ERROR    1A02
CK_SIZE_ERROR       1A16
CLEARLINE           1E1C
CMPI                1628
CMPIBODY            1650
CMPIDONE            168E
CMPIEA              161A
CMPIEAMASKS         1621
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         1E41
CONDITIONCODEMESSAGE  1DB4
CS                  5
CSM                 1D67
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         1E63
DATA_REG_DIRECT     1B24
ELPROMPT            1C85
END                 FFFFFE
ENDLOCATION         1E9E
ENDLOCATIONPROMPT   1E09
END_ADDRESS         1988
ENTER_ADDR_EDIT_ALL  19BA
ENTER_ADDR_EDIT_ALL_EXIT  19DE
EQ                  7
EQM                 1D6B
EVEN_MSG            1D41
FALSEPOSITIVE       1070
FARLABEL            FFE
FIN                 1940
FOUNDCC             1894
GE                  C
GEM                 1D6F
GET_EFFECTIVE_ADDRESS  1ACC
GET_EFFECTIVE_ADDRESS_EXIT  1C3E
GET_EFFECTIVE_ADDRESS_OTHER  1B08
GT                  E
GTM                 1D73
HANDLEBYTEDATA      1914
HEX_RANGE_ERROR     1A84
HI                  2
HIM                 1D77
IDATA               1E84
INSTLABELLIST       10CE
INSTMASKLIST        10B2
INSTOPLIST          1096
INVALIDEA           1C3E
INVALIDMSG          1CB4
INVCHARMSG          1CF9
JSR                 16A6
JSRBODY             16CE
JSRDONE             16EE
JSREA               169E
JSREAMASKS          16A2
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          1E47
LCASEHEX            1A66
LE                  F
LEM                 1D7B
LETTERA             1E8E
LETTERD             1E90
LONG                4
LPRN                1E96
LS                  3
LSM                 1D7F
LT                  D
LTM                 1D83
MAIN_LOOP           1026
MATCH               1076
MI                  B
MIM                 1D87
MINUS               1E94
MOVE                173E
MOVEA               17F0
MOVEABODY           1846
MOVEADESTEA         17EC
MOVEADESTEAMASKS    17EE
MOVEAMESSAGE        1E69
MOVEBODY            1794
MOVEDESTEA          1730
MOVEDESTEAMASKS     1737
MOVEINSTRUCTION     0
MOVEM               1414
MOVEMASK            C000
MOVEMBODY           147E
MOVEMESSAGE         1E56
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     140A
MOVEMMEMTOREGEAMASKS  140F
MOVEMMESSAGE        1E2F
MOVEMREGTOMEMEA     1400
MOVEMREGTOMEMEAMASKS  1405
MOVESOURCEEA        171E
MOVESOURCEEAMASKS   1727
NE                  6
NEG                 14C0
NEGBODY             14E8
NEGDONE             1516
NEGEA               14B0
NEGEAMASKS          14B8
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          1E5E
NEM                 1D8B
NEXTHEX             1A2C
NEXTHEXDONE         1A7E
NEXTHEXRETURN       1A9A
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 16FE
NOPMESSAGE          1E51
ORI                 15A0
ORIBODY             15CC
ORIDONE             160A
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          1E3C
PARSEHEXSTRING      1A2A
PL                  A
PLM                 1D8F
PLUS                1E92
PRGORG              1000
PROCESS_OP_CODES    1ACA
PROCESS_OP_CODES_EXIT  1ACA
PROMPT_USER         1014
RA                  0
RAM                 1D9B
RPRN                1E98
RTS                 170E
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          1E4C
SLPROMPT            1C54
SNIPPET             1106
SNIPPETEND          1142
SPC                 1D61
SPC_LEN             1D62
SR                  1
SRM                 1D9F
STACK               5000
START               1000
STARTLOCATION       1E9A
STARTLOCATIONPROMPT  1DF4
SUB                 1146
SUBDEST             120E
SUBINSTRUCTION      9000
SUBMASK             F000
SUBMESSAGE          1E1F
SUBSOURCE           11C6
SWITCHMODEANDREG    1C40
UCASEHEX            1A4E
UNKNOWNOPCODE       18EE
VALIDADDA           1274
VALIDADDDESTEA      1344
VALIDADDIMODES      1528
VALIDADDSOURCEEA    131A
VALIDCMPIMODES      162A
VALIDJSRMODES       16A8
VALIDMEMTOREG       1450
VALIDMOVEADESTMODES  181A
VALIDMOVEASOURCEMODES  17F2
VALIDMOVEDESTMODES  1768
VALIDMOVESOURCEMODES  1740
VALIDNEGMODES       14C2
VALIDORIMODES       15A2
VALIDREGTOMEM       142A
VALIDSUBDESTEA      1196
VALIDSUBSOURCEEA    116C
VC                  8
VCM                 1D93
VS                  9
VSM                 1D97
WORD                2
XXXL                1E7A
XXXW                1E70

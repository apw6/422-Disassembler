00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/9/2014 5:21:06 AM

00000000                             1  *##########################################################################
00000000                             2  * Title      : 
00000000                             3  * Written by : Andrew Watson
00000000                             4  *            : Elaine Keller
00000000                             5  *            : Robert Anderson
00000000                             6  * Date       : 11/14/2014
00000000                             7  * Description: 
00000000                             8  *##########################################################################
00000000                             9  
00000000                            10  ***Possible Bug***
00000000                            11  *can not tell data from an
00000000                            12  *unidentified instruction from an actual
00000000                            13  *instruction therefore causing errors.
00000000                            14  *may not actually be a bug because data
00000000                            15  *is data to the machine, and if you modify
00000000                            16  *the instructions in memory for a program
00000000                            17  *by moivng data, you can modify the instuctions
00000000                            18  *executed.
00000000                            19  
00000000                            20  
00000000                            21  ***************************************************************************
00000000                            22  *                   Variable/Data Definitions
00000000                            23  ***************************************************************************
00000000                            24  
00000000  =00005000                 25  stack   EQU   $00005000
00000000  =00005001                 26  begin   EQU   $00005001
00000000  =00FFFFFE                 27  end     EQU   $00FFFFFE
00000000  =00000001                 28  byte    EQU   1
00000000  =00000002                 29  word    EQU   2
00000000  =00000004                 30  long    EQU   4
00000000  =00001000                 31  prgorg  EQU   $1000
00000000                            32  
00000FFE                            33      ORG $00000FFE
00000FFE                            34  FarLabel:
00001000                            35      ORG    prgorg
00001000                            36  start:
00001000  4FF8 5000                 37          LEA stack, SP ;initialize stack
00001004                            38  
00001000                            39      ORG    prgorg
00001000                            40  
00001000                            41  ******************************************************************************
00001000                            42  *                   Begin processing active code
00001000                            43  ******************************************************************************
00001000                            44      
00001000                            45  start:
00001000                            46  
00001000  4FF8 5000                 47          LEA         stack, SP           ;Initialize stack
00001004                            48          
00001004                            49  *.............................................................................
00001004                            50  * Debug Mode - Comment out when done
00001004  267C 0000113E             51          MOVE.L      #snippet,A3
0000100A  287C 000011B4             52          MOVE.L      #snippetEnd,A4
00001010  6000 0014                 53          BRA         main_Loop
00001014                            54  * Debug Mode - Comment out when done
00001014                            55  *.............................................................................        
00001014                            56          
00001014                            57  prompt_user:
00001014                            58  
00001014  6100 0D0A                 59          BSR         begin_address
00001018  B67C FFFF                 60          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000101C  6700 0CFE                 61          BEQ         fin                 ;Yes, then exit
00001020                            62          
00001020  6000 0004                 63          BRA         main_Loop
00001024                            64          ;BSR         process_op_codes
00001024  60EE                      65          BRA         prompt_user
00001026                            66                  
00001026                            67  ******************************************************************************
00001026                            68  *                   Begin processing OP Codes
00001026                            69  ******************************************************************************
00001026                            70   
00001026                            71  main_Loop:
00001026                            72  
00001026  B9CB                      73          CMPA.L A3,A4 ;check end of prog
00001028  6700 0CF2                 74          BEQ fin
0000102C                            75          
0000102C  3213                      76          MOVE.W (A3),D1 ;copy word from other prog to analyze as instruction
0000102E                            77          
0000102E                            78          ;handle an odd memory access(instructions will never be misaligned)
0000102E  240B                      79          MOVE.L A3,D2 ; copy address to D2
00001030  0202 0001                 80          ANDI.B #%00000001,D2 ;mask everything except the least significant bit
00001034  0C02 0001                 81          CMPI.B #1,D2 ;compare the least sig bit of the address to one
00001038  6700 0CB6                 82          BEQ handlebytedata ;the least sig bit will only be one if the insrtuction
0000103C                            83                             ;is odd(misaligned) and therefore not an instruction
0000103C                            84          
0000103C  7600                      85          MOVEQ.L #0,D3
0000103E                            86          
0000103E                            87          ***things to save A3,A4,D1(?)***
0000103E  48E7 0018                 88          MOVEM.L A3-A4,-(SP)
00001042  6100 000C                 89          BSR checkOPcode
00001046  4CDF 1800                 90          MOVEM.L (SP)+,A3-A4
0000104A  D7C7                      91          ADDA.L  D7,A3 ;look past data that was part of the instruction
0000104C                            92          
0000104C  548B                      93          ADDQ.L  #word,A3
0000104E  60D6                      94          BRA     main_Loop 
00001050                            95          
00001050                            96  checkOPcode:
00001050                            97  
00001050                            98  
00001050  7E00                      99          MOVEQ.L #0,D7
00001052                           100          
00001052  41F9 00001096            101          LEA     instOPList,A0 ;get instruction signitrue list in A0
00001058  D1C3                     102          ADDA.L  D3,A0 ;get correct sig         
0000105A                           103          
0000105A  43F9 000010C0            104          LEA     instMaskList,A1 ;get instruction mask in A1
00001060  D3C3                     105          ADDA.L  D3,A1  ;get correct mast
00001062                           106          
00001062  3401                     107          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001064                           108          
00001064  C451                     109          AND.W   (A1),D2 ;mask instruction
00001066                           110          
00001066                           111          
00001066                           112          
00001066                           113          
00001066  B450                     114          CMP.W   (A0),D2 ;compare to sig
00001068  6700 000C                115          BEQ     match ;if sig matches branch
0000106C  5483                     116          ADDQ.L  #word,D3 ;add to D3 to check for next instruction
0000106E  60E0                     117          BRA checkOPcode
00001070                           118          
00001070                           119  falsePositive:
00001070                           120          
00001070  103C 00FF                121          MOVE.B #-1,D0
00001074  4E75                     122          RTS
00001076                           123  
00001076                           124  match:
00001076                           125          
00001076  43F9 000010EA            126          LEA     instLabelList,A1 ;get instruction code label
0000107C  D3C3                     127          ADDA.L  D3,A1 ;get correct label
0000107E  D3C3                     128          ADDA.L  D3,A1
00001080  5483                     129          ADDQ.L  #word,D3 ;add to D3 incase false positive
00001082  2251                     130          MOVEA.L (A1),A1
00001084  48E7 1000                131          MOVEM.L D3,-(SP) ; save D3
00001088  4E91                     132          JSR     (A1)
0000108A  4CDF 0008                133          MOVEM.L (SP)+,D3 ;restore D3
0000108E  B03C 00FF                134          CMP.B   #-1,D0
00001092  67BC                     135          BEQ     checkOPcode
00001094  4E75                     136          RTS
00001096                           137          
00001096                           138  
00001096= E6C0 E018 E0C0 E...      139  instOPList  DC.W rsrlweaInstruction,rsrlregInstruction,asrlweaInstruction,asrlregInstruction,lsrlweaInstruction,lsrlregInstruction
000010A2= 5100 9000 D000 D...      140  instOPList2 DC.W subqInstruction,subInstruction,addaInstruction,addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruct
000010C0                           141      
000010C0= FEC0 F018 FEC0 F...      142  instMaskList DC.W rsrlweaMask,rsrlregMask,asrlweaMask,asrlregMask,lsrlweaMask,lsrlregMask,subqMask,subMask,addaMask,addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
000010EA= 000011B8 00001218 ...    143  instLabelList DC.L RSRLWEA,RSRLREG,ASRLWEA,ASRLREG,LSRLWEA,LSRLREG,SUBQ,SUB,ADDA,ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
0000113E                           144  
0000113E                           145  snippet:
0000113E  4E71                     146           NOP
00001140  60FC                     147           BRA snippet
00001142  6000 FEBA                148           BRA FarLabel
00001146  67F6                     149           BEQ snippet
00001148  6E00 0752                150           BGT NEG
0000114C  61F0                     151           BSR snippet
0000114E  4441                     152           NEG D1
00001150  3239 00008500            153           MOVE.W $8500,D1
00001156  0645 001E                154           ADDI.W #30,D5
0000115A  4E75                     155           RTS
0000115C  4EB8 0054                156           JSR $54
00001160  0C41 0003                157           CMPI #3,D1
00001164  0041 0003                158           ORI  #3,D1
00001168  48E7 0018                159           MOVEM.L A3-A4,-(SP)
0000116C  D401                     160           ADD.B D1,D2
0000116E  0603 000A                161           ADD.B #10,D3
00001172  D7FC 00000463            162           ADDA.L #1123,A3
00001178  9A43                     163           SUB.W D3,D5
0000117A  5105                     164           SUBQ.B #8,D5
0000117C  5305                     165           SUBQ.B #1,D5
0000117E  E64B                     166           LSR #3,D3
00001180  E74C                     167           LSL #3,D4
00001182  E369                     168           LSL D1,D1
00001184  E66F                     169           LSR D3,D7
00001186  E2F8 3563                170           LSR $3563
0000118A  E3F9 00486412            171           LSL $486412
00001190  E643                     172           ASR #3,D3
00001192  E744                     173           ASL #3,D4
00001194  E361                     174           ASL D1,D1
00001196  E667                     175           ASR D3,D7
00001198  E0F8 3563                176           ASR $3563
0000119C  E1F9 00486412            177           ASL $486412
000011A2  E65B                     178           ROR #3,D3
000011A4  E75C                     179           ROL #3,D4
000011A6  E379                     180           ROL D1,D1
000011A8  E67F                     181           ROR D3,D7
000011AA  E6F8 3563                182           ROR $3563
000011AE  E7F9 00486412            183           ROL $486412
000011B4                           184  
000011B4                           185           
000011B4                           186  snippetEnd:
000011B4  FFFF FFFF                187           SIMHALT
000011B8                           188  
000011B8                           189  
000011B8                           190  RSRLWEA:
000011B8                           191          
000011B8                           192  
000011B8                           193          
000011B8  7000                     194          MOVEQ.L #0, D0 ;clear D0
000011BA                           195          
000011BA                           196  validRSRL:
000011BA                           197          
000011BA  43F9 0000130A            198          LEA lsrlEAmasks,A1 ;load the list of masks
000011C0  D3C0                     199          ADDA.L D0,A1 ;displace to a specific mask
000011C2  1A11                     200          MOVE.B (A1),D5 ;move the mask to D5
000011C4                           201          
000011C4  0C05 0000                202          CMPI.B #0,D5 ;check if the mask is 0
000011C8  6700 FEA6                203          BEQ falsePositive ;branch if it is
000011CC                           204          
000011CC  1401                     205          MOVE.B D1,D2 ;copy instruction to D2
000011CE  C405                     206          AND.B D5,D2  ;mask D2
000011D0                           207          
000011D0  43F9 00001304            208          LEA lsrlEA,A1 ;load the list of valid modes
000011D6  D3C0                     209          ADDA.L D0,A1 ;displace to a specific mode
000011D8  1811                     210          MOVE.B (A1),D4 ;move mode to D4
000011DA  B404                     211          CMP.B D4,D2 ;compare mode to masked value
000011DC  6700 0006                212          BEQ  rsrlweaCheckDirection ;if its match, its a valid mode and we can procede
000011E0                           213          
000011E0  5280                     214          ADDQ.L #1,D0 ;add one to displacement
000011E2  60D6                     215          BRA validRSRL ;check for next mode
000011E4                           216  
000011E4                           217  rsrlweaCheckDirection:
000011E4                           218          ;Figure out which direction we are going
000011E4  3401                     219          MOVE.W D1,D2 ;copy inst to D2
000011E6  E04A                     220          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000011E8  0202 0001                221          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000011EC  0C02 0000                222          CMPI.B #0,D2 ;compare bit to zero
000011F0  6700 0006                223          BEQ RSREA ;if zero, right
000011F4  6000 0012                224          BRA RSLEA ;else, its left
000011F8                           225  
000011F8                           226  RSREA:
000011F8                           227  
000011F8  43F9 00002200            228          LEA     rsrMessage,A1  ;move string for MOVE
000011FE  103C 000E                229          MOVE.B  #14,D0        ;set for task to display null terminated 
00001202                           230                                ;string with CR, LF
00001202  4E4F                     231          TRAP    #15
00001204  6000 0166                232          BRA lsrlweaBody
00001208                           233          
00001208                           234  RSLEA:
00001208                           235          
00001208  43F9 000021FB            236          LEA     rslMessage,A1  ;move string for MOVE
0000120E  103C 000E                237          MOVE.B  #14,D0        ;set for task to display null terminated 
00001212                           238                                ;string with CR, LF
00001212  4E4F                     239          TRAP    #15
00001214  6000 0156                240          BRA lsrlweaBody        
00001218                           241          
00001218                           242  
00001218                           243  
00001218                           244  RSRLREG:
00001218                           245          
00001218                           246  
00001218                           247          
00001218  7000                     248          MOVEQ.L #0, D0 ;clear D0
0000121A                           249          
0000121A                           250          ;check valid size field
0000121A  3401                     251          MOVE.W D1,D2 ;copy inst to D2
0000121C  EC4A                     252          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
0000121E  0202 0003                253          ANDI.B #%00000011,D2 ;mask out rest of byte
00001222  0C02 0003                254          CMPI.B #%11,D2 ;compare to 3
00001226  6700 FE48                255          BEQ falsePositive ;invalid size
0000122A                           256  
0000122A                           257          
0000122A                           258          ;Figure out which direction we are going
0000122A  3401                     259          MOVE.W D1,D2 ;copy inst to D2
0000122C  E04A                     260          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
0000122E  0202 0001                261          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
00001232  0C02 0000                262          CMPI.B #0,D2 ;compare bit to zero
00001236  6700 0006                263          BEQ RSRreg ;if zero, right
0000123A  6000 0012                264          BRA RSLreg ;else, its left        
0000123E                           265          
0000123E                           266  RSRreg:
0000123E                           267  
0000123E  43F9 00002200            268          LEA     rsrMessage,A1  ;move string for MOVE
00001244  103C 000E                269          MOVE.B  #14,D0        ;set for task to display null terminated 
00001248                           270                                ;string with CR, LF
00001248  4E4F                     271          TRAP    #15
0000124A  6000 018A                272          BRA LSRLregBody
0000124E                           273          
0000124E                           274  RSLreg:
0000124E                           275          
0000124E  43F9 000021FB            276          LEA     rslMessage,A1  ;move string for MOVE
00001254  103C 000E                277          MOVE.B  #14,D0        ;set for task to display null terminated 
00001258                           278                                ;string with CR, LF
00001258  4E4F                     279          TRAP    #15
0000125A  6000 017A                280          BRA LSRLregBody
0000125E                           281  
0000125E                           282       
0000125E                           283  
0000125E                           284  ASRLWEA:
0000125E                           285          
0000125E                           286  
0000125E                           287          
0000125E  7000                     288          MOVEQ.L #0, D0 ;clear D0
00001260                           289          
00001260                           290  validASRL:
00001260                           291          
00001260  43F9 0000130A            292          LEA lsrlEAmasks,A1 ;load the list of masks
00001266  D3C0                     293          ADDA.L D0,A1 ;displace to a specific mask
00001268  1A11                     294          MOVE.B (A1),D5 ;move the mask to D5
0000126A                           295          
0000126A  0C05 0000                296          CMPI.B #0,D5 ;check if the mask is 0
0000126E  6700 FE00                297          BEQ falsePositive ;branch if it is
00001272                           298          
00001272  1401                     299          MOVE.B D1,D2 ;copy instruction to D2
00001274  C405                     300          AND.B D5,D2  ;mask D2
00001276                           301          
00001276  43F9 00001304            302          LEA lsrlEA,A1 ;load the list of valid modes
0000127C  D3C0                     303          ADDA.L D0,A1 ;displace to a specific mode
0000127E  1811                     304          MOVE.B (A1),D4 ;move mode to D4
00001280  B404                     305          CMP.B D4,D2 ;compare mode to masked value
00001282  6700 0006                306          BEQ  asrlweaCheckDirection ;if its match, its a valid mode and we can procede
00001286                           307          
00001286  5280                     308          ADDQ.L #1,D0 ;add one to displacement
00001288  60D6                     309          BRA validASRL ;check for next mode
0000128A                           310  
0000128A                           311  asrlweaCheckDirection:
0000128A                           312          ;Figure out which direction we are going
0000128A  3401                     313          MOVE.W D1,D2 ;copy inst to D2
0000128C  E04A                     314          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
0000128E  0202 0001                315          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
00001292  0C02 0000                316          CMPI.B #0,D2 ;compare bit to zero
00001296  6700 0006                317          BEQ ASREA ;if zero, right
0000129A  6000 0012                318          BRA ASLEA ;else, its left
0000129E                           319  
0000129E                           320  ASREA:
0000129E                           321  
0000129E  43F9 0000220A            322          LEA     asrMessage,A1  ;move string for MOVE
000012A4  103C 000E                323          MOVE.B  #14,D0        ;set for task to display null terminated 
000012A8                           324                                ;string with CR, LF
000012A8  4E4F                     325          TRAP    #15
000012AA  6000 00C0                326          BRA lsrlweaBody
000012AE                           327          
000012AE                           328  ASLEA:
000012AE                           329          
000012AE  43F9 00002205            330          LEA     aslMessage,A1  ;move string for MOVE
000012B4  103C 000E                331          MOVE.B  #14,D0        ;set for task to display null terminated 
000012B8                           332                                ;string with CR, LF
000012B8  4E4F                     333          TRAP    #15
000012BA  6000 00B0                334          BRA lsrlweaBody        
000012BE                           335          
000012BE                           336  
000012BE                           337  
000012BE                           338  ASRLREG:
000012BE                           339          
000012BE                           340  
000012BE                           341          
000012BE  7000                     342          MOVEQ.L #0, D0 ;clear D0
000012C0                           343          
000012C0                           344          ;check valid size field
000012C0  3401                     345          MOVE.W D1,D2 ;copy inst to D2
000012C2  EC4A                     346          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
000012C4  0202 0003                347          ANDI.B #%00000011,D2 ;mask out rest of byte
000012C8  0C02 0003                348          CMPI.B #%11,D2 ;compare to 3
000012CC  6700 FDA2                349          BEQ falsePositive ;invalid size
000012D0                           350  
000012D0                           351          
000012D0                           352          ;Figure out which direction we are going
000012D0  3401                     353          MOVE.W D1,D2 ;copy inst to D2
000012D2  E04A                     354          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000012D4  0202 0001                355          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000012D8  0C02 0000                356          CMPI.B #0,D2 ;compare bit to zero
000012DC  6700 0006                357          BEQ ASRreg ;if zero, right
000012E0  6000 0012                358          BRA ASLreg ;else, its left        
000012E4                           359          
000012E4                           360  ASRreg:
000012E4                           361  
000012E4  43F9 0000220A            362          LEA     asrMessage,A1  ;move string for MOVE
000012EA  103C 000E                363          MOVE.B  #14,D0        ;set for task to display null terminated 
000012EE                           364                                ;string with CR, LF
000012EE  4E4F                     365          TRAP    #15
000012F0  6000 00E4                366          BRA LSRLregBody
000012F4                           367          
000012F4                           368  ASLreg:
000012F4                           369          
000012F4  43F9 00002205            370          LEA     aslMessage,A1  ;move string for MOVE
000012FA  103C 000E                371          MOVE.B  #14,D0        ;set for task to display null terminated 
000012FE                           372                                ;string with CR, LF
000012FE  4E4F                     373          TRAP    #15
00001300  6000 00D4                374          BRA LSRLregBody
00001304                           375  
00001304                           376  
00001304= 10 18 20 38 39 00        377  lsrlEA        DC.B %010000,%011000,%100000,%111000,%111001,0
0000130A= 38 38 38 3F 3F 00        378  lsrlEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0       
00001310                           379  
00001310                           380  LSRLWEA:
00001310                           381          
00001310                           382  
00001310                           383          
00001310  7000                     384          MOVEQ.L #0, D0 ;clear D0
00001312                           385          
00001312                           386  validLSRL:
00001312                           387          
00001312  43F8 130A                388          LEA lsrlEAmasks,A1 ;load the list of masks
00001316  D3C0                     389          ADDA.L D0,A1 ;displace to a specific mask
00001318  1A11                     390          MOVE.B (A1),D5 ;move the mask to D5
0000131A                           391          
0000131A  0C05 0000                392          CMPI.B #0,D5 ;check if the mask is 0
0000131E  6700 FD50                393          BEQ falsePositive ;branch if it is
00001322                           394          
00001322  1401                     395          MOVE.B D1,D2 ;copy instruction to D2
00001324  C405                     396          AND.B D5,D2  ;mask D2
00001326                           397          
00001326  43F8 1304                398          LEA lsrlEA,A1 ;load the list of valid modes
0000132A  D3C0                     399          ADDA.L D0,A1 ;displace to a specific mode
0000132C  1811                     400          MOVE.B (A1),D4 ;move mode to D4
0000132E  B404                     401          CMP.B D4,D2 ;compare mode to masked value
00001330  6700 0006                402          BEQ  lsrlweaCheckDirection ;if its match, its a valid mode and we can procede
00001334                           403          
00001334  5280                     404          ADDQ.L #1,D0 ;add one to displacement
00001336  60DA                     405          BRA validLSRL ;check for next mode
00001338                           406  
00001338                           407  lsrlweaCheckDirection:
00001338                           408          ;Figure out which direction we are going
00001338  3401                     409          MOVE.W D1,D2 ;copy inst to D2
0000133A  E04A                     410          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
0000133C  0202 0001                411          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
00001340  0C02 0000                412          CMPI.B #0,D2 ;compare bit to zero
00001344  6700 0006                413          BEQ LSREA ;if zero, right
00001348  6000 0012                414          BRA LSLEA ;else, its left
0000134C                           415  
0000134C                           416  LSREA:
0000134C                           417  
0000134C  43F9 00002214            418          LEA     lsrMessage,A1  ;move string for MOVE
00001352  103C 000E                419          MOVE.B  #14,D0        ;set for task to display null terminated 
00001356                           420                                ;string with CR, LF
00001356  4E4F                     421          TRAP    #15
00001358  6000 0012                422          BRA lsrlweaBody
0000135C                           423          
0000135C                           424  LSLEA:
0000135C                           425          
0000135C  43F9 0000220F            426          LEA     lslMessage,A1  ;move string for MOVE
00001362  103C 000E                427          MOVE.B  #14,D0        ;set for task to display null terminated 
00001366                           428                                ;string with CR, LF
00001366  4E4F                     429          TRAP    #15
00001368  6000 0002                430          BRA lsrlweaBody        
0000136C                           431          
0000136C                           432  lsrlweaBody:
0000136C                           433  
0000136C                           434          
0000136C  3401                     435          MOVE.W  D1,D2 ;check mode
0000136E  C43C 003F                436          AND.B   #%00111111,D2
00001372  1A02                     437          MOVE.B  D2,D5
00001374  48E7 4000                438          MOVEM.L D1,-(SP)
00001378  6100 0B2E                439          BSR     Get_Effective_Address
0000137C  4CDF 0002                440          MOVEM.L (SP)+,D1
00001380                           441          
00001380                           442          
00001380  43F9 000021F8            443          LEA     clearLine,A1  ;move string for a CR and LF
00001386  103C 000E                444          MOVE.B  #14,D0        ;set for task to display null terminated 
0000138A                           445                                ;string without CR, LF
0000138A  4E4F                     446          TRAP    #15
0000138C                           447  
0000138C  7000                     448          MOVEQ.L #0,D0
0000138E  4E75                     449          RTS
00001390                           450  
00001390                           451  
00001390                           452  LSRLREG:
00001390                           453          
00001390                           454  
00001390                           455          
00001390  7000                     456          MOVEQ.L #0, D0 ;clear D0
00001392                           457          
00001392                           458          ;check valid size field
00001392  3401                     459          MOVE.W D1,D2 ;copy inst to D2
00001394  EC4A                     460          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
00001396  0202 0003                461          ANDI.B #%00000011,D2 ;mask out rest of byte
0000139A  0C02 0003                462          CMPI.B #%11,D2 ;compare to 3
0000139E  6700 FCD0                463          BEQ falsePositive ;invalid size
000013A2                           464  
000013A2                           465          
000013A2                           466          ;Figure out which direction we are going
000013A2  3401                     467          MOVE.W D1,D2 ;copy inst to D2
000013A4  E04A                     468          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000013A6  0202 0001                469          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000013AA  0C02 0000                470          CMPI.B #0,D2 ;compare bit to zero
000013AE  6700 0006                471          BEQ LSRreg ;if zero, right
000013B2  6000 0012                472          BRA LSLreg ;else, its left        
000013B6                           473          
000013B6                           474  LSRreg:
000013B6                           475  
000013B6  43F9 00002214            476          LEA     lsrMessage,A1  ;move string for MOVE
000013BC  103C 000E                477          MOVE.B  #14,D0        ;set for task to display null terminated 
000013C0                           478                                ;string with CR, LF
000013C0  4E4F                     479          TRAP    #15
000013C2  6000 0012                480          BRA LSRLregBody
000013C6                           481          
000013C6                           482  LSLreg:
000013C6                           483          
000013C6  43F9 0000220F            484          LEA     lslMessage,A1  ;move string for MOVE
000013CC  103C 000E                485          MOVE.B  #14,D0        ;set for task to display null terminated 
000013D0                           486                                ;string with CR, LF
000013D0  4E4F                     487          TRAP    #15
000013D2  6000 0002                488          BRA LSRLregBody
000013D6                           489          
000013D6                           490  LSRLregBody:
000013D6                           491                      
000013D6                           492          ;check i/r
000013D6  48E7 4000                493          MOVEM.L D1,-(SP)
000013DA  6100 002A                494          BSR LSRLcheckIR
000013DE  4CDF 0002                495          MOVEM.L (SP)+,D1
000013E2                           496          
000013E2  3401                     497          MOVE.W  D1,D2 ;check mode
000013E4  C43C 0007                498          AND.B   #%00000111,D2
000013E8  1A02                     499          MOVE.B  D2,D5
000013EA  48E7 4000                500          MOVEM.L D1,-(SP)
000013EE  6100 0AB8                501          BSR     Get_Effective_Address
000013F2  4CDF 0002                502          MOVEM.L (SP)+,D1
000013F6                           503          
000013F6                           504          
000013F6  43F9 000021F8            505          LEA     clearLine,A1  ;move string for a CR and LF
000013FC  103C 000E                506          MOVE.B  #14,D0        ;set for task to display null terminated 
00001400                           507                                ;string without CR, LF
00001400  4E4F                     508          TRAP    #15
00001402                           509  
00001402  7000                     510          MOVEQ.L #0,D0
00001404  4E75                     511          RTS
00001406                           512  
00001406                           513  LSRLcheckIR:
00001406                           514  
00001406  1401                     515          MOVE.B D1,D2 ;move inst to D2
00001408  EA0A                     516          LSR.B  #5,D2
0000140A  C43C 0001                517          AND.B  #%00000001,D2
0000140E  0C02 0000                518          CMPI.B #0,D2
00001412  6700 0008                519          BEQ  LSRLcheckI
00001416  6000 0038                520          BRA  LSRLcheckR
0000141A                           521  LSRLcheckIRreturn:
0000141A  4E75                     522          RTS
0000141C                           523          
0000141C                           524  LSRLcheckI:
0000141C                           525          ;print '#'
0000141C  48E7 4000                526          MOVEM.L D1,-(SP) ;save D1 to the stack
00001420  123C 0023                527          MOVE.B #'#',D1 ;put ascii value of '#' in D1
00001424  103C 0006                528          MOVE.B #6,D0 ;move task 6 into D0
00001428  4E4F                     529          TRAP #15 ;prin char
0000142A  4CDF 0002                530          MOVEM.L (SP)+,D1 ;pull D1 off the stack
0000142E                           531          
0000142E                           532          ;print number
0000142E  48E7 4000                533          MOVEM.L D1,-(SP)
00001432  3401                     534          MOVE.W D1,D2 ;copy inst to d2
00001434  E04A                     535          LSR.W #8,D2 ;shift data section
00001436  E20A                     536          LSR.B #1,D2
00001438  C43C 0007                537          AND.B #%00000111,D2 ;mask out rest of data
0000143C  6100 00D6                538          BSR ZeroToEight ;handle zero
00001440  7200                     539          MOVEQ.L #0,D1 ;clear D1
00001442  1202                     540          MOVE.B D2,D1 ;move number to display into D1
00001444  103C 0003                541          MOVE.B #3,D0 ;move task 3 to D0
00001448  4E4F                     542          TRAP #15
0000144A  4CDF 0002                543          MOVEM.L (SP)+,D1
0000144E  60CA                     544          BRA LSRLcheckIRreturn
00001450                           545          
00001450                           546  LSRLcheckR:
00001450  3401                     547          MOVE.W D1,D2 ;copy inst to d2
00001452  E04A                     548          LSR.W #8,D2 ;shift data section
00001454  E20A                     549          LSR.B #1,D2
00001456  C43C 0007                550          AND.B #%00000111,D2 ;mask out rest of data
0000145A  1A02                     551          MOVE.B D2,D5 ;force Dn
0000145C  48E7 4000                552          MOVEM.L D1,-(SP)
00001460  6100 0A46                553          BSR     Get_Effective_Address
00001464  4CDF 0002                554          MOVEM.L (SP)+,D1
00001468  60B0                     555          BRA LSRLcheckIRreturn
0000146A                           556          
0000146A= 00 08 10 18 20 38 ...    557  subqEA        DC.B %000000,%001000,%010000,%011000,%100000,%111000,%111001,0
00001472= 38 38 38 38 38 3F ...    558  subqEAmasks   DC.B %111000,%111000,%111000,%111000,%111000,%111111,%111111,0
0000147A                           559  
0000147A                           560  SUBQ:
0000147A                           561          
0000147A                           562  
0000147A                           563          
0000147A  7000                     564          MOVEQ.L #0, D0 ;clear D0
0000147C                           565          
0000147C                           566          ;check valid size field
0000147C  3401                     567          MOVE.W D1,D2 ;copy inst to D2
0000147E  EC4A                     568          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
00001480  0202 0003                569          ANDI.B #%00000011,D2 ;mask out rest of byte
00001484  0C02 0003                570          CMPI.B #%11,D2 ;compare to 3
00001488  6700 FBE6                571          BEQ falsePositive ;invalid size
0000148C                           572          
0000148C                           573  validSubq:
0000148C                           574          
0000148C  43F8 1472                575          LEA subqEAmasks,A1 ;load the list of masks
00001490  D3C0                     576          ADDA.L D0,A1 ;displace to a specific mask
00001492  1A11                     577          MOVE.B (A1),D5 ;move the mask to D5
00001494                           578          
00001494  0C05 0000                579          CMPI.B #0,D5 ;check if the mask is 0
00001498  6700 FBD6                580          BEQ falsePositive ;branch if it is
0000149C                           581          
0000149C  1401                     582          MOVE.B D1,D2 ;copy instruction to D2
0000149E  C405                     583          AND.B D5,D2  ;mask D2
000014A0                           584          
000014A0  43F8 146A                585          LEA subqEA,A1 ;load the list of valid modes
000014A4  D3C0                     586          ADDA.L D0,A1 ;displace to a specific mode
000014A6  1811                     587          MOVE.B (A1),D4 ;move mode to D4
000014A8  B404                     588          CMP.B D4,D2 ;compare mode to masked value
000014AA  6700 0006                589          BEQ  subqBody ;if its match, its a valid mode and we can procede
000014AE                           590          
000014AE  5280                     591          ADDQ.L #1,D0 ;add one to displacement
000014B0  60DA                     592          BRA validSubq ;check for next mode
000014B2                           593          
000014B2                           594          
000014B2                           595  subqBody
000014B2                           596  
000014B2  43F9 00002219            597          LEA     subqMessage,A1  ;move string for MOVE
000014B8  103C 000E                598          MOVE.B  #14,D0        ;set for task to display null terminated 
000014BC                           599                                ;string with CR, LF
000014BC  4E4F                     600          TRAP    #15
000014BE                           601          
000014BE                           602          ;immediate data
000014BE                           603          
000014BE                           604          ;print '#'
000014BE  48E7 4000                605          MOVEM.L D1,-(SP) ;save D1 to the stack
000014C2  123C 0023                606          MOVE.B #'#',D1 ;put ascii value of '#' in D1
000014C6  103C 0006                607          MOVE.B #6,D0 ;move task 6 into D0
000014CA  4E4F                     608          TRAP #15 ;prin char
000014CC  4CDF 0002                609          MOVEM.L (SP)+,D1 ;pull D1 off the stack
000014D0                           610          
000014D0                           611          ;print number
000014D0  48E7 4000                612          MOVEM.L D1,-(SP)
000014D4  3401                     613          MOVE.W D1,D2 ;copy inst to d2
000014D6  E04A                     614          LSR.W #8,D2 ;shift data section
000014D8  E20A                     615          LSR.B #1,D2
000014DA  C43C 0007                616          AND.B #%00000111,D2 ;mask out rest of data
000014DE  6100 0034                617          BSR ZeroToEight ;handle zero
000014E2  7200                     618          MOVEQ.L #0,D1 ;clear D1
000014E4  1202                     619          MOVE.B D2,D1 ;move number to display into D1
000014E6  103C 0003                620          MOVE.B #3,D0 ;move task 3 to D0
000014EA  4E4F                     621          TRAP #15
000014EC  4CDF 0002                622          MOVEM.L (SP)+,D1
000014F0                           623          
000014F0                           624          ;print separator
000014F0                           625          
000014F0                           626          ;Then do EA
000014F0                           627          
000014F0  3401                     628          MOVE.W  D1,D2 ;check mode
000014F2  C43C 003F                629          AND.B   #%00111111,D2
000014F6  1A02                     630          MOVE.B  D2,D5
000014F8  48E7 4000                631          MOVEM.L D1,-(SP)
000014FC  6100 09AA                632          BSR     Get_Effective_Address
00001500  4CDF 0002                633          MOVEM.L (SP)+,D1
00001504                           634          
00001504  43F9 000021F8            635          LEA     clearLine,A1  ;move string for a CR and LF
0000150A  103C 000E                636          MOVE.B  #14,D0        ;set for task to display null terminated 
0000150E                           637                                ;string without CR, LF
0000150E  4E4F                     638          TRAP    #15
00001510                           639  
00001510  7000                     640          MOVEQ.L #0,D0
00001512  4E75                     641          RTS
00001514                           642          
00001514                           643  ZeroToEight:
00001514                           644          
00001514  0C02 0000                645          CMPI.B #0,D2
00001518  6700 0004                646          BEQ toEight
0000151C                           647  ZeroToEightReturn:
0000151C                           648          
0000151C  4E75                     649          RTS
0000151E                           650  toEight:
0000151E                           651          
0000151E  5002                     652          ADDQ.B #8,D2
00001520  60FA                     653          BRA ZeroToEightReturn
00001522                           654  
00001522                           655      
00001522                           656  SUB:
00001522                           657          
00001522                           658  
00001522                           659          
00001522  7000                     660          MOVEQ.L #0, D0 ;clear D0
00001524                           661          
00001524                           662          ;Figure out if EA is source or destination
00001524  3401                     663          MOVE.W D1,D2 ;copy inst to D2
00001526  EC4A                     664          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
00001528  0202 0007                665          ANDI.B #%00000111,D2 ;mask out rest of byte
0000152C  0C02 0002                666          CMPI.B #2,D2 ;compare to 2
00001530  6F00 0016                667          BLE validSubSourceEA ;2 or less is EA is source
00001534                           668          
00001534  0C02 0007                669          CMPI.B #%111,D2 ;compare to 7
00001538  6700 FB36                670          BEQ falsePositive ;thats not valid
0000153C  0C02 0003                671          CMPI.B #%11,D2 ;compare to 3
00001540  6700 FB2E                672          BEQ falsePositive ;also not valid
00001544  6000 002C                673          BRA validSubDestEA ;all thats left is valid EA as Dest 
00001548                           674          
00001548                           675  validSubSourceEA:
00001548                           676          
00001548  43F9 00001B03            677          LEA moveSourceEAmasks,A1 ;load the list of masks
0000154E  D3C0                     678          ADDA.L D0,A1 ;displace to a specific mask
00001550  1A11                     679          MOVE.B (A1),D5 ;move the mask to D5
00001552                           680          
00001552  0C05 0000                681          CMPI.B #0,D5 ;check if the mask is 0
00001556  6700 FB18                682          BEQ falsePositive ;branch if it is
0000155A                           683          
0000155A  1401                     684          MOVE.B D1,D2 ;copy instruction to D2
0000155C  C405                     685          AND.B D5,D2  ;mask D2
0000155E                           686          
0000155E  43F9 00001AFA            687          LEA moveSourceEA,A1 ;load the list of valid modes
00001564  D3C0                     688          ADDA.L D0,A1 ;displace to a specific mode
00001566  1811                     689          MOVE.B (A1),D4 ;move mode to D4
00001568  B404                     690          CMP.B D4,D2 ;compare mode to masked value
0000156A  6700 0036                691          BEQ  subSource ;if its match, its a valid mode and we can procede
0000156E                           692          
0000156E  5280                     693          ADDQ.L #1,D0 ;add one to displacement
00001570  60D6                     694          BRA validSubSourceEA ;check for next mode
00001572                           695          
00001572                           696          
00001572                           697  validSubDestEA:
00001572                           698          
00001572  43F9 000016CA            699          LEA addDestEAmasks,A1 ;load the list of masks
00001578  D3C0                     700          ADDA.L D0,A1 ;displace to a specific mask
0000157A  1A11                     701          MOVE.B (A1),D5 ;move the mask to D5
0000157C                           702          
0000157C  0C05 0000                703          CMPI.B #0,D5 ;check if the mask is 0
00001580  6700 FAEE                704          BEQ falsePositive ;branch if it is
00001584                           705          
00001584  3401                     706          MOVE.W D1,D2 ;copy instruction to D2
00001586  EC4A                     707          LSR.W #6,D2  ;move mode
00001588  6100 0A92                708          BSR switchModeAndReg ;switch register and mode
0000158C  C405                     709          AND.B D5,D2  ;mask D2
0000158E                           710          
0000158E  43F9 000016C4            711          LEA addDestEA,A1 ;load the list of valid modes
00001594  D3C0                     712          ADDA.L D0,A1 ;displace to a specific mode
00001596  1811                     713          MOVE.B (A1),D4 ;move mode to D4
00001598  B404                     714          CMP.B D4,D2 ;compare mode to masked value
0000159A  6700 004E                715          BEQ subDest ;if its match, its a valid mode and we can procede
0000159E                           716          
0000159E  5280                     717          ADDQ.L #1,D0 ;add one to displacement
000015A0  60D0                     718          BRA validSubDestEA ;check for next mode
000015A2                           719          
000015A2                           720  subSource
000015A2                           721  
000015A2  43F9 0000221F            722          LEA     subMessage,A1  ;move string for MOVE
000015A8  103C 000E                723          MOVE.B  #14,D0        ;set for task to display null terminated 
000015AC                           724                                ;string with CR, LF
000015AC  4E4F                     725          TRAP    #15
000015AE                           726          
000015AE                           727          ;do EA
000015AE                           728          
000015AE  3401                     729          MOVE.W  D1,D2 ;check mode
000015B0  C43C 003F                730          AND.B   #%00111111,D2
000015B4  1A02                     731          MOVE.B  D2,D5
000015B6  48E7 4000                732          MOVEM.L D1,-(SP)
000015BA  6100 08EC                733          BSR     Get_Effective_Address
000015BE  4CDF 0002                734          MOVEM.L (SP)+,D1
000015C2                           735          
000015C2                           736          ;print separator
000015C2                           737          
000015C2                           738          ;Then do Dn
000015C2                           739          
000015C2  3401                     740          MOVE.W  D1,D2
000015C4  E04A                     741          LSR.W   #8,D2 ;move reg into first byte
000015C6  E20A                     742          LSR.B   #1,D2 ;line it up to least sig bit
000015C8  C43C 0007                743          AND.B   #%00000111,D2 ;force mode to Dn
000015CC  1A02                     744          MOVE.B  D2,D5
000015CE  48E7 4000                745          MOVEM.L D1,-(SP)
000015D2  6100 08D4                746          BSR     Get_Effective_Address
000015D6  4CDF 0002                747          MOVEM.L (SP)+,D1
000015DA                           748          
000015DA  43F9 000021F8            749          LEA     clearLine,A1  ;move string for a CR and LF
000015E0  103C 000E                750          MOVE.B  #14,D0        ;set for task to display null terminated 
000015E4                           751                                ;string without CR, LF
000015E4  4E4F                     752          TRAP    #15
000015E6                           753  
000015E6  7000                     754          MOVEQ.L #0,D0
000015E8  4E75                     755          RTS
000015EA                           756  
000015EA                           757  subDest
000015EA                           758  
000015EA  43F9 0000221F            759          LEA     subMessage,A1  ;move string for MOVE
000015F0  103C 000E                760          MOVE.B  #14,D0        ;set for task to display null terminated 
000015F4                           761                                ;string with CR, LF
000015F4  4E4F                     762          TRAP    #15
000015F6                           763          
000015F6                           764          ;Do Dn
000015F6                           765          
000015F6  3401                     766          MOVE.W  D1,D2
000015F8  E04A                     767          LSR.W   #8,D2 ;move reg into first byte
000015FA  E20A                     768          LSR.B   #1,D2 ;line it up to least sig bit
000015FC  C43C 0007                769          AND.B   #%00000111,D2 ;force mode to Dn
00001600  1A02                     770          MOVE.B  D2,D5
00001602  48E7 4000                771          MOVEM.L D1,-(SP)
00001606  6100 08A0                772          BSR     Get_Effective_Address
0000160A  4CDF 0002                773          MOVEM.L (SP)+,D1
0000160E                           774          
0000160E                           775          
0000160E                           776          ;print separator
0000160E                           777          
0000160E                           778          ;Then do EA
0000160E                           779          
0000160E  3401                     780          MOVE.W  D1,D2 ;check mode
00001610  C43C 003F                781          AND.B   #%00111111,D2
00001614  1A02                     782          MOVE.B  D2,D5
00001616  48E7 4000                783          MOVEM.L D1,-(SP)
0000161A  6100 088C                784          BSR     Get_Effective_Address
0000161E  4CDF 0002                785          MOVEM.L (SP)+,D1
00001622                           786          
00001622                           787          
00001622  43F9 000021F8            788          LEA     clearLine,A1  ;move string for a CR and LF
00001628  103C 000E                789          MOVE.B  #14,D0        ;set for task to display null terminated 
0000162C                           790                                ;string without CR, LF
0000162C  4E4F                     791          TRAP    #15
0000162E                           792  
0000162E  7000                     793          MOVEQ.L #0,D0
00001630  4E75                     794          RTS
00001632                           795  
00001632                           796  
00001632                           797  ADDA:
00001632                           798          
00001632                           799  
00001632                           800          
00001632  7000                     801          MOVEQ.L #0, D0 ;clear D0
00001634                           802          
00001634                           803          ;check opmode field
00001634  3401                     804          MOVE.W D1,D2 ;copy inst to D2
00001636  EC4A                     805          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
00001638  0202 0007                806          ANDI.B #%00000111,D2 ;mask out rest of byte
0000163C  0C02 0007                807          CMPI.B #%111,D2 ;compare to 7
00001640  6700 000E                808          BEQ validAdda ;thats valid
00001644  0C02 0003                809          CMPI.B #%11,D2 ;compare to 3
00001648  6700 0006                810          BEQ validAdda ;also valid
0000164C  6000 FA22                811          BRA falsePositive ;all thats left is invalid 
00001650                           812          
00001650                           813  validAdda:
00001650                           814          
00001650  43F9 00001B03            815          LEA moveSourceEAmasks,A1 ;load the list of masks
00001656  D3C0                     816          ADDA.L D0,A1 ;displace to a specific mask
00001658  1A11                     817          MOVE.B (A1),D5 ;move the mask to D5
0000165A                           818          
0000165A  0C05 0000                819          CMPI.B #0,D5 ;check if the mask is 0
0000165E  6700 FA10                820          BEQ falsePositive ;branch if it is
00001662                           821          
00001662  1401                     822          MOVE.B D1,D2 ;copy instruction to D2
00001664  C405                     823          AND.B D5,D2  ;mask D2
00001666                           824          
00001666  43F9 00001AFA            825          LEA moveSourceEA,A1 ;load the list of valid modes
0000166C  D3C0                     826          ADDA.L D0,A1 ;displace to a specific mode
0000166E  1811                     827          MOVE.B (A1),D4 ;move mode to D4
00001670  B404                     828          CMP.B D4,D2 ;compare mode to masked value
00001672  6700 0006                829          BEQ  addaBody ;if its match, its a valid mode and we can procede
00001676                           830          
00001676  5280                     831          ADDQ.L #1,D0 ;add one to displacement
00001678  60D6                     832          BRA validAdda ;check for next mode
0000167A                           833          
0000167A                           834          
0000167A                           835  addaBody
0000167A                           836  
0000167A  43F9 00002224            837          LEA     addaMessage,A1  ;move string for MOVE
00001680  103C 000E                838          MOVE.B  #14,D0        ;set for task to display null terminated 
00001684                           839                                ;string with CR, LF
00001684  4E4F                     840          TRAP    #15
00001686                           841          
00001686                           842          ;do EA
00001686                           843          
00001686  3401                     844          MOVE.W  D1,D2 ;check mode
00001688  C43C 003F                845          AND.B   #%00111111,D2
0000168C  1A02                     846          MOVE.B  D2,D5
0000168E  48E7 4000                847          MOVEM.L D1,-(SP)
00001692  6100 0814                848          BSR     Get_Effective_Address
00001696  4CDF 0002                849          MOVEM.L (SP)+,D1
0000169A                           850          
0000169A                           851          ;print separator
0000169A                           852          
0000169A                           853          ;Then do Dn
0000169A                           854          
0000169A  3401                     855          MOVE.W  D1,D2
0000169C  E04A                     856          LSR.W   #8,D2 ;move reg into first byte
0000169E  E20A                     857          LSR.B   #1,D2 ;line it up to least sig bit
000016A0  C43C 0007                858          AND.B   #%00000111,D2 ;force mode to An
000016A4  5002                     859          ADDI.B  #%00001000,D2 
000016A6  1A02                     860          MOVE.B  D2,D5
000016A8  48E7 4000                861          MOVEM.L D1,-(SP)
000016AC  6100 07FA                862          BSR     Get_Effective_Address
000016B0  4CDF 0002                863          MOVEM.L (SP)+,D1
000016B4                           864          
000016B4  43F9 000021F8            865          LEA     clearLine,A1  ;move string for a CR and LF
000016BA  103C 000E                866          MOVE.B  #14,D0        ;set for task to display null terminated 
000016BE                           867                                ;string without CR, LF
000016BE  4E4F                     868          TRAP    #15
000016C0                           869  
000016C0  7000                     870          MOVEQ.L #0,D0
000016C2  4E75                     871          RTS
000016C4                           872  
000016C4                           873  
000016C4                           874      
000016C4= 10 18 20 38 39 00        875  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
000016CA= 38 38 38 3F 3F 00        876  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
000016D0                           877  
000016D0                           878  ADD:
000016D0                           879          
000016D0                           880  
000016D0                           881          
000016D0  7000                     882          MOVEQ.L #0, D0 ;clear D0
000016D2                           883          
000016D2                           884          ;Figure out if EA is source or destination
000016D2  3401                     885          MOVE.W D1,D2 ;copy inst to D2
000016D4  EC4A                     886          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
000016D6  0202 0007                887          ANDI.B #%00000111,D2 ;mask out rest of byte
000016DA  0C02 0002                888          CMPI.B #2,D2 ;compare to 2
000016DE  6F00 0016                889          BLE validAddSourceEA ;2 or less is EA is source
000016E2                           890          
000016E2  0C02 0007                891          CMPI.B #%111,D2 ;compare to 7
000016E6  6700 F988                892          BEQ falsePositive ;thats not valid
000016EA  0C02 0003                893          CMPI.B #%11,D2 ;compare to 3
000016EE  6700 F980                894          BEQ falsePositive ;also not valid
000016F2  6000 002C                895          BRA validAddDestEA ;all thats left is valid EA as Dest 
000016F6                           896          
000016F6                           897  validAddSourceEA:
000016F6                           898          
000016F6  43F9 00001B03            899          LEA moveSourceEAmasks,A1 ;load the list of masks
000016FC  D3C0                     900          ADDA.L D0,A1 ;displace to a specific mask
000016FE  1A11                     901          MOVE.B (A1),D5 ;move the mask to D5
00001700                           902          
00001700  0C05 0000                903          CMPI.B #0,D5 ;check if the mask is 0
00001704  6700 F96A                904          BEQ falsePositive ;branch if it is
00001708                           905          
00001708  1401                     906          MOVE.B D1,D2 ;copy instruction to D2
0000170A  C405                     907          AND.B D5,D2  ;mask D2
0000170C                           908          
0000170C  43F9 00001AFA            909          LEA moveSourceEA,A1 ;load the list of valid modes
00001712  D3C0                     910          ADDA.L D0,A1 ;displace to a specific mode
00001714  1811                     911          MOVE.B (A1),D4 ;move mode to D4
00001716  B404                     912          CMP.B D4,D2 ;compare mode to masked value
00001718  6700 0032                913          BEQ  addSource ;if its match, its a valid mode and we can procede
0000171C                           914          
0000171C  5280                     915          ADDQ.L #1,D0 ;add one to displacement
0000171E  60D6                     916          BRA validAddSourceEA ;check for next mode
00001720                           917          
00001720                           918          
00001720                           919  validAddDestEA:
00001720                           920          
00001720  43F8 16CA                921          LEA addDestEAmasks,A1 ;load the list of masks
00001724  D3C0                     922          ADDA.L D0,A1 ;displace to a specific mask
00001726  1A11                     923          MOVE.B (A1),D5 ;move the mask to D5
00001728                           924          
00001728  0C05 0000                925          CMPI.B #0,D5 ;check if the mask is 0
0000172C  6700 F942                926          BEQ falsePositive ;branch if it is
00001730                           927          
00001730  3401                     928          MOVE.W D1,D2 ;copy instruction to D2
00001732  EC4A                     929          LSR.W #6,D2  ;move mode
00001734  6100 08E6                930          BSR switchModeAndReg ;switch register and mode
00001738  C405                     931          AND.B D5,D2  ;mask D2
0000173A                           932          
0000173A  43F8 16C4                933          LEA addDestEA,A1 ;load the list of valid modes
0000173E  D3C0                     934          ADDA.L D0,A1 ;displace to a specific mode
00001740  1811                     935          MOVE.B (A1),D4 ;move mode to D4
00001742  B404                     936          CMP.B D4,D2 ;compare mode to masked value
00001744  6700 004E                937          BEQ addDest ;if its match, its a valid mode and we can procede
00001748                           938          
00001748  5280                     939          ADDQ.L #1,D0 ;add one to displacement
0000174A  60D4                     940          BRA validAddDestEA ;check for next mode
0000174C                           941          
0000174C                           942  addSource
0000174C                           943  
0000174C  43F9 0000222A            944          LEA     addMessage,A1  ;move string for MOVE
00001752  103C 000E                945          MOVE.B  #14,D0        ;set for task to display null terminated 
00001756                           946                                ;string with CR, LF
00001756  4E4F                     947          TRAP    #15
00001758                           948          
00001758                           949          ;do EA
00001758                           950          
00001758  3401                     951          MOVE.W  D1,D2 ;check mode
0000175A  C43C 003F                952          AND.B   #%00111111,D2
0000175E  1A02                     953          MOVE.B  D2,D5
00001760  48E7 4000                954          MOVEM.L D1,-(SP)
00001764  6100 0742                955          BSR     Get_Effective_Address
00001768  4CDF 0002                956          MOVEM.L (SP)+,D1
0000176C                           957          
0000176C                           958          ;print separator
0000176C                           959          
0000176C                           960          ;Then do Dn
0000176C                           961          
0000176C  3401                     962          MOVE.W  D1,D2
0000176E  E04A                     963          LSR.W   #8,D2 ;move reg into first byte
00001770  E20A                     964          LSR.B   #1,D2 ;line it up to least sig bit
00001772  C43C 0007                965          AND.B   #%00000111,D2 ;force mode to Dn
00001776  1A02                     966          MOVE.B  D2,D5
00001778  48E7 4000                967          MOVEM.L D1,-(SP)
0000177C  6100 072A                968          BSR     Get_Effective_Address
00001780  4CDF 0002                969          MOVEM.L (SP)+,D1
00001784                           970          
00001784  43F9 000021F8            971          LEA     clearLine,A1  ;move string for a CR and LF
0000178A  103C 000E                972          MOVE.B  #14,D0        ;set for task to display null terminated 
0000178E                           973                                ;string without CR, LF
0000178E  4E4F                     974          TRAP    #15
00001790                           975  
00001790  7000                     976          MOVEQ.L #0,D0
00001792  4E75                     977          RTS
00001794                           978  
00001794                           979  addDest
00001794                           980  
00001794  43F9 0000222A            981          LEA     addMessage,A1  ;move string for MOVE
0000179A  103C 000E                982          MOVE.B  #14,D0        ;set for task to display null terminated 
0000179E                           983                                ;string with CR, LF
0000179E  4E4F                     984          TRAP    #15
000017A0                           985          
000017A0                           986          ;Do Dn
000017A0                           987          
000017A0  3401                     988          MOVE.W  D1,D2
000017A2  E04A                     989          LSR.W   #8,D2 ;move reg into first byte
000017A4  E20A                     990          LSR.B   #1,D2 ;line it up to least sig bit
000017A6  C43C 0007                991          AND.B   #%00000111,D2 ;force mode to Dn
000017AA  1A02                     992          MOVE.B  D2,D5
000017AC  48E7 4000                993          MOVEM.L D1,-(SP)
000017B0  6100 06F6                994          BSR     Get_Effective_Address
000017B4  4CDF 0002                995          MOVEM.L (SP)+,D1
000017B8                           996          
000017B8                           997          
000017B8                           998          ;print separator
000017B8                           999          
000017B8                          1000          ;Then do EA
000017B8                          1001          
000017B8  3401                    1002          MOVE.W  D1,D2 ;check mode
000017BA  C43C 003F               1003          AND.B   #%00111111,D2
000017BE  1A02                    1004          MOVE.B  D2,D5
000017C0  48E7 4000               1005          MOVEM.L D1,-(SP)
000017C4  6100 06E2               1006          BSR     Get_Effective_Address
000017C8  4CDF 0002               1007          MOVEM.L (SP)+,D1
000017CC                          1008          
000017CC                          1009          
000017CC  43F9 000021F8           1010          LEA     clearLine,A1  ;move string for a CR and LF
000017D2  103C 000E               1011          MOVE.B  #14,D0        ;set for task to display null terminated 
000017D6                          1012                                ;string without CR, LF
000017D6  4E4F                    1013          TRAP    #15
000017D8                          1014  
000017D8  7000                    1015          MOVEQ.L #0,D0
000017DA  4E75                    1016          RTS
000017DC                          1017  
000017DC                          1018  
000017DC= 10 20 38 39 00          1019  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
000017E1= 38 38 3F 3F 00          1020  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
000017E6                          1021  
000017E6= 10 18 38 39 00          1022  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
000017EB= 38 38 3F 3F 00          1023  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
000017F0                          1024  
000017F0                          1025  MOVEM:
000017F0                          1026          
000017F0                          1027  
000017F0                          1028          
000017F0  7000                    1029          MOVEQ.L #0, D0 ;clear D0
000017F2                          1030          
000017F2                          1031          ;Figure out which direction we are going
000017F2  3401                    1032          MOVE.W D1,D2 ;copy inst to D2
000017F4  E64A                    1033          LSR.W #3,D2 ;shift direction bit into most sig bit of first byte
000017F6  0202 0080               1034          ANDI.B #%10000000,D2 ;mask out everything but direction bit in first byte
000017FA  0C02 0000               1035          CMPI.B #0,D2 ;compare bit to zero
000017FE  6700 0006               1036          BEQ validRegToMem ;if zero, reg to mem
00001802  6000 0028               1037          BRA validMemToReg ;else, its mem to reg
00001806                          1038          
00001806                          1039  validRegToMem:
00001806                          1040          
00001806  43F8 17E1               1041          LEA movemRegToMemEAmasks,A1 ;load the list of masks
0000180A  D3C0                    1042          ADDA.L D0,A1 ;displace to a specific mask
0000180C  1A11                    1043          MOVE.B (A1),D5 ;move the mask to D5
0000180E                          1044          
0000180E  0C05 0000               1045          CMPI.B #0,D5 ;check if the mask is 0
00001812  6700 F85C               1046          BEQ falsePositive ;branch if it is
00001816                          1047          
00001816  1401                    1048          MOVE.B D1,D2 ;copy instruction to D2
00001818  C405                    1049          AND.B D5,D2  ;mask D2
0000181A                          1050          
0000181A  43F8 17DC               1051          LEA movemRegToMemEA,A1 ;load the list of valid modes
0000181E  D3C0                    1052          ADDA.L D0,A1 ;displace to a specific mode
00001820  1811                    1053          MOVE.B (A1),D4 ;move mode to D4
00001822  B404                    1054          CMP.B D4,D2 ;compare mode to masked value
00001824  6700 0034               1055          BEQ  movemBody ;if its match, its a valid mode and we can procede
00001828                          1056          
00001828  5280                    1057          ADDQ.L #1,D0 ;add one to displacement
0000182A  60DA                    1058          BRA validRegToMem ;check for next mode
0000182C                          1059          
0000182C                          1060          
0000182C                          1061  validMemToReg:
0000182C                          1062          
0000182C  43F8 17EB               1063          LEA movemMemToRegEAmasks,A1 ;load the list of masks
00001830  D3C0                    1064          ADDA.L D0,A1 ;displace to a specific mask
00001832  1A11                    1065          MOVE.B (A1),D5 ;move the mask to D5
00001834                          1066          
00001834  0C05 0000               1067          CMPI.B #0,D5 ;check if the mask is 0
00001838  6700 F836               1068          BEQ falsePositive ;branch if it is
0000183C                          1069          
0000183C  3401                    1070          MOVE.W D1,D2 ;copy instruction to D2
0000183E  EC4A                    1071          LSR.W #6,D2  ;move mode
00001840  6100 07DA               1072          BSR switchModeAndReg ;switch register and mode
00001844  C405                    1073          AND.B D5,D2  ;mask D2
00001846                          1074          
00001846  43F8 17E6               1075          LEA movemMemToRegEA,A1 ;load the list of valid modes
0000184A  D3C0                    1076          ADDA.L D0,A1 ;displace to a specific mode
0000184C  1811                    1077          MOVE.B (A1),D4 ;move mode to D4
0000184E  B404                    1078          CMP.B D4,D2 ;compare mode to masked value
00001850  6700 0008               1079          BEQ movemBody ;if its match, its a valid mode and we can procede
00001854                          1080          
00001854  5280                    1081          ADDQ.L #1,D0 ;add one to displacement
00001856  6000 02EC               1082          BRA validMoveDestModes ;check for next mode
0000185A                          1083          
0000185A                          1084  movemBody
0000185A                          1085  
0000185A  43F9 0000222F           1086          LEA     movemMessage,A1  ;move string for MOVE
00001860  103C 000E               1087          MOVE.B  #14,D0        ;set for task to display null terminated 
00001864                          1088                                ;string with CR, LF
00001864  4E4F                    1089          TRAP    #15
00001866                          1090          
00001866                          1091          ;show list
00001866                          1092          
00001866  5487                    1093          ADDQ.L #word,D7 ;read past the register list mask(word) following
00001868                          1094                          ;the instruction
00001868                          1095          
00001868                          1096          ;print separator
00001868                          1097          
00001868  3401                    1098          MOVE.W  D1,D2 ;check mode
0000186A  C43C 003F               1099          AND.B   #%00111111,D2
0000186E  1A02                    1100          MOVE.B  D2,D5
00001870  48E7 4000               1101          MOVEM.L D1,-(SP)
00001874  6100 0632               1102          BSR     Get_Effective_Address
00001878  4CDF 0002               1103          MOVEM.L (SP)+,D1
0000187C                          1104          
0000187C                          1105          
0000187C  43F9 000021F8           1106          LEA     clearLine,A1  ;move string for a CR and LF
00001882  103C 000E               1107          MOVE.B  #14,D0        ;set for task to display null terminated 
00001886                          1108                                ;string without CR, LF
00001886  4E4F                    1109          TRAP    #15
00001888                          1110  
00001888  7000                    1111          MOVEQ.L #0,D0
0000188A  4E75                    1112          RTS
0000188C                          1113  
0000188C                          1114  
0000188C                          1115      
0000188C= 00 10 18 20 28 38 ...   1116  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
00001894= 38 38 38 38 38 3F ...   1117  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
0000189C                          1118     
0000189C                          1119  NEG:            
0000189C                          1120       
0000189C  7000                    1121          MOVEQ.L #0, D0 ;clear D0
0000189E                          1122          
0000189E                          1123  validNegModes:
0000189E                          1124          
0000189E  43F8 1894               1125          LEA NegEAmasks,A1 ;load the list of masks
000018A2  D3C0                    1126          ADDA.L D0,A1 ;displace to a specific mask
000018A4  1A11                    1127          MOVE.B (A1),D5 ;move the mask to D5
000018A6                          1128          
000018A6  0C05 0000               1129          CMPI.B #0,D5 ;check if the mask is 0
000018AA  6700 F7C4               1130          BEQ falsePositive ;branch if it is
000018AE                          1131          
000018AE  1401                    1132          MOVE.B D1,D2 ;copy instruction to D2
000018B0  C405                    1133          AND.B D5,D2  ;mask D2
000018B2  43F8 188C               1134          LEA NegEA,A1 ;load the list of valid modes
000018B6  D3C0                    1135          ADDA.L D0,A1 ;displace to a specific mode
000018B8  1811                    1136          MOVE.B (A1),D4 ;move mode to D4
000018BA  B404                    1137          CMP.B D4,D2 ;compare mode to masked value
000018BC  6700 0006               1138          BEQ NegBody ;if its match, its a valid mode and we can procede
000018C0                          1139          
000018C0  5280                    1140          ADDQ.L #1,D0 ;add one to displacement
000018C2  60DA                    1141          BRA validNegModes ;check for next mode
000018C4                          1142          
000018C4                          1143  NegBody:
000018C4                          1144  
000018C4                          1145  
000018C4  3401                    1146          MOVE.W  D1,D2 ;copy inst to D2
000018C6  C47C 0600               1147          AND.W  #%0011000000000,D2 ;mask word for size
000018CA  0C42 0000               1148          CMPI.W #0,D2 ;0 is the only non valid size
000018CE  6700 F7A0               1149          BEQ falsePositive ; zero is not valid
000018D2                          1150  
000018D2  43F9 0000225E           1151          LEA     negMessage,A1  ;move string for NEG info
000018D8  103C 000E               1152          MOVE.B  #14,D0        ;set for task to display null terminated 
000018DC                          1153                                ;string without CR, LF
000018DC  4E4F                    1154          TRAP    #15
000018DE                          1155          
000018DE  3401                    1156          MOVE.W D1,D2
000018E0  C47C 003F               1157          AND #%000000000111111,D2
000018E4  1A02                    1158          MOVE.B D2,D5
000018E6                          1159          
000018E6  48E7 4000               1160          MOVEM.L D1,-(SP)
000018EA  6100 05BC               1161          BSR     Get_Effective_Address
000018EE  4CDF 0002               1162          MOVEM.L (SP)+,D1
000018F2                          1163          
000018F2                          1164                
000018F2                          1165          
000018F2                          1166  NEGdone:
000018F2                          1167  
000018F2  43F9 000021F8           1168          LEA     clearLine,A1  ;move string for a CR and LF
000018F8  103C 000E               1169          MOVE.B  #14,D0        ;set for task to display null terminated 
000018FC                          1170                                ;string without CR, LF
000018FC  4E4F                    1171          TRAP    #15
000018FE  7000                    1172          MOVEQ.L #0,D0
00001900  4E75                    1173          RTS
00001902                          1174          
00001902                          1175   ADDI:            
00001902                          1176       
00001902  7000                    1177          MOVEQ.L #0, D0 ;clear D0
00001904                          1178          
00001904                          1179  validAddiModes:
00001904                          1180          
00001904                          1181          
00001904  43F9 000019FD           1182          LEA cmpiEAmasks,A1 ;load the list of masks
0000190A  D3C0                    1183          ADDA.L D0,A1 ;displace to a specific mask
0000190C  1A11                    1184          MOVE.B (A1),D5 ;move the mask to D5
0000190E                          1185          
0000190E  0C05 0000               1186          CMPI.B #0,D5 ;check if the mask is 0
00001912  6700 F75C               1187          BEQ falsePositive ;branch if it is
00001916                          1188          
00001916  1401                    1189          MOVE.B D1,D2 ;copy instruction to D2
00001918  C405                    1190          AND.B D5,D2  ;mask D2
0000191A  43F9 000019F6           1191          LEA cmpiEA,A1 ;load the list of valid modes
00001920  D3C0                    1192          ADDA.L D0,A1 ;displace to a specific mode
00001922  1811                    1193          MOVE.B (A1),D4 ;move mode to D4
00001924  B404                    1194          CMP.B D4,D2 ;compare mode to masked value
00001926  6700 0006               1195          BEQ addiBody ;if its match, its a valid mode and we can procede
0000192A                          1196          
0000192A  5280                    1197          ADDQ.L #1,D0 ;add one to displacement
0000192C  60D6                    1198          BRA validAddiModes ;check for next mode
0000192E                          1199          
0000192E                          1200  addiBody:
0000192E                          1201  
0000192E                          1202  
0000192E  3401                    1203          MOVE.W  D1,D2 ;copy inst to D2
00001930  C47C 00C0               1204          AND.W  #%0000000011000000,D2 ;mask word for size
00001934  0C42 00C0               1205          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001938  6700 F736               1206          BEQ falsePositive
0000193C                          1207  
0000193C  43F9 00002236           1208          LEA     addiMessage,A1  ;move string for NEG info
00001942  103C 000E               1209          MOVE.B  #14,D0        ;set for task to display null terminated 
00001946                          1210                                ;string without CR, LF
00001946  4E4F                    1211          TRAP    #15
00001948                          1212          
00001948                          1213          ;go to Effective_Address for immediate data
00001948  143C 003C               1214          MOVE.B #%00111100,D2
0000194C  48E7 4000               1215          MOVEM.L D1,-(SP)
00001950  6100 0556               1216          BSR     Get_Effective_Address
00001954  4CDF 0002               1217          MOVEM.L (SP)+,D1
00001958                          1218          
00001958  3401                    1219          MOVE.W D1,D2 ;copy inst to D2
0000195A  C47C 003F               1220          AND #%000000000111111,D2 ;and out everything but modes and regs
0000195E  1A02                    1221          MOVE.B D2,D5 ; copy to D5 for following BSR
00001960                          1222          
00001960  48E7 4000               1223          MOVEM.L D1,-(SP)
00001964  6100 0542               1224          BSR     Get_Effective_Address
00001968  4CDF 0002               1225          MOVEM.L (SP)+,D1
0000196C                          1226          
0000196C                          1227                
0000196C                          1228          
0000196C                          1229  addidone:
0000196C                          1230  
0000196C  43F9 000021F8           1231          LEA     clearLine,A1  ;move string for a CR and LF
00001972  103C 000E               1232          MOVE.B  #14,D0        ;set for task to display null terminated 
00001976                          1233                                ;string without CR, LF
00001976  4E4F                    1234          TRAP    #15
00001978  7000                    1235          MOVEQ.L #0,D0
0000197A  4E75                    1236          RTS
0000197C                          1237    
0000197C                          1238  ORI:            
0000197C                          1239       
0000197C  7000                    1240          MOVEQ.L #0, D0 ;clear D0
0000197E                          1241          
0000197E                          1242  validOriModes:
0000197E                          1243          
0000197E                          1244          
0000197E  43F9 000019FD           1245          LEA cmpiEAmasks,A1 ;load the list of masks
00001984  D3C0                    1246          ADDA.L D0,A1 ;displace to a specific mask
00001986  1A11                    1247          MOVE.B (A1),D5 ;move the mask to D5
00001988                          1248          
00001988  0C05 0000               1249          CMPI.B #0,D5 ;check if the mask is 0
0000198C  6700 F6E2               1250          BEQ falsePositive ;branch if it is
00001990                          1251          
00001990  1401                    1252          MOVE.B D1,D2 ;copy instruction to D2
00001992  C405                    1253          AND.B D5,D2  ;mask D2
00001994  43F9 000019F6           1254          LEA cmpiEA,A1 ;load the list of valid modes
0000199A  D3C0                    1255          ADDA.L D0,A1 ;displace to a specific mode
0000199C  1811                    1256          MOVE.B (A1),D4 ;move mode to D4
0000199E  B404                    1257          CMP.B D4,D2 ;compare mode to masked value
000019A0  6700 0006               1258          BEQ oriBody ;if its match, its a valid mode and we can procede
000019A4                          1259          
000019A4  5280                    1260          ADDQ.L #1,D0 ;add one to displacement
000019A6  60D6                    1261          BRA validOriModes ;check for next mode
000019A8                          1262          
000019A8                          1263  oriBody:
000019A8                          1264  
000019A8                          1265  
000019A8  3401                    1266          MOVE.W  D1,D2 ;copy inst to D2
000019AA  C47C 00C0               1267          AND.W  #%0000000011000000,D2 ;mask word for size
000019AE  0C42 00C0               1268          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
000019B2  6700 F6BC               1269          BEQ falsePositive
000019B6                          1270  
000019B6  43F9 0000223C           1271          LEA     oriMessage,A1  ;move string for NEG info
000019BC  103C 000E               1272          MOVE.B  #14,D0        ;set for task to display null terminated 
000019C0                          1273                                ;string without CR, LF
000019C0  4E4F                    1274          TRAP    #15
000019C2                          1275          
000019C2                          1276          ;go to Effective_Address for immediate data
000019C2  143C 003C               1277          MOVE.B #%00111100,D2
000019C6  48E7 4000               1278          MOVEM.L D1,-(SP)
000019CA  6100 04DC               1279          BSR     Get_Effective_Address
000019CE  4CDF 0002               1280          MOVEM.L (SP)+,D1
000019D2                          1281          
000019D2  3401                    1282          MOVE.W D1,D2 ;copy inst to D2
000019D4  C47C 003F               1283          AND #%000000000111111,D2 ;and out everything but modes and regs
000019D8  1A02                    1284          MOVE.B D2,D5 ; copy to D5 for following BSR
000019DA                          1285          
000019DA  48E7 4000               1286          MOVEM.L D1,-(SP)
000019DE  6100 04C8               1287          BSR     Get_Effective_Address
000019E2  4CDF 0002               1288          MOVEM.L (SP)+,D1
000019E6                          1289          
000019E6                          1290                
000019E6                          1291          
000019E6                          1292  oridone:
000019E6                          1293  
000019E6  43F9 000021F8           1294          LEA     clearLine,A1  ;move string for a CR and LF
000019EC  103C 000E               1295          MOVE.B  #14,D0        ;set for task to display null terminated 
000019F0                          1296                                ;string without CR, LF
000019F0  4E4F                    1297          TRAP    #15
000019F2  7000                    1298          MOVEQ.L #0,D0
000019F4  4E75                    1299          RTS
000019F6                          1300  
000019F6                          1301          
000019F6                          1302          
000019F6= 20 18 00 10 38 39 00    1303  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
000019FD= 38 38 38 38 3F 3F 00    1304  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
00001A04                          1305     
00001A04                          1306  CMPI:            
00001A04                          1307       
00001A04  7000                    1308          MOVEQ.L #0, D0 ;clear D0
00001A06                          1309          
00001A06                          1310  validCmpiModes:
00001A06                          1311          
00001A06                          1312          
00001A06  43F8 19FD               1313          LEA cmpiEAmasks,A1 ;load the list of masks
00001A0A  D3C0                    1314          ADDA.L D0,A1 ;displace to a specific mask
00001A0C  1A11                    1315          MOVE.B (A1),D5 ;move the mask to D5
00001A0E                          1316          
00001A0E  0C05 0000               1317          CMPI.B #0,D5 ;check if the mask is 0
00001A12  6700 F65C               1318          BEQ falsePositive ;branch if it is
00001A16                          1319          
00001A16  1401                    1320          MOVE.B D1,D2 ;copy instruction to D2
00001A18  C405                    1321          AND.B D5,D2  ;mask D2
00001A1A  43F8 19F6               1322          LEA cmpiEA,A1 ;load the list of valid modes
00001A1E  D3C0                    1323          ADDA.L D0,A1 ;displace to a specific mode
00001A20  1811                    1324          MOVE.B (A1),D4 ;move mode to D4
00001A22  B404                    1325          CMP.B D4,D2 ;compare mode to masked value
00001A24  6700 0006               1326          BEQ CMPIBody ;if its match, its a valid mode and we can procede
00001A28                          1327          
00001A28  5280                    1328          ADDQ.L #1,D0 ;add one to displacement
00001A2A  60DA                    1329          BRA validCmpiModes ;check for next mode
00001A2C                          1330          
00001A2C                          1331  CMPIBody:
00001A2C                          1332  
00001A2C                          1333  
00001A2C  3401                    1334          MOVE.W  D1,D2 ;copy inst to D2
00001A2E  C47C 00C0               1335          AND.W  #%0000000011000000,D2 ;mask word for size
00001A32  0C42 00C0               1336          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001A36  6700 F638               1337          BEQ falsePositive
00001A3A                          1338  
00001A3A  43F9 00002241           1339          LEA     cmpiMessage,A1  ;move string for NEG info
00001A40  103C 000E               1340          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A44                          1341                                ;string without CR, LF
00001A44  4E4F                    1342          TRAP    #15
00001A46                          1343          
00001A46                          1344          ;go to Effective_Address for immediate data
00001A46  143C 003C               1345          MOVE.B #%00111100,D2
00001A4A  48E7 4000               1346          MOVEM.L D1,-(SP)
00001A4E  6100 0458               1347          BSR     Get_Effective_Address
00001A52  4CDF 0002               1348          MOVEM.L (SP)+,D1
00001A56                          1349          
00001A56  3401                    1350          MOVE.W D1,D2 ;copy inst to D2
00001A58  C47C 003F               1351          AND #%000000000111111,D2 ;and out everything but modes and regs
00001A5C  1A02                    1352          MOVE.B D2,D5 ; copy to D5 for following BSR
00001A5E                          1353          
00001A5E  48E7 4000               1354          MOVEM.L D1,-(SP)
00001A62  6100 0444               1355          BSR     Get_Effective_Address
00001A66  4CDF 0002               1356          MOVEM.L (SP)+,D1
00001A6A                          1357          
00001A6A                          1358                
00001A6A                          1359          
00001A6A                          1360  CMPidone:
00001A6A                          1361  
00001A6A  43F9 000021F8           1362          LEA     clearLine,A1  ;move string for a CR and LF
00001A70  103C 000E               1363          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A74                          1364                                ;string without CR, LF
00001A74  4E4F                    1365          TRAP    #15
00001A76  7000                    1366          MOVEQ.L #0,D0
00001A78  4E75                    1367          RTS
00001A7A                          1368  
00001A7A                          1369          
00001A7A= 10 38 39 00             1370  JsrEA        DC.B %010000, %111000, %111001,0
00001A7E= 38 3F 3F 00             1371  JsrEAmasks   DC.B %111000, %111111, %111111,0
00001A82                          1372     
00001A82                          1373  JSR:            
00001A82                          1374       
00001A82  7000                    1375          MOVEQ.L #0, D0 ;clear D0
00001A84                          1376          
00001A84                          1377  validJsrModes:
00001A84                          1378          
00001A84  43F8 1A7E               1379          LEA JsrEAmasks,A1 ;load the list of masks
00001A88  D3C0                    1380          ADDA.L D0,A1 ;displace to a specific mask
00001A8A  1A11                    1381          MOVE.B (A1),D5 ;move the mask to D5
00001A8C                          1382          
00001A8C  0C05 0000               1383          CMPI.B #0,D5 ;check if the mask is 0
00001A90  6700 F5DE               1384          BEQ falsePositive ;branch if it is
00001A94                          1385          
00001A94  1401                    1386          MOVE.B D1,D2 ;copy instruction to D2
00001A96  C405                    1387          AND.B D5,D2  ;mask D2
00001A98  43F8 1A7A               1388          LEA JsrEA,A1 ;load the list of valid modes
00001A9C  D3C0                    1389          ADDA.L D0,A1 ;displace to a specific mode
00001A9E  1811                    1390          MOVE.B (A1),D4 ;move mode to D4
00001AA0  B404                    1391          CMP.B D4,D2 ;compare mode to masked value
00001AA2  6700 0006               1392          BEQ JsrBody ;if its match, its a valid mode and we can procede
00001AA6                          1393          
00001AA6  5280                    1394          ADDQ.L #1,D0 ;add one to displacement
00001AA8  60DA                    1395          BRA validJsrModes ;check for next mode
00001AAA                          1396          
00001AAA                          1397  JsrBody:
00001AAA                          1398  
00001AAA                          1399  
00001AAA  43F9 00002247           1400          LEA     jsrMessage,A1  ;move string for NEG info
00001AB0  103C 000E               1401          MOVE.B  #14,D0        ;set for task to display null terminated 
00001AB4                          1402                                ;string without CR, LF
00001AB4  4E4F                    1403          TRAP    #15
00001AB6                          1404          
00001AB6  3401                    1405          MOVE.W D1,D2 ;copy inst to D2
00001AB8  C47C 003F               1406          AND #%000000000111111,D2 ;and out everything but modes and regs
00001ABC  1A02                    1407          MOVE.B D2,D5 ; copy to D5 for following BSR
00001ABE                          1408          
00001ABE  48E7 4000               1409          MOVEM.L D1,-(SP)
00001AC2  6100 03E4               1410          BSR     Get_Effective_Address
00001AC6  4CDF 0002               1411          MOVEM.L (SP)+,D1
00001ACA                          1412          
00001ACA                          1413                
00001ACA                          1414          
00001ACA                          1415  Jsrdone:
00001ACA                          1416  
00001ACA  43F9 000021F8           1417          LEA     clearLine,A1  ;move string for a CR and LF
00001AD0  103C 000E               1418          MOVE.B  #14,D0        ;set for task to display null terminated 
00001AD4                          1419                                ;string without CR, LF
00001AD4  4E4F                    1420          TRAP    #15
00001AD6  7000                    1421          MOVEQ.L #0,D0
00001AD8  4E75                    1422          RTS
00001ADA                          1423  
00001ADA                          1424  
00001ADA                          1425          
00001ADA                          1426  NOP:
00001ADA                          1427  
00001ADA  43F9 00002251           1428          LEA     nopMessage,A1 ;move string for NOP info
00001AE0  103C 000D               1429          MOVE.B  #13,D0        ;set for task to display null terminated 
00001AE4                          1430                                ;string with CR, LF
00001AE4  4E4F                    1431          TRAP    #15
00001AE6                          1432          
00001AE6  7000                    1433          MOVEQ.L #0,D0
00001AE8  4E75                    1434          RTS
00001AEA                          1435          
00001AEA                          1436  RTS:
00001AEA                          1437          
00001AEA  43F9 0000224C           1438          LEA     rtsMessage,A1  ;move string for rts info
00001AF0  103C 000D               1439          MOVE.B  #13,D0        ;set for task to display null terminated 
00001AF4                          1440                                ;string with CR, LF
00001AF4  4E4F                    1441          TRAP    #15  
00001AF6                          1442     
00001AF6  7000                    1443          MOVEQ.L #0,D0
00001AF8  4E75                    1444          RTS   
00001AFA                          1445  
00001AFA= 3C 08 00 10 18 20 ...   1446  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
00001B03= 3F 38 38 38 38 38 ...   1447  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001B0C                          1448  
00001B0C= 00 10 18 20 38 39 00    1449  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
00001B13= 38 38 38 38 3F 3F 00    1450  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
00001B1A                          1451  
00001B1A                          1452  MOVE:
00001B1A                          1453          
00001B1A                          1454  
00001B1A                          1455          
00001B1A  7000                    1456          MOVEQ.L #0, D0 ;clear D0
00001B1C                          1457          
00001B1C                          1458  validMoveSourceModes:
00001B1C                          1459          
00001B1C  43F8 1B03               1460          LEA moveSourceEAmasks,A1 ;load the list of masks
00001B20  D3C0                    1461          ADDA.L D0,A1 ;displace to a specific mask
00001B22  1A11                    1462          MOVE.B (A1),D5 ;move the mask to D5
00001B24                          1463          
00001B24  0C05 0000               1464          CMPI.B #0,D5 ;check if the mask is 0
00001B28  6700 F546               1465          BEQ falsePositive ;branch if it is
00001B2C                          1466          
00001B2C  1401                    1467          MOVE.B D1,D2 ;copy instruction to D2
00001B2E  C405                    1468          AND.B D5,D2  ;mask D2
00001B30                          1469          
00001B30  43F8 1AFA               1470          LEA moveSourceEA,A1 ;load the list of valid modes
00001B34  D3C0                    1471          ADDA.L D0,A1 ;displace to a specific mode
00001B36  1811                    1472          MOVE.B (A1),D4 ;move mode to D4
00001B38  B404                    1473          CMP.B D4,D2 ;compare mode to masked value
00001B3A  6700 0006               1474          BEQ  checkMoveDest ;if its match, its a valid mode and we can procede
00001B3E                          1475          
00001B3E  5280                    1476          ADDQ.L #1,D0 ;add one to displacement
00001B40  60DA                    1477          BRA validMoveSourceModes ;check for next mode
00001B42                          1478          
00001B42                          1479  checkMoveDest:
00001B42  7000                    1480          MOVEQ.L #0, D0 ;clear D0
00001B44                          1481          
00001B44                          1482  validMoveDestModes:
00001B44                          1483          
00001B44  43F8 1B13               1484          LEA moveDestEAmasks,A1 ;load the list of masks
00001B48  D3C0                    1485          ADDA.L D0,A1 ;displace to a specific mask
00001B4A  1A11                    1486          MOVE.B (A1),D5 ;move the mask to D5
00001B4C                          1487          
00001B4C  0C05 0000               1488          CMPI.B #0,D5 ;check if the mask is 0
00001B50  6700 F51E               1489          BEQ falsePositive ;branch if it is
00001B54                          1490          
00001B54  3401                    1491          MOVE.W D1,D2 ;copy instruction to D2
00001B56  EC4A                    1492          LSR.W #6,D2  ;move mode
00001B58  6100 04C2               1493          BSR switchModeAndReg ;switch register and mode
00001B5C  C405                    1494          AND.B D5,D2  ;mask D2
00001B5E                          1495          
00001B5E  43F8 1B0C               1496          LEA moveDestEA,A1 ;load the list of valid modes
00001B62  D3C0                    1497          ADDA.L D0,A1 ;displace to a specific mode
00001B64  1811                    1498          MOVE.B (A1),D4 ;move mode to D4
00001B66  B404                    1499          CMP.B D4,D2 ;compare mode to masked value
00001B68  6700 0006               1500          BEQ moveBody ;if its match, its a valid mode and we can procede
00001B6C                          1501          
00001B6C  5280                    1502          ADDQ.L #1,D0 ;add one to displacement
00001B6E  60D4                    1503          BRA validMoveDestModes ;check for next mode
00001B70                          1504          
00001B70                          1505  moveBody
00001B70  3401                    1506          MOVE.W  D1,D2 ;copy inst to D2
00001B72  C47C 3000               1507          AND.W  #%0011000000000000,D2 ;mask word for size
00001B76  0C42 0000               1508          CMPI.W #0,D2 ;0 is the only non valid size
00001B7A  6700 F4F4               1509          BEQ falsePositive ; if zero, this is not move
00001B7E                          1510  
00001B7E  43F9 00002256           1511          LEA     moveMessage,A1  ;move string for MOVE
00001B84  103C 000E               1512          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B88                          1513                                ;string with CR, LF
00001B88  4E4F                    1514          TRAP    #15
00001B8A                          1515          
00001B8A                          1516          
00001B8A  3401                    1517          MOVE.W  D1,D2 ;check source mode
00001B8C  C43C 003F               1518          AND.B   #%00111111,D2
00001B90  1A02                    1519          MOVE.B  D2,D5
00001B92  48E7 4000               1520          MOVEM.L D1,-(SP)
00001B96  6100 0310               1521          BSR     Get_Effective_Address
00001B9A  4CDF 0002               1522          MOVEM.L (SP)+,D1
00001B9E                          1523          
00001B9E                          1524          ;print separator
00001B9E                          1525          
00001B9E  3401                    1526          MOVE.W  D1,D2 ;check dest mode
00001BA0  EC4A                    1527          LSR.W   #6,D2
00001BA2  6100 0478               1528          BSR  switchModeAndReg
00001BA6  C43C 003F               1529          AND.B   #%00111111,D2
00001BAA  1A02                    1530          MOVE.B  D2,D5
00001BAC  48E7 4000               1531          MOVEM.L D1,-(SP)
00001BB0  6100 02F6               1532          BSR     Get_Effective_Address
00001BB4  4CDF 0002               1533          MOVEM.L (SP)+,D1
00001BB8                          1534          
00001BB8                          1535          
00001BB8                          1536          
00001BB8  43F9 000021F8           1537          LEA     clearLine,A1  ;move string for a CR and LF
00001BBE  103C 000E               1538          MOVE.B  #14,D0        ;set for task to display null terminated 
00001BC2                          1539                                ;string without CR, LF
00001BC2  4E4F                    1540          TRAP    #15
00001BC4                          1541  
00001BC4  7000                    1542          MOVEQ.L #0,D0
00001BC6  4E75                    1543          RTS
00001BC8                          1544          
00001BC8= 08 00                   1545  moveADestEA        DC.B %001000,0
00001BCA= 38 00                   1546  moveADestEAmasks   DC.B %111000,0
00001BCC                          1547          
00001BCC                          1548  MOVEA:
00001BCC                          1549  
00001BCC  7000                    1550          MOVEQ.L #0, D0 ;clear D0
00001BCE                          1551          
00001BCE                          1552  validMoveASourceModes:
00001BCE                          1553          
00001BCE  43F8 1B03               1554          LEA moveSourceEAmasks,A1 ;load the list of masks
00001BD2  D3C0                    1555          ADDA.L D0,A1 ;displace to a specific mask
00001BD4  1A11                    1556          MOVE.B (A1),D5 ;move the mask to D5
00001BD6                          1557          
00001BD6  0C05 0000               1558          CMPI.B #0,D5 ;check if the mask is 0
00001BDA  6700 F494               1559          BEQ falsePositive ;branch if it is
00001BDE                          1560          
00001BDE  1401                    1561          MOVE.B D1,D2 ;copy instruction to D2
00001BE0  C405                    1562          AND.B D5,D2  ;mask D2
00001BE2                          1563          
00001BE2  43F8 1AFA               1564          LEA moveSourceEA,A1 ;load the list of valid modes
00001BE6  D3C0                    1565          ADDA.L D0,A1 ;displace to a specific mode
00001BE8  1811                    1566          MOVE.B (A1),D4 ;move mode to D4
00001BEA  B404                    1567          CMP.B D4,D2 ;compare mode to masked value
00001BEC  6700 0006               1568          BEQ  checkMoveADest ;if its match, its a valid mode and we can procede
00001BF0                          1569          
00001BF0  5280                    1570          ADDQ.L #1,D0 ;add one to displacement
00001BF2  60DA                    1571          BRA validMoveASourceModes ;check for next mode
00001BF4                          1572          
00001BF4                          1573  checkMoveADest:
00001BF4  7000                    1574          MOVEQ.L #0, D0 ;clear D0
00001BF6                          1575  validMoveADestModes:
00001BF6                          1576          
00001BF6  43F8 1BCA               1577          LEA moveADestEAmasks,A1 ;load the list of masks
00001BFA  D3C0                    1578          ADDA.L D0,A1 ;displace to a specific mask
00001BFC  1A11                    1579          MOVE.B (A1),D5 ;move the mask to D5
00001BFE                          1580          
00001BFE  0C05 0000               1581          CMPI.B #0,D5 ;check if the mask is 0
00001C02  6700 F46C               1582          BEQ falsePositive ;branch if it is
00001C06                          1583          
00001C06  3401                    1584          MOVE.W D1,D2 ;copy instruction to D2
00001C08  EA4A                    1585          LSR.W #5,D2  ;move mode
00001C0A  6100 0410               1586          BSR switchModeAndReg ;switch register and mode
00001C0E  C405                    1587          AND.B D5,D2  ;mask D2
00001C10                          1588          
00001C10  43F8 1BC8               1589          LEA moveADestEA,A1 ;load the list of valid modes
00001C14  D3C0                    1590          ADDA.L D0,A1 ;displace to a specific mode
00001C16  1811                    1591          MOVE.B (A1),D4 ;move mode to D4
00001C18  B404                    1592          CMP.B D4,D2 ;compare mode to masked value
00001C1A  6700 0006               1593          BEQ moveABody ;if its match, its a valid mode and we can procede
00001C1E                          1594          
00001C1E  5280                    1595          ADDQ.L #1,D0 ;add one to displacement
00001C20  60D4                    1596          BRA validMoveADestModes ;check for next mode
00001C22                          1597  moveABody:
00001C22  3401                    1598          MOVE.W  D1,D2 ;copy inst to D2
00001C24  C47C 3000               1599          AND.W  #%0011000000000000,D2 ;mask word for size
00001C28  0C42 0000               1600          CMPI.W #0,D2 ;0 is the non valid size
00001C2C  6700 F442               1601          BEQ falsePositive ; if zero, this is not move
00001C30  0C42 1000               1602          CMPI.W #%0001000000000000,D2
00001C34  6700 F43A               1603          BEQ falsePositive ; if byte, this is not movea
00001C38                          1604  
00001C38                          1605  
00001C38  43F9 00002269           1606          LEA     moveAMessage,A1  ;move string for MOVE
00001C3E  103C 000D               1607          MOVE.B  #13,D0        ;set for task to display null terminated 
00001C42                          1608                                ;string with CR, LF
00001C42  4E4F                    1609          TRAP    #15
00001C44                          1610  
00001C44  7000                    1611          MOVEQ.L #0,D0
00001C46  4E75                    1612          RTS
00001C48                          1613  
00001C48                          1614             
00001C48                          1615  Bcc:
00001C48                          1616  
00001C48  43F9 0000225C           1617          LEA     bccMessage,A1  ;move string for BRA info
00001C4E  103C 000E               1618          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C52                          1619                                ;string without CR, LF
00001C52  4E4F                    1620          TRAP    #15
00001C54                          1621          
00001C54  7000                    1622          MOVEQ.L #0,D0 ;clear D0
00001C56  3401                    1623          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001C58  E04A                    1624          LSR.W   #8,D2
00001C5A  C47C 000F               1625          AND.W   #$0F,D2 ;mask instruction
00001C5E                          1626          
00001C5E                          1627  checkCC:        
00001C5E  41F9 0000217F           1628          LEA     bccList,A0 ;get condition code signature list in A0
00001C64  D1C0                    1629          ADDA.L  D0,A0 ;get correct sig         
00001C66  B410                    1630          CMP.B   (A0),D2 ;compare to sig
00001C68  6700 0006               1631          BEQ     foundCC ;if sig matches branch
00001C6C  5200                    1632          ADDQ.B  #byte,D0
00001C6E  60EE                    1633          BRA     checkCC
00001C70                          1634  foundCC:
00001C70  43F9 00002190           1635          LEA     conditionCodeMessage,A1 ;get condition code message in A1
00001C76  C0FC 0004               1636          MULU.W  #long,D0 ;adjust size of D0 for a long
00001C7A  D3C0                    1637          ADDA.L  D0,A1 ;get correct message location
00001C7C  2251                    1638          MOVEA.L (A1),A1 ;get correct message
00001C7E                          1639          
00001C7E  103C 000E               1640          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C82                          1641                                ;string without CR, LF
00001C82  4E4F                    1642          TRAP    #15
00001C84                          1643  
00001C84                          1644          
00001C84                          1645          
00001C84  548B                    1646          ADDQ.L  #word,A3 ;move past instruction in case long displacement
00001C86  C27C 00FF               1647          AND.W   #$00FF,D1   ;check for word sized displacement
00001C8A                          1648          
00001C8A  B23C 0000               1649          CMP.B   #$0,D1
00001C8E  6700 0010               1650          BEQ     BccWord
00001C92                          1651          
00001C92  B23C 00FF               1652          CMP.B   #$FF,D1 check for long sized displacement
00001C96  6700 0010               1653          BEQ     BccLong
00001C9A                          1654          
00001C9A                          1655  BccByte:
00001C9A                          1656          
00001C9A  7E00                    1657          MOVEQ.L #0,D7 ;pass back no extra data followed
00001C9C  6000 0012               1658          BRA     BccDone
00001CA0                          1659  BccWord:
00001CA0  3213                    1660          MOVE.W  (A3),D1
00001CA2                          1661          
00001CA2  7E02                    1662          MOVEQ.L #word,D7 ;pass back an extra word followed
00001CA4  6000 000A               1663          BRA     BccDone
00001CA8                          1664  BccLong:
00001CA8  2213                    1665          MOVE.L  (A3),D1
00001CAA                          1666          
00001CAA  7E04                    1667          MOVEQ.L #long,D7 ;pass back an extra long followed
00001CAC  6000 0002               1668          BRA     BccDone
00001CB0                          1669  BccDone:
00001CB0                          1670  
00001CB0  343C 0010               1671          MOVE.W  #16,D2 ;put base in D2
00001CB4  303C 000F               1672          MOVE.W  #15,D0  ;put task #15 in D0
00001CB8  4E4F                    1673          TRAP    #15
00001CBA                          1674          
00001CBA  43F9 000021F8           1675          LEA     clearLine,A1  ;move string for a CR and LF
00001CC0  103C 000E               1676          MOVE.B  #14,D0        ;set for task to display null terminated 
00001CC4                          1677                                ;string without CR, LF
00001CC4  4E4F                    1678          TRAP    #15
00001CC6                          1679  
00001CC6  7000                    1680          MOVEQ.L #0,D0
00001CC8  4E75                    1681          RTS
00001CCA                          1682          
00001CCA                          1683          
00001CCA                          1684  unknownOpCode:
00001CCA  43F9 00002263           1685          LEA     dataMessage,A1 ;move string for data info
00001CD0  103C 000E               1686          MOVE.B  #14,D0        ;set for task to display null terminated 
00001CD4                          1687                                ;string without CR, LF
00001CD4  4E4F                    1688          TRAP    #15
00001CD6                          1689          
00001CD6  143C 0010               1690          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001CDA  103C 000F               1691          MOVE.B  #15,D0
00001CDE  4E4F                    1692          TRAP    #15
00001CE0                          1693          
00001CE0  43F9 000021F8           1694          LEA     clearLine,A1  ;move string for a CR and LF
00001CE6  103C 000E               1695          MOVE.B  #14,D0        ;set for task to display null terminated 
00001CEA                          1696                                ;string without CR, LF
00001CEA  4E4F                    1697          TRAP    #15
00001CEC                          1698          
00001CEC  7000                    1699          MOVEQ.L #0,D0
00001CEE  4E75                    1700          RTS
00001CF0                          1701          
00001CF0                          1702  handlebytedata:
00001CF0                          1703  
00001CF0  43F9 00002263           1704          LEA     dataMessage,A1 ;move string for data info
00001CF6  103C 000E               1705          MOVE.B  #14,D0        ;set for task to display null terminated 
00001CFA                          1706                                ;string without CR, LF
00001CFA  4E4F                    1707          TRAP    #15
00001CFC                          1708          
00001CFC  E049                    1709          LSR.W   #8,D1 ;shift the word read into D1 by a byte
00001CFE                          1710          
00001CFE  143C 0010               1711          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001D02  103C 000F               1712          MOVE.B  #15,D0
00001D06  4E4F                    1713          TRAP    #15
00001D08                          1714          
00001D08  43F9 000021F8           1715          LEA     clearLine,A1  ;move string for a CR and LF
00001D0E  103C 000E               1716          MOVE.B  #14,D0        ;set for task to display null terminated 
00001D12                          1717                                ;string without CR, LF
00001D12  4E4F                    1718          TRAP    #15
00001D14                          1719          
00001D14  7000                    1720          MOVEQ.L #0,D0
00001D16                          1721          
00001D16  528B                    1722          ADDQ.L  #byte,A3
00001D18  6000 F30C               1723          BRA main_Loop
00001D1C                          1724  
00001D1C                          1725          
00001D1C                          1726          
00001D1C                          1727  fin
00001D1C                          1728  
00001D1C                          1729          
00001D1C                          1730          
00001D1C  FFFF FFFF               1731          simhalt
00001D20                          1732          
00001D20                          1733  
00001D20                          1734  *******************************************************************************
00001D20                          1735  *                            SUB ROUTINES
00001D20                          1736  *******************************************************************************
00001D20                          1737  
00001D20                          1738  *******************************************************************************
00001D20                          1739  *                          IO ROLE ROUTINES
00001D20                          1740  *******************************************************************************
00001D20                          1741  
00001D20                          1742  *==========================================================================
00001D20                          1743  *                   Enter / Validate beginning address 
00001D20                          1744  *==========================================================================
00001D20                          1745   
00001D20                          1746  begin_address:
00001D20                          1747  
00001D20                          1748         
00001D20  43F9 00002030           1749          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00001D26  2239 00002030           1750          MOVE.L      slPrompt,D1         ;Load display length to D1
00001D2C  700E                    1751          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001D2E  4E4F                    1752          TRAP        #15                 ;Perform task 14 (display)
00001D30                          1753          
00001D30  43F9 0000229A           1754          LEA         startLocation,A1    ;Load address to store user input
00001D36  103C 0002               1755          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001D3A  4E4F                    1756          TRAP        #15                 ;Perform task 2 (input)
00001D3C                          1757          
00001D3C  0C11 001B               1758          CMP.B       #27,(A1)            ;Check for ESC entered
00001D40  6700 004C               1759          BEQ         address_Exit        ;Exit condition 
00001D44                          1760          
00001D44  6100 0050               1761          BSR         enter_addr_edit_all
00001D48  B67C FFFF               1762          CMP.W       #-1,D3              ;Did the edit pass?
00001D4C  67D2                    1763          BEQ         begin_address       ;No, loop and ask for correct input
00001D4E                          1764          
00001D4E  2643                    1765          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
00001D50                          1766          
00001D50  43F9 0000213D           1767          LEA         spc,A1              ;Load address for starting loaction prompt
00001D56  1239 0000213E           1768          MOVE.B      spc_len,D1          ;Load empty line length
00001D5C  7000                    1769          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
00001D5E  4E4F                    1770          TRAP        #15                 ;Perform task 14 (display)
00001D60  6000 0002               1771          BRA         end_address
00001D64                          1772  
00001D64                          1773  *===========================================================================
00001D64                          1774  *                   Enter / Validate ending address 
00001D64                          1775  *===========================================================================
00001D64                          1776  
00001D64                          1777  end_address:
00001D64                          1778          
00001D64  43F9 00002061           1779          LEA         elPrompt,A1         ;Load address for ending loaction prompt
00001D6A                          1780          ;MOVE.L     elPrompt,D1         ;Load display length to D1
00001D6A  7250                    1781          MOVE.L      #80,D1       ;did not like previous command, do not know why, it should have worked
00001D6C  700E                    1782          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001D6E  4E4F                    1783          TRAP        #15                 ;Perform task 14 (display)
00001D70                          1784          
00001D70  103C 0002               1785          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001D74  4E4F                    1786          TRAP        #15                 ;Perform task 2 (input)
00001D76                          1787          
00001D76  0C11 001B               1788          CMP.B       #27,(A1)            ;Check for ESC entered
00001D7A  6700 0012               1789          BEQ         address_Exit        ;Exit condition 
00001D7E                          1790          
00001D7E  6100 0016               1791          BSR         enter_addr_edit_all
00001D82  B67C FFFF               1792          CMP.W       #-1,D3              ;Did the edit pass?
00001D86  67DC                    1793          BEQ         end_address         ;No, loop and ask for correct input
00001D88                          1794  
00001D88  2843                    1795          MOVEA.L     D3,A4               ;Ending address gets stored in A4
00001D8A  6000 0008               1796          BRA         address_done
00001D8E                          1797  
00001D8E                          1798  address_Exit:
00001D8E                          1799  
00001D8E  76FF                    1800          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001D90  6000 0002               1801          BRA         address_done
00001D94                          1802          
00001D94                          1803  address_done:
00001D94                          1804  
00001D94  4E75                    1805          RTS    
00001D96                          1806  
00001D96                          1807  *==============================================================================
00001D96                          1808  * enter_addr_edit_all - Enter address edit check to edit all errors  
00001D96                          1809  *                       using multiple different error checking routines.
00001D96                          1810  *
00001D96                          1811  * Parameters -
00001D96                          1812  *   Input   A1      The data that needs checked.
00001D96                          1813  *   Input   D1      The number of characters input     
00001D96                          1814  *   Output  D3      Returns '-1' when there is an error.
00001D96                          1815  *==============================================================================
00001D96                          1816  
00001D96                          1817  enter_addr_edit_all
00001D96                          1818  
00001D96                          1819  *------------------------------------------------------------------------------
00001D96                          1820  * Test for odd number of characters entered, not allowed
00001D96                          1821  *------------------------------------------------------------------------------
00001D96                          1822         
00001D96  6100 0024               1823          BSR         ck_boundry          ;check if the input is on a odd / even boundry
00001D9A  B67C FFFF               1824          CMP.W       #-1,D3              ;Is the address odd?
00001D9E  6700 001A               1825          BEQ         enter_addr_edit_all_exit     ;No, return
00001DA2                          1826  
00001DA2                          1827  *------------------------------------------------------------------------------
00001DA2                          1828  * Ttest for character entered all being valid address characters
00001DA2                          1829  * Note: lower case a-f, gets converted to upper case A-F in D3
00001DA2                          1830  *------------------------------------------------------------------------------
00001DA2                          1831          
00001DA2  6100 0062               1832          BSR         parseHexString      ;check if the input contains valid Hex characters
00001DA6  B67C FFFF               1833          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
00001DAA  6700 000E               1834          BEQ         enter_addr_edit_all_exit     ;No, return
00001DAE                          1835  
00001DAE                          1836  *------------------------------------------------------------------------------
00001DAE                          1837  * Verify that the address entered is witin the range defined in the Equate
00001DAE                          1838  *------------------------------------------------------------------------------        
00001DAE                          1839          
00001DAE  6100 00C8               1840          BSR         ck_addr_range       ;is address entered witin the range 
00001DB2                          1841                                          ;   as defined in the Equate? 
00001DB2  B67C FFFF               1842          CMP.W       #-1,D3              ;is the address  valid?
00001DB6  6700 0002               1843          BEQ         enter_addr_edit_all_exit     ;No, return
00001DBA                          1844  
00001DBA                          1845  enter_addr_edit_all_exit:
00001DBA                          1846  
00001DBA  4E75                    1847          RTS                             ;return
00001DBC                          1848  
00001DBC                          1849  *==============================================================================
00001DBC                          1850  * ck_boundry - Check the size of the data characters input and determine
00001DBC                          1851  *              if an odd number of characters was entered
00001DBC                          1852  *
00001DBC                          1853  * Parameters -
00001DBC                          1854  *   Input   A1      The data that needs checked for odd length.
00001DBC                          1855  *   Input   D1      The number of characters input     
00001DBC                          1856  *   Output  D3      Returns '-1' when there is an odd length.
00001DBC                          1857  *==============================================================================
00001DBC                          1858  
00001DBC                          1859  ck_boundry:
00001DBC                          1860  
00001DBC  4243                    1861          CLR.W       D3                  ;Clear the return
00001DBE                          1862  
00001DBE  B23C 0000               1863          CMP.B       #0,D1               ;Check for nothing entered
00001DC2  6700 002E               1864          BEQ         ck_size_error       ;Number of characters entered must be 
00001DC6                          1865                                          ;greater than 0  
00001DC6                          1866          
00001DC6                          1867          
00001DC6                          1868          * The program will branch to ck_size_error if D1 is greater than #8        
00001DC6  B23C 0008               1869          CMP.B       #8,D1               ;Check for more than 8 characters entered
00001DCA  6E00 0026               1870          BGT         ck_size_error       ;Number of characters entered must be less
00001DCE                          1871                                          ;than 9
00001DCE                          1872          
00001DCE  7402                    1873          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
00001DD0  82C2                    1874          DIVU        D2,D1               ;Divide address by 2
00001DD2  4841                    1875          SWAP        D1                  ;get remainder
00001DD4  B23C 0001               1876          CMP.B       #$01,D1             ;Check for remainder of 1
00001DD8  6700 0004               1877          BEQ         ck_boundry_error    ;Number of characters entered must be an 
00001DDC                          1878                                          ;even number   
00001DDC                          1879    
00001DDC  4E75                    1880          RTS                             ;return
00001DDE                          1881  
00001DDE                          1882  *------------------------------------------------------------------------------
00001DDE                          1883  * ck_boundry_error - An odd number of characters was entered
00001DDE                          1884  *                  - Load error message and display it
00001DDE                          1885  *                  - Return error condition
00001DDE                          1886  *------------------------------------------------------------------------------
00001DDE                          1887          
00001DDE                          1888  ck_boundry_error:
00001DDE                          1889  
00001DDE  43F9 0000211D           1890          LEA         even_msg,A1         ;Load odd error message into A1
00001DE4  2239 0000211D           1891          MOVE.L      even_msg,D1         ;Load error length to D1
00001DEA                          1892          
00001DEA  7000                    1893          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001DEC                          1894                                          ; n is D1.W with CR, LF. 
00001DEC  4E4F                    1895          TRAP #15                        ;Display the error message
00001DEE  76FF                    1896          MOVE.L #-1,D3                   ;Load -1 into return parameter
00001DF0  4E75                    1897          RTS                             ;Return
00001DF2                          1898          
00001DF2                          1899  *------------------------------------------------------------------------------
00001DF2                          1900  * ck_size_error -   The number of characters entered must be more than zero
00001DF2                          1901  *                  - Load error message and display it
00001DF2                          1902  *                  - Return error condition
00001DF2                          1903  *------------------------------------------------------------------------------
00001DF2                          1904          
00001DF2                          1905  ck_size_error:
00001DF2                          1906  
00001DF2  43F9 00002090           1907          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001DF8  2239 00002090           1908          MOVE.L      invalidMsg,D1       ;Load error length to D1
00001DFE                          1909          
00001DFE  7000                    1910          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001E00                          1911                                          ; n is D1.W with CR, LF. 
00001E00  4E4F                    1912          TRAP        #15                 ;Display the error message
00001E02  76FF                    1913          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001E04  4E75                    1914          RTS                             ;Return        
00001E06                          1915  
00001E06                          1916  
00001E06                          1917  *==============================================================================
00001E06                          1918  * parseHexString - Converts user input string into a valid memory address
00001E06                          1919  *                - Stores parsed address data into D3
00001E06                          1920  *                - Stores good/bad (1/0) data in D4 
00001E06                          1921  *
00001E06                          1922  * Hex values are stored as bytes in D2, the ASCII chart shows their value
00001E06                          1923  *   The ASCII chart values we care about are in the ranges of: 
00001E06                          1924  *                            Hex            Decimal
00001E06                          1925  *       No Value           NULL = 0         0
00001E06                          1926  *       Numeric Values:     0-9 = 30-39     48-57
00001E06                          1927  *       Upper Case letters: A-F = 41-46     65-70
00001E06                          1928  *       Lower Case letterc: a-f = 61-66     97-102
00001E06                          1929  
00001E06                          1930  * Parameters -
00001E06                          1931  *   Input   A1      The data that needs checked for valid input.
00001E06                          1932  *   Output  D3      The return value, '-1' for error
00001E06                          1933  *==============================================================================
00001E06                          1934  
00001E06                          1935  parseHexString:
00001E06                          1936  
00001E06                          1937  * setup any initializing item that do not get looped through
00001E06  4243                    1938          CLR.W       D3                  ;Clear the return
00001E08                          1939  
00001E08                          1940          
00001E08                          1941  *------------------------------------------------------------------------------
00001E08                          1942  * NextHex - Loop through all bytes and vaildate the input
00001E08                          1943  * Parameters -
00001E08                          1944  *   Input   A1      The data that needs checked for valid input.
00001E08                          1945  *   Output  D3      The return value, '-1' for error
00001E08                          1946  *------------------------------------------------------------------------------
00001E08                          1947          
00001E08                          1948  NextHex:
00001E08                          1949  
00001E08  1419                    1950          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00001E0A  B43C 0000               1951          CMP.B       #0,D2               ;Check character for null 
00001E0E  6700 0066               1952          BEQ         NextHexReturn       ;Character is null (end of input)
00001E12                          1953          
00001E12                          1954  *................................................................................
00001E12                          1955  *  Check decimal values 0-9 by testing hexadecimal values 30-39
00001E12                          1956  *................................................................................
00001E12                          1957                  
00001E12                          1958          * The program will branch to hex_range_error if D2 is less than #30
00001E12  B43C 0030               1959          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
00001E16  6D00 0048               1960          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001E1A                          1961                                          ;processing
00001E1A                          1962          
00001E1A                          1963          * The program will branch to UcaseHex if D2 is greater than #39
00001E1A  B43C 0039               1964          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
00001E1E  6E00 000A               1965          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
00001E22                          1966          
00001E22                          1967          *a valid number was found within this range
00001E22  0402 0030               1968          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
00001E26  6000 0032               1969          BRA         NextHexDone         ;Done parsing this byte
00001E2A                          1970  
00001E2A                          1971  
00001E2A                          1972  *..............................................................................
00001E2A                          1973  *  Check upper case values A-F by testing hexadecimal values 41-46
00001E2A                          1974  *..............................................................................
00001E2A                          1975  
00001E2A                          1976  UcaseHex:
00001E2A                          1977  
00001E2A                          1978          * The program will branch to hex_range_error if D2 is less than #41
00001E2A  B43C 0041               1979          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
00001E2E  6D00 0030               1980          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001E32                          1981                                          ;processing
00001E32                          1982          
00001E32  B43C 0046               1983          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
00001E36  6E00 000A               1984          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
00001E3A                          1985                                          ;processing
00001E3A                          1986          
00001E3A                          1987          *a valid number was found within this range
00001E3A  0402 0037               1988          SUBI.B      #55,D2              ;Change uppercase character to actual value
00001E3E  6000 001A               1989          BRA         NextHexDone         ;Done parsing this byte
00001E42                          1990  
00001E42                          1991  
00001E42                          1992  *..............................................................................
00001E42                          1993  *  Check lower case values a-f by testing hexadecimal values 61-66
00001E42                          1994  *..............................................................................
00001E42                          1995  
00001E42                          1996  LcaseHex
00001E42                          1997          
00001E42                          1998          * The program will branch to hex_range_error if D2 is less than #61
00001E42  B43C 0061               1999          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
00001E46  6D00 0018               2000          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
00001E4A                          2001                                          ;processing
00001E4A                          2002  
00001E4A  B43C 0066               2003          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
00001E4E  6E00 0010               2004          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
00001E52                          2005                                          ;processing
00001E52                          2006  
00001E52                          2007          *a valid number was found within this range
00001E52  0402 0057               2008          SUBI.B      #87,D2              ;Change lowercase character to actual value
00001E56  6000 0002               2009          BRA         NextHexDone         ;Done parsing this byte
00001E5A                          2010  
00001E5A                          2011  NextHexDone:
00001E5A                          2012  
00001E5A  E983                    2013          ASL.L       #4,D3               ; Make rooom for new byte in the return register
00001E5C  D602                    2014          ADD.B       D2,D3               ; Move the new byte into the return register
00001E5E  60A8                    2015          BRA         NextHex             ; We're ready to parse the next byte
00001E60                          2016          
00001E60                          2017  *-------------------------------------------------------------------------------------
00001E60                          2018  * hex_range_error -  A character entered was within the valid range for a hex address
00001E60                          2019  *                 -  Load error message and display it
00001E60                          2020  *                 -  Return error condition
00001E60                          2021  *-------------------------------------------------------------------------------------
00001E60                          2022          
00001E60                          2023  hex_range_error:
00001E60                          2024  
00001E60  43F9 000020D5           2025          LEA         invCharMsg,A1       ;Load invalid range message into A1
00001E66  2239 000020D5           2026          MOVE.L      invCharMsg,D1       ;Load error length to D1
00001E6C                          2027          
00001E6C  7000                    2028          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001E6E                          2029                                          ; n is D1.W with CR, LF. 
00001E6E  4E4F                    2030          TRAP        #15                 ;Display the error message
00001E70  76FF                    2031          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001E72  6000 0002               2032          BRA         NextHexReturn
00001E76                          2033          
00001E76                          2034  NextHexReturn:
00001E76                          2035          
00001E76  4E75                    2036          RTS                             ;Return      
00001E78                          2037  
00001E78                          2038  
00001E78                          2039  *===============================================================================
00001E78                          2040  * ck_addr_range - check the address input is within a valid memory address range
00001E78                          2041  *                - Parsed address data into D3
00001E78                          2042  *
00001E78                          2043  * Parameters -
00001E78                          2044  *   Input   A1      The data that needs checked for valid address.
00001E78                          2045  *   Output  D3      The return value, '-1' for error
00001E78                          2046  *===============================================================================
00001E78                          2047  
00001E78                          2048  
00001E78                          2049  ck_addr_range:   
00001E78                          2050  
00001E78                          2051  *------------------------------------------------------------------------------
00001E78                          2052  * Verify that the address entered is witin the 
00001E78                          2053  * beginning range ('begin') as defined in the Equate
00001E78                          2054  *------------------------------------------------------------------------------   
00001E78                          2055              
00001E78  2C3C 00005001           2056          MOVE.L      #begin,D6           * Load minimum starting address
00001E7E  B686                    2057          CMP.L       D6,D3               * Is input at or above minimum?
00001E80  6D00 0012               2058          BLT         ck_addr_range_error 
00001E84                          2059          
00001E84                          2060  *------------------------------------------------------------------------------
00001E84                          2061  * Verify that the address entered is witin the 
00001E84                          2062  * ending range ('end') as defined in the Equate
00001E84                          2063  *------------------------------------------------------------------------------
00001E84                          2064          
00001E84  2C3C 00FFFFFE           2065          MOVE.L      #end,D6             * Load maximum starting address
00001E8A  B686                    2066          CMP.L       D6,D3               * Is input at or below maximum?
00001E8C  6E00 0006               2067          BGT         ck_addr_range_error 
00001E90  6000 0012               2068          BRA         ck_addr_done        ;done checking
00001E94                          2069          
00001E94                          2070  *..............................................................................
00001E94                          2071  * ck_addr_range_error -  A address entered is not within the 
00001E94                          2072  *                        valid range for a hex address
00001E94                          2073  *..............................................................................
00001E94                          2074          
00001E94                          2075  ck_addr_range_error
00001E94                          2076  
00001E94  43F9 00002090           2077          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001E9A                          2078          
00001E9A  700D                    2079          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
00001E9C                          2080                                          ;with CR, LF. 
00001E9C  4E4F                    2081          TRAP        #15                 ;Display the error message
00001E9E  76FF                    2082          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001EA0  6000 0002               2083          BRA         ck_addr_done 
00001EA4                          2084  
00001EA4                          2085  ck_addr_done:
00001EA4                          2086  
00001EA4  4E75                    2087          RTS                             ;Return
00001EA6                          2088  
00001EA6                          2089  *******************************************************************************
00001EA6                          2090  *                          OP CODE ROLE ROUTINES
00001EA6                          2091  *******************************************************************************
00001EA6                          2092  
00001EA6                          2093  process_op_codes:
00001EA6                          2094  
00001EA6                          2095  
00001EA6                          2096  
00001EA6                          2097  process_op_codes_exit:
00001EA6                          2098  
00001EA6  4E75                    2099          RTS
00001EA8                          2100  
00001EA8                          2101  
00001EA8                          2102  *******************************************************************************
00001EA8                          2103  *                    Effective Addressing ROLE ROUTINES
00001EA8                          2104  *******************************************************************************
00001EA8                          2105  
00001EA8                          2106  Get_Effective_Address:
00001EA8                          2107  
00001EA8  1C05                    2108          MOVE.B      D5,D6
00001EAA  E60E                    2109          LSR.B       #3,D6               ;mode
00001EAC  CA3C 0007               2110          And.B       #%00000111,D5       ;register
00001EB0                          2111          
00001EB0  BC3C 0000               2112          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
00001EB4  6700 004A               2113          BEQ         Data_Reg_Direct
00001EB8                          2114          
00001EB8  BC3C 0001               2115          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
00001EBC  6700 005C               2116          BEQ         Addr_Reg_Direct
00001EC0                          2117          
00001EC0  BC3C 0002               2118          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
00001EC4  6700 006E               2119          BEQ         Addr_Reg_Indirect
00001EC8                          2120          
00001EC8  BC3C 0003               2121          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
00001ECC  6700 0098               2122          BEQ         Addr_Reg_Indirect_Inc
00001ED0                          2123          
00001ED0  BC3C 0004               2124          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
00001ED4  6700 00CE               2125          BEQ         Addr_Reg_Indirect_Dec
00001ED8                          2126          
00001ED8  BC3C 0007               2127          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
00001EDC  6700 0006               2128          BEQ         Get_Effective_Address_Other
00001EE0                          2129          
00001EE0  6000 0138               2130          BRA         invalidEA
00001EE4                          2131          
00001EE4                          2132  Get_Effective_Address_Other:        
00001EE4                          2133          
00001EE4  BA3C 0000               2134          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00001EE8  6700 00F8               2135          BEQ Addr_Abs_Short
00001EEC                          2136          
00001EEC  BA3C 0001               2137          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
00001EF0  6700 0104               2138          BEQ Addr_Abs_Long
00001EF4                          2139          
00001EF4  BA3C 0004               2140          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
00001EF8  6700 0110               2141          BEQ Addr_Immediate_Data
00001EFC                          2142          
00001EFC  6000 011C               2143          BRA         invalidEA
00001F00                          2144          
00001F00                          2145  Data_Reg_Direct:                        ;case 0(0000)
00001F00                          2146  
00001F00  43F9 00002290           2147          LEA         letterD,A1          ;output 'D' for data register
00001F06  103C 000E               2148          MOVE.B      #14,D0              ;set for task to display null terminated 
00001F0A  4E4F                    2149          TRAP        #15                 ;string without CR, LF
00001F0C                          2150                          
00001F0C  4281                    2151          CLR.L       D1
00001F0E  1205                    2152          MOVE.B      D5,D1               ;move register number for display into D1
00001F10  103C 0003               2153          MOVE.B      #3,D0               ;set for task to display null terminated 
00001F14  4E4F                    2154          TRAP        #15                 ;string without CR, LF
00001F16                          2155                 
00001F16  6000 0102               2156          BRA         Get_Effective_Address_Exit  ;return
00001F1A                          2157          
00001F1A                          2158          
00001F1A                          2159  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
00001F1A                          2160        
00001F1A  43F9 0000228E           2161          LEA         letterA,A1          ;output 'A' for address register
00001F20  103C 000E               2162          MOVE.B      #14,D0              ;set for task to display null terminated 
00001F24  4E4F                    2163          TRAP        #15                 ;string without CR, LF
00001F26                          2164          
00001F26  4281                    2165          CLR.L       D1
00001F28  1205                    2166          MOVE.B      D5,D1               ;move register number for display into D1
00001F2A  103C 0003               2167          MOVE.B      #3,D0               ;set for task to display null terminated 
00001F2E  4E4F                    2168          TRAP        #15                 ;string without CR, LF
00001F30                          2169          
00001F30  6000 00E8               2170          BRA         Get_Effective_Address_Exit  ;return
00001F34                          2171  
00001F34                          2172  
00001F34                          2173  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
00001F34                          2174          
00001F34  43F9 00002296           2175          LEA         lprn,A1             ;output 'D' for data register
00001F3A  103C 000E               2176          MOVE.B      #14,D0              ;set for task to display null terminated 
00001F3E  4E4F                    2177          TRAP        #15                 ;string without CR, LF
00001F40                          2178  
00001F40  43F9 0000228E           2179          LEA         letterA,A1          ;output 'A' for address register
00001F46  103C 000E               2180          MOVE.B      #14,D0              ;set for task to display null terminated 
00001F4A  4E4F                    2181          TRAP        #15                 ;string without CR, LF
00001F4C                          2182          
00001F4C  4281                    2183          CLR.L       D1
00001F4E  1205                    2184          MOVE.B      D5,D1               ;move register number for display into D1
00001F50  103C 0003               2185          MOVE.B      #3,D0               ;set for task to display null terminated 
00001F54  4E4F                    2186          TRAP        #15                 ;string without CR, LF
00001F56                          2187  
00001F56  43F9 00002298           2188          LEA         rprn,A1             ;output 'D' for data register
00001F5C  103C 000E               2189          MOVE.B      #14,D0              ;set for task to display null terminated 
00001F60  4E4F                    2190          TRAP        #15                 ;string without CR, LF
00001F62                          2191          
00001F62  6000 00B6               2192          BRA         Get_Effective_Address_Exit  ;return
00001F66                          2193  
00001F66                          2194                 
00001F66                          2195  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
00001F66                          2196  
00001F66  43F9 00002296           2197          LEA         lprn,A1             ;output 'D' for data register
00001F6C  103C 000E               2198          MOVE.B      #14,D0              ;set for task to display null terminated 
00001F70  4E4F                    2199          TRAP        #15                 ;string without CR, LF
00001F72                          2200  
00001F72  43F9 0000228E           2201          LEA         letterA,A1          ;output 'A' for address register
00001F78  103C 000E               2202          MOVE.B      #14,D0              ;set for task to display null terminated 
00001F7C  4E4F                    2203          TRAP        #15                 ;string without CR, LF
00001F7E                          2204          
00001F7E  4281                    2205          CLR.L       D1
00001F80  1205                    2206          MOVE.B      D5,D1               ;move register number for display into D1
00001F82  103C 0003               2207          MOVE.B      #3,D0               ;set for task to display null terminated 
00001F86  4E4F                    2208          TRAP        #15                 ;string without CR, LF
00001F88                          2209  
00001F88  43F9 00002298           2210          LEA         rprn,A1             ;output 'D' for data register
00001F8E  103C 000E               2211          MOVE.B      #14,D0              ;set for task to display null terminated 
00001F92  4E4F                    2212          TRAP        #15                 ;string without CR, LF
00001F94                          2213          
00001F94  43F9 00002292           2214          LEA         plus,A1             ;output 'D' for data register
00001F9A  103C 000E               2215          MOVE.B      #14,D0              ;set for task to display null terminated 
00001F9E  4E4F                    2216          TRAP        #15                 ;string without CR, LF
00001FA0                          2217          
00001FA0  6000 0078               2218          BRA         Get_Effective_Address_Exit  ;return
00001FA4                          2219  
00001FA4                          2220  Addr_Reg_Indirect_Dec                   ;4 = (An) - Address Register Indirect with Predecrement (100)
00001FA4                          2221  
00001FA4  43F9 00002294           2222          LEA         minus,A1            ;output '-' for Predecrement
00001FAA  103C 000E               2223          MOVE.B      #14,D0              ;set for task to display null terminated 
00001FAE  4E4F                    2224          TRAP        #15                 ;string without CR, LF
00001FB0                          2225  
00001FB0  43F9 00002296           2226          LEA         lprn,A1             ;output 'D' for data register
00001FB6  103C 000E               2227          MOVE.B      #14,D0              ;set for task to display null terminated 
00001FBA  4E4F                    2228          TRAP        #15                 ;string without CR, LF
00001FBC                          2229  
00001FBC  43F9 0000228E           2230          LEA         letterA,A1          ;output 'A' for address register
00001FC2  103C 000E               2231          MOVE.B      #14,D0              ;set for task to display null terminated 
00001FC6  4E4F                    2232          TRAP        #15                 ;string without CR, LF
00001FC8                          2233          
00001FC8  4281                    2234          CLR.L       D1
00001FCA  1205                    2235          MOVE.B      D5,D1               ;move register number for display into D1
00001FCC  103C 0003               2236          MOVE.B      #3,D0               ;set for task to display null terminated 
00001FD0  4E4F                    2237          TRAP        #15                 ;string without CR, LF
00001FD2                          2238  
00001FD2  43F9 00002298           2239          LEA         rprn,A1             ;output 'D' for data register
00001FD8  103C 000E               2240          MOVE.B      #14,D0              ;set for task to display null terminated 
00001FDC  4E4F                    2241          TRAP        #15                 ;string without CR, LF
00001FDE                          2242          
00001FDE  6000 003A               2243          BRA         Get_Effective_Address_Exit  ;return
00001FE2                          2244          
00001FE2                          2245                         
00001FE2                          2246  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00001FE2                          2247          
00001FE2                          2248          
00001FE2  43F9 00002270           2249          LEA         xxxW,A1             ;output 'D' for data register
00001FE8  103C 000E               2250          MOVE.B      #14,D0              ;set for task to display null terminated 
00001FEC  4E4F                    2251          TRAP        #15                 ;string without CR, LF
00001FEE                          2252  
00001FEE  548B                    2253          ADDA.L      #word,A3
00001FF0                          2254          
00001FF0                          2255          ;print word (A3)
00001FF0                          2256          ;MOVE.W      A3,(A1)
00001FF0                          2257          ;MOVE.B      #1,D0               ;set for task to display null terminated 
00001FF0                          2258          ;TRAP        #15                 ;string without CR, LF
00001FF0                          2259          
00001FF0  5487                    2260          ADDI.L      #word,D7 
00001FF2  6000 0026               2261          BRA         Get_Effective_Address_Exit  ;return
00001FF6                          2262                         
00001FF6                          2263  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
00001FF6                          2264          
00001FF6  43F9 0000227A           2265          LEA         xxxL,A1             ;output 'D' for data register
00001FFC  103C 000E               2266          MOVE.B      #14,D0              ;set for task to display null terminated 
00002000  4E4F                    2267          TRAP        #15                 ;string without CR, LF
00002002                          2268  
00002002  548B                    2269          ADDA.L      #word,A3
00002004                          2270          
00002004                          2271          ;print long (A3)
00002004                          2272          ;MOVE.L      A3,(A1)
00002004                          2273          ;MOVE.B      #14,D0              ;set for task to display null terminated 
00002004                          2274          ;TRAP        #15                 ;string without CR, LF
00002004                          2275          
00002004  5887                    2276          ADDI.L      #long,D7
00002006  6000 0012               2277          BRA         Get_Effective_Address_Exit  ;return
0000200A                          2278                         
0000200A                          2279  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
0000200A                          2280  
0000200A  43F9 00002284           2281          LEA         iData,A1            ;output 'D' for data register
00002010  103C 000E               2282          MOVE.B      #14,D0              ;set for task to display null terminated 
00002014  4E4F                    2283          TRAP        #15                 ;string without CR, LF
00002016                          2284          
00002016                          2285          *need another input param for size
00002016  6000 0002               2286          BRA         Get_Effective_Address_Exit  ;return
0000201A                          2287  
0000201A                          2288  invalidEA:
0000201A                          2289  
0000201A                          2290          ;do something
0000201A                          2291   
0000201A                          2292  Get_Effective_Address_Exit:     
0000201A                          2293  
0000201A  4E75                    2294          RTS                             ;return
0000201C                          2295  
0000201C                          2296  switchModeAndReg:
0000201C                          2297  ***
0000201C                          2298  * Assumed in D2
0000201C                          2299  *
0000201C                          2300  * Assumed that they are in least significant byte:
0000201C                          2301  *
0000201C                          2302  *            _this_
0000201C                          2303  *           /      \
0000201C                          2304  *  ........ ........
0000201C                          2305  *  \                /
0000201C                          2306  *   -----word-------
0000201C                          2307  *
0000201C                          2308  *  and that in that byte they are ordered:
0000201C                          2309  *
0000201C                          2310  *       ........   
0000201C                          2311  *       \/\_/\_/
0000201C                          2312  *      /  /    \
0000201C                          2313  *    /   /      \
0000201C                          2314  * dont  one    other
0000201C                          2315  * care
0000201C                          2316  *
0000201C                          2317  * after they will be
0000201C                          2318  *
0000201C                          2319  *       ........   
0000201C                          2320  *       \/\_/\_/
0000201C                          2321  *      /  /    \
0000201C                          2322  *    /   /      \
0000201C                          2323  * dont other    one
0000201C                          2324  * care
0000201C                          2325  *** 
0000201C  0202 003F               2326          AndI.B #%00111111,D2 ;remove unwanted bits from D2
00002020  0283 00000000           2327          ANDI.L #0,D3 ;clear D3
00002026  1602                    2328          MOVE.B D2,D3 ;copy to D3
00002028  E70B                    2329          LSL.B  #3,D3 
0000202A  E60A                    2330          LSR.B  #3,D2
0000202C  D403                    2331          ADD.B  D3,D2
0000202E  4E75                    2332          RTS
00002030                          2333  
00002030                          2334          
00002030                          2335  *==============================================================================
00002030                          2336  *                            variables and constants
00002030                          2337  *==============================================================================
00002030                          2338  
00002030                          2339  
00002030                          2340  ***initial user prompt stuff        
00002030= 45 6E 74 65 72 20 ...   2341  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE: $',0
00002061= 45 6E 74 65 72 20 ...   2342  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE: $',0
00002090                          2343  
00002090= 20 41 64 64 72 65 ...   2344  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
000020D5= 20 41 20 43 68 61 ...   2345  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
0000211D                          2346  
0000211D= 20 59 6F 75 20 6D ...   2347  even_msg        DC.B    ' You must enter an even address!'
0000213D                          2348  
0000213D= 20                      2349  spc             DC.B    ' '
0000213E= 01                      2350  spc_len         DC.B    spc_len-spc
0000213F                          2351  ***
0000213F                          2352  
0000213F                          2353  
0000213F                          2354  
0000213F                          2355  ***list of OP codes
0000213F                          2356  
0000213F  =0000E6C0               2357  rsrlweaInstruction  EQU %1110011011000000
0000213F  =0000E018               2358  rsrlregInstruction  EQU %1110000000011000
0000213F  =0000E0C0               2359  asrlweaInstruction  EQU %1110000011000000
0000213F  =0000E000               2360  asrlregInstruction  EQU %1110000000000000
0000213F  =0000E2C0               2361  lsrlweaInstruction  EQU %1110001011000000
0000213F  =0000E008               2362  lsrlregInstruction  EQU %1110000000001000
0000213F  =00005100               2363  subqInstruction  EQU %0101000100000000
0000213F  =00009000               2364  subInstruction   EQU %1001000000000000
0000213F  =0000D000               2365  addaInstruction  EQU %1101000000000000
0000213F  =0000D000               2366  addInstruction   EQU %1101000000000000
0000213F  =00004880               2367  movemInstruction EQU %0100100010000000
0000213F  =00000600               2368  addiInstruction  EQU %0000011000000000
0000213F  =00000000               2369  oriInstruction   EQU 0
0000213F  =00000C00               2370  cmpiInstruction  EQU %0000110000000000
0000213F  =00004E80               2371  jsrInstruction   EQU %0100111010000000
0000213F  =00004E75               2372  rtsInstruction   EQU %0100111001110101
0000213F  =00004E71               2373  NoOpInstruction  EQU %0100111001110001
0000213F  =00000000               2374  moveInstruction  EQU 0
0000213F  =00006000               2375  bccInstruction   EQU %0110000000000000
0000213F  =00004400               2376  negInstruction   EQU %0100010000000000
0000213F  =00000000               2377  dataInstruction  EQU 0
0000213F                          2378  
0000213F                          2379  ***
0000213F                          2380  
0000213F                          2381  ***list of OP masks
0000213F                          2382  
0000213F  =0000FEC0               2383  rsrlweaMask  EQU %1111111011000000
0000213F  =0000F018               2384  rsrlregMask  EQU %1111000000011000
0000213F  =0000FEC0               2385  asrlweaMask  EQU %1111111011000000
0000213F  =0000F018               2386  asrlregMask  EQU %1111000000011000
0000213F  =0000FEC0               2387  lsrlweaMask  EQU %1111111011000000
0000213F  =0000F018               2388  lsrlregMask  EQU %1111000000011000
0000213F  =0000F100               2389  subqMask  EQU %1111000100000000
0000213F  =0000F000               2390  subMask   EQU %1111000000000000
0000213F  =0000F000               2391  addaMask  EQU %1111000000000000
0000213F  =0000F000               2392  addMask   EQU %1111000000000000
0000213F  =0000FB80               2393  movemMask EQU %1111101110000000
0000213F  =0000FF00               2394  addiMask  EQU %1111111100000000
0000213F  =0000FF00               2395  oriMask   EQU %1111111100000000
0000213F  =0000FF00               2396  cmpiMask  EQU %1111111100000000
0000213F  =0000FFC0               2397  jsrMask   EQU %1111111111000000
0000213F  =0000FFFF               2398  rtsMask   EQU $FFFF
0000213F  =0000FFFF               2399  NoOpMask  EQU $FFFF
0000213F  =0000C000               2400  moveMask  EQU $C000
0000213F  =0000F000               2401  bccMask   EQU $F000
0000213F  =0000FF00               2402  negMask   EQU $FF00
0000213F  =00000000               2403  dataMask  EQU 0
0000213F                          2404  ***
0000213F                          2405  
0000213F                          2406  ***Bcc Codes***
0000213F  =00000004               2407  CC EQU $04
0000213F  =00000005               2408  CS EQU $05
0000213F  =00000007               2409  EQ EQU $07
0000213F  =0000000C               2410  GE EQU $0C
0000213F  =0000000E               2411  GT EQU $0E
0000213F  =00000002               2412  HI EQU $02
0000213F  =0000000F               2413  LE EQU $0F
0000213F  =00000003               2414  LS EQU $03
0000213F  =0000000D               2415  LT EQU $0D
0000213F  =0000000B               2416  MI EQU $0B
0000213F  =00000006               2417  NE EQU $06
0000213F  =0000000A               2418  PL EQU $0A
0000213F  =00000008               2419  VC EQU $08
0000213F  =00000009               2420  VS EQU $09
0000213F  =00000000               2421  RA EQU $00 ;not really a Condition Code
0000213F  =00000001               2422  SR EQU $01 ;not really a Condition Code
0000213F                          2423  
0000213F= 43 43 20 00             2424  CCm DC.B 'CC ',0
00002143= 43 53 20 00             2425  CSm DC.B 'CS ',0
00002147= 45 51 20 00             2426  EQm DC.B 'EQ ',0
0000214B= 47 45 20 00             2427  GEm DC.B 'GE ',0
0000214F= 47 54 20 00             2428  GTm DC.B 'GT ',0
00002153= 48 49 20 00             2429  HIm DC.B 'HI ',0
00002157= 4C 45 20 00             2430  LEm DC.B 'LE ',0
0000215B= 4C 53 20 00             2431  LSm DC.B 'LS ',0
0000215F= 4C 54 20 00             2432  LTm DC.B 'LT ',0
00002163= 4D 49 20 00             2433  MIm DC.B 'MI ',0
00002167= 4E 45 20 00             2434  NEm DC.B 'NE ',0
0000216B= 50 4C 20 00             2435  PLm DC.B 'PL ',0
0000216F= 56 43 20 00             2436  VCm DC.B 'VC ',0
00002173= 56 53 20 00             2437  VSm DC.B 'VS ',0
00002177= 52 41 20 00             2438  RAm DC.B 'RA ',0
0000217B= 53 52 20 00             2439  SRm DC.B 'SR ',0
0000217F                          2440  
0000217F= 01 04 05 07 0C 0E ...   2441  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
00002190= 0000217B 0000213F ...   2442  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
000021D0                          2443  ***
000021D0                          2444  
000021D0= 45 6E 74 65 72 20 ...   2445  startLocationPrompt DC.B    'Enter start location',0
000021E5= 45 6E 74 65 72 20 ...   2446  endLocationPrompt   DC.B    'Enter end location',0
000021F8                          2447  
000021F8= 0D 0A 00                2448  clearLine  DC.B $0D,$0A,0
000021FB                          2449  
000021FB= 52 4F 4C 20 00          2450  rslMessage      DC.B 'ROL ',0
00002200= 52 4F 52 20 00          2451  rsrMessage      DC.B 'ROR ',0
00002205= 41 53 4C 20 00          2452  aslMessage      DC.B 'ASL ',0
0000220A= 41 53 52 20 00          2453  asrMessage      DC.B 'ASR ',0
0000220F= 4C 53 4C 20 00          2454  lslMessage      DC.B 'LSL ',0
00002214= 4C 53 52 20 00          2455  lsrMessage      DC.B 'LSR ',0
00002219= 53 55 42 51 20 00       2456  subqMessage     DC.B 'SUBQ ',0
0000221F= 53 55 42 20 00          2457  subMessage      DC.B 'SUB ',0 
00002224= 41 44 44 41 20 00       2458  addaMessage     DC.B 'ADDA ',0
0000222A= 41 44 44 20 00          2459  addMessage      DC.B 'ADD ',0
0000222F= 4D 4F 56 45 4D 20 00    2460  movemMessage    DC.B 'MOVEM ',0
00002236= 41 44 44 49 20 00       2461  addiMessage     DC.B 'ADDI ',0
0000223C= 4F 52 49 20 00          2462  oriMessage      DC.B 'ORI ',0
00002241= 43 4D 50 49 20 00       2463  cmpiMessage     DC.B 'CMPI ',0
00002247= 4A 53 52 20 00          2464  jsrMessage      DC.B 'JSR ',0
0000224C= 52 54 53 20 00          2465  rtsMessage      DC.B 'RTS ',0
00002251= 4E 4F 50 20 00          2466  nopMessage      DC.B 'NOP ',0 
00002256= 4D 4F 56 45 20 00       2467  moveMessage     DC.B 'MOVE ',0
0000225C= 42 00                   2468  bccMessage      DC.B 'B',0
0000225E= 4E 45 47 20 00          2469  negMessage      DC.B 'NEG ',0
00002263= 44 41 54 41 20 00       2470  dataMessage     DC.B 'DATA ',0
00002269= 4D 4F 56 45 41 20 00    2471  moveaMessage    DC.B 'MOVEA ',0
00002270                          2472  
00002270= 28 78 78 78 29 2E ...   2473  xxxW            DC.B '(xxx).W: ',0
0000227A= 28 78 78 78 29 2E ...   2474  xxxL            DC.B '(xxx).L: ',0
00002284= 23 28 64 61 74 61 ...   2475  iData           DC.B '#(data): ',0
0000228E                          2476  
0000228E= 41 00                   2477  letterA         DC.B 'A', 0
00002290= 44 00                   2478  letterD         DC.B 'D', 0
00002292                          2479  
00002292= 2B 00                   2480  plus            DC.B '+', 0
00002294= 2D 00                   2481  minus           DC.B '-', 0
00002296= 28 00                   2482  lPrn            DC.B '(', 0
00002298= 29 00                   2483  rPrn            DC.B ')', 0
0000229A                          2484  
0000229A                          2485  
0000229A= 00000000                2486  startLocation       DC.L    0
0000229E= 00000000                2487  endLocation         DC.L    0
000022A2                          2488  
000022A2                          2489  
000022A2                          2490     
000022A2                          2491      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 16D0
ADDA                1632
ADDABODY            167A
ADDAINSTRUCTION     D000
ADDAMASK            F000
ADDAMESSAGE         2224
ADDDEST             1794
ADDDESTEA           16C4
ADDDESTEAMASKS      16CA
ADDI                1902
ADDIBODY            192E
ADDIDONE            196C
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         2236
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          222A
ADDRESS_DONE        1D94
ADDRESS_EXIT        1D8E
ADDR_ABS_LONG       1FF6
ADDR_ABS_SHORT      1FE2
ADDR_IMMEDIATE_DATA  200A
ADDR_REG_DIRECT     1F1A
ADDR_REG_INDIRECT   1F34
ADDR_REG_INDIRECT_DEC  1FA4
ADDR_REG_INDIRECT_INC  1F66
ADDSOURCE           174C
ASLEA               12AE
ASLMESSAGE          2205
ASLREG              12F4
ASREA               129E
ASRLREG             12BE
ASRLREGINSTRUCTION  E000
ASRLREGMASK         F018
ASRLWEA             125E
ASRLWEACHECKDIRECTION  128A
ASRLWEAINSTRUCTION  E0C0
ASRLWEAMASK         FEC0
ASRMESSAGE          220A
ASRREG              12E4
BCC                 1C48
BCCBYTE             1C9A
BCCDONE             1CB0
BCCINSTRUCTION      6000
BCCLIST             217F
BCCLONG             1CA8
BCCMASK             F000
BCCMESSAGE          225C
BCCWORD             1CA0
BEGIN               5001
BEGIN_ADDRESS       1D20
BYTE                1
CC                  4
CCM                 213F
CHECKCC             1C5E
CHECKMOVEADEST      1BF4
CHECKMOVEDEST       1B42
CHECKOPCODE         1050
CK_ADDR_DONE        1EA4
CK_ADDR_RANGE       1E78
CK_ADDR_RANGE_ERROR  1E94
CK_BOUNDRY          1DBC
CK_BOUNDRY_ERROR    1DDE
CK_SIZE_ERROR       1DF2
CLEARLINE           21F8
CMPI                1A04
CMPIBODY            1A2C
CMPIDONE            1A6A
CMPIEA              19F6
CMPIEAMASKS         19FD
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         2241
CONDITIONCODEMESSAGE  2190
CS                  5
CSM                 2143
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         2263
DATA_REG_DIRECT     1F00
ELPROMPT            2061
END                 FFFFFE
ENDLOCATION         229E
ENDLOCATIONPROMPT   21E5
END_ADDRESS         1D64
ENTER_ADDR_EDIT_ALL  1D96
ENTER_ADDR_EDIT_ALL_EXIT  1DBA
EQ                  7
EQM                 2147
EVEN_MSG            211D
FALSEPOSITIVE       1070
FARLABEL            FFE
FIN                 1D1C
FOUNDCC             1C70
GE                  C
GEM                 214B
GET_EFFECTIVE_ADDRESS  1EA8
GET_EFFECTIVE_ADDRESS_EXIT  201A
GET_EFFECTIVE_ADDRESS_OTHER  1EE4
GT                  E
GTM                 214F
HANDLEBYTEDATA      1CF0
HEX_RANGE_ERROR     1E60
HI                  2
HIM                 2153
IDATA               2284
INSTLABELLIST       10EA
INSTMASKLIST        10C0
INSTOPLIST          1096
INSTOPLIST2         10A2
INVALIDEA           201A
INVALIDMSG          2090
INVCHARMSG          20D5
JSR                 1A82
JSRBODY             1AAA
JSRDONE             1ACA
JSREA               1A7A
JSREAMASKS          1A7E
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          2247
LCASEHEX            1E42
LE                  F
LEM                 2157
LETTERA             228E
LETTERD             2290
LONG                4
LPRN                2296
LS                  3
LSLEA               135C
LSLMESSAGE          220F
LSLREG              13C6
LSM                 215B
LSREA               134C
LSRLCHECKI          141C
LSRLCHECKIR         1406
LSRLCHECKIRRETURN   141A
LSRLCHECKR          1450
LSRLEA              1304
LSRLEAMASKS         130A
LSRLREG             1390
LSRLREGBODY         13D6
LSRLREGINSTRUCTION  E008
LSRLREGMASK         F018
LSRLWEA             1310
LSRLWEABODY         136C
LSRLWEACHECKDIRECTION  1338
LSRLWEAINSTRUCTION  E2C0
LSRLWEAMASK         FEC0
LSRMESSAGE          2214
LSRREG              13B6
LT                  D
LTM                 215F
MAIN_LOOP           1026
MATCH               1076
MI                  B
MIM                 2163
MINUS               2294
MOVE                1B1A
MOVEA               1BCC
MOVEABODY           1C22
MOVEADESTEA         1BC8
MOVEADESTEAMASKS    1BCA
MOVEAMESSAGE        2269
MOVEBODY            1B70
MOVEDESTEA          1B0C
MOVEDESTEAMASKS     1B13
MOVEINSTRUCTION     0
MOVEM               17F0
MOVEMASK            C000
MOVEMBODY           185A
MOVEMESSAGE         2256
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     17E6
MOVEMMEMTOREGEAMASKS  17EB
MOVEMMESSAGE        222F
MOVEMREGTOMEMEA     17DC
MOVEMREGTOMEMEAMASKS  17E1
MOVESOURCEEA        1AFA
MOVESOURCEEAMASKS   1B03
NE                  6
NEG                 189C
NEGBODY             18C4
NEGDONE             18F2
NEGEA               188C
NEGEAMASKS          1894
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          225E
NEM                 2167
NEXTHEX             1E08
NEXTHEXDONE         1E5A
NEXTHEXRETURN       1E76
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 1ADA
NOPMESSAGE          2251
ORI                 197C
ORIBODY             19A8
ORIDONE             19E6
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          223C
PARSEHEXSTRING      1E06
PL                  A
PLM                 216B
PLUS                2292
PRGORG              1000
PROCESS_OP_CODES    1EA6
PROCESS_OP_CODES_EXIT  1EA6
PROMPT_USER         1014
RA                  0
RAM                 2177
RPRN                2298
RSLEA               1208
RSLMESSAGE          21FB
RSLREG              124E
RSREA               11F8
RSRLREG             1218
RSRLREGINSTRUCTION  E018
RSRLREGMASK         F018
RSRLWEA             11B8
RSRLWEACHECKDIRECTION  11E4
RSRLWEAINSTRUCTION  E6C0
RSRLWEAMASK         FEC0
RSRMESSAGE          2200
RSRREG              123E
RTS                 1AEA
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          224C
SLPROMPT            2030
SNIPPET             113E
SNIPPETEND          11B4
SPC                 213D
SPC_LEN             213E
SR                  1
SRM                 217B
STACK               5000
START               1000
STARTLOCATION       229A
STARTLOCATIONPROMPT  21D0
SUB                 1522
SUBDEST             15EA
SUBINSTRUCTION      9000
SUBMASK             F000
SUBMESSAGE          221F
SUBQ                147A
SUBQBODY            14B2
SUBQEA              146A
SUBQEAMASKS         1472
SUBQINSTRUCTION     5100
SUBQMASK            F100
SUBQMESSAGE         2219
SUBSOURCE           15A2
SWITCHMODEANDREG    201C
TOEIGHT             151E
UCASEHEX            1E2A
UNKNOWNOPCODE       1CCA
VALIDADDA           1650
VALIDADDDESTEA      1720
VALIDADDIMODES      1904
VALIDADDSOURCEEA    16F6
VALIDASRL           1260
VALIDCMPIMODES      1A06
VALIDJSRMODES       1A84
VALIDLSRL           1312
VALIDMEMTOREG       182C
VALIDMOVEADESTMODES  1BF6
VALIDMOVEASOURCEMODES  1BCE
VALIDMOVEDESTMODES  1B44
VALIDMOVESOURCEMODES  1B1C
VALIDNEGMODES       189E
VALIDORIMODES       197E
VALIDREGTOMEM       1806
VALIDRSRL           11BA
VALIDSUBDESTEA      1572
VALIDSUBQ           148C
VALIDSUBSOURCEEA    1548
VC                  8
VCM                 216F
VS                  9
VSM                 2173
WORD                2
XXXL                227A
XXXW                2270
ZEROTOEIGHT         1514
ZEROTOEIGHTRETURN   151C

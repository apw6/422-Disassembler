00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/9/2014 6:37:51 PM

00000000                             1  *##########################################################################
00000000                             2  * Title      : 
00000000                             3  * Written by : Andrew Watson
00000000                             4  *            : Elaine Keller
00000000                             5  *            : Robert Anderson
00000000                             6  * Date       : 11/14/2014
00000000                             7  * Description: 
00000000                             8  *##########################################################################
00000000                             9  
00000000                            10  ***Possible Bug***
00000000                            11  *can not tell data from an
00000000                            12  *unidentified instruction from an actual
00000000                            13  *instruction therefore causing errors.
00000000                            14  *may not actually be a bug because data
00000000                            15  *is data to the machine, and if you modify
00000000                            16  *the instructions in memory for a program
00000000                            17  *by moivng data, you can modify the instuctions
00000000                            18  *executed.
00000000                            19  
00000000                            20  
00000000                            21  ***************************************************************************
00000000                            22  *                   Variable/Data Definitions
00000000                            23  ***************************************************************************
00000000                            24  
00000000  =00005000                 25  stack   EQU   $00005000
00000000  =00005001                 26  begin   EQU   $00005001
00000000  =00FFFFFE                 27  end     EQU   $00FFFFFE
00000000  =00000001                 28  byte    EQU   1
00000000  =00000002                 29  word    EQU   2
00000000  =00000004                 30  long    EQU   4
00000000  =00001000                 31  prgorg  EQU   $1000
00000000                            32  
00000FFE                            33      ORG $00000FFE
00000FFE                            34  FarLabel:
00001000                            35      ORG    prgorg
00001000                            36  start:
00001000  4FF8 5000                 37          LEA stack, SP ;initialize stack
00001004                            38  
00001000                            39      ORG    prgorg
00001000                            40  
00001000                            41  ******************************************************************************
00001000                            42  *                   Begin processing active code
00001000                            43  ******************************************************************************
00001000                            44      
00001000                            45  start:
00001000                            46  
00001000  4FF8 5000                 47          LEA         stack, SP           ;Initialize stack
00001004                            48          
00001004                            49  *.............................................................................
00001004                            50  * Debug Mode - Comment out when done
00001004  267C 0000114E             51          MOVE.L      #snippet,A3
0000100A  287C 000011CC             52          MOVE.L      #snippetEnd,A4
00001010  6000 0014                 53          BRA         main_Loop
00001014                            54  * Debug Mode - Comment out when done
00001014                            55  *.............................................................................        
00001014                            56          
00001014                            57  prompt_user:
00001014                            58  
00001014  6100 0E16                 59          BSR         begin_address
00001018  B67C FFFF                 60          CMP.W       #-1,D3              ;Did the choose to exit, or error occur?
0000101C  6700 0E0A                 61          BEQ         fin                 ;Yes, then exit
00001020                            62          
00001020  6000 0004                 63          BRA         main_Loop
00001024                            64          ;BSR         process_op_codes
00001024  60EE                      65          BRA         prompt_user
00001026                            66                  
00001026                            67  ******************************************************************************
00001026                            68  *                   Begin processing OP Codes
00001026                            69  ******************************************************************************
00001026                            70   
00001026                            71  main_Loop:
00001026                            72  
00001026  B9CB                      73          CMPA.L A3,A4 ;check end of prog
00001028  6700 0DFE                 74          BEQ fin
0000102C                            75          
0000102C  3213                      76          MOVE.W (A3),D1 ;copy word from other prog to analyze as instruction
0000102E                            77          
0000102E                            78          ;handle an odd memory access(instructions will never be misaligned)
0000102E  240B                      79          MOVE.L A3,D2 ; copy address to D2
00001030  0202 0001                 80          ANDI.B #%00000001,D2 ;mask everything except the least significant bit
00001034  0C02 0001                 81          CMPI.B #1,D2 ;compare the least sig bit of the address to one
00001038  6700 0DC2                 82          BEQ handlebytedata ;the least sig bit will only be one if the insrtuction
0000103C                            83                             ;is odd(misaligned) and therefore not an instruction
0000103C                            84          
0000103C  7600                      85          MOVEQ.L #0,D3
0000103E                            86          
0000103E                            87          ***things to save A3,A4,D1(?)***
0000103E  48E7 0018                 88          MOVEM.L A3-A4,-(SP)
00001042  6100 000C                 89          BSR checkOPcode
00001046  4CDF 1800                 90          MOVEM.L (SP)+,A3-A4
0000104A  D7C7                      91          ADDA.L  D7,A3 ;look past data that was part of the instruction
0000104C                            92          
0000104C  548B                      93          ADDQ.L  #word,A3
0000104E  60D6                      94          BRA     main_Loop 
00001050                            95          
00001050                            96  checkOPcode:
00001050                            97  
00001050                            98  
00001050  7E00                      99          MOVEQ.L #0,D7
00001052                           100          
00001052  41F9 00001096            101          LEA     instOPList,A0 ;get instruction signitrue list in A0
00001058  D1C3                     102          ADDA.L  D3,A0 ;get correct sig         
0000105A                           103          
0000105A  43F9 000010C4            104          LEA     instMaskList,A1 ;get instruction mask in A1
00001060  D3C3                     105          ADDA.L  D3,A1  ;get correct mast
00001062                           106          
00001062  3401                     107          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001064                           108          
00001064  C451                     109          AND.W   (A1),D2 ;mask instruction
00001066                           110          
00001066                           111          
00001066                           112          
00001066                           113          
00001066  B450                     114          CMP.W   (A0),D2 ;compare to sig
00001068  6700 000C                115          BEQ     match ;if sig matches branch
0000106C  5483                     116          ADDQ.L  #word,D3 ;add to D3 to check for next instruction
0000106E  60E0                     117          BRA checkOPcode
00001070                           118          
00001070                           119  falsePositive:
00001070                           120          
00001070  103C 00FF                121          MOVE.B #-1,D0
00001074  4E75                     122          RTS
00001076                           123  
00001076                           124  match:
00001076                           125          
00001076  43F9 000010F2            126          LEA     instLabelList,A1 ;get instruction code label
0000107C  D3C3                     127          ADDA.L  D3,A1 ;get correct label
0000107E  D3C3                     128          ADDA.L  D3,A1
00001080  5483                     129          ADDQ.L  #word,D3 ;add to D3 incase false positive
00001082  2251                     130          MOVEA.L (A1),A1
00001084  48E7 1000                131          MOVEM.L D3,-(SP) ; save D3
00001088  4E91                     132          JSR     (A1)
0000108A  4CDF 0008                133          MOVEM.L (SP)+,D3 ;restore D3
0000108E  B03C 00FF                134          CMP.B   #-1,D0
00001092  67BC                     135          BEQ     checkOPcode
00001094  4E75                     136          RTS
00001096                           137          
00001096                           138  
00001096= 81C0 C1C0 E6C0 E...      139  instOPList  DC.W divsInstruction,mulsInstruction,rsrlweaInstruction,rsrlregInstruction,asrlweaInstruction,asrlregInstruction,lsrlweaInstruction,lsrlregInstruction
000010A6= 5100 9000 D000 D...      140  instOPList2 DC.W subqInstruction,subInstruction,addaInstruction,addInstruction,movemInstruction,addiInstruction,oriInstruction,cmpiInstruction,jsrInstruction,rtsInstruction,negInstruction,NoOpInstruction,moveInstruction,bccInstruction,dataInstruct
000010C4                           141      
000010C4= F1C0 F1C0 FEC0 F...      142  instMaskList DC.W divsMask,mulsMask,rsrlweaMask,rsrlregMask,asrlweaMask,asrlregMask,lsrlweaMask,lsrlregMask,subqMask,subMask,addaMask,addMask,movemMask,addiMask,oriMask,cmpiMask,jsrMask,rtsMask,negMask,NoOpMask,moveMask,bccMask,dataMask          
000010F2= 000011D0                 143  instLabelList  DC.L DIVS
000010F6= 00001254 000012C4 ...    144  instLabelList2 DC.L MULS,RSRLWEA,RSRLREG,ASRLWEA,ASRLREG,LSRLWEA,LSRLREG,SUBQ,SUB,ADDA,ADD,MOVEM,ADDI,ORI,CMPI,JSR,RTS,NEG,NOP, MOVE,Bcc,unknownOpCode
0000114E                           145  
0000114E                           146  snippet:
0000114E  4E71                     147           NOP
00001150  60FC                     148           BRA snippet
00001152  6000 FEAA                149           BRA FarLabel
00001156  67F6                     150           BEQ snippet
00001158  6E00 084E                151           BGT NEG
0000115C  61F0                     152           BSR snippet
0000115E  4441                     153           NEG D1
00001160  3239 00008500            154           MOVE.W $8500,D1
00001166  0645 001E                155           ADDI.W #30,D5
0000116A  4E75                     156           RTS
0000116C  4EB8 0054                157           JSR $54
00001170  0C41 0003                158           CMPI #3,D1
00001174  0041 0003                159           ORI  #3,D1
00001178  48E7 0018                160           MOVEM.L A3-A4,-(SP)
0000117C  D401                     161           ADD.B D1,D2
0000117E  0603 000A                162           ADD.B #10,D3
00001182  D7FC 00000463            163           ADDA.L #1123,A3
00001188  9A43                     164           SUB.W D3,D5
0000118A  5105                     165           SUBQ.B #8,D5
0000118C  5305                     166           SUBQ.B #1,D5
0000118E  E64B                     167           LSR #3,D3
00001190  E74C                     168           LSL #3,D4
00001192  E369                     169           LSL D1,D1
00001194  E66F                     170           LSR D3,D7
00001196  E2F8 3563                171           LSR $3563
0000119A  E3F9 00486412            172           LSL $486412
000011A0  E643                     173           ASR #3,D3
000011A2  E744                     174           ASL #3,D4
000011A4  E361                     175           ASL D1,D1
000011A6  E667                     176           ASR D3,D7
000011A8  E0F8 3563                177           ASR $3563
000011AC  E1F9 00486412            178           ASL $486412
000011B2  E65B                     179           ROR #3,D3
000011B4  E75C                     180           ROL #3,D4
000011B6  E379                     181           ROL D1,D1
000011B8  E67F                     182           ROR D3,D7
000011BA  E6F8 3563                183           ROR $3563
000011BE  E7F9 00486412            184           ROL $486412
000011C4  C5FC 4562                185           MULS #$4562,D2
000011C8  85FC 4562                186           DIVS #$4562,D2
000011CC                           187  
000011CC                           188           
000011CC                           189  snippetEnd:
000011CC  FFFF FFFF                190           SIMHALT
000011D0                           191  
000011D0                           192  
000011D0                           193  DIVS:
000011D0                           194  
000011D0  7000                     195          MOVEQ.L #0, D0 ;clear D0
000011D2                           196          
000011D2                           197  validDivsModes:
000011D2                           198          
000011D2  43F9 0000124C            199          LEA mulsEAmasks,A1 ;load the list of masks
000011D8  D3C0                     200          ADDA.L D0,A1 ;displace to a specific mask
000011DA  1A11                     201          MOVE.B (A1),D5 ;move the mask to D5
000011DC                           202          
000011DC  0C05 0000                203          CMPI.B #0,D5 ;check if the mask is 0
000011E0  6700 FE8E                204          BEQ falsePositive ;branch if it is
000011E4                           205          
000011E4  1401                     206          MOVE.B D1,D2 ;copy instruction to D2
000011E6  C405                     207          AND.B D5,D2  ;mask D2
000011E8                           208          
000011E8  43F9 00001244            209          LEA mulsEA,A1 ;load the list of valid modes
000011EE  D3C0                     210          ADDA.L D0,A1 ;displace to a specific mode
000011F0  1811                     211          MOVE.B (A1),D4 ;move mode to D4
000011F2  B404                     212          CMP.B D4,D2 ;compare mode to masked value
000011F4  6700 0006                213          BEQ  divsBody ;if its match, its a valid mode and we can procede
000011F8                           214          
000011F8  5280                     215          ADDQ.L #1,D0 ;add one to displacement
000011FA  60D6                     216          BRA validDivsModes ;check for next mode
000011FC                           217          
000011FC                           218  divsBody:
000011FC                           219          
000011FC                           220  
000011FC                           221  
000011FC  43F9 00002307            222          LEA     divsMessage,A1  ;move string for MOVE
00001202  103C 000E                223          MOVE.B  #14,D0        ;set for task to display null terminated 
00001206                           224                                ;string without CR, LF
00001206  4E4F                     225          TRAP    #15
00001208                           226  
00001208                           227          ;do source EA
00001208  3401                     228          MOVE.W  D1,D2 ;check mode
0000120A  C43C 003F                229          AND.B   #%00111111,D2
0000120E  1A02                     230          MOVE.B  D2,D5
00001210  48E7 4000                231          MOVEM.L D1,-(SP)
00001214  6100 0D9E                232          BSR     Get_Effective_Address
00001218  4CDF 0002                233          MOVEM.L (SP)+,D1
0000121C                           234  
0000121C                           235          ;print separator
0000121C                           236          
0000121C                           237          ;do dest data reg
0000121C  3401                     238          MOVE.W  D1,D2 ;check mode
0000121E  E04A                     239          LSR.W #8,D2 ;shift reg over
00001220  E20A                     240          LSR.B #1,D2
00001222  C43C 0007                241          AND.B   #%00000111,D2 ;force recognition as a Dn
00001226  1A02                     242          MOVE.B  D2,D5
00001228  48E7 4000                243          MOVEM.L D1,-(SP)
0000122C  6100 0D86                244          BSR     Get_Effective_Address
00001230  4CDF 0002                245          MOVEM.L (SP)+,D1
00001234                           246          
00001234  43F9 00002304            247          LEA     clearLine,A1  ;move string for a CR and LF
0000123A  103C 000E                248          MOVE.B  #14,D0        ;set for task to display null terminated 
0000123E                           249                                ;string without CR, LF
0000123E  4E4F                     250          TRAP    #15
00001240                           251  
00001240  7000                     252          MOVEQ.L #0,D0
00001242  4E75                     253          RTS
00001244                           254  
00001244                           255  
00001244                           256  
00001244                           257  
00001244= 00 10 18 20 38 39 ...    258  mulsEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,%111100,0
0000124C= 38 38 38 38 3F 3F ...    259  mulsEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,%111111,0
00001254                           260          
00001254                           261  MULS:
00001254                           262  
00001254  7000                     263          MOVEQ.L #0, D0 ;clear D0
00001256                           264          
00001256                           265  validMulsModes:
00001256                           266          
00001256  43F8 124C                267          LEA mulsEAmasks,A1 ;load the list of masks
0000125A  D3C0                     268          ADDA.L D0,A1 ;displace to a specific mask
0000125C  1A11                     269          MOVE.B (A1),D5 ;move the mask to D5
0000125E                           270          
0000125E  0C05 0000                271          CMPI.B #0,D5 ;check if the mask is 0
00001262  6700 FE0C                272          BEQ falsePositive ;branch if it is
00001266                           273          
00001266  1401                     274          MOVE.B D1,D2 ;copy instruction to D2
00001268  C405                     275          AND.B D5,D2  ;mask D2
0000126A                           276          
0000126A  43F8 1244                277          LEA mulsEA,A1 ;load the list of valid modes
0000126E  D3C0                     278          ADDA.L D0,A1 ;displace to a specific mode
00001270  1811                     279          MOVE.B (A1),D4 ;move mode to D4
00001272  B404                     280          CMP.B D4,D2 ;compare mode to masked value
00001274  6700 0006                281          BEQ  mulsBody ;if its match, its a valid mode and we can procede
00001278                           282          
00001278  5280                     283          ADDQ.L #1,D0 ;add one to displacement
0000127A  60DA                     284          BRA validMulsModes ;check for next mode
0000127C                           285          
0000127C                           286  mulsBody:
0000127C                           287          
0000127C                           288  
0000127C                           289  
0000127C  43F9 0000230D            290          LEA     mulsMessage,A1  ;move string for MOVE
00001282  103C 000E                291          MOVE.B  #14,D0        ;set for task to display null terminated 
00001286                           292                                ;string without CR, LF
00001286  4E4F                     293          TRAP    #15
00001288                           294  
00001288                           295          ;do source EA
00001288  3401                     296          MOVE.W  D1,D2 ;check mode
0000128A  C43C 003F                297          AND.B   #%00111111,D2
0000128E  1A02                     298          MOVE.B  D2,D5
00001290  48E7 4000                299          MOVEM.L D1,-(SP)
00001294  6100 0D1E                300          BSR     Get_Effective_Address
00001298  4CDF 0002                301          MOVEM.L (SP)+,D1
0000129C                           302  
0000129C                           303          ;print separator
0000129C                           304          
0000129C                           305          ;do dest data reg
0000129C  3401                     306          MOVE.W  D1,D2 ;check mode
0000129E  E04A                     307          LSR.W #8,D2 ;shift reg over
000012A0  E20A                     308          LSR.B #1,D2
000012A2  C43C 0007                309          AND.B   #%00000111,D2 ;force recognition as a Dn
000012A6  1A02                     310          MOVE.B  D2,D5
000012A8  48E7 4000                311          MOVEM.L D1,-(SP)
000012AC  6100 0D06                312          BSR     Get_Effective_Address
000012B0  4CDF 0002                313          MOVEM.L (SP)+,D1
000012B4                           314          
000012B4  43F9 00002304            315          LEA     clearLine,A1  ;move string for a CR and LF
000012BA  103C 000E                316          MOVE.B  #14,D0        ;set for task to display null terminated 
000012BE                           317                                ;string without CR, LF
000012BE  4E4F                     318          TRAP    #15
000012C0                           319  
000012C0  7000                     320          MOVEQ.L #0,D0
000012C2  4E75                     321          RTS
000012C4                           322  
000012C4                           323  
000012C4                           324  
000012C4                           325  RSRLWEA:
000012C4                           326          
000012C4                           327  
000012C4                           328          
000012C4  7000                     329          MOVEQ.L #0, D0 ;clear D0
000012C6                           330          
000012C6                           331  validRSRL:
000012C6                           332          
000012C6  43F9 00001416            333          LEA lsrlEAmasks,A1 ;load the list of masks
000012CC  D3C0                     334          ADDA.L D0,A1 ;displace to a specific mask
000012CE  1A11                     335          MOVE.B (A1),D5 ;move the mask to D5
000012D0                           336          
000012D0  0C05 0000                337          CMPI.B #0,D5 ;check if the mask is 0
000012D4  6700 FD9A                338          BEQ falsePositive ;branch if it is
000012D8                           339          
000012D8  1401                     340          MOVE.B D1,D2 ;copy instruction to D2
000012DA  C405                     341          AND.B D5,D2  ;mask D2
000012DC                           342          
000012DC  43F9 00001410            343          LEA lsrlEA,A1 ;load the list of valid modes
000012E2  D3C0                     344          ADDA.L D0,A1 ;displace to a specific mode
000012E4  1811                     345          MOVE.B (A1),D4 ;move mode to D4
000012E6  B404                     346          CMP.B D4,D2 ;compare mode to masked value
000012E8  6700 0006                347          BEQ  rsrlweaCheckDirection ;if its match, its a valid mode and we can procede
000012EC                           348          
000012EC  5280                     349          ADDQ.L #1,D0 ;add one to displacement
000012EE  60D6                     350          BRA validRSRL ;check for next mode
000012F0                           351  
000012F0                           352  rsrlweaCheckDirection:
000012F0                           353          ;Figure out which direction we are going
000012F0  3401                     354          MOVE.W D1,D2 ;copy inst to D2
000012F2  E04A                     355          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000012F4  0202 0001                356          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000012F8  0C02 0000                357          CMPI.B #0,D2 ;compare bit to zero
000012FC  6700 0006                358          BEQ RSREA ;if zero, right
00001300  6000 0012                359          BRA RSLEA ;else, its left
00001304                           360  
00001304                           361  RSREA:
00001304                           362  
00001304  43F9 00002318            363          LEA     rsrMessage,A1  ;move string for MOVE
0000130A  103C 000E                364          MOVE.B  #14,D0        ;set for task to display null terminated 
0000130E                           365                                ;string with CR, LF
0000130E  4E4F                     366          TRAP    #15
00001310  6000 0166                367          BRA lsrlweaBody
00001314                           368          
00001314                           369  RSLEA:
00001314                           370          
00001314  43F9 00002313            371          LEA     rslMessage,A1  ;move string for MOVE
0000131A  103C 000E                372          MOVE.B  #14,D0        ;set for task to display null terminated 
0000131E                           373                                ;string with CR, LF
0000131E  4E4F                     374          TRAP    #15
00001320  6000 0156                375          BRA lsrlweaBody        
00001324                           376          
00001324                           377  
00001324                           378  
00001324                           379  RSRLREG:
00001324                           380          
00001324                           381  
00001324                           382          
00001324  7000                     383          MOVEQ.L #0, D0 ;clear D0
00001326                           384          
00001326                           385          ;check valid size field
00001326  3401                     386          MOVE.W D1,D2 ;copy inst to D2
00001328  EC4A                     387          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
0000132A  0202 0003                388          ANDI.B #%00000011,D2 ;mask out rest of byte
0000132E  0C02 0003                389          CMPI.B #%11,D2 ;compare to 3
00001332  6700 FD3C                390          BEQ falsePositive ;invalid size
00001336                           391  
00001336                           392          
00001336                           393          ;Figure out which direction we are going
00001336  3401                     394          MOVE.W D1,D2 ;copy inst to D2
00001338  E04A                     395          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
0000133A  0202 0001                396          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
0000133E  0C02 0000                397          CMPI.B #0,D2 ;compare bit to zero
00001342  6700 0006                398          BEQ RSRreg ;if zero, right
00001346  6000 0012                399          BRA RSLreg ;else, its left        
0000134A                           400          
0000134A                           401  RSRreg:
0000134A                           402  
0000134A  43F9 00002318            403          LEA     rsrMessage,A1  ;move string for MOVE
00001350  103C 000E                404          MOVE.B  #14,D0        ;set for task to display null terminated 
00001354                           405                                ;string with CR, LF
00001354  4E4F                     406          TRAP    #15
00001356  6000 018A                407          BRA LSRLregBody
0000135A                           408          
0000135A                           409  RSLreg:
0000135A                           410          
0000135A  43F9 00002313            411          LEA     rslMessage,A1  ;move string for MOVE
00001360  103C 000E                412          MOVE.B  #14,D0        ;set for task to display null terminated 
00001364                           413                                ;string with CR, LF
00001364  4E4F                     414          TRAP    #15
00001366  6000 017A                415          BRA LSRLregBody
0000136A                           416  
0000136A                           417       
0000136A                           418  
0000136A                           419  ASRLWEA:
0000136A                           420          
0000136A                           421  
0000136A                           422          
0000136A  7000                     423          MOVEQ.L #0, D0 ;clear D0
0000136C                           424          
0000136C                           425  validASRL:
0000136C                           426          
0000136C  43F9 00001416            427          LEA lsrlEAmasks,A1 ;load the list of masks
00001372  D3C0                     428          ADDA.L D0,A1 ;displace to a specific mask
00001374  1A11                     429          MOVE.B (A1),D5 ;move the mask to D5
00001376                           430          
00001376  0C05 0000                431          CMPI.B #0,D5 ;check if the mask is 0
0000137A  6700 FCF4                432          BEQ falsePositive ;branch if it is
0000137E                           433          
0000137E  1401                     434          MOVE.B D1,D2 ;copy instruction to D2
00001380  C405                     435          AND.B D5,D2  ;mask D2
00001382                           436          
00001382  43F9 00001410            437          LEA lsrlEA,A1 ;load the list of valid modes
00001388  D3C0                     438          ADDA.L D0,A1 ;displace to a specific mode
0000138A  1811                     439          MOVE.B (A1),D4 ;move mode to D4
0000138C  B404                     440          CMP.B D4,D2 ;compare mode to masked value
0000138E  6700 0006                441          BEQ  asrlweaCheckDirection ;if its match, its a valid mode and we can procede
00001392                           442          
00001392  5280                     443          ADDQ.L #1,D0 ;add one to displacement
00001394  60D6                     444          BRA validASRL ;check for next mode
00001396                           445  
00001396                           446  asrlweaCheckDirection:
00001396                           447          ;Figure out which direction we are going
00001396  3401                     448          MOVE.W D1,D2 ;copy inst to D2
00001398  E04A                     449          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
0000139A  0202 0001                450          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
0000139E  0C02 0000                451          CMPI.B #0,D2 ;compare bit to zero
000013A2  6700 0006                452          BEQ ASREA ;if zero, right
000013A6  6000 0012                453          BRA ASLEA ;else, its left
000013AA                           454  
000013AA                           455  ASREA:
000013AA                           456  
000013AA  43F9 00002322            457          LEA     asrMessage,A1  ;move string for MOVE
000013B0  103C 000E                458          MOVE.B  #14,D0        ;set for task to display null terminated 
000013B4                           459                                ;string with CR, LF
000013B4  4E4F                     460          TRAP    #15
000013B6  6000 00C0                461          BRA lsrlweaBody
000013BA                           462          
000013BA                           463  ASLEA:
000013BA                           464          
000013BA  43F9 0000231D            465          LEA     aslMessage,A1  ;move string for MOVE
000013C0  103C 000E                466          MOVE.B  #14,D0        ;set for task to display null terminated 
000013C4                           467                                ;string with CR, LF
000013C4  4E4F                     468          TRAP    #15
000013C6  6000 00B0                469          BRA lsrlweaBody        
000013CA                           470          
000013CA                           471  
000013CA                           472  
000013CA                           473  ASRLREG:
000013CA                           474          
000013CA                           475  
000013CA                           476          
000013CA  7000                     477          MOVEQ.L #0, D0 ;clear D0
000013CC                           478          
000013CC                           479          ;check valid size field
000013CC  3401                     480          MOVE.W D1,D2 ;copy inst to D2
000013CE  EC4A                     481          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
000013D0  0202 0003                482          ANDI.B #%00000011,D2 ;mask out rest of byte
000013D4  0C02 0003                483          CMPI.B #%11,D2 ;compare to 3
000013D8  6700 FC96                484          BEQ falsePositive ;invalid size
000013DC                           485  
000013DC                           486          
000013DC                           487          ;Figure out which direction we are going
000013DC  3401                     488          MOVE.W D1,D2 ;copy inst to D2
000013DE  E04A                     489          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000013E0  0202 0001                490          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000013E4  0C02 0000                491          CMPI.B #0,D2 ;compare bit to zero
000013E8  6700 0006                492          BEQ ASRreg ;if zero, right
000013EC  6000 0012                493          BRA ASLreg ;else, its left        
000013F0                           494          
000013F0                           495  ASRreg:
000013F0                           496  
000013F0  43F9 00002322            497          LEA     asrMessage,A1  ;move string for MOVE
000013F6  103C 000E                498          MOVE.B  #14,D0        ;set for task to display null terminated 
000013FA                           499                                ;string with CR, LF
000013FA  4E4F                     500          TRAP    #15
000013FC  6000 00E4                501          BRA LSRLregBody
00001400                           502          
00001400                           503  ASLreg:
00001400                           504          
00001400  43F9 0000231D            505          LEA     aslMessage,A1  ;move string for MOVE
00001406  103C 000E                506          MOVE.B  #14,D0        ;set for task to display null terminated 
0000140A                           507                                ;string with CR, LF
0000140A  4E4F                     508          TRAP    #15
0000140C  6000 00D4                509          BRA LSRLregBody
00001410                           510  
00001410                           511  
00001410= 10 18 20 38 39 00        512  lsrlEA        DC.B %010000,%011000,%100000,%111000,%111001,0
00001416= 38 38 38 3F 3F 00        513  lsrlEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0       
0000141C                           514  
0000141C                           515  LSRLWEA:
0000141C                           516          
0000141C                           517  
0000141C                           518          
0000141C  7000                     519          MOVEQ.L #0, D0 ;clear D0
0000141E                           520          
0000141E                           521  validLSRL:
0000141E                           522          
0000141E  43F8 1416                523          LEA lsrlEAmasks,A1 ;load the list of masks
00001422  D3C0                     524          ADDA.L D0,A1 ;displace to a specific mask
00001424  1A11                     525          MOVE.B (A1),D5 ;move the mask to D5
00001426                           526          
00001426  0C05 0000                527          CMPI.B #0,D5 ;check if the mask is 0
0000142A  6700 FC44                528          BEQ falsePositive ;branch if it is
0000142E                           529          
0000142E  1401                     530          MOVE.B D1,D2 ;copy instruction to D2
00001430  C405                     531          AND.B D5,D2  ;mask D2
00001432                           532          
00001432  43F8 1410                533          LEA lsrlEA,A1 ;load the list of valid modes
00001436  D3C0                     534          ADDA.L D0,A1 ;displace to a specific mode
00001438  1811                     535          MOVE.B (A1),D4 ;move mode to D4
0000143A  B404                     536          CMP.B D4,D2 ;compare mode to masked value
0000143C  6700 0006                537          BEQ  lsrlweaCheckDirection ;if its match, its a valid mode and we can procede
00001440                           538          
00001440  5280                     539          ADDQ.L #1,D0 ;add one to displacement
00001442  60DA                     540          BRA validLSRL ;check for next mode
00001444                           541  
00001444                           542  lsrlweaCheckDirection:
00001444                           543          ;Figure out which direction we are going
00001444  3401                     544          MOVE.W D1,D2 ;copy inst to D2
00001446  E04A                     545          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
00001448  0202 0001                546          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
0000144C  0C02 0000                547          CMPI.B #0,D2 ;compare bit to zero
00001450  6700 0006                548          BEQ LSREA ;if zero, right
00001454  6000 0012                549          BRA LSLEA ;else, its left
00001458                           550  
00001458                           551  LSREA:
00001458                           552  
00001458  43F9 0000232C            553          LEA     lsrMessage,A1  ;move string for MOVE
0000145E  103C 000E                554          MOVE.B  #14,D0        ;set for task to display null terminated 
00001462                           555                                ;string with CR, LF
00001462  4E4F                     556          TRAP    #15
00001464  6000 0012                557          BRA lsrlweaBody
00001468                           558          
00001468                           559  LSLEA:
00001468                           560          
00001468  43F9 00002327            561          LEA     lslMessage,A1  ;move string for MOVE
0000146E  103C 000E                562          MOVE.B  #14,D0        ;set for task to display null terminated 
00001472                           563                                ;string with CR, LF
00001472  4E4F                     564          TRAP    #15
00001474  6000 0002                565          BRA lsrlweaBody        
00001478                           566          
00001478                           567  lsrlweaBody:
00001478                           568  
00001478                           569          
00001478  3401                     570          MOVE.W  D1,D2 ;check mode
0000147A  C43C 003F                571          AND.B   #%00111111,D2
0000147E  1A02                     572          MOVE.B  D2,D5
00001480  48E7 4000                573          MOVEM.L D1,-(SP)
00001484  6100 0B2E                574          BSR     Get_Effective_Address
00001488  4CDF 0002                575          MOVEM.L (SP)+,D1
0000148C                           576          
0000148C                           577          
0000148C  43F9 00002304            578          LEA     clearLine,A1  ;move string for a CR and LF
00001492  103C 000E                579          MOVE.B  #14,D0        ;set for task to display null terminated 
00001496                           580                                ;string without CR, LF
00001496  4E4F                     581          TRAP    #15
00001498                           582  
00001498  7000                     583          MOVEQ.L #0,D0
0000149A  4E75                     584          RTS
0000149C                           585  
0000149C                           586  
0000149C                           587  LSRLREG:
0000149C                           588          
0000149C                           589  
0000149C                           590          
0000149C  7000                     591          MOVEQ.L #0, D0 ;clear D0
0000149E                           592          
0000149E                           593          ;check valid size field
0000149E  3401                     594          MOVE.W D1,D2 ;copy inst to D2
000014A0  EC4A                     595          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
000014A2  0202 0003                596          ANDI.B #%00000011,D2 ;mask out rest of byte
000014A6  0C02 0003                597          CMPI.B #%11,D2 ;compare to 3
000014AA  6700 FBC4                598          BEQ falsePositive ;invalid size
000014AE                           599  
000014AE                           600          
000014AE                           601          ;Figure out which direction we are going
000014AE  3401                     602          MOVE.W D1,D2 ;copy inst to D2
000014B0  E04A                     603          LSR.W #8,D2 ;shift direction bit into most sig bit of first byte
000014B2  0202 0001                604          ANDI.B #%00000001,D2 ;mask out everything but direction bit in first byte
000014B6  0C02 0000                605          CMPI.B #0,D2 ;compare bit to zero
000014BA  6700 0006                606          BEQ LSRreg ;if zero, right
000014BE  6000 0012                607          BRA LSLreg ;else, its left        
000014C2                           608          
000014C2                           609  LSRreg:
000014C2                           610  
000014C2  43F9 0000232C            611          LEA     lsrMessage,A1  ;move string for MOVE
000014C8  103C 000E                612          MOVE.B  #14,D0        ;set for task to display null terminated 
000014CC                           613                                ;string with CR, LF
000014CC  4E4F                     614          TRAP    #15
000014CE  6000 0012                615          BRA LSRLregBody
000014D2                           616          
000014D2                           617  LSLreg:
000014D2                           618          
000014D2  43F9 00002327            619          LEA     lslMessage,A1  ;move string for MOVE
000014D8  103C 000E                620          MOVE.B  #14,D0        ;set for task to display null terminated 
000014DC                           621                                ;string with CR, LF
000014DC  4E4F                     622          TRAP    #15
000014DE  6000 0002                623          BRA LSRLregBody
000014E2                           624          
000014E2                           625  LSRLregBody:
000014E2                           626                      
000014E2                           627          ;check i/r
000014E2  48E7 4000                628          MOVEM.L D1,-(SP)
000014E6  6100 002A                629          BSR LSRLcheckIR
000014EA  4CDF 0002                630          MOVEM.L (SP)+,D1
000014EE                           631          
000014EE  3401                     632          MOVE.W  D1,D2 ;check mode
000014F0  C43C 0007                633          AND.B   #%00000111,D2
000014F4  1A02                     634          MOVE.B  D2,D5
000014F6  48E7 4000                635          MOVEM.L D1,-(SP)
000014FA  6100 0AB8                636          BSR     Get_Effective_Address
000014FE  4CDF 0002                637          MOVEM.L (SP)+,D1
00001502                           638          
00001502                           639          
00001502  43F9 00002304            640          LEA     clearLine,A1  ;move string for a CR and LF
00001508  103C 000E                641          MOVE.B  #14,D0        ;set for task to display null terminated 
0000150C                           642                                ;string without CR, LF
0000150C  4E4F                     643          TRAP    #15
0000150E                           644  
0000150E  7000                     645          MOVEQ.L #0,D0
00001510  4E75                     646          RTS
00001512                           647  
00001512                           648  LSRLcheckIR:
00001512                           649  
00001512  1401                     650          MOVE.B D1,D2 ;move inst to D2
00001514  EA0A                     651          LSR.B  #5,D2
00001516  C43C 0001                652          AND.B  #%00000001,D2
0000151A  0C02 0000                653          CMPI.B #0,D2
0000151E  6700 0008                654          BEQ  LSRLcheckI
00001522  6000 0038                655          BRA  LSRLcheckR
00001526                           656  LSRLcheckIRreturn:
00001526  4E75                     657          RTS
00001528                           658          
00001528                           659  LSRLcheckI:
00001528                           660          ;print '#'
00001528  48E7 4000                661          MOVEM.L D1,-(SP) ;save D1 to the stack
0000152C  123C 0023                662          MOVE.B #'#',D1 ;put ascii value of '#' in D1
00001530  103C 0006                663          MOVE.B #6,D0 ;move task 6 into D0
00001534  4E4F                     664          TRAP #15 ;prin char
00001536  4CDF 0002                665          MOVEM.L (SP)+,D1 ;pull D1 off the stack
0000153A                           666          
0000153A                           667          ;print number
0000153A  48E7 4000                668          MOVEM.L D1,-(SP)
0000153E  3401                     669          MOVE.W D1,D2 ;copy inst to d2
00001540  E04A                     670          LSR.W #8,D2 ;shift data section
00001542  E20A                     671          LSR.B #1,D2
00001544  C43C 0007                672          AND.B #%00000111,D2 ;mask out rest of data
00001548  6100 00D6                673          BSR ZeroToEight ;handle zero
0000154C  7200                     674          MOVEQ.L #0,D1 ;clear D1
0000154E  1202                     675          MOVE.B D2,D1 ;move number to display into D1
00001550  103C 0003                676          MOVE.B #3,D0 ;move task 3 to D0
00001554  4E4F                     677          TRAP #15
00001556  4CDF 0002                678          MOVEM.L (SP)+,D1
0000155A  60CA                     679          BRA LSRLcheckIRreturn
0000155C                           680          
0000155C                           681  LSRLcheckR:
0000155C  3401                     682          MOVE.W D1,D2 ;copy inst to d2
0000155E  E04A                     683          LSR.W #8,D2 ;shift data section
00001560  E20A                     684          LSR.B #1,D2
00001562  C43C 0007                685          AND.B #%00000111,D2 ;mask out rest of data
00001566  1A02                     686          MOVE.B D2,D5 ;force Dn
00001568  48E7 4000                687          MOVEM.L D1,-(SP)
0000156C  6100 0A46                688          BSR     Get_Effective_Address
00001570  4CDF 0002                689          MOVEM.L (SP)+,D1
00001574  60B0                     690          BRA LSRLcheckIRreturn
00001576                           691          
00001576= 00 08 10 18 20 38 ...    692  subqEA        DC.B %000000,%001000,%010000,%011000,%100000,%111000,%111001,0
0000157E= 38 38 38 38 38 3F ...    693  subqEAmasks   DC.B %111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001586                           694  
00001586                           695  SUBQ:
00001586                           696          
00001586                           697  
00001586                           698          
00001586  7000                     699          MOVEQ.L #0, D0 ;clear D0
00001588                           700          
00001588                           701          ;check valid size field
00001588  3401                     702          MOVE.W D1,D2 ;copy inst to D2
0000158A  EC4A                     703          LSR.W  #6,D2 ;shift size to least sig bit of least sig byte
0000158C  0202 0003                704          ANDI.B #%00000011,D2 ;mask out rest of byte
00001590  0C02 0003                705          CMPI.B #%11,D2 ;compare to 3
00001594  6700 FADA                706          BEQ falsePositive ;invalid size
00001598                           707          
00001598                           708  validSubq:
00001598                           709          
00001598  43F8 157E                710          LEA subqEAmasks,A1 ;load the list of masks
0000159C  D3C0                     711          ADDA.L D0,A1 ;displace to a specific mask
0000159E  1A11                     712          MOVE.B (A1),D5 ;move the mask to D5
000015A0                           713          
000015A0  0C05 0000                714          CMPI.B #0,D5 ;check if the mask is 0
000015A4  6700 FACA                715          BEQ falsePositive ;branch if it is
000015A8                           716          
000015A8  1401                     717          MOVE.B D1,D2 ;copy instruction to D2
000015AA  C405                     718          AND.B D5,D2  ;mask D2
000015AC                           719          
000015AC  43F8 1576                720          LEA subqEA,A1 ;load the list of valid modes
000015B0  D3C0                     721          ADDA.L D0,A1 ;displace to a specific mode
000015B2  1811                     722          MOVE.B (A1),D4 ;move mode to D4
000015B4  B404                     723          CMP.B D4,D2 ;compare mode to masked value
000015B6  6700 0006                724          BEQ  subqBody ;if its match, its a valid mode and we can procede
000015BA                           725          
000015BA  5280                     726          ADDQ.L #1,D0 ;add one to displacement
000015BC  60DA                     727          BRA validSubq ;check for next mode
000015BE                           728          
000015BE                           729          
000015BE                           730  subqBody
000015BE                           731  
000015BE  43F9 00002331            732          LEA     subqMessage,A1  ;move string for MOVE
000015C4  103C 000E                733          MOVE.B  #14,D0        ;set for task to display null terminated 
000015C8                           734                                ;string with CR, LF
000015C8  4E4F                     735          TRAP    #15
000015CA                           736          
000015CA                           737          ;immediate data
000015CA                           738          
000015CA                           739          ;print '#'
000015CA  48E7 4000                740          MOVEM.L D1,-(SP) ;save D1 to the stack
000015CE  123C 0023                741          MOVE.B #'#',D1 ;put ascii value of '#' in D1
000015D2  103C 0006                742          MOVE.B #6,D0 ;move task 6 into D0
000015D6  4E4F                     743          TRAP #15 ;prin char
000015D8  4CDF 0002                744          MOVEM.L (SP)+,D1 ;pull D1 off the stack
000015DC                           745          
000015DC                           746          ;print number
000015DC  48E7 4000                747          MOVEM.L D1,-(SP)
000015E0  3401                     748          MOVE.W D1,D2 ;copy inst to d2
000015E2  E04A                     749          LSR.W #8,D2 ;shift data section
000015E4  E20A                     750          LSR.B #1,D2
000015E6  C43C 0007                751          AND.B #%00000111,D2 ;mask out rest of data
000015EA  6100 0034                752          BSR ZeroToEight ;handle zero
000015EE  7200                     753          MOVEQ.L #0,D1 ;clear D1
000015F0  1202                     754          MOVE.B D2,D1 ;move number to display into D1
000015F2  103C 0003                755          MOVE.B #3,D0 ;move task 3 to D0
000015F6  4E4F                     756          TRAP #15
000015F8  4CDF 0002                757          MOVEM.L (SP)+,D1
000015FC                           758          
000015FC                           759          ;print separator
000015FC                           760          
000015FC                           761          ;Then do EA
000015FC                           762          
000015FC  3401                     763          MOVE.W  D1,D2 ;check mode
000015FE  C43C 003F                764          AND.B   #%00111111,D2
00001602  1A02                     765          MOVE.B  D2,D5
00001604  48E7 4000                766          MOVEM.L D1,-(SP)
00001608  6100 09AA                767          BSR     Get_Effective_Address
0000160C  4CDF 0002                768          MOVEM.L (SP)+,D1
00001610                           769          
00001610  43F9 00002304            770          LEA     clearLine,A1  ;move string for a CR and LF
00001616  103C 000E                771          MOVE.B  #14,D0        ;set for task to display null terminated 
0000161A                           772                                ;string without CR, LF
0000161A  4E4F                     773          TRAP    #15
0000161C                           774  
0000161C  7000                     775          MOVEQ.L #0,D0
0000161E  4E75                     776          RTS
00001620                           777          
00001620                           778  ZeroToEight:
00001620                           779          
00001620  0C02 0000                780          CMPI.B #0,D2
00001624  6700 0004                781          BEQ toEight
00001628                           782  ZeroToEightReturn:
00001628                           783          
00001628  4E75                     784          RTS
0000162A                           785  toEight:
0000162A                           786          
0000162A  5002                     787          ADDQ.B #8,D2
0000162C  60FA                     788          BRA ZeroToEightReturn
0000162E                           789  
0000162E                           790      
0000162E                           791  SUB:
0000162E                           792          
0000162E                           793  
0000162E                           794          
0000162E  7000                     795          MOVEQ.L #0, D0 ;clear D0
00001630                           796          
00001630                           797          ;Figure out if EA is source or destination
00001630  3401                     798          MOVE.W D1,D2 ;copy inst to D2
00001632  EC4A                     799          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
00001634  0202 0007                800          ANDI.B #%00000111,D2 ;mask out rest of byte
00001638  0C02 0002                801          CMPI.B #2,D2 ;compare to 2
0000163C  6F00 0016                802          BLE validSubSourceEA ;2 or less is EA is source
00001640                           803          
00001640  0C02 0007                804          CMPI.B #%111,D2 ;compare to 7
00001644  6700 FA2A                805          BEQ falsePositive ;thats not valid
00001648  0C02 0003                806          CMPI.B #%11,D2 ;compare to 3
0000164C  6700 FA22                807          BEQ falsePositive ;also not valid
00001650  6000 002C                808          BRA validSubDestEA ;all thats left is valid EA as Dest 
00001654                           809          
00001654                           810  validSubSourceEA:
00001654                           811          
00001654  43F9 00001C0F            812          LEA moveSourceEAmasks,A1 ;load the list of masks
0000165A  D3C0                     813          ADDA.L D0,A1 ;displace to a specific mask
0000165C  1A11                     814          MOVE.B (A1),D5 ;move the mask to D5
0000165E                           815          
0000165E  0C05 0000                816          CMPI.B #0,D5 ;check if the mask is 0
00001662  6700 FA0C                817          BEQ falsePositive ;branch if it is
00001666                           818          
00001666  1401                     819          MOVE.B D1,D2 ;copy instruction to D2
00001668  C405                     820          AND.B D5,D2  ;mask D2
0000166A                           821          
0000166A  43F9 00001C06            822          LEA moveSourceEA,A1 ;load the list of valid modes
00001670  D3C0                     823          ADDA.L D0,A1 ;displace to a specific mode
00001672  1811                     824          MOVE.B (A1),D4 ;move mode to D4
00001674  B404                     825          CMP.B D4,D2 ;compare mode to masked value
00001676  6700 0036                826          BEQ  subSource ;if its match, its a valid mode and we can procede
0000167A                           827          
0000167A  5280                     828          ADDQ.L #1,D0 ;add one to displacement
0000167C  60D6                     829          BRA validSubSourceEA ;check for next mode
0000167E                           830          
0000167E                           831          
0000167E                           832  validSubDestEA:
0000167E                           833          
0000167E  43F9 000017D6            834          LEA addDestEAmasks,A1 ;load the list of masks
00001684  D3C0                     835          ADDA.L D0,A1 ;displace to a specific mask
00001686  1A11                     836          MOVE.B (A1),D5 ;move the mask to D5
00001688                           837          
00001688  0C05 0000                838          CMPI.B #0,D5 ;check if the mask is 0
0000168C  6700 F9E2                839          BEQ falsePositive ;branch if it is
00001690                           840          
00001690  3401                     841          MOVE.W D1,D2 ;copy instruction to D2
00001692  EC4A                     842          LSR.W #6,D2  ;move mode
00001694  6100 0A92                843          BSR switchModeAndReg ;switch register and mode
00001698  C405                     844          AND.B D5,D2  ;mask D2
0000169A                           845          
0000169A  43F9 000017D0            846          LEA addDestEA,A1 ;load the list of valid modes
000016A0  D3C0                     847          ADDA.L D0,A1 ;displace to a specific mode
000016A2  1811                     848          MOVE.B (A1),D4 ;move mode to D4
000016A4  B404                     849          CMP.B D4,D2 ;compare mode to masked value
000016A6  6700 004E                850          BEQ subDest ;if its match, its a valid mode and we can procede
000016AA                           851          
000016AA  5280                     852          ADDQ.L #1,D0 ;add one to displacement
000016AC  60D0                     853          BRA validSubDestEA ;check for next mode
000016AE                           854          
000016AE                           855  subSource
000016AE                           856  
000016AE  43F9 00002337            857          LEA     subMessage,A1  ;move string for MOVE
000016B4  103C 000E                858          MOVE.B  #14,D0        ;set for task to display null terminated 
000016B8                           859                                ;string with CR, LF
000016B8  4E4F                     860          TRAP    #15
000016BA                           861          
000016BA                           862          ;do EA
000016BA                           863          
000016BA  3401                     864          MOVE.W  D1,D2 ;check mode
000016BC  C43C 003F                865          AND.B   #%00111111,D2
000016C0  1A02                     866          MOVE.B  D2,D5
000016C2  48E7 4000                867          MOVEM.L D1,-(SP)
000016C6  6100 08EC                868          BSR     Get_Effective_Address
000016CA  4CDF 0002                869          MOVEM.L (SP)+,D1
000016CE                           870          
000016CE                           871          ;print separator
000016CE                           872          
000016CE                           873          ;Then do Dn
000016CE                           874          
000016CE  3401                     875          MOVE.W  D1,D2
000016D0  E04A                     876          LSR.W   #8,D2 ;move reg into first byte
000016D2  E20A                     877          LSR.B   #1,D2 ;line it up to least sig bit
000016D4  C43C 0007                878          AND.B   #%00000111,D2 ;force mode to Dn
000016D8  1A02                     879          MOVE.B  D2,D5
000016DA  48E7 4000                880          MOVEM.L D1,-(SP)
000016DE  6100 08D4                881          BSR     Get_Effective_Address
000016E2  4CDF 0002                882          MOVEM.L (SP)+,D1
000016E6                           883          
000016E6  43F9 00002304            884          LEA     clearLine,A1  ;move string for a CR and LF
000016EC  103C 000E                885          MOVE.B  #14,D0        ;set for task to display null terminated 
000016F0                           886                                ;string without CR, LF
000016F0  4E4F                     887          TRAP    #15
000016F2                           888  
000016F2  7000                     889          MOVEQ.L #0,D0
000016F4  4E75                     890          RTS
000016F6                           891  
000016F6                           892  subDest
000016F6                           893  
000016F6  43F9 00002337            894          LEA     subMessage,A1  ;move string for MOVE
000016FC  103C 000E                895          MOVE.B  #14,D0        ;set for task to display null terminated 
00001700                           896                                ;string with CR, LF
00001700  4E4F                     897          TRAP    #15
00001702                           898          
00001702                           899          ;Do Dn
00001702                           900          
00001702  3401                     901          MOVE.W  D1,D2
00001704  E04A                     902          LSR.W   #8,D2 ;move reg into first byte
00001706  E20A                     903          LSR.B   #1,D2 ;line it up to least sig bit
00001708  C43C 0007                904          AND.B   #%00000111,D2 ;force mode to Dn
0000170C  1A02                     905          MOVE.B  D2,D5
0000170E  48E7 4000                906          MOVEM.L D1,-(SP)
00001712  6100 08A0                907          BSR     Get_Effective_Address
00001716  4CDF 0002                908          MOVEM.L (SP)+,D1
0000171A                           909          
0000171A                           910          
0000171A                           911          ;print separator
0000171A                           912          
0000171A                           913          ;Then do EA
0000171A                           914          
0000171A  3401                     915          MOVE.W  D1,D2 ;check mode
0000171C  C43C 003F                916          AND.B   #%00111111,D2
00001720  1A02                     917          MOVE.B  D2,D5
00001722  48E7 4000                918          MOVEM.L D1,-(SP)
00001726  6100 088C                919          BSR     Get_Effective_Address
0000172A  4CDF 0002                920          MOVEM.L (SP)+,D1
0000172E                           921          
0000172E                           922          
0000172E  43F9 00002304            923          LEA     clearLine,A1  ;move string for a CR and LF
00001734  103C 000E                924          MOVE.B  #14,D0        ;set for task to display null terminated 
00001738                           925                                ;string without CR, LF
00001738  4E4F                     926          TRAP    #15
0000173A                           927  
0000173A  7000                     928          MOVEQ.L #0,D0
0000173C  4E75                     929          RTS
0000173E                           930  
0000173E                           931  
0000173E                           932  ADDA:
0000173E                           933          
0000173E                           934  
0000173E                           935          
0000173E  7000                     936          MOVEQ.L #0, D0 ;clear D0
00001740                           937          
00001740                           938          ;check opmode field
00001740  3401                     939          MOVE.W D1,D2 ;copy inst to D2
00001742  EC4A                     940          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
00001744  0202 0007                941          ANDI.B #%00000111,D2 ;mask out rest of byte
00001748  0C02 0007                942          CMPI.B #%111,D2 ;compare to 7
0000174C  6700 000E                943          BEQ validAdda ;thats valid
00001750  0C02 0003                944          CMPI.B #%11,D2 ;compare to 3
00001754  6700 0006                945          BEQ validAdda ;also valid
00001758  6000 F916                946          BRA falsePositive ;all thats left is invalid 
0000175C                           947          
0000175C                           948  validAdda:
0000175C                           949          
0000175C  43F9 00001C0F            950          LEA moveSourceEAmasks,A1 ;load the list of masks
00001762  D3C0                     951          ADDA.L D0,A1 ;displace to a specific mask
00001764  1A11                     952          MOVE.B (A1),D5 ;move the mask to D5
00001766                           953          
00001766  0C05 0000                954          CMPI.B #0,D5 ;check if the mask is 0
0000176A  6700 F904                955          BEQ falsePositive ;branch if it is
0000176E                           956          
0000176E  1401                     957          MOVE.B D1,D2 ;copy instruction to D2
00001770  C405                     958          AND.B D5,D2  ;mask D2
00001772                           959          
00001772  43F9 00001C06            960          LEA moveSourceEA,A1 ;load the list of valid modes
00001778  D3C0                     961          ADDA.L D0,A1 ;displace to a specific mode
0000177A  1811                     962          MOVE.B (A1),D4 ;move mode to D4
0000177C  B404                     963          CMP.B D4,D2 ;compare mode to masked value
0000177E  6700 0006                964          BEQ  addaBody ;if its match, its a valid mode and we can procede
00001782                           965          
00001782  5280                     966          ADDQ.L #1,D0 ;add one to displacement
00001784  60D6                     967          BRA validAdda ;check for next mode
00001786                           968          
00001786                           969          
00001786                           970  addaBody
00001786                           971  
00001786  43F9 0000233C            972          LEA     addaMessage,A1  ;move string for MOVE
0000178C  103C 000E                973          MOVE.B  #14,D0        ;set for task to display null terminated 
00001790                           974                                ;string with CR, LF
00001790  4E4F                     975          TRAP    #15
00001792                           976          
00001792                           977          ;do EA
00001792                           978          
00001792  3401                     979          MOVE.W  D1,D2 ;check mode
00001794  C43C 003F                980          AND.B   #%00111111,D2
00001798  1A02                     981          MOVE.B  D2,D5
0000179A  48E7 4000                982          MOVEM.L D1,-(SP)
0000179E  6100 0814                983          BSR     Get_Effective_Address
000017A2  4CDF 0002                984          MOVEM.L (SP)+,D1
000017A6                           985          
000017A6                           986          ;print separator
000017A6                           987          
000017A6                           988          ;Then do Dn
000017A6                           989          
000017A6  3401                     990          MOVE.W  D1,D2
000017A8  E04A                     991          LSR.W   #8,D2 ;move reg into first byte
000017AA  E20A                     992          LSR.B   #1,D2 ;line it up to least sig bit
000017AC  C43C 0007                993          AND.B   #%00000111,D2 ;force mode to An
000017B0  5002                     994          ADDI.B  #%00001000,D2 
000017B2  1A02                     995          MOVE.B  D2,D5
000017B4  48E7 4000                996          MOVEM.L D1,-(SP)
000017B8  6100 07FA                997          BSR     Get_Effective_Address
000017BC  4CDF 0002                998          MOVEM.L (SP)+,D1
000017C0                           999          
000017C0  43F9 00002304           1000          LEA     clearLine,A1  ;move string for a CR and LF
000017C6  103C 000E               1001          MOVE.B  #14,D0        ;set for task to display null terminated 
000017CA                          1002                                ;string without CR, LF
000017CA  4E4F                    1003          TRAP    #15
000017CC                          1004  
000017CC  7000                    1005          MOVEQ.L #0,D0
000017CE  4E75                    1006          RTS
000017D0                          1007  
000017D0                          1008  
000017D0                          1009      
000017D0= 10 18 20 38 39 00       1010  addDestEA        DC.B %010000,%011000,%100000,%111000,%111001,0
000017D6= 38 38 38 3F 3F 00       1011  addDestEAmasks   DC.B %111000,%111000,%111000,%111111,%111111,0      
000017DC                          1012  
000017DC                          1013  ADD:
000017DC                          1014          
000017DC                          1015  
000017DC                          1016          
000017DC  7000                    1017          MOVEQ.L #0, D0 ;clear D0
000017DE                          1018          
000017DE                          1019          ;Figure out if EA is source or destination
000017DE  3401                    1020          MOVE.W D1,D2 ;copy inst to D2
000017E0  EC4A                    1021          LSR.W  #6,D2 ;shift opmode to least sig bit of least sig byte
000017E2  0202 0007               1022          ANDI.B #%00000111,D2 ;mask out rest of byte
000017E6  0C02 0002               1023          CMPI.B #2,D2 ;compare to 2
000017EA  6F00 0016               1024          BLE validAddSourceEA ;2 or less is EA is source
000017EE                          1025          
000017EE  0C02 0007               1026          CMPI.B #%111,D2 ;compare to 7
000017F2  6700 F87C               1027          BEQ falsePositive ;thats not valid
000017F6  0C02 0003               1028          CMPI.B #%11,D2 ;compare to 3
000017FA  6700 F874               1029          BEQ falsePositive ;also not valid
000017FE  6000 002C               1030          BRA validAddDestEA ;all thats left is valid EA as Dest 
00001802                          1031          
00001802                          1032  validAddSourceEA:
00001802                          1033          
00001802  43F9 00001C0F           1034          LEA moveSourceEAmasks,A1 ;load the list of masks
00001808  D3C0                    1035          ADDA.L D0,A1 ;displace to a specific mask
0000180A  1A11                    1036          MOVE.B (A1),D5 ;move the mask to D5
0000180C                          1037          
0000180C  0C05 0000               1038          CMPI.B #0,D5 ;check if the mask is 0
00001810  6700 F85E               1039          BEQ falsePositive ;branch if it is
00001814                          1040          
00001814  1401                    1041          MOVE.B D1,D2 ;copy instruction to D2
00001816  C405                    1042          AND.B D5,D2  ;mask D2
00001818                          1043          
00001818  43F9 00001C06           1044          LEA moveSourceEA,A1 ;load the list of valid modes
0000181E  D3C0                    1045          ADDA.L D0,A1 ;displace to a specific mode
00001820  1811                    1046          MOVE.B (A1),D4 ;move mode to D4
00001822  B404                    1047          CMP.B D4,D2 ;compare mode to masked value
00001824  6700 0032               1048          BEQ  addSource ;if its match, its a valid mode and we can procede
00001828                          1049          
00001828  5280                    1050          ADDQ.L #1,D0 ;add one to displacement
0000182A  60D6                    1051          BRA validAddSourceEA ;check for next mode
0000182C                          1052          
0000182C                          1053          
0000182C                          1054  validAddDestEA:
0000182C                          1055          
0000182C  43F8 17D6               1056          LEA addDestEAmasks,A1 ;load the list of masks
00001830  D3C0                    1057          ADDA.L D0,A1 ;displace to a specific mask
00001832  1A11                    1058          MOVE.B (A1),D5 ;move the mask to D5
00001834                          1059          
00001834  0C05 0000               1060          CMPI.B #0,D5 ;check if the mask is 0
00001838  6700 F836               1061          BEQ falsePositive ;branch if it is
0000183C                          1062          
0000183C  3401                    1063          MOVE.W D1,D2 ;copy instruction to D2
0000183E  EC4A                    1064          LSR.W #6,D2  ;move mode
00001840  6100 08E6               1065          BSR switchModeAndReg ;switch register and mode
00001844  C405                    1066          AND.B D5,D2  ;mask D2
00001846                          1067          
00001846  43F8 17D0               1068          LEA addDestEA,A1 ;load the list of valid modes
0000184A  D3C0                    1069          ADDA.L D0,A1 ;displace to a specific mode
0000184C  1811                    1070          MOVE.B (A1),D4 ;move mode to D4
0000184E  B404                    1071          CMP.B D4,D2 ;compare mode to masked value
00001850  6700 004E               1072          BEQ addDest ;if its match, its a valid mode and we can procede
00001854                          1073          
00001854  5280                    1074          ADDQ.L #1,D0 ;add one to displacement
00001856  60D4                    1075          BRA validAddDestEA ;check for next mode
00001858                          1076          
00001858                          1077  addSource
00001858                          1078  
00001858  43F9 00002342           1079          LEA     addMessage,A1  ;move string for MOVE
0000185E  103C 000E               1080          MOVE.B  #14,D0        ;set for task to display null terminated 
00001862                          1081                                ;string with CR, LF
00001862  4E4F                    1082          TRAP    #15
00001864                          1083          
00001864                          1084          ;do EA
00001864                          1085          
00001864  3401                    1086          MOVE.W  D1,D2 ;check mode
00001866  C43C 003F               1087          AND.B   #%00111111,D2
0000186A  1A02                    1088          MOVE.B  D2,D5
0000186C  48E7 4000               1089          MOVEM.L D1,-(SP)
00001870  6100 0742               1090          BSR     Get_Effective_Address
00001874  4CDF 0002               1091          MOVEM.L (SP)+,D1
00001878                          1092          
00001878                          1093          ;print separator
00001878                          1094          
00001878                          1095          ;Then do Dn
00001878                          1096          
00001878  3401                    1097          MOVE.W  D1,D2
0000187A  E04A                    1098          LSR.W   #8,D2 ;move reg into first byte
0000187C  E20A                    1099          LSR.B   #1,D2 ;line it up to least sig bit
0000187E  C43C 0007               1100          AND.B   #%00000111,D2 ;force mode to Dn
00001882  1A02                    1101          MOVE.B  D2,D5
00001884  48E7 4000               1102          MOVEM.L D1,-(SP)
00001888  6100 072A               1103          BSR     Get_Effective_Address
0000188C  4CDF 0002               1104          MOVEM.L (SP)+,D1
00001890                          1105          
00001890  43F9 00002304           1106          LEA     clearLine,A1  ;move string for a CR and LF
00001896  103C 000E               1107          MOVE.B  #14,D0        ;set for task to display null terminated 
0000189A                          1108                                ;string without CR, LF
0000189A  4E4F                    1109          TRAP    #15
0000189C                          1110  
0000189C  7000                    1111          MOVEQ.L #0,D0
0000189E  4E75                    1112          RTS
000018A0                          1113  
000018A0                          1114  addDest
000018A0                          1115  
000018A0  43F9 00002342           1116          LEA     addMessage,A1  ;move string for MOVE
000018A6  103C 000E               1117          MOVE.B  #14,D0        ;set for task to display null terminated 
000018AA                          1118                                ;string with CR, LF
000018AA  4E4F                    1119          TRAP    #15
000018AC                          1120          
000018AC                          1121          ;Do Dn
000018AC                          1122          
000018AC  3401                    1123          MOVE.W  D1,D2
000018AE  E04A                    1124          LSR.W   #8,D2 ;move reg into first byte
000018B0  E20A                    1125          LSR.B   #1,D2 ;line it up to least sig bit
000018B2  C43C 0007               1126          AND.B   #%00000111,D2 ;force mode to Dn
000018B6  1A02                    1127          MOVE.B  D2,D5
000018B8  48E7 4000               1128          MOVEM.L D1,-(SP)
000018BC  6100 06F6               1129          BSR     Get_Effective_Address
000018C0  4CDF 0002               1130          MOVEM.L (SP)+,D1
000018C4                          1131          
000018C4                          1132          
000018C4                          1133          ;print separator
000018C4                          1134          
000018C4                          1135          ;Then do EA
000018C4                          1136          
000018C4  3401                    1137          MOVE.W  D1,D2 ;check mode
000018C6  C43C 003F               1138          AND.B   #%00111111,D2
000018CA  1A02                    1139          MOVE.B  D2,D5
000018CC  48E7 4000               1140          MOVEM.L D1,-(SP)
000018D0  6100 06E2               1141          BSR     Get_Effective_Address
000018D4  4CDF 0002               1142          MOVEM.L (SP)+,D1
000018D8                          1143          
000018D8                          1144          
000018D8  43F9 00002304           1145          LEA     clearLine,A1  ;move string for a CR and LF
000018DE  103C 000E               1146          MOVE.B  #14,D0        ;set for task to display null terminated 
000018E2                          1147                                ;string without CR, LF
000018E2  4E4F                    1148          TRAP    #15
000018E4                          1149  
000018E4  7000                    1150          MOVEQ.L #0,D0
000018E6  4E75                    1151          RTS
000018E8                          1152  
000018E8                          1153  
000018E8= 10 20 38 39 00          1154  movemRegToMemEA        DC.B %010000,%100000,%111000,%111001,0
000018ED= 38 38 3F 3F 00          1155  movemRegToMemEAmasks   DC.B %111000,%111000,%111111,%111111,0
000018F2                          1156  
000018F2= 10 18 38 39 00          1157  movemMemToRegEA        DC.B %010000,%011000,%111000,%111001,0
000018F7= 38 38 3F 3F 00          1158  movemMemToRegEAmasks   DC.B %111000,%111000,%111111,%111111,0        
000018FC                          1159  
000018FC                          1160  MOVEM:
000018FC                          1161          
000018FC                          1162  
000018FC                          1163          
000018FC  7000                    1164          MOVEQ.L #0, D0 ;clear D0
000018FE                          1165          
000018FE                          1166          ;Figure out which direction we are going
000018FE  3401                    1167          MOVE.W D1,D2 ;copy inst to D2
00001900  E64A                    1168          LSR.W #3,D2 ;shift direction bit into most sig bit of first byte
00001902  0202 0080               1169          ANDI.B #%10000000,D2 ;mask out everything but direction bit in first byte
00001906  0C02 0000               1170          CMPI.B #0,D2 ;compare bit to zero
0000190A  6700 0006               1171          BEQ validRegToMem ;if zero, reg to mem
0000190E  6000 0028               1172          BRA validMemToReg ;else, its mem to reg
00001912                          1173          
00001912                          1174  validRegToMem:
00001912                          1175          
00001912  43F8 18ED               1176          LEA movemRegToMemEAmasks,A1 ;load the list of masks
00001916  D3C0                    1177          ADDA.L D0,A1 ;displace to a specific mask
00001918  1A11                    1178          MOVE.B (A1),D5 ;move the mask to D5
0000191A                          1179          
0000191A  0C05 0000               1180          CMPI.B #0,D5 ;check if the mask is 0
0000191E  6700 F750               1181          BEQ falsePositive ;branch if it is
00001922                          1182          
00001922  1401                    1183          MOVE.B D1,D2 ;copy instruction to D2
00001924  C405                    1184          AND.B D5,D2  ;mask D2
00001926                          1185          
00001926  43F8 18E8               1186          LEA movemRegToMemEA,A1 ;load the list of valid modes
0000192A  D3C0                    1187          ADDA.L D0,A1 ;displace to a specific mode
0000192C  1811                    1188          MOVE.B (A1),D4 ;move mode to D4
0000192E  B404                    1189          CMP.B D4,D2 ;compare mode to masked value
00001930  6700 0034               1190          BEQ  movemBody ;if its match, its a valid mode and we can procede
00001934                          1191          
00001934  5280                    1192          ADDQ.L #1,D0 ;add one to displacement
00001936  60DA                    1193          BRA validRegToMem ;check for next mode
00001938                          1194          
00001938                          1195          
00001938                          1196  validMemToReg:
00001938                          1197          
00001938  43F8 18F7               1198          LEA movemMemToRegEAmasks,A1 ;load the list of masks
0000193C  D3C0                    1199          ADDA.L D0,A1 ;displace to a specific mask
0000193E  1A11                    1200          MOVE.B (A1),D5 ;move the mask to D5
00001940                          1201          
00001940  0C05 0000               1202          CMPI.B #0,D5 ;check if the mask is 0
00001944  6700 F72A               1203          BEQ falsePositive ;branch if it is
00001948                          1204          
00001948  3401                    1205          MOVE.W D1,D2 ;copy instruction to D2
0000194A  EC4A                    1206          LSR.W #6,D2  ;move mode
0000194C  6100 07DA               1207          BSR switchModeAndReg ;switch register and mode
00001950  C405                    1208          AND.B D5,D2  ;mask D2
00001952                          1209          
00001952  43F8 18F2               1210          LEA movemMemToRegEA,A1 ;load the list of valid modes
00001956  D3C0                    1211          ADDA.L D0,A1 ;displace to a specific mode
00001958  1811                    1212          MOVE.B (A1),D4 ;move mode to D4
0000195A  B404                    1213          CMP.B D4,D2 ;compare mode to masked value
0000195C  6700 0008               1214          BEQ movemBody ;if its match, its a valid mode and we can procede
00001960                          1215          
00001960  5280                    1216          ADDQ.L #1,D0 ;add one to displacement
00001962  6000 02EC               1217          BRA validMoveDestModes ;check for next mode
00001966                          1218          
00001966                          1219  movemBody
00001966                          1220  
00001966  43F9 00002347           1221          LEA     movemMessage,A1  ;move string for MOVE
0000196C  103C 000E               1222          MOVE.B  #14,D0        ;set for task to display null terminated 
00001970                          1223                                ;string with CR, LF
00001970  4E4F                    1224          TRAP    #15
00001972                          1225          
00001972                          1226          ;show list
00001972                          1227          
00001972  5487                    1228          ADDQ.L #word,D7 ;read past the register list mask(word) following
00001974                          1229                          ;the instruction
00001974                          1230          
00001974                          1231          ;print separator
00001974                          1232          
00001974  3401                    1233          MOVE.W  D1,D2 ;check mode
00001976  C43C 003F               1234          AND.B   #%00111111,D2
0000197A  1A02                    1235          MOVE.B  D2,D5
0000197C  48E7 4000               1236          MOVEM.L D1,-(SP)
00001980  6100 0632               1237          BSR     Get_Effective_Address
00001984  4CDF 0002               1238          MOVEM.L (SP)+,D1
00001988                          1239          
00001988                          1240          
00001988  43F9 00002304           1241          LEA     clearLine,A1  ;move string for a CR and LF
0000198E  103C 000E               1242          MOVE.B  #14,D0        ;set for task to display null terminated 
00001992                          1243                                ;string without CR, LF
00001992  4E4F                    1244          TRAP    #15
00001994                          1245  
00001994  7000                    1246          MOVEQ.L #0,D0
00001996  4E75                    1247          RTS
00001998                          1248  
00001998                          1249  
00001998                          1250      
00001998= 00 10 18 20 28 38 ...   1251  NegEA        DC.B %000000,%010000, %011000, %100000, %101000, %111000, %111001,0
000019A0= 38 38 38 38 38 3F ...   1252  NegEAmasks   DC.B %111000,%111000, %111000, %111000, %111000, %111111, %111111,0
000019A8                          1253     
000019A8                          1254  NEG:            
000019A8                          1255       
000019A8  7000                    1256          MOVEQ.L #0, D0 ;clear D0
000019AA                          1257          
000019AA                          1258  validNegModes:
000019AA                          1259          
000019AA  43F8 19A0               1260          LEA NegEAmasks,A1 ;load the list of masks
000019AE  D3C0                    1261          ADDA.L D0,A1 ;displace to a specific mask
000019B0  1A11                    1262          MOVE.B (A1),D5 ;move the mask to D5
000019B2                          1263          
000019B2  0C05 0000               1264          CMPI.B #0,D5 ;check if the mask is 0
000019B6  6700 F6B8               1265          BEQ falsePositive ;branch if it is
000019BA                          1266          
000019BA  1401                    1267          MOVE.B D1,D2 ;copy instruction to D2
000019BC  C405                    1268          AND.B D5,D2  ;mask D2
000019BE  43F8 1998               1269          LEA NegEA,A1 ;load the list of valid modes
000019C2  D3C0                    1270          ADDA.L D0,A1 ;displace to a specific mode
000019C4  1811                    1271          MOVE.B (A1),D4 ;move mode to D4
000019C6  B404                    1272          CMP.B D4,D2 ;compare mode to masked value
000019C8  6700 0006               1273          BEQ NegBody ;if its match, its a valid mode and we can procede
000019CC                          1274          
000019CC  5280                    1275          ADDQ.L #1,D0 ;add one to displacement
000019CE  60DA                    1276          BRA validNegModes ;check for next mode
000019D0                          1277          
000019D0                          1278  NegBody:
000019D0                          1279  
000019D0                          1280  
000019D0  3401                    1281          MOVE.W  D1,D2 ;copy inst to D2
000019D2  C47C 0600               1282          AND.W  #%0011000000000,D2 ;mask word for size
000019D6  0C42 0000               1283          CMPI.W #0,D2 ;0 is the only non valid size
000019DA  6700 F694               1284          BEQ falsePositive ; zero is not valid
000019DE                          1285  
000019DE  43F9 00002376           1286          LEA     negMessage,A1  ;move string for NEG info
000019E4  103C 000E               1287          MOVE.B  #14,D0        ;set for task to display null terminated 
000019E8                          1288                                ;string without CR, LF
000019E8  4E4F                    1289          TRAP    #15
000019EA                          1290          
000019EA  3401                    1291          MOVE.W D1,D2
000019EC  C47C 003F               1292          AND #%000000000111111,D2
000019F0  1A02                    1293          MOVE.B D2,D5
000019F2                          1294          
000019F2  48E7 4000               1295          MOVEM.L D1,-(SP)
000019F6  6100 05BC               1296          BSR     Get_Effective_Address
000019FA  4CDF 0002               1297          MOVEM.L (SP)+,D1
000019FE                          1298          
000019FE                          1299                
000019FE                          1300          
000019FE                          1301  NEGdone:
000019FE                          1302  
000019FE  43F9 00002304           1303          LEA     clearLine,A1  ;move string for a CR and LF
00001A04  103C 000E               1304          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A08                          1305                                ;string without CR, LF
00001A08  4E4F                    1306          TRAP    #15
00001A0A  7000                    1307          MOVEQ.L #0,D0
00001A0C  4E75                    1308          RTS
00001A0E                          1309          
00001A0E                          1310   ADDI:            
00001A0E                          1311       
00001A0E  7000                    1312          MOVEQ.L #0, D0 ;clear D0
00001A10                          1313          
00001A10                          1314  validAddiModes:
00001A10                          1315          
00001A10                          1316          
00001A10  43F9 00001B09           1317          LEA cmpiEAmasks,A1 ;load the list of masks
00001A16  D3C0                    1318          ADDA.L D0,A1 ;displace to a specific mask
00001A18  1A11                    1319          MOVE.B (A1),D5 ;move the mask to D5
00001A1A                          1320          
00001A1A  0C05 0000               1321          CMPI.B #0,D5 ;check if the mask is 0
00001A1E  6700 F650               1322          BEQ falsePositive ;branch if it is
00001A22                          1323          
00001A22  1401                    1324          MOVE.B D1,D2 ;copy instruction to D2
00001A24  C405                    1325          AND.B D5,D2  ;mask D2
00001A26  43F9 00001B02           1326          LEA cmpiEA,A1 ;load the list of valid modes
00001A2C  D3C0                    1327          ADDA.L D0,A1 ;displace to a specific mode
00001A2E  1811                    1328          MOVE.B (A1),D4 ;move mode to D4
00001A30  B404                    1329          CMP.B D4,D2 ;compare mode to masked value
00001A32  6700 0006               1330          BEQ addiBody ;if its match, its a valid mode and we can procede
00001A36                          1331          
00001A36  5280                    1332          ADDQ.L #1,D0 ;add one to displacement
00001A38  60D6                    1333          BRA validAddiModes ;check for next mode
00001A3A                          1334          
00001A3A                          1335  addiBody:
00001A3A                          1336  
00001A3A                          1337  
00001A3A  3401                    1338          MOVE.W  D1,D2 ;copy inst to D2
00001A3C  C47C 00C0               1339          AND.W  #%0000000011000000,D2 ;mask word for size
00001A40  0C42 00C0               1340          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001A44  6700 F62A               1341          BEQ falsePositive
00001A48                          1342  
00001A48  43F9 0000234E           1343          LEA     addiMessage,A1  ;move string for NEG info
00001A4E  103C 000E               1344          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A52                          1345                                ;string without CR, LF
00001A52  4E4F                    1346          TRAP    #15
00001A54                          1347          
00001A54                          1348          ;go to Effective_Address for immediate data
00001A54  143C 003C               1349          MOVE.B #%00111100,D2
00001A58  48E7 4000               1350          MOVEM.L D1,-(SP)
00001A5C  6100 0556               1351          BSR     Get_Effective_Address
00001A60  4CDF 0002               1352          MOVEM.L (SP)+,D1
00001A64                          1353          
00001A64  3401                    1354          MOVE.W D1,D2 ;copy inst to D2
00001A66  C47C 003F               1355          AND #%000000000111111,D2 ;and out everything but modes and regs
00001A6A  1A02                    1356          MOVE.B D2,D5 ; copy to D5 for following BSR
00001A6C                          1357          
00001A6C  48E7 4000               1358          MOVEM.L D1,-(SP)
00001A70  6100 0542               1359          BSR     Get_Effective_Address
00001A74  4CDF 0002               1360          MOVEM.L (SP)+,D1
00001A78                          1361          
00001A78                          1362                
00001A78                          1363          
00001A78                          1364  addidone:
00001A78                          1365  
00001A78  43F9 00002304           1366          LEA     clearLine,A1  ;move string for a CR and LF
00001A7E  103C 000E               1367          MOVE.B  #14,D0        ;set for task to display null terminated 
00001A82                          1368                                ;string without CR, LF
00001A82  4E4F                    1369          TRAP    #15
00001A84  7000                    1370          MOVEQ.L #0,D0
00001A86  4E75                    1371          RTS
00001A88                          1372    
00001A88                          1373  ORI:            
00001A88                          1374       
00001A88  7000                    1375          MOVEQ.L #0, D0 ;clear D0
00001A8A                          1376          
00001A8A                          1377  validOriModes:
00001A8A                          1378          
00001A8A                          1379          
00001A8A  43F9 00001B09           1380          LEA cmpiEAmasks,A1 ;load the list of masks
00001A90  D3C0                    1381          ADDA.L D0,A1 ;displace to a specific mask
00001A92  1A11                    1382          MOVE.B (A1),D5 ;move the mask to D5
00001A94                          1383          
00001A94  0C05 0000               1384          CMPI.B #0,D5 ;check if the mask is 0
00001A98  6700 F5D6               1385          BEQ falsePositive ;branch if it is
00001A9C                          1386          
00001A9C  1401                    1387          MOVE.B D1,D2 ;copy instruction to D2
00001A9E  C405                    1388          AND.B D5,D2  ;mask D2
00001AA0  43F9 00001B02           1389          LEA cmpiEA,A1 ;load the list of valid modes
00001AA6  D3C0                    1390          ADDA.L D0,A1 ;displace to a specific mode
00001AA8  1811                    1391          MOVE.B (A1),D4 ;move mode to D4
00001AAA  B404                    1392          CMP.B D4,D2 ;compare mode to masked value
00001AAC  6700 0006               1393          BEQ oriBody ;if its match, its a valid mode and we can procede
00001AB0                          1394          
00001AB0  5280                    1395          ADDQ.L #1,D0 ;add one to displacement
00001AB2  60D6                    1396          BRA validOriModes ;check for next mode
00001AB4                          1397          
00001AB4                          1398  oriBody:
00001AB4                          1399  
00001AB4                          1400  
00001AB4  3401                    1401          MOVE.W  D1,D2 ;copy inst to D2
00001AB6  C47C 00C0               1402          AND.W  #%0000000011000000,D2 ;mask word for size
00001ABA  0C42 00C0               1403          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001ABE  6700 F5B0               1404          BEQ falsePositive
00001AC2                          1405  
00001AC2  43F9 00002354           1406          LEA     oriMessage,A1  ;move string for NEG info
00001AC8  103C 000E               1407          MOVE.B  #14,D0        ;set for task to display null terminated 
00001ACC                          1408                                ;string without CR, LF
00001ACC  4E4F                    1409          TRAP    #15
00001ACE                          1410          
00001ACE                          1411          ;go to Effective_Address for immediate data
00001ACE  143C 003C               1412          MOVE.B #%00111100,D2
00001AD2  48E7 4000               1413          MOVEM.L D1,-(SP)
00001AD6  6100 04DC               1414          BSR     Get_Effective_Address
00001ADA  4CDF 0002               1415          MOVEM.L (SP)+,D1
00001ADE                          1416          
00001ADE  3401                    1417          MOVE.W D1,D2 ;copy inst to D2
00001AE0  C47C 003F               1418          AND #%000000000111111,D2 ;and out everything but modes and regs
00001AE4  1A02                    1419          MOVE.B D2,D5 ; copy to D5 for following BSR
00001AE6                          1420          
00001AE6  48E7 4000               1421          MOVEM.L D1,-(SP)
00001AEA  6100 04C8               1422          BSR     Get_Effective_Address
00001AEE  4CDF 0002               1423          MOVEM.L (SP)+,D1
00001AF2                          1424          
00001AF2                          1425                
00001AF2                          1426          
00001AF2                          1427  oridone:
00001AF2                          1428  
00001AF2  43F9 00002304           1429          LEA     clearLine,A1  ;move string for a CR and LF
00001AF8  103C 000E               1430          MOVE.B  #14,D0        ;set for task to display null terminated 
00001AFC                          1431                                ;string without CR, LF
00001AFC  4E4F                    1432          TRAP    #15
00001AFE  7000                    1433          MOVEQ.L #0,D0
00001B00  4E75                    1434          RTS
00001B02                          1435  
00001B02                          1436          
00001B02                          1437          
00001B02= 20 18 00 10 38 39 00    1438  cmpiEA        DC.B %100000,%011000,%000000,%010000, %111000, %111001,0
00001B09= 38 38 38 38 3F 3F 00    1439  cmpiEAmasks   DC.B %111000,%111000,%111000,%111000, %111111, %111111,0
00001B10                          1440     
00001B10                          1441  CMPI:            
00001B10                          1442       
00001B10  7000                    1443          MOVEQ.L #0, D0 ;clear D0
00001B12                          1444          
00001B12                          1445  validCmpiModes:
00001B12                          1446          
00001B12                          1447          
00001B12  43F8 1B09               1448          LEA cmpiEAmasks,A1 ;load the list of masks
00001B16  D3C0                    1449          ADDA.L D0,A1 ;displace to a specific mask
00001B18  1A11                    1450          MOVE.B (A1),D5 ;move the mask to D5
00001B1A                          1451          
00001B1A  0C05 0000               1452          CMPI.B #0,D5 ;check if the mask is 0
00001B1E  6700 F550               1453          BEQ falsePositive ;branch if it is
00001B22                          1454          
00001B22  1401                    1455          MOVE.B D1,D2 ;copy instruction to D2
00001B24  C405                    1456          AND.B D5,D2  ;mask D2
00001B26  43F8 1B02               1457          LEA cmpiEA,A1 ;load the list of valid modes
00001B2A  D3C0                    1458          ADDA.L D0,A1 ;displace to a specific mode
00001B2C  1811                    1459          MOVE.B (A1),D4 ;move mode to D4
00001B2E  B404                    1460          CMP.B D4,D2 ;compare mode to masked value
00001B30  6700 0006               1461          BEQ CMPIBody ;if its match, its a valid mode and we can procede
00001B34                          1462          
00001B34  5280                    1463          ADDQ.L #1,D0 ;add one to displacement
00001B36  60DA                    1464          BRA validCmpiModes ;check for next mode
00001B38                          1465          
00001B38                          1466  CMPIBody:
00001B38                          1467  
00001B38                          1468  
00001B38  3401                    1469          MOVE.W  D1,D2 ;copy inst to D2
00001B3A  C47C 00C0               1470          AND.W  #%0000000011000000,D2 ;mask word for size
00001B3E  0C42 00C0               1471          CMPI.W #%0000000011000000,D2 ;11 is the only non valid size
00001B42  6700 F52C               1472          BEQ falsePositive
00001B46                          1473  
00001B46  43F9 00002359           1474          LEA     cmpiMessage,A1  ;move string for NEG info
00001B4C  103C 000E               1475          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B50                          1476                                ;string without CR, LF
00001B50  4E4F                    1477          TRAP    #15
00001B52                          1478          
00001B52                          1479          ;go to Effective_Address for immediate data
00001B52  143C 003C               1480          MOVE.B #%00111100,D2
00001B56  48E7 4000               1481          MOVEM.L D1,-(SP)
00001B5A  6100 0458               1482          BSR     Get_Effective_Address
00001B5E  4CDF 0002               1483          MOVEM.L (SP)+,D1
00001B62                          1484          
00001B62  3401                    1485          MOVE.W D1,D2 ;copy inst to D2
00001B64  C47C 003F               1486          AND #%000000000111111,D2 ;and out everything but modes and regs
00001B68  1A02                    1487          MOVE.B D2,D5 ; copy to D5 for following BSR
00001B6A                          1488          
00001B6A  48E7 4000               1489          MOVEM.L D1,-(SP)
00001B6E  6100 0444               1490          BSR     Get_Effective_Address
00001B72  4CDF 0002               1491          MOVEM.L (SP)+,D1
00001B76                          1492          
00001B76                          1493                
00001B76                          1494          
00001B76                          1495  CMPidone:
00001B76                          1496  
00001B76  43F9 00002304           1497          LEA     clearLine,A1  ;move string for a CR and LF
00001B7C  103C 000E               1498          MOVE.B  #14,D0        ;set for task to display null terminated 
00001B80                          1499                                ;string without CR, LF
00001B80  4E4F                    1500          TRAP    #15
00001B82  7000                    1501          MOVEQ.L #0,D0
00001B84  4E75                    1502          RTS
00001B86                          1503  
00001B86                          1504          
00001B86= 10 38 39 00             1505  JsrEA        DC.B %010000, %111000, %111001,0
00001B8A= 38 3F 3F 00             1506  JsrEAmasks   DC.B %111000, %111111, %111111,0
00001B8E                          1507     
00001B8E                          1508  JSR:            
00001B8E                          1509       
00001B8E  7000                    1510          MOVEQ.L #0, D0 ;clear D0
00001B90                          1511          
00001B90                          1512  validJsrModes:
00001B90                          1513          
00001B90  43F8 1B8A               1514          LEA JsrEAmasks,A1 ;load the list of masks
00001B94  D3C0                    1515          ADDA.L D0,A1 ;displace to a specific mask
00001B96  1A11                    1516          MOVE.B (A1),D5 ;move the mask to D5
00001B98                          1517          
00001B98  0C05 0000               1518          CMPI.B #0,D5 ;check if the mask is 0
00001B9C  6700 F4D2               1519          BEQ falsePositive ;branch if it is
00001BA0                          1520          
00001BA0  1401                    1521          MOVE.B D1,D2 ;copy instruction to D2
00001BA2  C405                    1522          AND.B D5,D2  ;mask D2
00001BA4  43F8 1B86               1523          LEA JsrEA,A1 ;load the list of valid modes
00001BA8  D3C0                    1524          ADDA.L D0,A1 ;displace to a specific mode
00001BAA  1811                    1525          MOVE.B (A1),D4 ;move mode to D4
00001BAC  B404                    1526          CMP.B D4,D2 ;compare mode to masked value
00001BAE  6700 0006               1527          BEQ JsrBody ;if its match, its a valid mode and we can procede
00001BB2                          1528          
00001BB2  5280                    1529          ADDQ.L #1,D0 ;add one to displacement
00001BB4  60DA                    1530          BRA validJsrModes ;check for next mode
00001BB6                          1531          
00001BB6                          1532  JsrBody:
00001BB6                          1533  
00001BB6                          1534  
00001BB6  43F9 0000235F           1535          LEA     jsrMessage,A1  ;move string for NEG info
00001BBC  103C 000E               1536          MOVE.B  #14,D0        ;set for task to display null terminated 
00001BC0                          1537                                ;string without CR, LF
00001BC0  4E4F                    1538          TRAP    #15
00001BC2                          1539          
00001BC2  3401                    1540          MOVE.W D1,D2 ;copy inst to D2
00001BC4  C47C 003F               1541          AND #%000000000111111,D2 ;and out everything but modes and regs
00001BC8  1A02                    1542          MOVE.B D2,D5 ; copy to D5 for following BSR
00001BCA                          1543          
00001BCA  48E7 4000               1544          MOVEM.L D1,-(SP)
00001BCE  6100 03E4               1545          BSR     Get_Effective_Address
00001BD2  4CDF 0002               1546          MOVEM.L (SP)+,D1
00001BD6                          1547          
00001BD6                          1548                
00001BD6                          1549          
00001BD6                          1550  Jsrdone:
00001BD6                          1551  
00001BD6  43F9 00002304           1552          LEA     clearLine,A1  ;move string for a CR and LF
00001BDC  103C 000E               1553          MOVE.B  #14,D0        ;set for task to display null terminated 
00001BE0                          1554                                ;string without CR, LF
00001BE0  4E4F                    1555          TRAP    #15
00001BE2  7000                    1556          MOVEQ.L #0,D0
00001BE4  4E75                    1557          RTS
00001BE6                          1558  
00001BE6                          1559  
00001BE6                          1560          
00001BE6                          1561  NOP:
00001BE6                          1562  
00001BE6  43F9 00002369           1563          LEA     nopMessage,A1 ;move string for NOP info
00001BEC  103C 000D               1564          MOVE.B  #13,D0        ;set for task to display null terminated 
00001BF0                          1565                                ;string with CR, LF
00001BF0  4E4F                    1566          TRAP    #15
00001BF2                          1567          
00001BF2  7000                    1568          MOVEQ.L #0,D0
00001BF4  4E75                    1569          RTS
00001BF6                          1570          
00001BF6                          1571  RTS:
00001BF6                          1572          
00001BF6  43F9 00002364           1573          LEA     rtsMessage,A1  ;move string for rts info
00001BFC  103C 000D               1574          MOVE.B  #13,D0        ;set for task to display null terminated 
00001C00                          1575                                ;string with CR, LF
00001C00  4E4F                    1576          TRAP    #15  
00001C02                          1577     
00001C02  7000                    1578          MOVEQ.L #0,D0
00001C04  4E75                    1579          RTS   
00001C06                          1580  
00001C06= 3C 08 00 10 18 20 ...   1581  moveSourceEA        DC.B %111100,%001000,%000000,%010000,%011000,%100000,%111000,%111001,0
00001C0F= 3F 38 38 38 38 38 ...   1582  moveSourceEAmasks   DC.B %111111,%111000,%111000,%111000,%111000,%111000,%111111,%111111,0
00001C18                          1583  
00001C18= 00 10 18 20 38 39 00    1584  moveDestEA        DC.B %000000,%010000,%011000,%100000,%111000,%111001,0
00001C1F= 38 38 38 38 3F 3F 00    1585  moveDestEAmasks   DC.B %111000,%111000,%111000,%111000,%111111,%111111,0        
00001C26                          1586  
00001C26                          1587  MOVE:
00001C26                          1588          
00001C26                          1589  
00001C26                          1590          
00001C26  7000                    1591          MOVEQ.L #0, D0 ;clear D0
00001C28                          1592          
00001C28                          1593  validMoveSourceModes:
00001C28                          1594          
00001C28  43F8 1C0F               1595          LEA moveSourceEAmasks,A1 ;load the list of masks
00001C2C  D3C0                    1596          ADDA.L D0,A1 ;displace to a specific mask
00001C2E  1A11                    1597          MOVE.B (A1),D5 ;move the mask to D5
00001C30                          1598          
00001C30  0C05 0000               1599          CMPI.B #0,D5 ;check if the mask is 0
00001C34  6700 F43A               1600          BEQ falsePositive ;branch if it is
00001C38                          1601          
00001C38  1401                    1602          MOVE.B D1,D2 ;copy instruction to D2
00001C3A  C405                    1603          AND.B D5,D2  ;mask D2
00001C3C                          1604          
00001C3C  43F8 1C06               1605          LEA moveSourceEA,A1 ;load the list of valid modes
00001C40  D3C0                    1606          ADDA.L D0,A1 ;displace to a specific mode
00001C42  1811                    1607          MOVE.B (A1),D4 ;move mode to D4
00001C44  B404                    1608          CMP.B D4,D2 ;compare mode to masked value
00001C46  6700 0006               1609          BEQ  checkMoveDest ;if its match, its a valid mode and we can procede
00001C4A                          1610          
00001C4A  5280                    1611          ADDQ.L #1,D0 ;add one to displacement
00001C4C  60DA                    1612          BRA validMoveSourceModes ;check for next mode
00001C4E                          1613          
00001C4E                          1614  checkMoveDest:
00001C4E  7000                    1615          MOVEQ.L #0, D0 ;clear D0
00001C50                          1616          
00001C50                          1617  validMoveDestModes:
00001C50                          1618          
00001C50  43F8 1C1F               1619          LEA moveDestEAmasks,A1 ;load the list of masks
00001C54  D3C0                    1620          ADDA.L D0,A1 ;displace to a specific mask
00001C56  1A11                    1621          MOVE.B (A1),D5 ;move the mask to D5
00001C58                          1622          
00001C58  0C05 0000               1623          CMPI.B #0,D5 ;check if the mask is 0
00001C5C  6700 F412               1624          BEQ falsePositive ;branch if it is
00001C60                          1625          
00001C60  3401                    1626          MOVE.W D1,D2 ;copy instruction to D2
00001C62  EC4A                    1627          LSR.W #6,D2  ;move mode
00001C64  6100 04C2               1628          BSR switchModeAndReg ;switch register and mode
00001C68  C405                    1629          AND.B D5,D2  ;mask D2
00001C6A                          1630          
00001C6A  43F8 1C18               1631          LEA moveDestEA,A1 ;load the list of valid modes
00001C6E  D3C0                    1632          ADDA.L D0,A1 ;displace to a specific mode
00001C70  1811                    1633          MOVE.B (A1),D4 ;move mode to D4
00001C72  B404                    1634          CMP.B D4,D2 ;compare mode to masked value
00001C74  6700 0006               1635          BEQ moveBody ;if its match, its a valid mode and we can procede
00001C78                          1636          
00001C78  5280                    1637          ADDQ.L #1,D0 ;add one to displacement
00001C7A  60D4                    1638          BRA validMoveDestModes ;check for next mode
00001C7C                          1639          
00001C7C                          1640  moveBody
00001C7C  3401                    1641          MOVE.W  D1,D2 ;copy inst to D2
00001C7E  C47C 3000               1642          AND.W  #%0011000000000000,D2 ;mask word for size
00001C82  0C42 0000               1643          CMPI.W #0,D2 ;0 is the only non valid size
00001C86  6700 F3E8               1644          BEQ falsePositive ; if zero, this is not move
00001C8A                          1645  
00001C8A  43F9 0000236E           1646          LEA     moveMessage,A1  ;move string for MOVE
00001C90  103C 000E               1647          MOVE.B  #14,D0        ;set for task to display null terminated 
00001C94                          1648                                ;string with CR, LF
00001C94  4E4F                    1649          TRAP    #15
00001C96                          1650          
00001C96                          1651          
00001C96  3401                    1652          MOVE.W  D1,D2 ;check source mode
00001C98  C43C 003F               1653          AND.B   #%00111111,D2
00001C9C  1A02                    1654          MOVE.B  D2,D5
00001C9E  48E7 4000               1655          MOVEM.L D1,-(SP)
00001CA2  6100 0310               1656          BSR     Get_Effective_Address
00001CA6  4CDF 0002               1657          MOVEM.L (SP)+,D1
00001CAA                          1658          
00001CAA                          1659          ;print separator
00001CAA                          1660          
00001CAA  3401                    1661          MOVE.W  D1,D2 ;check dest mode
00001CAC  EC4A                    1662          LSR.W   #6,D2
00001CAE  6100 0478               1663          BSR  switchModeAndReg
00001CB2  C43C 003F               1664          AND.B   #%00111111,D2
00001CB6  1A02                    1665          MOVE.B  D2,D5
00001CB8  48E7 4000               1666          MOVEM.L D1,-(SP)
00001CBC  6100 02F6               1667          BSR     Get_Effective_Address
00001CC0  4CDF 0002               1668          MOVEM.L (SP)+,D1
00001CC4                          1669          
00001CC4                          1670          
00001CC4                          1671          
00001CC4  43F9 00002304           1672          LEA     clearLine,A1  ;move string for a CR and LF
00001CCA  103C 000E               1673          MOVE.B  #14,D0        ;set for task to display null terminated 
00001CCE                          1674                                ;string without CR, LF
00001CCE  4E4F                    1675          TRAP    #15
00001CD0                          1676  
00001CD0  7000                    1677          MOVEQ.L #0,D0
00001CD2  4E75                    1678          RTS
00001CD4                          1679          
00001CD4= 08 00                   1680  moveADestEA        DC.B %001000,0
00001CD6= 38 00                   1681  moveADestEAmasks   DC.B %111000,0
00001CD8                          1682          
00001CD8                          1683  MOVEA:
00001CD8                          1684  
00001CD8  7000                    1685          MOVEQ.L #0, D0 ;clear D0
00001CDA                          1686          
00001CDA                          1687  validMoveASourceModes:
00001CDA                          1688          
00001CDA  43F8 1C0F               1689          LEA moveSourceEAmasks,A1 ;load the list of masks
00001CDE  D3C0                    1690          ADDA.L D0,A1 ;displace to a specific mask
00001CE0  1A11                    1691          MOVE.B (A1),D5 ;move the mask to D5
00001CE2                          1692          
00001CE2  0C05 0000               1693          CMPI.B #0,D5 ;check if the mask is 0
00001CE6  6700 F388               1694          BEQ falsePositive ;branch if it is
00001CEA                          1695          
00001CEA  1401                    1696          MOVE.B D1,D2 ;copy instruction to D2
00001CEC  C405                    1697          AND.B D5,D2  ;mask D2
00001CEE                          1698          
00001CEE  43F8 1C06               1699          LEA moveSourceEA,A1 ;load the list of valid modes
00001CF2  D3C0                    1700          ADDA.L D0,A1 ;displace to a specific mode
00001CF4  1811                    1701          MOVE.B (A1),D4 ;move mode to D4
00001CF6  B404                    1702          CMP.B D4,D2 ;compare mode to masked value
00001CF8  6700 0006               1703          BEQ  checkMoveADest ;if its match, its a valid mode and we can procede
00001CFC                          1704          
00001CFC  5280                    1705          ADDQ.L #1,D0 ;add one to displacement
00001CFE  60DA                    1706          BRA validMoveASourceModes ;check for next mode
00001D00                          1707          
00001D00                          1708  checkMoveADest:
00001D00  7000                    1709          MOVEQ.L #0, D0 ;clear D0
00001D02                          1710  validMoveADestModes:
00001D02                          1711          
00001D02  43F8 1CD6               1712          LEA moveADestEAmasks,A1 ;load the list of masks
00001D06  D3C0                    1713          ADDA.L D0,A1 ;displace to a specific mask
00001D08  1A11                    1714          MOVE.B (A1),D5 ;move the mask to D5
00001D0A                          1715          
00001D0A  0C05 0000               1716          CMPI.B #0,D5 ;check if the mask is 0
00001D0E  6700 F360               1717          BEQ falsePositive ;branch if it is
00001D12                          1718          
00001D12  3401                    1719          MOVE.W D1,D2 ;copy instruction to D2
00001D14  EA4A                    1720          LSR.W #5,D2  ;move mode
00001D16  6100 0410               1721          BSR switchModeAndReg ;switch register and mode
00001D1A  C405                    1722          AND.B D5,D2  ;mask D2
00001D1C                          1723          
00001D1C  43F8 1CD4               1724          LEA moveADestEA,A1 ;load the list of valid modes
00001D20  D3C0                    1725          ADDA.L D0,A1 ;displace to a specific mode
00001D22  1811                    1726          MOVE.B (A1),D4 ;move mode to D4
00001D24  B404                    1727          CMP.B D4,D2 ;compare mode to masked value
00001D26  6700 0006               1728          BEQ moveABody ;if its match, its a valid mode and we can procede
00001D2A                          1729          
00001D2A  5280                    1730          ADDQ.L #1,D0 ;add one to displacement
00001D2C  60D4                    1731          BRA validMoveADestModes ;check for next mode
00001D2E                          1732  moveABody:
00001D2E  3401                    1733          MOVE.W  D1,D2 ;copy inst to D2
00001D30  C47C 3000               1734          AND.W  #%0011000000000000,D2 ;mask word for size
00001D34  0C42 0000               1735          CMPI.W #0,D2 ;0 is the non valid size
00001D38  6700 F336               1736          BEQ falsePositive ; if zero, this is not move
00001D3C  0C42 1000               1737          CMPI.W #%0001000000000000,D2
00001D40  6700 F32E               1738          BEQ falsePositive ; if byte, this is not movea
00001D44                          1739  
00001D44                          1740  
00001D44  43F9 00002381           1741          LEA     moveAMessage,A1  ;move string for MOVE
00001D4A  103C 000D               1742          MOVE.B  #13,D0        ;set for task to display null terminated 
00001D4E                          1743                                ;string with CR, LF
00001D4E  4E4F                    1744          TRAP    #15
00001D50                          1745  
00001D50  7000                    1746          MOVEQ.L #0,D0
00001D52  4E75                    1747          RTS
00001D54                          1748  
00001D54                          1749             
00001D54                          1750  Bcc:
00001D54                          1751  
00001D54  43F9 00002374           1752          LEA     bccMessage,A1  ;move string for BRA info
00001D5A  103C 000E               1753          MOVE.B  #14,D0        ;set for task to display null terminated 
00001D5E                          1754                                ;string without CR, LF
00001D5E  4E4F                    1755          TRAP    #15
00001D60                          1756          
00001D60  7000                    1757          MOVEQ.L #0,D0 ;clear D0
00001D62  3401                    1758          MOVE.W  D1,D2 ;move instruction into D2 for manipulaiton
00001D64  E04A                    1759          LSR.W   #8,D2
00001D66  C47C 000F               1760          AND.W   #$0F,D2 ;mask instruction
00001D6A                          1761          
00001D6A                          1762  checkCC:        
00001D6A  41F9 0000228B           1763          LEA     bccList,A0 ;get condition code signature list in A0
00001D70  D1C0                    1764          ADDA.L  D0,A0 ;get correct sig         
00001D72  B410                    1765          CMP.B   (A0),D2 ;compare to sig
00001D74  6700 0006               1766          BEQ     foundCC ;if sig matches branch
00001D78  5200                    1767          ADDQ.B  #byte,D0
00001D7A  60EE                    1768          BRA     checkCC
00001D7C                          1769  foundCC:
00001D7C  43F9 0000229C           1770          LEA     conditionCodeMessage,A1 ;get condition code message in A1
00001D82  C0FC 0004               1771          MULU.W  #long,D0 ;adjust size of D0 for a long
00001D86  D3C0                    1772          ADDA.L  D0,A1 ;get correct message location
00001D88  2251                    1773          MOVEA.L (A1),A1 ;get correct message
00001D8A                          1774          
00001D8A  103C 000E               1775          MOVE.B  #14,D0        ;set for task to display null terminated 
00001D8E                          1776                                ;string without CR, LF
00001D8E  4E4F                    1777          TRAP    #15
00001D90                          1778  
00001D90                          1779          
00001D90                          1780          
00001D90  548B                    1781          ADDQ.L  #word,A3 ;move past instruction in case long displacement
00001D92  C27C 00FF               1782          AND.W   #$00FF,D1   ;check for word sized displacement
00001D96                          1783          
00001D96  B23C 0000               1784          CMP.B   #$0,D1
00001D9A  6700 0010               1785          BEQ     BccWord
00001D9E                          1786          
00001D9E  B23C 00FF               1787          CMP.B   #$FF,D1 check for long sized displacement
00001DA2  6700 0010               1788          BEQ     BccLong
00001DA6                          1789          
00001DA6                          1790  BccByte:
00001DA6                          1791          
00001DA6  7E00                    1792          MOVEQ.L #0,D7 ;pass back no extra data followed
00001DA8  6000 0012               1793          BRA     BccDone
00001DAC                          1794  BccWord:
00001DAC  3213                    1795          MOVE.W  (A3),D1
00001DAE                          1796          
00001DAE  7E02                    1797          MOVEQ.L #word,D7 ;pass back an extra word followed
00001DB0  6000 000A               1798          BRA     BccDone
00001DB4                          1799  BccLong:
00001DB4  2213                    1800          MOVE.L  (A3),D1
00001DB6                          1801          
00001DB6  7E04                    1802          MOVEQ.L #long,D7 ;pass back an extra long followed
00001DB8  6000 0002               1803          BRA     BccDone
00001DBC                          1804  BccDone:
00001DBC                          1805  
00001DBC  343C 0010               1806          MOVE.W  #16,D2 ;put base in D2
00001DC0  303C 000F               1807          MOVE.W  #15,D0  ;put task #15 in D0
00001DC4  4E4F                    1808          TRAP    #15
00001DC6                          1809          
00001DC6  43F9 00002304           1810          LEA     clearLine,A1  ;move string for a CR and LF
00001DCC  103C 000E               1811          MOVE.B  #14,D0        ;set for task to display null terminated 
00001DD0                          1812                                ;string without CR, LF
00001DD0  4E4F                    1813          TRAP    #15
00001DD2                          1814  
00001DD2  7000                    1815          MOVEQ.L #0,D0
00001DD4  4E75                    1816          RTS
00001DD6                          1817          
00001DD6                          1818          
00001DD6                          1819  unknownOpCode:
00001DD6  43F9 0000237B           1820          LEA     dataMessage,A1 ;move string for data info
00001DDC  103C 000E               1821          MOVE.B  #14,D0        ;set for task to display null terminated 
00001DE0                          1822                                ;string without CR, LF
00001DE0  4E4F                    1823          TRAP    #15
00001DE2                          1824          
00001DE2  143C 0010               1825          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001DE6  103C 000F               1826          MOVE.B  #15,D0
00001DEA  4E4F                    1827          TRAP    #15
00001DEC                          1828          
00001DEC  43F9 00002304           1829          LEA     clearLine,A1  ;move string for a CR and LF
00001DF2  103C 000E               1830          MOVE.B  #14,D0        ;set for task to display null terminated 
00001DF6                          1831                                ;string without CR, LF
00001DF6  4E4F                    1832          TRAP    #15
00001DF8                          1833          
00001DF8  7000                    1834          MOVEQ.L #0,D0
00001DFA  4E75                    1835          RTS
00001DFC                          1836          
00001DFC                          1837  handlebytedata:
00001DFC                          1838  
00001DFC  43F9 0000237B           1839          LEA     dataMessage,A1 ;move string for data info
00001E02  103C 000E               1840          MOVE.B  #14,D0        ;set for task to display null terminated 
00001E06                          1841                                ;string without CR, LF
00001E06  4E4F                    1842          TRAP    #15
00001E08                          1843          
00001E08  E049                    1844          LSR.W   #8,D1 ;shift the word read into D1 by a byte
00001E0A                          1845          
00001E0A  143C 0010               1846          MOVE.B  #16,D2        ;set for displaying a base16(hex) number in D1
00001E0E  103C 000F               1847          MOVE.B  #15,D0
00001E12  4E4F                    1848          TRAP    #15
00001E14                          1849          
00001E14  43F9 00002304           1850          LEA     clearLine,A1  ;move string for a CR and LF
00001E1A  103C 000E               1851          MOVE.B  #14,D0        ;set for task to display null terminated 
00001E1E                          1852                                ;string without CR, LF
00001E1E  4E4F                    1853          TRAP    #15
00001E20                          1854          
00001E20  7000                    1855          MOVEQ.L #0,D0
00001E22                          1856          
00001E22  528B                    1857          ADDQ.L  #byte,A3
00001E24  6000 F200               1858          BRA main_Loop
00001E28                          1859  
00001E28                          1860          
00001E28                          1861          
00001E28                          1862  fin
00001E28                          1863  
00001E28                          1864          
00001E28                          1865          
00001E28  FFFF FFFF               1866          simhalt
00001E2C                          1867          
00001E2C                          1868  
00001E2C                          1869  *******************************************************************************
00001E2C                          1870  *                            SUB ROUTINES
00001E2C                          1871  *******************************************************************************
00001E2C                          1872  
00001E2C                          1873  *******************************************************************************
00001E2C                          1874  *                          IO ROLE ROUTINES
00001E2C                          1875  *******************************************************************************
00001E2C                          1876  
00001E2C                          1877  *==========================================================================
00001E2C                          1878  *                   Enter / Validate beginning address 
00001E2C                          1879  *==========================================================================
00001E2C                          1880   
00001E2C                          1881  begin_address:
00001E2C                          1882  
00001E2C                          1883         
00001E2C  43F9 0000213C           1884          LEA         slPrompt,A1         ;Load address for starting loaction prompt
00001E32  2239 0000213C           1885          MOVE.L      slPrompt,D1         ;Load display length to D1
00001E38  700E                    1886          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001E3A  4E4F                    1887          TRAP        #15                 ;Perform task 14 (display)
00001E3C                          1888          
00001E3C  43F9 000023B2           1889          LEA         startLocation,A1    ;Load address to store user input
00001E42  103C 0002               1890          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001E46  4E4F                    1891          TRAP        #15                 ;Perform task 2 (input)
00001E48                          1892          
00001E48  0C11 001B               1893          CMP.B       #27,(A1)            ;Check for ESC entered
00001E4C  6700 004C               1894          BEQ         address_Exit        ;Exit condition 
00001E50                          1895          
00001E50  6100 0050               1896          BSR         enter_addr_edit_all
00001E54  B67C FFFF               1897          CMP.W       #-1,D3              ;Did the edit pass?
00001E58  67D2                    1898          BEQ         begin_address       ;No, loop and ask for correct input
00001E5A                          1899          
00001E5A  2643                    1900          MOVEA.L     D3,A3               ;Beginning address gets stored in A3
00001E5C                          1901          
00001E5C  43F9 00002249           1902          LEA         spc,A1              ;Load address for starting loaction prompt
00001E62  1239 0000224A           1903          MOVE.B      spc_len,D1          ;Load empty line length
00001E68  7000                    1904          MOVE.L      #0,D0               ;0 = Display the NULL terminated string at (A1) with CR, LF.
00001E6A  4E4F                    1905          TRAP        #15                 ;Perform task 14 (display)
00001E6C  6000 0002               1906          BRA         end_address
00001E70                          1907  
00001E70                          1908  *===========================================================================
00001E70                          1909  *                   Enter / Validate ending address 
00001E70                          1910  *===========================================================================
00001E70                          1911  
00001E70                          1912  end_address:
00001E70                          1913          
00001E70  43F9 0000216D           1914          LEA         elPrompt,A1         ;Load address for ending loaction prompt
00001E76                          1915          ;MOVE.L     elPrompt,D1         ;Load display length to D1
00001E76  7250                    1916          MOVE.L      #80,D1       ;did not like previous command, do not know why, it should have worked
00001E78  700E                    1917          MOVE.L      #14,D0              ;14 = Display the NULL terminated string at (A1) without CR, LF.
00001E7A  4E4F                    1918          TRAP        #15                 ;Perform task 14 (display)
00001E7C                          1919          
00001E7C  103C 0002               1920          MOVE.B      #2,D0               ;2=Read string from keyboard and store at (A1), NULL (0) terminated, length returned in D1.W (max 80
00001E80  4E4F                    1921          TRAP        #15                 ;Perform task 2 (input)
00001E82                          1922          
00001E82  0C11 001B               1923          CMP.B       #27,(A1)            ;Check for ESC entered
00001E86  6700 0012               1924          BEQ         address_Exit        ;Exit condition 
00001E8A                          1925          
00001E8A  6100 0016               1926          BSR         enter_addr_edit_all
00001E8E  B67C FFFF               1927          CMP.W       #-1,D3              ;Did the edit pass?
00001E92  67DC                    1928          BEQ         end_address         ;No, loop and ask for correct input
00001E94                          1929  
00001E94  2843                    1930          MOVEA.L     D3,A4               ;Ending address gets stored in A4
00001E96  6000 0008               1931          BRA         address_done
00001E9A                          1932  
00001E9A                          1933  address_Exit:
00001E9A                          1934  
00001E9A  76FF                    1935          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001E9C  6000 0002               1936          BRA         address_done
00001EA0                          1937          
00001EA0                          1938  address_done:
00001EA0                          1939  
00001EA0  4E75                    1940          RTS    
00001EA2                          1941  
00001EA2                          1942  *==============================================================================
00001EA2                          1943  * enter_addr_edit_all - Enter address edit check to edit all errors  
00001EA2                          1944  *                       using multiple different error checking routines.
00001EA2                          1945  *
00001EA2                          1946  * Parameters -
00001EA2                          1947  *   Input   A1      The data that needs checked.
00001EA2                          1948  *   Input   D1      The number of characters input     
00001EA2                          1949  *   Output  D3      Returns '-1' when there is an error.
00001EA2                          1950  *==============================================================================
00001EA2                          1951  
00001EA2                          1952  enter_addr_edit_all
00001EA2                          1953  
00001EA2                          1954  *------------------------------------------------------------------------------
00001EA2                          1955  * Test for odd number of characters entered, not allowed
00001EA2                          1956  *------------------------------------------------------------------------------
00001EA2                          1957         
00001EA2  6100 0024               1958          BSR         ck_boundry          ;check if the input is on a odd / even boundry
00001EA6  B67C FFFF               1959          CMP.W       #-1,D3              ;Is the address odd?
00001EAA  6700 001A               1960          BEQ         enter_addr_edit_all_exit     ;No, return
00001EAE                          1961  
00001EAE                          1962  *------------------------------------------------------------------------------
00001EAE                          1963  * Ttest for character entered all being valid address characters
00001EAE                          1964  * Note: lower case a-f, gets converted to upper case A-F in D3
00001EAE                          1965  *------------------------------------------------------------------------------
00001EAE                          1966          
00001EAE  6100 0062               1967          BSR         parseHexString      ;check if the input contains valid Hex characters
00001EB2  B67C FFFF               1968          CMP.W       #-1,D3              ;Does the address contain valid Hex characters?
00001EB6  6700 000E               1969          BEQ         enter_addr_edit_all_exit     ;No, return
00001EBA                          1970  
00001EBA                          1971  *------------------------------------------------------------------------------
00001EBA                          1972  * Verify that the address entered is witin the range defined in the Equate
00001EBA                          1973  *------------------------------------------------------------------------------        
00001EBA                          1974          
00001EBA  6100 00C8               1975          BSR         ck_addr_range       ;is address entered witin the range 
00001EBE                          1976                                          ;   as defined in the Equate? 
00001EBE  B67C FFFF               1977          CMP.W       #-1,D3              ;is the address  valid?
00001EC2  6700 0002               1978          BEQ         enter_addr_edit_all_exit     ;No, return
00001EC6                          1979  
00001EC6                          1980  enter_addr_edit_all_exit:
00001EC6                          1981  
00001EC6  4E75                    1982          RTS                             ;return
00001EC8                          1983  
00001EC8                          1984  *==============================================================================
00001EC8                          1985  * ck_boundry - Check the size of the data characters input and determine
00001EC8                          1986  *              if an odd number of characters was entered
00001EC8                          1987  *
00001EC8                          1988  * Parameters -
00001EC8                          1989  *   Input   A1      The data that needs checked for odd length.
00001EC8                          1990  *   Input   D1      The number of characters input     
00001EC8                          1991  *   Output  D3      Returns '-1' when there is an odd length.
00001EC8                          1992  *==============================================================================
00001EC8                          1993  
00001EC8                          1994  ck_boundry:
00001EC8                          1995  
00001EC8  4243                    1996          CLR.W       D3                  ;Clear the return
00001ECA                          1997  
00001ECA  B23C 0000               1998          CMP.B       #0,D1               ;Check for nothing entered
00001ECE  6700 002E               1999          BEQ         ck_size_error       ;Number of characters entered must be 
00001ED2                          2000                                          ;greater than 0  
00001ED2                          2001          
00001ED2                          2002          
00001ED2                          2003          * The program will branch to ck_size_error if D1 is greater than #8        
00001ED2  B23C 0008               2004          CMP.B       #8,D1               ;Check for more than 8 characters entered
00001ED6  6E00 0026               2005          BGT         ck_size_error       ;Number of characters entered must be less
00001EDA                          2006                                          ;than 9
00001EDA                          2007          
00001EDA  7402                    2008          MOVE.L      #$00000002,D2       ;Load a long 2 into D1
00001EDC  82C2                    2009          DIVU        D2,D1               ;Divide address by 2
00001EDE  4841                    2010          SWAP        D1                  ;get remainder
00001EE0  B23C 0001               2011          CMP.B       #$01,D1             ;Check for remainder of 1
00001EE4  6700 0004               2012          BEQ         ck_boundry_error    ;Number of characters entered must be an 
00001EE8                          2013                                          ;even number   
00001EE8                          2014    
00001EE8  4E75                    2015          RTS                             ;return
00001EEA                          2016  
00001EEA                          2017  *------------------------------------------------------------------------------
00001EEA                          2018  * ck_boundry_error - An odd number of characters was entered
00001EEA                          2019  *                  - Load error message and display it
00001EEA                          2020  *                  - Return error condition
00001EEA                          2021  *------------------------------------------------------------------------------
00001EEA                          2022          
00001EEA                          2023  ck_boundry_error:
00001EEA                          2024  
00001EEA  43F9 00002229           2025          LEA         even_msg,A1         ;Load odd error message into A1
00001EF0  2239 00002229           2026          MOVE.L      even_msg,D1         ;Load error length to D1
00001EF6                          2027          
00001EF6  7000                    2028          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001EF8                          2029                                          ; n is D1.W with CR, LF. 
00001EF8  4E4F                    2030          TRAP #15                        ;Display the error message
00001EFA  76FF                    2031          MOVE.L #-1,D3                   ;Load -1 into return parameter
00001EFC  4E75                    2032          RTS                             ;Return
00001EFE                          2033          
00001EFE                          2034  *------------------------------------------------------------------------------
00001EFE                          2035  * ck_size_error -   The number of characters entered must be more than zero
00001EFE                          2036  *                  - Load error message and display it
00001EFE                          2037  *                  - Return error condition
00001EFE                          2038  *------------------------------------------------------------------------------
00001EFE                          2039          
00001EFE                          2040  ck_size_error:
00001EFE                          2041  
00001EFE  43F9 0000219C           2042          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001F04  2239 0000219C           2043          MOVE.L      invalidMsg,D1       ;Load error length to D1
00001F0A                          2044          
00001F0A  7000                    2045          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001F0C                          2046                                          ; n is D1.W with CR, LF. 
00001F0C  4E4F                    2047          TRAP        #15                 ;Display the error message
00001F0E  76FF                    2048          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001F10  4E75                    2049          RTS                             ;Return        
00001F12                          2050  
00001F12                          2051  
00001F12                          2052  *==============================================================================
00001F12                          2053  * parseHexString - Converts user input string into a valid memory address
00001F12                          2054  *                - Stores parsed address data into D3
00001F12                          2055  *                - Stores good/bad (1/0) data in D4 
00001F12                          2056  *
00001F12                          2057  * Hex values are stored as bytes in D2, the ASCII chart shows their value
00001F12                          2058  *   The ASCII chart values we care about are in the ranges of: 
00001F12                          2059  *                            Hex            Decimal
00001F12                          2060  *       No Value           NULL = 0         0
00001F12                          2061  *       Numeric Values:     0-9 = 30-39     48-57
00001F12                          2062  *       Upper Case letters: A-F = 41-46     65-70
00001F12                          2063  *       Lower Case letterc: a-f = 61-66     97-102
00001F12                          2064  
00001F12                          2065  * Parameters -
00001F12                          2066  *   Input   A1      The data that needs checked for valid input.
00001F12                          2067  *   Output  D3      The return value, '-1' for error
00001F12                          2068  *==============================================================================
00001F12                          2069  
00001F12                          2070  parseHexString:
00001F12                          2071  
00001F12                          2072  * setup any initializing item that do not get looped through
00001F12  4243                    2073          CLR.W       D3                  ;Clear the return
00001F14                          2074  
00001F14                          2075          
00001F14                          2076  *------------------------------------------------------------------------------
00001F14                          2077  * NextHex - Loop through all bytes and vaildate the input
00001F14                          2078  * Parameters -
00001F14                          2079  *   Input   A1      The data that needs checked for valid input.
00001F14                          2080  *   Output  D3      The return value, '-1' for error
00001F14                          2081  *------------------------------------------------------------------------------
00001F14                          2082          
00001F14                          2083  NextHex:
00001F14                          2084  
00001F14  1419                    2085          MOVE.B      (A1)+,D2            ;Examine next character and decode it
00001F16  B43C 0000               2086          CMP.B       #0,D2               ;Check character for null 
00001F1A  6700 0066               2087          BEQ         NextHexReturn       ;Character is null (end of input)
00001F1E                          2088          
00001F1E                          2089  *................................................................................
00001F1E                          2090  *  Check decimal values 0-9 by testing hexadecimal values 30-39
00001F1E                          2091  *................................................................................
00001F1E                          2092                  
00001F1E                          2093          * The program will branch to hex_range_error if D2 is less than #30
00001F1E  B43C 0030               2094          CMP.B       #48,D2              ;Hex value 30 = Ascii numeric value 0
00001F22  6D00 0048               2095          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001F26                          2096                                          ;processing
00001F26                          2097          
00001F26                          2098          * The program will branch to UcaseHex if D2 is greater than #39
00001F26  B43C 0039               2099          CMP.B       #57,D2              ;Hex value 30 = Ascii numeric value 0
00001F2A  6E00 000A               2100          BGT         UcaseHex            ;Branch to upper case hexidecimal processing
00001F2E                          2101          
00001F2E                          2102          *a valid number was found within this range
00001F2E  0402 0030               2103          SUBI.B      #48,D2              ;Change ascii decimal code to actual value
00001F32  6000 0032               2104          BRA         NextHexDone         ;Done parsing this byte
00001F36                          2105  
00001F36                          2106  
00001F36                          2107  *..............................................................................
00001F36                          2108  *  Check upper case values A-F by testing hexadecimal values 41-46
00001F36                          2109  *..............................................................................
00001F36                          2110  
00001F36                          2111  UcaseHex:
00001F36                          2112  
00001F36                          2113          * The program will branch to hex_range_error if D2 is less than #41
00001F36  B43C 0041               2114          CMP.B       #65,D2              ;Hex value 41 = Ascii character value 'A'
00001F3A  6D00 0030               2115          BLT         hex_range_error     ;Branch to handle range error hexidecimal
00001F3E                          2116                                          ;processing
00001F3E                          2117          
00001F3E  B43C 0046               2118          CMP.B       #70,D2              ;Hex value 46 = Ascii character value 'F'
00001F42  6E00 000A               2119          BGT         LcaseHex            ;Branch to handle lower case hexidecimal 
00001F46                          2120                                          ;processing
00001F46                          2121          
00001F46                          2122          *a valid number was found within this range
00001F46  0402 0037               2123          SUBI.B      #55,D2              ;Change uppercase character to actual value
00001F4A  6000 001A               2124          BRA         NextHexDone         ;Done parsing this byte
00001F4E                          2125  
00001F4E                          2126  
00001F4E                          2127  *..............................................................................
00001F4E                          2128  *  Check lower case values a-f by testing hexadecimal values 61-66
00001F4E                          2129  *..............................................................................
00001F4E                          2130  
00001F4E                          2131  LcaseHex
00001F4E                          2132          
00001F4E                          2133          * The program will branch to hex_range_error if D2 is less than #61
00001F4E  B43C 0061               2134          CMP.B       #97,D2              ;Hex value 61 = Ascii character value 'a'
00001F52  6D00 0018               2135          BLT         hex_range_error     ;Branch to handle range error hexidecimal 
00001F56                          2136                                          ;processing
00001F56                          2137  
00001F56  B43C 0066               2138          CMP.B       #102,D2              ;Hex value 66 = Ascii character value 'f'
00001F5A  6E00 0010               2139          BGT         hex_range_error     ;Branch to handle range error hexidecimal 
00001F5E                          2140                                          ;processing
00001F5E                          2141  
00001F5E                          2142          *a valid number was found within this range
00001F5E  0402 0057               2143          SUBI.B      #87,D2              ;Change lowercase character to actual value
00001F62  6000 0002               2144          BRA         NextHexDone         ;Done parsing this byte
00001F66                          2145  
00001F66                          2146  NextHexDone:
00001F66                          2147  
00001F66  E983                    2148          ASL.L       #4,D3               ; Make rooom for new byte in the return register
00001F68  D602                    2149          ADD.B       D2,D3               ; Move the new byte into the return register
00001F6A  60A8                    2150          BRA         NextHex             ; We're ready to parse the next byte
00001F6C                          2151          
00001F6C                          2152  *-------------------------------------------------------------------------------------
00001F6C                          2153  * hex_range_error -  A character entered was within the valid range for a hex address
00001F6C                          2154  *                 -  Load error message and display it
00001F6C                          2155  *                 -  Return error condition
00001F6C                          2156  *-------------------------------------------------------------------------------------
00001F6C                          2157          
00001F6C                          2158  hex_range_error:
00001F6C                          2159  
00001F6C  43F9 000021E1           2160          LEA         invCharMsg,A1       ;Load invalid range message into A1
00001F72  2239 000021E1           2161          MOVE.L      invCharMsg,D1       ;Load error length to D1
00001F78                          2162          
00001F78  7000                    2163          MOVE.L      #0,D0               ;Display n characters of string at (A1), 
00001F7A                          2164                                          ; n is D1.W with CR, LF. 
00001F7A  4E4F                    2165          TRAP        #15                 ;Display the error message
00001F7C  76FF                    2166          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001F7E  6000 0002               2167          BRA         NextHexReturn
00001F82                          2168          
00001F82                          2169  NextHexReturn:
00001F82                          2170          
00001F82  4E75                    2171          RTS                             ;Return      
00001F84                          2172  
00001F84                          2173  
00001F84                          2174  *===============================================================================
00001F84                          2175  * ck_addr_range - check the address input is within a valid memory address range
00001F84                          2176  *                - Parsed address data into D3
00001F84                          2177  *
00001F84                          2178  * Parameters -
00001F84                          2179  *   Input   A1      The data that needs checked for valid address.
00001F84                          2180  *   Output  D3      The return value, '-1' for error
00001F84                          2181  *===============================================================================
00001F84                          2182  
00001F84                          2183  
00001F84                          2184  ck_addr_range:   
00001F84                          2185  
00001F84                          2186  *------------------------------------------------------------------------------
00001F84                          2187  * Verify that the address entered is witin the 
00001F84                          2188  * beginning range ('begin') as defined in the Equate
00001F84                          2189  *------------------------------------------------------------------------------   
00001F84                          2190              
00001F84  2C3C 00005001           2191          MOVE.L      #begin,D6           * Load minimum starting address
00001F8A  B686                    2192          CMP.L       D6,D3               * Is input at or above minimum?
00001F8C  6D00 0012               2193          BLT         ck_addr_range_error 
00001F90                          2194          
00001F90                          2195  *------------------------------------------------------------------------------
00001F90                          2196  * Verify that the address entered is witin the 
00001F90                          2197  * ending range ('end') as defined in the Equate
00001F90                          2198  *------------------------------------------------------------------------------
00001F90                          2199          
00001F90  2C3C 00FFFFFE           2200          MOVE.L      #end,D6             * Load maximum starting address
00001F96  B686                    2201          CMP.L       D6,D3               * Is input at or below maximum?
00001F98  6E00 0006               2202          BGT         ck_addr_range_error 
00001F9C  6000 0012               2203          BRA         ck_addr_done        ;done checking
00001FA0                          2204          
00001FA0                          2205  *..............................................................................
00001FA0                          2206  * ck_addr_range_error -  A address entered is not within the 
00001FA0                          2207  *                        valid range for a hex address
00001FA0                          2208  *..............................................................................
00001FA0                          2209          
00001FA0                          2210  ck_addr_range_error
00001FA0                          2211  
00001FA0  43F9 0000219C           2212          LEA         invalidMsg,A1       ;Load invalid range message into A1
00001FA6                          2213          
00001FA6  700D                    2214          MOVE.L      #13,D0              ;Display null terminated string at (A1), 
00001FA8                          2215                                          ;with CR, LF. 
00001FA8  4E4F                    2216          TRAP        #15                 ;Display the error message
00001FAA  76FF                    2217          MOVE.L      #-1,D3              ;Load -1 into return parameter
00001FAC  6000 0002               2218          BRA         ck_addr_done 
00001FB0                          2219  
00001FB0                          2220  ck_addr_done:
00001FB0                          2221  
00001FB0  4E75                    2222          RTS                             ;Return
00001FB2                          2223  
00001FB2                          2224  *******************************************************************************
00001FB2                          2225  *                          OP CODE ROLE ROUTINES
00001FB2                          2226  *******************************************************************************
00001FB2                          2227  
00001FB2                          2228  process_op_codes:
00001FB2                          2229  
00001FB2                          2230  
00001FB2                          2231  
00001FB2                          2232  process_op_codes_exit:
00001FB2                          2233  
00001FB2  4E75                    2234          RTS
00001FB4                          2235  
00001FB4                          2236  
00001FB4                          2237  *******************************************************************************
00001FB4                          2238  *                    Effective Addressing ROLE ROUTINES
00001FB4                          2239  *******************************************************************************
00001FB4                          2240  
00001FB4                          2241  Get_Effective_Address:
00001FB4                          2242  
00001FB4  1C05                    2243          MOVE.B      D5,D6
00001FB6  E60E                    2244          LSR.B       #3,D6               ;mode
00001FB8  CA3C 0007               2245          And.B       #%00000111,D5       ;register
00001FBC                          2246          
00001FBC  BC3C 0000               2247          CMP.B       #0,D6               ;0 = Dn - Data Register Direct (000)
00001FC0  6700 004A               2248          BEQ         Data_Reg_Direct
00001FC4                          2249          
00001FC4  BC3C 0001               2250          CMP.B       #1,D6               ;1 = (An) - Address Register Direct (001) 
00001FC8  6700 005C               2251          BEQ         Addr_Reg_Direct
00001FCC                          2252          
00001FCC  BC3C 0002               2253          CMP.B       #2,D6               ;2 = (An) - Address Register Indirect (010
00001FD0  6700 006E               2254          BEQ         Addr_Reg_Indirect
00001FD4                          2255          
00001FD4  BC3C 0003               2256          CMP.B       #3,D6               ;3 = (An) - Address Register Indirect with Postincrement (011)
00001FD8  6700 0098               2257          BEQ         Addr_Reg_Indirect_Inc
00001FDC                          2258          
00001FDC  BC3C 0004               2259          CMP.B       #4,D6               ;4 = (An) - Address Register Indirect with Predecrement (100)
00001FE0  6700 00CE               2260          BEQ         Addr_Reg_Indirect_Dec
00001FE4                          2261          
00001FE4  BC3C 0007               2262          CMP.B       #7,D6               ;7 = (An) - Address Register Indirect with Predecrement (111)
00001FE8  6700 0006               2263          BEQ         Get_Effective_Address_Other
00001FEC                          2264          
00001FEC  6000 0138               2265          BRA         invalidEA
00001FF0                          2266          
00001FF0                          2267  Get_Effective_Address_Other:        
00001FF0                          2268          
00001FF0  BA3C 0000               2269          CMP.B       #0,D5               ;0 = (xxx).W - Absolute Short Addressing Mode (000)
00001FF4  6700 00F8               2270          BEQ Addr_Abs_Short
00001FF8                          2271          
00001FF8  BA3C 0001               2272          CMP.B       #1,D5               ;1 = (xxx).W - Absolute Long Addressing Mode (001)
00001FFC  6700 0104               2273          BEQ Addr_Abs_Long
00002000                          2274          
00002000  BA3C 0004               2275          CMP.B       #4,D5               ;4 = #(data).W - Absolute Long Addressing Mode (100)
00002004  6700 0110               2276          BEQ Addr_Immediate_Data
00002008                          2277          
00002008  6000 011C               2278          BRA         invalidEA
0000200C                          2279          
0000200C                          2280  Data_Reg_Direct:                        ;case 0(0000)
0000200C                          2281  
0000200C  43F9 000023A8           2282          LEA         letterD,A1          ;output 'D' for data register
00002012  103C 000E               2283          MOVE.B      #14,D0              ;set for task to display null terminated 
00002016  4E4F                    2284          TRAP        #15                 ;string without CR, LF
00002018                          2285                          
00002018  4281                    2286          CLR.L       D1
0000201A  1205                    2287          MOVE.B      D5,D1               ;move register number for display into D1
0000201C  103C 0003               2288          MOVE.B      #3,D0               ;set for task to display null terminated 
00002020  4E4F                    2289          TRAP        #15                 ;string without CR, LF
00002022                          2290                 
00002022  6000 0102               2291          BRA         Get_Effective_Address_Exit  ;return
00002026                          2292          
00002026                          2293          
00002026                          2294  Addr_Reg_Direct:                        ;case 1(001) - output "A" then D5
00002026                          2295        
00002026  43F9 000023A6           2296          LEA         letterA,A1          ;output 'A' for address register
0000202C  103C 000E               2297          MOVE.B      #14,D0              ;set for task to display null terminated 
00002030  4E4F                    2298          TRAP        #15                 ;string without CR, LF
00002032                          2299          
00002032  4281                    2300          CLR.L       D1
00002034  1205                    2301          MOVE.B      D5,D1               ;move register number for display into D1
00002036  103C 0003               2302          MOVE.B      #3,D0               ;set for task to display null terminated 
0000203A  4E4F                    2303          TRAP        #15                 ;string without CR, LF
0000203C                          2304          
0000203C  6000 00E8               2305          BRA         Get_Effective_Address_Exit  ;return
00002040                          2306  
00002040                          2307  
00002040                          2308  Addr_Reg_Indirect:                      ;case 1(010) - output "(A" then D5, then ")"
00002040                          2309          
00002040  43F9 000023AE           2310          LEA         lprn,A1             ;output 'D' for data register
00002046  103C 000E               2311          MOVE.B      #14,D0              ;set for task to display null terminated 
0000204A  4E4F                    2312          TRAP        #15                 ;string without CR, LF
0000204C                          2313  
0000204C  43F9 000023A6           2314          LEA         letterA,A1          ;output 'A' for address register
00002052  103C 000E               2315          MOVE.B      #14,D0              ;set for task to display null terminated 
00002056  4E4F                    2316          TRAP        #15                 ;string without CR, LF
00002058                          2317          
00002058  4281                    2318          CLR.L       D1
0000205A  1205                    2319          MOVE.B      D5,D1               ;move register number for display into D1
0000205C  103C 0003               2320          MOVE.B      #3,D0               ;set for task to display null terminated 
00002060  4E4F                    2321          TRAP        #15                 ;string without CR, LF
00002062                          2322  
00002062  43F9 000023B0           2323          LEA         rprn,A1             ;output 'D' for data register
00002068  103C 000E               2324          MOVE.B      #14,D0              ;set for task to display null terminated 
0000206C  4E4F                    2325          TRAP        #15                 ;string without CR, LF
0000206E                          2326          
0000206E  6000 00B6               2327          BRA         Get_Effective_Address_Exit  ;return
00002072                          2328  
00002072                          2329                 
00002072                          2330  Addr_Reg_Indirect_Inc                   ;3 = (An)+ - Address Register Indirect with Postincrement (011)
00002072                          2331  
00002072  43F9 000023AE           2332          LEA         lprn,A1             ;output 'D' for data register
00002078  103C 000E               2333          MOVE.B      #14,D0              ;set for task to display null terminated 
0000207C  4E4F                    2334          TRAP        #15                 ;string without CR, LF
0000207E                          2335  
0000207E  43F9 000023A6           2336          LEA         letterA,A1          ;output 'A' for address register
00002084  103C 000E               2337          MOVE.B      #14,D0              ;set for task to display null terminated 
00002088  4E4F                    2338          TRAP        #15                 ;string without CR, LF
0000208A                          2339          
0000208A  4281                    2340          CLR.L       D1
0000208C  1205                    2341          MOVE.B      D5,D1               ;move register number for display into D1
0000208E  103C 0003               2342          MOVE.B      #3,D0               ;set for task to display null terminated 
00002092  4E4F                    2343          TRAP        #15                 ;string without CR, LF
00002094                          2344  
00002094  43F9 000023B0           2345          LEA         rprn,A1             ;output 'D' for data register
0000209A  103C 000E               2346          MOVE.B      #14,D0              ;set for task to display null terminated 
0000209E  4E4F                    2347          TRAP        #15                 ;string without CR, LF
000020A0                          2348          
000020A0  43F9 000023AA           2349          LEA         plus,A1             ;output 'D' for data register
000020A6  103C 000E               2350          MOVE.B      #14,D0              ;set for task to display null terminated 
000020AA  4E4F                    2351          TRAP        #15                 ;string without CR, LF
000020AC                          2352          
000020AC  6000 0078               2353          BRA         Get_Effective_Address_Exit  ;return
000020B0                          2354  
000020B0                          2355  Addr_Reg_Indirect_Dec                   ;4 = (An) - Address Register Indirect with Predecrement (100)
000020B0                          2356  
000020B0  43F9 000023AC           2357          LEA         minus,A1            ;output '-' for Predecrement
000020B6  103C 000E               2358          MOVE.B      #14,D0              ;set for task to display null terminated 
000020BA  4E4F                    2359          TRAP        #15                 ;string without CR, LF
000020BC                          2360  
000020BC  43F9 000023AE           2361          LEA         lprn,A1             ;output 'D' for data register
000020C2  103C 000E               2362          MOVE.B      #14,D0              ;set for task to display null terminated 
000020C6  4E4F                    2363          TRAP        #15                 ;string without CR, LF
000020C8                          2364  
000020C8  43F9 000023A6           2365          LEA         letterA,A1          ;output 'A' for address register
000020CE  103C 000E               2366          MOVE.B      #14,D0              ;set for task to display null terminated 
000020D2  4E4F                    2367          TRAP        #15                 ;string without CR, LF
000020D4                          2368          
000020D4  4281                    2369          CLR.L       D1
000020D6  1205                    2370          MOVE.B      D5,D1               ;move register number for display into D1
000020D8  103C 0003               2371          MOVE.B      #3,D0               ;set for task to display null terminated 
000020DC  4E4F                    2372          TRAP        #15                 ;string without CR, LF
000020DE                          2373  
000020DE  43F9 000023B0           2374          LEA         rprn,A1             ;output 'D' for data register
000020E4  103C 000E               2375          MOVE.B      #14,D0              ;set for task to display null terminated 
000020E8  4E4F                    2376          TRAP        #15                 ;string without CR, LF
000020EA                          2377          
000020EA  6000 003A               2378          BRA         Get_Effective_Address_Exit  ;return
000020EE                          2379          
000020EE                          2380                         
000020EE                          2381  Addr_Abs_Short                          ;0 = (xxx).W - Absolute Short Addressing Mode (000)
000020EE                          2382          
000020EE                          2383          
000020EE  43F9 00002388           2384          LEA         xxxW,A1             ;output 'D' for data register
000020F4  103C 000E               2385          MOVE.B      #14,D0              ;set for task to display null terminated 
000020F8  4E4F                    2386          TRAP        #15                 ;string without CR, LF
000020FA                          2387  
000020FA  548B                    2388          ADDA.L      #word,A3
000020FC                          2389          
000020FC                          2390          ;print word (A3)
000020FC                          2391          ;MOVE.W      A3,(A1)
000020FC                          2392          ;MOVE.B      #1,D0               ;set for task to display null terminated 
000020FC                          2393          ;TRAP        #15                 ;string without CR, LF
000020FC                          2394          
000020FC  5487                    2395          ADDI.L      #word,D7 
000020FE  6000 0026               2396          BRA         Get_Effective_Address_Exit  ;return
00002102                          2397                         
00002102                          2398  Addr_Abs_Long                           ;1 = (xxx).L - Absolute Long Addressing Mode (001)
00002102                          2399          
00002102  43F9 00002392           2400          LEA         xxxL,A1             ;output 'D' for data register
00002108  103C 000E               2401          MOVE.B      #14,D0              ;set for task to display null terminated 
0000210C  4E4F                    2402          TRAP        #15                 ;string without CR, LF
0000210E                          2403  
0000210E  548B                    2404          ADDA.L      #word,A3
00002110                          2405          
00002110                          2406          ;print long (A3)
00002110                          2407          ;MOVE.L      A3,(A1)
00002110                          2408          ;MOVE.B      #14,D0              ;set for task to display null terminated 
00002110                          2409          ;TRAP        #15                 ;string without CR, LF
00002110                          2410          
00002110  5887                    2411          ADDI.L      #long,D7
00002112  6000 0012               2412          BRA         Get_Effective_Address_Exit  ;return
00002116                          2413                         
00002116                          2414  Addr_Immediate_Data                     ;4 = #(data) - Absolute Long Addressing Mode (100)
00002116                          2415  
00002116  43F9 0000239C           2416          LEA         iData,A1            ;output 'D' for data register
0000211C  103C 000E               2417          MOVE.B      #14,D0              ;set for task to display null terminated 
00002120  4E4F                    2418          TRAP        #15                 ;string without CR, LF
00002122                          2419          
00002122                          2420          *need another input param for size
00002122  6000 0002               2421          BRA         Get_Effective_Address_Exit  ;return
00002126                          2422  
00002126                          2423  invalidEA:
00002126                          2424  
00002126                          2425          ;do something
00002126                          2426   
00002126                          2427  Get_Effective_Address_Exit:     
00002126                          2428  
00002126  4E75                    2429          RTS                             ;return
00002128                          2430  
00002128                          2431  switchModeAndReg:
00002128                          2432  ***
00002128                          2433  * Assumed in D2
00002128                          2434  *
00002128                          2435  * Assumed that they are in least significant byte:
00002128                          2436  *
00002128                          2437  *            _this_
00002128                          2438  *           /      \
00002128                          2439  *  ........ ........
00002128                          2440  *  \                /
00002128                          2441  *   -----word-------
00002128                          2442  *
00002128                          2443  *  and that in that byte they are ordered:
00002128                          2444  *
00002128                          2445  *       ........   
00002128                          2446  *       \/\_/\_/
00002128                          2447  *      /  /    \
00002128                          2448  *    /   /      \
00002128                          2449  * dont  one    other
00002128                          2450  * care
00002128                          2451  *
00002128                          2452  * after they will be
00002128                          2453  *
00002128                          2454  *       ........   
00002128                          2455  *       \/\_/\_/
00002128                          2456  *      /  /    \
00002128                          2457  *    /   /      \
00002128                          2458  * dont other    one
00002128                          2459  * care
00002128                          2460  *** 
00002128  0202 003F               2461          AndI.B #%00111111,D2 ;remove unwanted bits from D2
0000212C  0283 00000000           2462          ANDI.L #0,D3 ;clear D3
00002132  1602                    2463          MOVE.B D2,D3 ;copy to D3
00002134  E70B                    2464          LSL.B  #3,D3 
00002136  E60A                    2465          LSR.B  #3,D2
00002138  D403                    2466          ADD.B  D3,D2
0000213A  4E75                    2467          RTS
0000213C                          2468  
0000213C                          2469          
0000213C                          2470  *==============================================================================
0000213C                          2471  *                            variables and constants
0000213C                          2472  *==============================================================================
0000213C                          2473  
0000213C                          2474  
0000213C                          2475  ***initial user prompt stuff        
0000213C= 45 6E 74 65 72 20 ...   2476  slPrompt        DC.B    'Enter a starting address from $0 to $00FFFFFE: $',0
0000216D= 45 6E 74 65 72 20 ...   2477  elPrompt        DC.B    'Enter a ending address from $0 to $00FFFFFE: $',0
0000219C                          2478  
0000219C= 20 41 64 64 72 65 ...   2479  invalidMsg      DC.B    ' Address entered is not within the specified range! Please try again',0
000021E1= 20 41 20 43 68 61 ...   2480  invCharMsg      DC.B    ' A Character entered is not a valid address character! Please try again',0
00002229                          2481  
00002229= 20 59 6F 75 20 6D ...   2482  even_msg        DC.B    ' You must enter an even address!'
00002249                          2483  
00002249= 20                      2484  spc             DC.B    ' '
0000224A= 01                      2485  spc_len         DC.B    spc_len-spc
0000224B                          2486  ***
0000224B                          2487  
0000224B                          2488  
0000224B                          2489  
0000224B                          2490  ***list of OP codes
0000224B                          2491  
0000224B  =000081C0               2492  divsInstruction  EQU %1000000111000000
0000224B  =0000C1C0               2493  mulsInstruction  EQU %1100000111000000
0000224B  =0000E6C0               2494  rsrlweaInstruction  EQU %1110011011000000
0000224B  =0000E018               2495  rsrlregInstruction  EQU %1110000000011000
0000224B  =0000E0C0               2496  asrlweaInstruction  EQU %1110000011000000
0000224B  =0000E000               2497  asrlregInstruction  EQU %1110000000000000
0000224B  =0000E2C0               2498  lsrlweaInstruction  EQU %1110001011000000
0000224B  =0000E008               2499  lsrlregInstruction  EQU %1110000000001000
0000224B  =00005100               2500  subqInstruction  EQU %0101000100000000
0000224B  =00009000               2501  subInstruction   EQU %1001000000000000
0000224B  =0000D000               2502  addaInstruction  EQU %1101000000000000
0000224B  =0000D000               2503  addInstruction   EQU %1101000000000000
0000224B  =00004880               2504  movemInstruction EQU %0100100010000000
0000224B  =00000600               2505  addiInstruction  EQU %0000011000000000
0000224B  =00000000               2506  oriInstruction   EQU 0
0000224B  =00000C00               2507  cmpiInstruction  EQU %0000110000000000
0000224B  =00004E80               2508  jsrInstruction   EQU %0100111010000000
0000224B  =00004E75               2509  rtsInstruction   EQU %0100111001110101
0000224B  =00004E71               2510  NoOpInstruction  EQU %0100111001110001
0000224B  =00000000               2511  moveInstruction  EQU 0
0000224B  =00006000               2512  bccInstruction   EQU %0110000000000000
0000224B  =00004400               2513  negInstruction   EQU %0100010000000000
0000224B  =00000000               2514  dataInstruction  EQU 0
0000224B                          2515  
0000224B                          2516  ***
0000224B                          2517  
0000224B                          2518  ***list of OP masks
0000224B                          2519  
0000224B  =0000F1C0               2520  divsMask  EQU %1111000111000000
0000224B  =0000F1C0               2521  mulsMask  EQU %1111000111000000
0000224B  =0000FEC0               2522  rsrlweaMask  EQU %1111111011000000
0000224B  =0000F018               2523  rsrlregMask  EQU %1111000000011000
0000224B  =0000FEC0               2524  asrlweaMask  EQU %1111111011000000
0000224B  =0000F018               2525  asrlregMask  EQU %1111000000011000
0000224B  =0000FEC0               2526  lsrlweaMask  EQU %1111111011000000
0000224B  =0000F018               2527  lsrlregMask  EQU %1111000000011000
0000224B  =0000F100               2528  subqMask  EQU %1111000100000000
0000224B  =0000F000               2529  subMask   EQU %1111000000000000
0000224B  =0000F000               2530  addaMask  EQU %1111000000000000
0000224B  =0000F000               2531  addMask   EQU %1111000000000000
0000224B  =0000FB80               2532  movemMask EQU %1111101110000000
0000224B  =0000FF00               2533  addiMask  EQU %1111111100000000
0000224B  =0000FF00               2534  oriMask   EQU %1111111100000000
0000224B  =0000FF00               2535  cmpiMask  EQU %1111111100000000
0000224B  =0000FFC0               2536  jsrMask   EQU %1111111111000000
0000224B  =0000FFFF               2537  rtsMask   EQU $FFFF
0000224B  =0000FFFF               2538  NoOpMask  EQU $FFFF
0000224B  =0000C000               2539  moveMask  EQU $C000
0000224B  =0000F000               2540  bccMask   EQU $F000
0000224B  =0000FF00               2541  negMask   EQU $FF00
0000224B  =00000000               2542  dataMask  EQU 0
0000224B                          2543  ***
0000224B                          2544  
0000224B                          2545  ***Bcc Codes***
0000224B  =00000004               2546  CC EQU $04
0000224B  =00000005               2547  CS EQU $05
0000224B  =00000007               2548  EQ EQU $07
0000224B  =0000000C               2549  GE EQU $0C
0000224B  =0000000E               2550  GT EQU $0E
0000224B  =00000002               2551  HI EQU $02
0000224B  =0000000F               2552  LE EQU $0F
0000224B  =00000003               2553  LS EQU $03
0000224B  =0000000D               2554  LT EQU $0D
0000224B  =0000000B               2555  MI EQU $0B
0000224B  =00000006               2556  NE EQU $06
0000224B  =0000000A               2557  PL EQU $0A
0000224B  =00000008               2558  VC EQU $08
0000224B  =00000009               2559  VS EQU $09
0000224B  =00000000               2560  RA EQU $00 ;not really a Condition Code
0000224B  =00000001               2561  SR EQU $01 ;not really a Condition Code
0000224B                          2562  
0000224B= 43 43 20 00             2563  CCm DC.B 'CC ',0
0000224F= 43 53 20 00             2564  CSm DC.B 'CS ',0
00002253= 45 51 20 00             2565  EQm DC.B 'EQ ',0
00002257= 47 45 20 00             2566  GEm DC.B 'GE ',0
0000225B= 47 54 20 00             2567  GTm DC.B 'GT ',0
0000225F= 48 49 20 00             2568  HIm DC.B 'HI ',0
00002263= 4C 45 20 00             2569  LEm DC.B 'LE ',0
00002267= 4C 53 20 00             2570  LSm DC.B 'LS ',0
0000226B= 4C 54 20 00             2571  LTm DC.B 'LT ',0
0000226F= 4D 49 20 00             2572  MIm DC.B 'MI ',0
00002273= 4E 45 20 00             2573  NEm DC.B 'NE ',0
00002277= 50 4C 20 00             2574  PLm DC.B 'PL ',0
0000227B= 56 43 20 00             2575  VCm DC.B 'VC ',0
0000227F= 56 53 20 00             2576  VSm DC.B 'VS ',0
00002283= 52 41 20 00             2577  RAm DC.B 'RA ',0
00002287= 53 52 20 00             2578  SRm DC.B 'SR ',0
0000228B                          2579  
0000228B= 01 04 05 07 0C 0E ...   2580  BccList DC.B SR,CC,CS,EQ,GE,GT,HI,LE,LS,LT,MI,NE,PL,VC,VS,RA
0000229C= 00002287 0000224B ...   2581  conditionCodeMessage DC.L SRm,CCm,CSm,EQm,GEm,GTm,HIm,LEm,LSm,LTm,MIm,NEm,PLm,VCm,VSm,RAm
000022DC                          2582  ***
000022DC                          2583  
000022DC= 45 6E 74 65 72 20 ...   2584  startLocationPrompt DC.B    'Enter start location',0
000022F1= 45 6E 74 65 72 20 ...   2585  endLocationPrompt   DC.B    'Enter end location',0
00002304                          2586  
00002304= 0D 0A 00                2587  clearLine  DC.B $0D,$0A,0
00002307                          2588  
00002307= 44 49 56 53 20 00       2589  divsMessage     DC.B 'DIVS ',0
0000230D= 4D 55 4C 53 20 00       2590  mulsMessage     DC.B 'MULS ',0
00002313= 52 4F 4C 20 00          2591  rslMessage      DC.B 'ROL ',0
00002318= 52 4F 52 20 00          2592  rsrMessage      DC.B 'ROR ',0
0000231D= 41 53 4C 20 00          2593  aslMessage      DC.B 'ASL ',0
00002322= 41 53 52 20 00          2594  asrMessage      DC.B 'ASR ',0
00002327= 4C 53 4C 20 00          2595  lslMessage      DC.B 'LSL ',0
0000232C= 4C 53 52 20 00          2596  lsrMessage      DC.B 'LSR ',0
00002331= 53 55 42 51 20 00       2597  subqMessage     DC.B 'SUBQ ',0
00002337= 53 55 42 20 00          2598  subMessage      DC.B 'SUB ',0 
0000233C= 41 44 44 41 20 00       2599  addaMessage     DC.B 'ADDA ',0
00002342= 41 44 44 20 00          2600  addMessage      DC.B 'ADD ',0
00002347= 4D 4F 56 45 4D 20 00    2601  movemMessage    DC.B 'MOVEM ',0
0000234E= 41 44 44 49 20 00       2602  addiMessage     DC.B 'ADDI ',0
00002354= 4F 52 49 20 00          2603  oriMessage      DC.B 'ORI ',0
00002359= 43 4D 50 49 20 00       2604  cmpiMessage     DC.B 'CMPI ',0
0000235F= 4A 53 52 20 00          2605  jsrMessage      DC.B 'JSR ',0
00002364= 52 54 53 20 00          2606  rtsMessage      DC.B 'RTS ',0
00002369= 4E 4F 50 20 00          2607  nopMessage      DC.B 'NOP ',0 
0000236E= 4D 4F 56 45 20 00       2608  moveMessage     DC.B 'MOVE ',0
00002374= 42 00                   2609  bccMessage      DC.B 'B',0
00002376= 4E 45 47 20 00          2610  negMessage      DC.B 'NEG ',0
0000237B= 44 41 54 41 20 00       2611  dataMessage     DC.B 'DATA ',0
00002381= 4D 4F 56 45 41 20 00    2612  moveaMessage    DC.B 'MOVEA ',0
00002388                          2613  
00002388= 28 78 78 78 29 2E ...   2614  xxxW            DC.B '(xxx).W: ',0
00002392= 28 78 78 78 29 2E ...   2615  xxxL            DC.B '(xxx).L: ',0
0000239C= 23 28 64 61 74 61 ...   2616  iData           DC.B '#(data): ',0
000023A6                          2617  
000023A6= 41 00                   2618  letterA         DC.B 'A', 0
000023A8= 44 00                   2619  letterD         DC.B 'D', 0
000023AA                          2620  
000023AA= 2B 00                   2621  plus            DC.B '+', 0
000023AC= 2D 00                   2622  minus           DC.B '-', 0
000023AE= 28 00                   2623  lPrn            DC.B '(', 0
000023B0= 29 00                   2624  rPrn            DC.B ')', 0
000023B2                          2625  
000023B2                          2626  
000023B2= 00000000                2627  startLocation       DC.L    0
000023B6= 00000000                2628  endLocation         DC.L    0
000023BA                          2629  
000023BA                          2630  
000023BA                          2631     
000023BA                          2632      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 17DC
ADDA                173E
ADDABODY            1786
ADDAINSTRUCTION     D000
ADDAMASK            F000
ADDAMESSAGE         233C
ADDDEST             18A0
ADDDESTEA           17D0
ADDDESTEAMASKS      17D6
ADDI                1A0E
ADDIBODY            1A3A
ADDIDONE            1A78
ADDIINSTRUCTION     600
ADDIMASK            FF00
ADDIMESSAGE         234E
ADDINSTRUCTION      D000
ADDMASK             F000
ADDMESSAGE          2342
ADDRESS_DONE        1EA0
ADDRESS_EXIT        1E9A
ADDR_ABS_LONG       2102
ADDR_ABS_SHORT      20EE
ADDR_IMMEDIATE_DATA  2116
ADDR_REG_DIRECT     2026
ADDR_REG_INDIRECT   2040
ADDR_REG_INDIRECT_DEC  20B0
ADDR_REG_INDIRECT_INC  2072
ADDSOURCE           1858
ASLEA               13BA
ASLMESSAGE          231D
ASLREG              1400
ASREA               13AA
ASRLREG             13CA
ASRLREGINSTRUCTION  E000
ASRLREGMASK         F018
ASRLWEA             136A
ASRLWEACHECKDIRECTION  1396
ASRLWEAINSTRUCTION  E0C0
ASRLWEAMASK         FEC0
ASRMESSAGE          2322
ASRREG              13F0
BCC                 1D54
BCCBYTE             1DA6
BCCDONE             1DBC
BCCINSTRUCTION      6000
BCCLIST             228B
BCCLONG             1DB4
BCCMASK             F000
BCCMESSAGE          2374
BCCWORD             1DAC
BEGIN               5001
BEGIN_ADDRESS       1E2C
BYTE                1
CC                  4
CCM                 224B
CHECKCC             1D6A
CHECKMOVEADEST      1D00
CHECKMOVEDEST       1C4E
CHECKOPCODE         1050
CK_ADDR_DONE        1FB0
CK_ADDR_RANGE       1F84
CK_ADDR_RANGE_ERROR  1FA0
CK_BOUNDRY          1EC8
CK_BOUNDRY_ERROR    1EEA
CK_SIZE_ERROR       1EFE
CLEARLINE           2304
CMPI                1B10
CMPIBODY            1B38
CMPIDONE            1B76
CMPIEA              1B02
CMPIEAMASKS         1B09
CMPIINSTRUCTION     C00
CMPIMASK            FF00
CMPIMESSAGE         2359
CONDITIONCODEMESSAGE  229C
CS                  5
CSM                 224F
DATAINSTRUCTION     0
DATAMASK            0
DATAMESSAGE         237B
DATA_REG_DIRECT     200C
DIVS                11D0
DIVSBODY            11FC
DIVSINSTRUCTION     81C0
DIVSMASK            F1C0
DIVSMESSAGE         2307
ELPROMPT            216D
END                 FFFFFE
ENDLOCATION         23B6
ENDLOCATIONPROMPT   22F1
END_ADDRESS         1E70
ENTER_ADDR_EDIT_ALL  1EA2
ENTER_ADDR_EDIT_ALL_EXIT  1EC6
EQ                  7
EQM                 2253
EVEN_MSG            2229
FALSEPOSITIVE       1070
FARLABEL            FFE
FIN                 1E28
FOUNDCC             1D7C
GE                  C
GEM                 2257
GET_EFFECTIVE_ADDRESS  1FB4
GET_EFFECTIVE_ADDRESS_EXIT  2126
GET_EFFECTIVE_ADDRESS_OTHER  1FF0
GT                  E
GTM                 225B
HANDLEBYTEDATA      1DFC
HEX_RANGE_ERROR     1F6C
HI                  2
HIM                 225F
IDATA               239C
INSTLABELLIST       10F2
INSTLABELLIST2      10F6
INSTMASKLIST        10C4
INSTOPLIST          1096
INSTOPLIST2         10A6
INVALIDEA           2126
INVALIDMSG          219C
INVCHARMSG          21E1
JSR                 1B8E
JSRBODY             1BB6
JSRDONE             1BD6
JSREA               1B86
JSREAMASKS          1B8A
JSRINSTRUCTION      4E80
JSRMASK             FFC0
JSRMESSAGE          235F
LCASEHEX            1F4E
LE                  F
LEM                 2263
LETTERA             23A6
LETTERD             23A8
LONG                4
LPRN                23AE
LS                  3
LSLEA               1468
LSLMESSAGE          2327
LSLREG              14D2
LSM                 2267
LSREA               1458
LSRLCHECKI          1528
LSRLCHECKIR         1512
LSRLCHECKIRRETURN   1526
LSRLCHECKR          155C
LSRLEA              1410
LSRLEAMASKS         1416
LSRLREG             149C
LSRLREGBODY         14E2
LSRLREGINSTRUCTION  E008
LSRLREGMASK         F018
LSRLWEA             141C
LSRLWEABODY         1478
LSRLWEACHECKDIRECTION  1444
LSRLWEAINSTRUCTION  E2C0
LSRLWEAMASK         FEC0
LSRMESSAGE          232C
LSRREG              14C2
LT                  D
LTM                 226B
MAIN_LOOP           1026
MATCH               1076
MI                  B
MIM                 226F
MINUS               23AC
MOVE                1C26
MOVEA               1CD8
MOVEABODY           1D2E
MOVEADESTEA         1CD4
MOVEADESTEAMASKS    1CD6
MOVEAMESSAGE        2381
MOVEBODY            1C7C
MOVEDESTEA          1C18
MOVEDESTEAMASKS     1C1F
MOVEINSTRUCTION     0
MOVEM               18FC
MOVEMASK            C000
MOVEMBODY           1966
MOVEMESSAGE         236E
MOVEMINSTRUCTION    4880
MOVEMMASK           FB80
MOVEMMEMTOREGEA     18F2
MOVEMMEMTOREGEAMASKS  18F7
MOVEMMESSAGE        2347
MOVEMREGTOMEMEA     18E8
MOVEMREGTOMEMEAMASKS  18ED
MOVESOURCEEA        1C06
MOVESOURCEEAMASKS   1C0F
MULS                1254
MULSBODY            127C
MULSEA              1244
MULSEAMASKS         124C
MULSINSTRUCTION     C1C0
MULSMASK            F1C0
MULSMESSAGE         230D
NE                  6
NEG                 19A8
NEGBODY             19D0
NEGDONE             19FE
NEGEA               1998
NEGEAMASKS          19A0
NEGINSTRUCTION      4400
NEGMASK             FF00
NEGMESSAGE          2376
NEM                 2273
NEXTHEX             1F14
NEXTHEXDONE         1F66
NEXTHEXRETURN       1F82
NOOPINSTRUCTION     4E71
NOOPMASK            FFFF
NOP                 1BE6
NOPMESSAGE          2369
ORI                 1A88
ORIBODY             1AB4
ORIDONE             1AF2
ORIINSTRUCTION      0
ORIMASK             FF00
ORIMESSAGE          2354
PARSEHEXSTRING      1F12
PL                  A
PLM                 2277
PLUS                23AA
PRGORG              1000
PROCESS_OP_CODES    1FB2
PROCESS_OP_CODES_EXIT  1FB2
PROMPT_USER         1014
RA                  0
RAM                 2283
RPRN                23B0
RSLEA               1314
RSLMESSAGE          2313
RSLREG              135A
RSREA               1304
RSRLREG             1324
RSRLREGINSTRUCTION  E018
RSRLREGMASK         F018
RSRLWEA             12C4
RSRLWEACHECKDIRECTION  12F0
RSRLWEAINSTRUCTION  E6C0
RSRLWEAMASK         FEC0
RSRMESSAGE          2318
RSRREG              134A
RTS                 1BF6
RTSINSTRUCTION      4E75
RTSMASK             FFFF
RTSMESSAGE          2364
SLPROMPT            213C
SNIPPET             114E
SNIPPETEND          11CC
SPC                 2249
SPC_LEN             224A
SR                  1
SRM                 2287
STACK               5000
START               1000
STARTLOCATION       23B2
STARTLOCATIONPROMPT  22DC
SUB                 162E
SUBDEST             16F6
SUBINSTRUCTION      9000
SUBMASK             F000
SUBMESSAGE          2337
SUBQ                1586
SUBQBODY            15BE
SUBQEA              1576
SUBQEAMASKS         157E
SUBQINSTRUCTION     5100
SUBQMASK            F100
SUBQMESSAGE         2331
SUBSOURCE           16AE
SWITCHMODEANDREG    2128
TOEIGHT             162A
UCASEHEX            1F36
UNKNOWNOPCODE       1DD6
VALIDADDA           175C
VALIDADDDESTEA      182C
VALIDADDIMODES      1A10
VALIDADDSOURCEEA    1802
VALIDASRL           136C
VALIDCMPIMODES      1B12
VALIDDIVSMODES      11D2
VALIDJSRMODES       1B90
VALIDLSRL           141E
VALIDMEMTOREG       1938
VALIDMOVEADESTMODES  1D02
VALIDMOVEASOURCEMODES  1CDA
VALIDMOVEDESTMODES  1C50
VALIDMOVESOURCEMODES  1C28
VALIDMULSMODES      1256
VALIDNEGMODES       19AA
VALIDORIMODES       1A8A
VALIDREGTOMEM       1912
VALIDRSRL           12C6
VALIDSUBDESTEA      167E
VALIDSUBQ           1598
VALIDSUBSOURCEEA    1654
VC                  8
VCM                 227B
VS                  9
VSM                 227F
WORD                2
XXXL                2392
XXXW                2388
ZEROTOEIGHT         1620
ZEROTOEIGHTRETURN   1628
